(()=>{var __webpack_modules__={27:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval("\n// NAMESPACE OBJECT: ./node_modules/react-konva/es/ReactKonvaHostConfig.js\nvar ReactKonvaHostConfig_namespaceObject = {};\n__webpack_require__.r(ReactKonvaHostConfig_namespaceObject);\n__webpack_require__.d(ReactKonvaHostConfig_namespaceObject, {\n  \"appendChild\": () => (appendChild),\n  \"appendChildToContainer\": () => (appendChildToContainer),\n  \"appendInitialChild\": () => (appendInitialChild),\n  \"cancelTimeout\": () => (cancelTimeout),\n  \"clearContainer\": () => (clearContainer),\n  \"commitMount\": () => (commitMount),\n  \"commitTextUpdate\": () => (commitTextUpdate),\n  \"commitUpdate\": () => (commitUpdate),\n  \"createInstance\": () => (createInstance),\n  \"createTextInstance\": () => (createTextInstance),\n  \"detachDeletedInstance\": () => (detachDeletedInstance),\n  \"finalizeInitialChildren\": () => (finalizeInitialChildren),\n  \"getChildHostContext\": () => (getChildHostContext),\n  \"getCurrentEventPriority\": () => (getCurrentEventPriority),\n  \"getPublicInstance\": () => (getPublicInstance),\n  \"getRootHostContext\": () => (getRootHostContext),\n  \"hideInstance\": () => (hideInstance),\n  \"hideTextInstance\": () => (hideTextInstance),\n  \"idlePriority\": () => (scheduler.unstable_IdlePriority),\n  \"insertBefore\": () => (insertBefore),\n  \"insertInContainerBefore\": () => (insertInContainerBefore),\n  \"isPrimaryRenderer\": () => (isPrimaryRenderer),\n  \"noTimeout\": () => (noTimeout),\n  \"now\": () => (scheduler.unstable_now),\n  \"prepareForCommit\": () => (prepareForCommit),\n  \"preparePortalMount\": () => (preparePortalMount),\n  \"prepareUpdate\": () => (prepareUpdate),\n  \"removeChild\": () => (removeChild),\n  \"removeChildFromContainer\": () => (removeChildFromContainer),\n  \"resetAfterCommit\": () => (resetAfterCommit),\n  \"resetTextContent\": () => (resetTextContent),\n  \"run\": () => (scheduler.unstable_runWithPriority),\n  \"scheduleTimeout\": () => (scheduleTimeout),\n  \"shouldDeprioritizeSubtree\": () => (shouldDeprioritizeSubtree),\n  \"shouldSetTextContent\": () => (shouldSetTextContent),\n  \"supportsMutation\": () => (supportsMutation),\n  \"unhideInstance\": () => (unhideInstance),\n  \"unhideTextInstance\": () => (unhideTextInstance),\n  \"warnsIfNotActing\": () => (warnsIfNotActing)\n});\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(294);\n// EXTERNAL MODULE: ./node_modules/react-dom/client.js\nvar client = __webpack_require__(745);\n// EXTERNAL MODULE: ./node_modules/use-sync-external-store/shim/index.js\nvar shim = __webpack_require__(688);\n// EXTERNAL MODULE: ./node_modules/use-sync-external-store/shim/with-selector.js\nvar with_selector = __webpack_require__(798);\n// EXTERNAL MODULE: ./node_modules/react-dom/index.js\nvar react_dom = __webpack_require__(935);\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/utils/reactBatchedUpdates.js\n\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/utils/batch.js\n// Default to a dummy \"batch\" implementation that just runs the callback\nfunction defaultNoopBatch(callback) {\n  callback();\n}\n\nlet batch = defaultNoopBatch; // Allow injecting another batching function later\n\nconst setBatch = newBatch => batch = newBatch; // Supply a getter just to skip dealing with ESM bindings\n\nconst getBatch = () => batch;\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/components/Context.js\n\nconst Context_ReactReduxContext = /*#__PURE__*/react.createContext(null);\n\nif (false) {}\n\n/* harmony default export */ const Context = ((/* unused pure expression or super */ null && (Context_ReactReduxContext)));\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/hooks/useReduxContext.js\n\n\n\n/**\r\n * A hook to access the value of the `ReactReduxContext`. This is a low-level\r\n * hook that you should usually not need to call directly.\r\n *\r\n * @returns {any} the value of the `ReactReduxContext`\r\n *\r\n * @example\r\n *\r\n * import React from 'react'\r\n * import { useReduxContext } from 'react-redux'\r\n *\r\n * export const CounterComponent = () => {\r\n *   const { store } = useReduxContext()\r\n *   return <div>{store.getState()}</div>\r\n * }\r\n */\nfunction useReduxContext_useReduxContext() {\n  const contextValue = (0,react.useContext)(Context_ReactReduxContext);\n\n  if (false) {}\n\n  return contextValue;\n}\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/utils/useSyncExternalStore.js\nconst notInitialized = () => {\n  throw new Error('uSES not initialized!');\n};\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/hooks/useSelector.js\n\n\n\n\nlet useSyncExternalStoreWithSelector = notInitialized;\nconst initializeUseSelector = fn => {\n  useSyncExternalStoreWithSelector = fn;\n};\n\nconst refEquality = (a, b) => a === b;\n/**\r\n * Hook factory, which creates a `useSelector` hook bound to a given context.\r\n *\r\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\r\n * @returns {Function} A `useSelector` hook bound to the specified context.\r\n */\n\n\nfunction createSelectorHook(context = Context_ReactReduxContext) {\n  const useReduxContext = context === Context_ReactReduxContext ? useReduxContext_useReduxContext : () => (0,react.useContext)(context);\n  return function useSelector(selector, equalityFn = refEquality) {\n    if (false) {}\n\n    const {\n      store,\n      subscription,\n      getServerState\n    } = useReduxContext();\n    const selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store.getState, getServerState || store.getState, selector, equalityFn);\n    (0,react.useDebugValue)(selectedState);\n    return selectedState;\n  };\n}\n/**\r\n * A hook to access the redux store's state. This hook takes a selector function\r\n * as an argument. The selector is called with the store state.\r\n *\r\n * This hook takes an optional equality comparison function as the second parameter\r\n * that allows you to customize the way the selected state is compared to determine\r\n * whether the component needs to be re-rendered.\r\n *\r\n * @param {Function} selector the selector function\r\n * @param {Function=} equalityFn the function that will be used to determine equality\r\n *\r\n * @returns {any} the selected state\r\n *\r\n * @example\r\n *\r\n * import React from 'react'\r\n * import { useSelector } from 'react-redux'\r\n *\r\n * export const CounterComponent = () => {\r\n *   const counter = useSelector(state => state.counter)\r\n *   return <div>{counter}</div>\r\n * }\r\n */\n\nconst useSelector = /*#__PURE__*/createSelectorHook();\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js\nfunction extends_extends() {\n  extends_extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return extends_extends.apply(this, arguments);\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n// EXTERNAL MODULE: ./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js\nvar hoist_non_react_statics_cjs = __webpack_require__(679);\nvar hoist_non_react_statics_cjs_default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics_cjs);\n// EXTERNAL MODULE: ./node_modules/react-redux/node_modules/react-is/index.js\nvar react_is = __webpack_require__(973);\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/connect/selectorFactory.js\n\nconst _excluded = [\"initMapStateToProps\", \"initMapDispatchToProps\", \"initMergeProps\"];\n\nfunction pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, {\n  areStatesEqual,\n  areOwnPropsEqual,\n  areStatePropsEqual\n}) {\n  let hasRunAtLeastOnce = false;\n  let state;\n  let ownProps;\n  let stateProps;\n  let dispatchProps;\n  let mergedProps;\n\n  function handleFirstCall(firstState, firstOwnProps) {\n    state = firstState;\n    ownProps = firstOwnProps;\n    stateProps = mapStateToProps(state, ownProps);\n    dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    hasRunAtLeastOnce = true;\n    return mergedProps;\n  }\n\n  function handleNewPropsAndNewState() {\n    stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n\n  function handleNewProps() {\n    if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n\n  function handleNewState() {\n    const nextStateProps = mapStateToProps(state, ownProps);\n    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);\n    stateProps = nextStateProps;\n    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n\n  function handleSubsequentCalls(nextState, nextOwnProps) {\n    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);\n    const stateChanged = !areStatesEqual(nextState, state);\n    state = nextState;\n    ownProps = nextOwnProps;\n    if (propsChanged && stateChanged) return handleNewPropsAndNewState();\n    if (propsChanged) return handleNewProps();\n    if (stateChanged) return handleNewState();\n    return mergedProps;\n  }\n\n  return function pureFinalPropsSelector(nextState, nextOwnProps) {\n    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);\n  };\n}\n// TODO: Add more comments\n// The selector returned by selectorFactory will memoize its results,\n// allowing connect's shouldComponentUpdate to return false if final\n// props have not changed.\nfunction finalPropsSelectorFactory(dispatch, _ref) {\n  let {\n    initMapStateToProps,\n    initMapDispatchToProps,\n    initMergeProps\n  } = _ref,\n      options = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n  const mapStateToProps = initMapStateToProps(dispatch, options);\n  const mapDispatchToProps = initMapDispatchToProps(dispatch, options);\n  const mergeProps = initMergeProps(dispatch, options);\n\n  if (false) {}\n\n  return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);\n}\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/utils/bindActionCreators.js\nfunction bindActionCreators(actionCreators, dispatch) {\n  const boundActionCreators = {};\n\n  for (const key in actionCreators) {\n    const actionCreator = actionCreators[key];\n\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = (...args) => dispatch(actionCreator(...args));\n    }\n  }\n\n  return boundActionCreators;\n}\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/connect/wrapMapToProps.js\n\nfunction wrapMapToPropsConstant( // * Note:\n//  It seems that the dispatch argument\n//  could be a dispatch function in some cases (ex: whenMapDispatchToPropsIsMissing)\n//  and a state object in some others (ex: whenMapStateToPropsIsMissing)\n// eslint-disable-next-line no-unused-vars\ngetConstant) {\n  return function initConstantSelector(dispatch) {\n    const constant = getConstant(dispatch);\n\n    function constantSelector() {\n      return constant;\n    }\n\n    constantSelector.dependsOnOwnProps = false;\n    return constantSelector;\n  };\n} // dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args\n// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine\n// whether mapToProps needs to be invoked when props have changed.\n//\n// A length of one signals that mapToProps does not depend on props from the parent component.\n// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and\n// therefore not reporting its length accurately..\n// TODO Can this get pulled out so that we can subscribe directly to the store if we don't need ownProps?\n\nfunction getDependsOnOwnProps(mapToProps) {\n  return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;\n} // Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,\n// this function wraps mapToProps in a proxy function which does several things:\n//\n//  * Detects whether the mapToProps function being called depends on props, which\n//    is used by selectorFactory to decide if it should reinvoke on props changes.\n//\n//  * On first call, handles mapToProps if returns another function, and treats that\n//    new function as the true mapToProps for subsequent calls.\n//\n//  * On first call, verifies the first result is a plain object, in order to warn\n//    the developer that their mapToProps function is not returning a valid result.\n//\n\nfunction wrapMapToPropsFunc(mapToProps, methodName) {\n  return function initProxySelector(dispatch, {\n    displayName\n  }) {\n    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {\n      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, undefined);\n    }; // allow detectFactoryAndVerify to get ownProps\n\n\n    proxy.dependsOnOwnProps = true;\n\n    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {\n      proxy.mapToProps = mapToProps;\n      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);\n      let props = proxy(stateOrDispatch, ownProps);\n\n      if (typeof props === 'function') {\n        proxy.mapToProps = props;\n        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);\n        props = proxy(stateOrDispatch, ownProps);\n      }\n\n      if (false) {}\n      return props;\n    };\n\n    return proxy;\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/connect/invalidArgFactory.js\nfunction createInvalidArgFactory(arg, name) {\n  return (dispatch, options) => {\n    throw new Error(`Invalid value of type ${typeof arg} for ${name} argument when connecting component ${options.wrappedComponentName}.`);\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/connect/mapDispatchToProps.js\n\n\n\nfunction mapDispatchToPropsFactory(mapDispatchToProps) {\n  return mapDispatchToProps && typeof mapDispatchToProps === 'object' ? wrapMapToPropsConstant(dispatch => // @ts-ignore\n  bindActionCreators(mapDispatchToProps, dispatch)) : !mapDispatchToProps ? wrapMapToPropsConstant(dispatch => ({\n    dispatch\n  })) : typeof mapDispatchToProps === 'function' ? // @ts-ignore\n  wrapMapToPropsFunc(mapDispatchToProps, 'mapDispatchToProps') : createInvalidArgFactory(mapDispatchToProps, 'mapDispatchToProps');\n}\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/connect/mapStateToProps.js\n\n\nfunction mapStateToPropsFactory(mapStateToProps) {\n  return !mapStateToProps ? wrapMapToPropsConstant(() => ({})) : typeof mapStateToProps === 'function' ? // @ts-ignore\n  wrapMapToPropsFunc(mapStateToProps, 'mapStateToProps') : createInvalidArgFactory(mapStateToProps, 'mapStateToProps');\n}\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/connect/mergeProps.js\n\n\n\nfunction defaultMergeProps(stateProps, dispatchProps, ownProps) {\n  // @ts-ignore\n  return extends_extends({}, ownProps, stateProps, dispatchProps);\n}\nfunction wrapMergePropsFunc(mergeProps) {\n  return function initMergePropsProxy(dispatch, {\n    displayName,\n    areMergedPropsEqual\n  }) {\n    let hasRunOnce = false;\n    let mergedProps;\n    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {\n      const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n\n      if (hasRunOnce) {\n        if (!areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;\n      } else {\n        hasRunOnce = true;\n        mergedProps = nextMergedProps;\n        if (false) {}\n      }\n\n      return mergedProps;\n    };\n  };\n}\nfunction mergePropsFactory(mergeProps) {\n  return !mergeProps ? () => defaultMergeProps : typeof mergeProps === 'function' ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, 'mergeProps');\n}\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/utils/Subscription.js\n // encapsulates the subscription logic for connecting a component to the redux store, as\n// well as nesting subscriptions of descendant components, so that we can ensure the\n// ancestor components re-render before descendants\n\nfunction createListenerCollection() {\n  const batch = getBatch();\n  let first = null;\n  let last = null;\n  return {\n    clear() {\n      first = null;\n      last = null;\n    },\n\n    notify() {\n      batch(() => {\n        let listener = first;\n\n        while (listener) {\n          listener.callback();\n          listener = listener.next;\n        }\n      });\n    },\n\n    get() {\n      let listeners = [];\n      let listener = first;\n\n      while (listener) {\n        listeners.push(listener);\n        listener = listener.next;\n      }\n\n      return listeners;\n    },\n\n    subscribe(callback) {\n      let isSubscribed = true;\n      let listener = last = {\n        callback,\n        next: null,\n        prev: last\n      };\n\n      if (listener.prev) {\n        listener.prev.next = listener;\n      } else {\n        first = listener;\n      }\n\n      return function unsubscribe() {\n        if (!isSubscribed || first === null) return;\n        isSubscribed = false;\n\n        if (listener.next) {\n          listener.next.prev = listener.prev;\n        } else {\n          last = listener.prev;\n        }\n\n        if (listener.prev) {\n          listener.prev.next = listener.next;\n        } else {\n          first = listener.next;\n        }\n      };\n    }\n\n  };\n}\n\nconst nullListeners = {\n  notify() {},\n\n  get: () => []\n};\nfunction createSubscription(store, parentSub) {\n  let unsubscribe;\n  let listeners = nullListeners;\n\n  function addNestedSub(listener) {\n    trySubscribe();\n    return listeners.subscribe(listener);\n  }\n\n  function notifyNestedSubs() {\n    listeners.notify();\n  }\n\n  function handleChangeWrapper() {\n    if (subscription.onStateChange) {\n      subscription.onStateChange();\n    }\n  }\n\n  function isSubscribed() {\n    return Boolean(unsubscribe);\n  }\n\n  function trySubscribe() {\n    if (!unsubscribe) {\n      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);\n      listeners = createListenerCollection();\n    }\n  }\n\n  function tryUnsubscribe() {\n    if (unsubscribe) {\n      unsubscribe();\n      unsubscribe = undefined;\n      listeners.clear();\n      listeners = nullListeners;\n    }\n  }\n\n  const subscription = {\n    addNestedSub,\n    notifyNestedSubs,\n    handleChangeWrapper,\n    isSubscribed,\n    trySubscribe,\n    tryUnsubscribe,\n    getListeners: () => listeners\n  };\n  return subscription;\n}\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/utils/useIsomorphicLayoutEffect.js\n // React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store\n// subscription callback always has the selector from the latest render commit\n// available, otherwise a store update may happen between render and the effect,\n// which may cause missed updates; we also must ensure the store subscription\n// is created synchronously, otherwise a store update may occur before the\n// subscription is created and an inconsistent state may be observed\n// Matches logic in React's `shared/ExecutionEnvironment` file\n\nconst canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\nconst useIsomorphicLayoutEffect = canUseDOM ? react.useLayoutEffect : react.useEffect;\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/utils/shallowEqual.js\nfunction is(x, y) {\n  if (x === y) {\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n\nfunction shallowEqual(objA, objB) {\n  if (is(objA, objB)) return true;\n\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false;\n  }\n\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n  if (keysA.length !== keysB.length) return false;\n\n  for (let i = 0; i < keysA.length; i++) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/components/connect.js\n\n\nconst connect_excluded = [\"reactReduxForwardedRef\"];\n\n/* eslint-disable valid-jsdoc, @typescript-eslint/no-unused-vars */\n\n\n\n\n\n\n\n\n\n\n\n\n\nlet useSyncExternalStore = notInitialized;\nconst initializeConnect = fn => {\n  useSyncExternalStore = fn;\n}; // Define some constant arrays just to avoid re-creating these\n\nconst EMPTY_ARRAY = (/* unused pure expression or super */ null && ([null, 0]));\nconst NO_SUBSCRIPTION_ARRAY = [null, null]; // Attempts to stringify whatever not-really-a-component value we were given\n// for logging in an error message\n\nconst stringifyComponent = Comp => {\n  try {\n    return JSON.stringify(Comp);\n  } catch (err) {\n    return String(Comp);\n  }\n};\n\n// This is \"just\" a `useLayoutEffect`, but with two modifications:\n// - we need to fall back to `useEffect` in SSR to avoid annoying warnings\n// - we extract this to a separate function to avoid closing over values\n//   and causing memory leaks\nfunction useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {\n  useIsomorphicLayoutEffect(() => effectFunc(...effectArgs), dependencies);\n} // Effect callback, extracted: assign the latest props values to refs for later usage\n\n\nfunction captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, // actualChildProps: unknown,\nchildPropsFromStoreUpdate, notifyNestedSubs) {\n  // We want to capture the wrapper props and child props we used for later comparisons\n  lastWrapperProps.current = wrapperProps;\n  renderIsScheduled.current = false; // If the render was from a store update, clear out that reference and cascade the subscriber update\n\n  if (childPropsFromStoreUpdate.current) {\n    childPropsFromStoreUpdate.current = null;\n    notifyNestedSubs();\n  }\n} // Effect callback, extracted: subscribe to the Redux store or nearest connected ancestor,\n// check for updates after dispatched actions, and trigger re-renders.\n\n\nfunction subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, // forceComponentUpdateDispatch: React.Dispatch<any>,\nadditionalSubscribeListener) {\n  // If we're not subscribed to the store, nothing to do here\n  if (!shouldHandleStateChanges) return () => {}; // Capture values for checking if and when this component unmounts\n\n  let didUnsubscribe = false;\n  let lastThrownError = null; // We'll run this callback every time a store subscription update propagates to this component\n\n  const checkForUpdates = () => {\n    if (didUnsubscribe || !isMounted.current) {\n      // Don't run stale listeners.\n      // Redux doesn't guarantee unsubscriptions happen until next dispatch.\n      return;\n    } // TODO We're currently calling getState ourselves here, rather than letting `uSES` do it\n\n\n    const latestStoreState = store.getState();\n    let newChildProps, error;\n\n    try {\n      // Actually run the selector with the most recent store state and wrapper props\n      // to determine what the child props should be\n      newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);\n    } catch (e) {\n      error = e;\n      lastThrownError = e;\n    }\n\n    if (!error) {\n      lastThrownError = null;\n    } // If the child props haven't changed, nothing to do here - cascade the subscription update\n\n\n    if (newChildProps === lastChildProps.current) {\n      if (!renderIsScheduled.current) {\n        notifyNestedSubs();\n      }\n    } else {\n      // Save references to the new child props.  Note that we track the \"child props from store update\"\n      // as a ref instead of a useState/useReducer because we need a way to determine if that value has\n      // been processed.  If this went into useState/useReducer, we couldn't clear out the value without\n      // forcing another re-render, which we don't want.\n      lastChildProps.current = newChildProps;\n      childPropsFromStoreUpdate.current = newChildProps;\n      renderIsScheduled.current = true; // TODO This is hacky and not how `uSES` is meant to be used\n      // Trigger the React `useSyncExternalStore` subscriber\n\n      additionalSubscribeListener();\n    }\n  }; // Actually subscribe to the nearest connected ancestor (or store)\n\n\n  subscription.onStateChange = checkForUpdates;\n  subscription.trySubscribe(); // Pull data from the store after first render in case the store has\n  // changed since we began.\n\n  checkForUpdates();\n\n  const unsubscribeWrapper = () => {\n    didUnsubscribe = true;\n    subscription.tryUnsubscribe();\n    subscription.onStateChange = null;\n\n    if (lastThrownError) {\n      // It's possible that we caught an error due to a bad mapState function, but the\n      // parent re-rendered without this component and we're about to unmount.\n      // This shouldn't happen as long as we do top-down subscriptions correctly, but\n      // if we ever do those wrong, this throw will surface the error in our tests.\n      // In that case, throw the error from here so it doesn't get lost.\n      throw lastThrownError;\n    }\n  };\n\n  return unsubscribeWrapper;\n} // Reducer initial state creation for our update reducer\n\n\nconst initStateUpdates = () => EMPTY_ARRAY;\n\nfunction strictEqual(a, b) {\n  return a === b;\n}\n/**\r\n * Infers the type of props that a connector will inject into a component.\r\n */\n\n\nlet hasWarnedAboutDeprecatedPureOption = false;\n/**\r\n * Connects a React component to a Redux store.\r\n *\r\n * - Without arguments, just wraps the component, without changing the behavior / props\r\n *\r\n * - If 2 params are passed (3rd param, mergeProps, is skipped), default behavior\r\n * is to override ownProps (as stated in the docs), so what remains is everything that's\r\n * not a state or dispatch prop\r\n *\r\n * - When 3rd param is passed, we don't know if ownProps propagate and whether they\r\n * should be valid component props, because it depends on mergeProps implementation.\r\n * As such, it is the user's responsibility to extend ownProps interface from state or\r\n * dispatch props or both when applicable\r\n *\r\n * @param mapStateToProps A function that extracts values from state\r\n * @param mapDispatchToProps Setup for dispatching actions\r\n * @param mergeProps Optional callback to merge state and dispatch props together\r\n * @param options Options for configuring the connection\r\n *\r\n */\n\nfunction connect(mapStateToProps, mapDispatchToProps, mergeProps, {\n  // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.\n  // @ts-ignore\n  pure,\n  areStatesEqual = strictEqual,\n  areOwnPropsEqual = shallowEqual,\n  areStatePropsEqual = shallowEqual,\n  areMergedPropsEqual = shallowEqual,\n  // use React's forwardRef to expose a ref of the wrapped component\n  forwardRef = false,\n  // the context consumer to use\n  context = Context_ReactReduxContext\n} = {}) {\n  if (false) {}\n\n  const Context = context;\n  const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);\n  const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);\n  const initMergeProps = mergePropsFactory(mergeProps);\n  const shouldHandleStateChanges = Boolean(mapStateToProps);\n\n  const wrapWithConnect = WrappedComponent => {\n    if (false) {}\n\n    const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';\n    const displayName = `Connect(${wrappedComponentName})`;\n    const selectorFactoryOptions = {\n      shouldHandleStateChanges,\n      displayName,\n      wrappedComponentName,\n      WrappedComponent,\n      // @ts-ignore\n      initMapStateToProps,\n      // @ts-ignore\n      initMapDispatchToProps,\n      initMergeProps,\n      areStatesEqual,\n      areStatePropsEqual,\n      areOwnPropsEqual,\n      areMergedPropsEqual\n    };\n\n    function ConnectFunction(props) {\n      const [propsContext, reactReduxForwardedRef, wrapperProps] = (0,react.useMemo)(() => {\n        // Distinguish between actual \"data\" props that were passed to the wrapper component,\n        // and values needed to control behavior (forwarded refs, alternate context instances).\n        // To maintain the wrapperProps object reference, memoize this destructuring.\n        const {\n          reactReduxForwardedRef\n        } = props,\n              wrapperProps = _objectWithoutPropertiesLoose(props, connect_excluded);\n\n        return [props.context, reactReduxForwardedRef, wrapperProps];\n      }, [props]);\n      const ContextToUse = (0,react.useMemo)(() => {\n        // Users may optionally pass in a custom context instance to use instead of our ReactReduxContext.\n        // Memoize the check that determines which context instance we should use.\n        return propsContext && propsContext.Consumer && // @ts-ignore\n        (0,react_is.isContextConsumer)( /*#__PURE__*/react.createElement(propsContext.Consumer, null)) ? propsContext : Context;\n      }, [propsContext, Context]); // Retrieve the store and ancestor subscription via context, if available\n\n      const contextValue = (0,react.useContext)(ContextToUse); // The store _must_ exist as either a prop or in context.\n      // We'll check to see if it _looks_ like a Redux store first.\n      // This allows us to pass through a `store` prop that is just a plain value.\n\n      const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);\n      const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);\n\n      if (false) {} // Based on the previous check, one of these must be true\n\n\n      const store = didStoreComeFromProps ? props.store : contextValue.store;\n      const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;\n      const childPropsSelector = (0,react.useMemo)(() => {\n        // The child props selector needs the store reference as an input.\n        // Re-create this selector whenever the store changes.\n        return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);\n      }, [store]);\n      const [subscription, notifyNestedSubs] = (0,react.useMemo)(() => {\n        if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY; // This Subscription's source should match where store came from: props vs. context. A component\n        // connected to the store via props shouldn't use subscription from context, or vice versa.\n\n        const subscription = createSubscription(store, didStoreComeFromProps ? undefined : contextValue.subscription); // `notifyNestedSubs` is duplicated to handle the case where the component is unmounted in\n        // the middle of the notification loop, where `subscription` will then be null. This can\n        // probably be avoided if Subscription's listeners logic is changed to not call listeners\n        // that have been unsubscribed in the  middle of the notification loop.\n\n        const notifyNestedSubs = subscription.notifyNestedSubs.bind(subscription);\n        return [subscription, notifyNestedSubs];\n      }, [store, didStoreComeFromProps, contextValue]); // Determine what {store, subscription} value should be put into nested context, if necessary,\n      // and memoize that value to avoid unnecessary context updates.\n\n      const overriddenContextValue = (0,react.useMemo)(() => {\n        if (didStoreComeFromProps) {\n          // This component is directly subscribed to a store from props.\n          // We don't want descendants reading from this store - pass down whatever\n          // the existing context value is from the nearest connected ancestor.\n          return contextValue;\n        } // Otherwise, put this component's subscription instance into context, so that\n        // connected descendants won't update until after this component is done\n\n\n        return extends_extends({}, contextValue, {\n          subscription\n        });\n      }, [didStoreComeFromProps, contextValue, subscription]); // Set up refs to coordinate values between the subscription effect and the render logic\n\n      const lastChildProps = (0,react.useRef)();\n      const lastWrapperProps = (0,react.useRef)(wrapperProps);\n      const childPropsFromStoreUpdate = (0,react.useRef)();\n      const renderIsScheduled = (0,react.useRef)(false);\n      const isProcessingDispatch = (0,react.useRef)(false);\n      const isMounted = (0,react.useRef)(false);\n      const latestSubscriptionCallbackError = (0,react.useRef)();\n      useIsomorphicLayoutEffect(() => {\n        isMounted.current = true;\n        return () => {\n          isMounted.current = false;\n        };\n      }, []);\n      const actualChildPropsSelector = (0,react.useMemo)(() => {\n        const selector = () => {\n          // Tricky logic here:\n          // - This render may have been triggered by a Redux store update that produced new child props\n          // - However, we may have gotten new wrapper props after that\n          // If we have new child props, and the same wrapper props, we know we should use the new child props as-is.\n          // But, if we have new wrapper props, those might change the child props, so we have to recalculate things.\n          // So, we'll use the child props from store update only if the wrapper props are the same as last time.\n          if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {\n            return childPropsFromStoreUpdate.current;\n          } // TODO We're reading the store directly in render() here. Bad idea?\n          // This will likely cause Bad Things (TM) to happen in Concurrent Mode.\n          // Note that we do this because on renders _not_ caused by store updates, we need the latest store state\n          // to determine what the child props should be.\n\n\n          return childPropsSelector(store.getState(), wrapperProps);\n        };\n\n        return selector;\n      }, [store, wrapperProps]); // We need this to execute synchronously every time we re-render. However, React warns\n      // about useLayoutEffect in SSR, so we try to detect environment and fall back to\n      // just useEffect instead to avoid the warning, since neither will run anyway.\n\n      const subscribeForReact = (0,react.useMemo)(() => {\n        const subscribe = reactListener => {\n          if (!subscription) {\n            return () => {};\n          }\n\n          return subscribeUpdates(shouldHandleStateChanges, store, subscription, // @ts-ignore\n          childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, reactListener);\n        };\n\n        return subscribe;\n      }, [subscription]);\n      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs]);\n      let actualChildProps;\n\n      try {\n        actualChildProps = useSyncExternalStore( // TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing\n        subscribeForReact, // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,\n        // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.\n        actualChildPropsSelector, getServerState ? () => childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector);\n      } catch (err) {\n        if (latestSubscriptionCallbackError.current) {\n          ;\n          err.message += `\\nThe error may be correlated with this previous error:\\n${latestSubscriptionCallbackError.current.stack}\\n\\n`;\n        }\n\n        throw err;\n      }\n\n      useIsomorphicLayoutEffect(() => {\n        latestSubscriptionCallbackError.current = undefined;\n        childPropsFromStoreUpdate.current = undefined;\n        lastChildProps.current = actualChildProps;\n      }); // Now that all that's done, we can finally try to actually render the child component.\n      // We memoize the elements for the rendered child component as an optimization.\n\n      const renderedWrappedComponent = (0,react.useMemo)(() => {\n        return (\n          /*#__PURE__*/\n          // @ts-ignore\n          react.createElement(WrappedComponent, extends_extends({}, actualChildProps, {\n            ref: reactReduxForwardedRef\n          }))\n        );\n      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]); // If React sees the exact same element reference as last time, it bails out of re-rendering\n      // that child, same as if it was wrapped in React.memo() or returned false from shouldComponentUpdate.\n\n      const renderedChild = (0,react.useMemo)(() => {\n        if (shouldHandleStateChanges) {\n          // If this component is subscribed to store updates, we need to pass its own\n          // subscription instance down to our descendants. That means rendering the same\n          // Context instance, and putting a different value into the context.\n          return /*#__PURE__*/react.createElement(ContextToUse.Provider, {\n            value: overriddenContextValue\n          }, renderedWrappedComponent);\n        }\n\n        return renderedWrappedComponent;\n      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);\n      return renderedChild;\n    }\n\n    const _Connect = react.memo(ConnectFunction);\n\n    // Add a hacky cast to get the right output type\n    const Connect = _Connect;\n    Connect.WrappedComponent = WrappedComponent;\n    Connect.displayName = ConnectFunction.displayName = displayName;\n\n    if (forwardRef) {\n      const _forwarded = react.forwardRef(function forwardConnectRef(props, ref) {\n        // @ts-ignore\n        return /*#__PURE__*/react.createElement(Connect, extends_extends({}, props, {\n          reactReduxForwardedRef: ref\n        }));\n      });\n\n      const forwarded = _forwarded;\n      forwarded.displayName = displayName;\n      forwarded.WrappedComponent = WrappedComponent;\n      return hoist_non_react_statics_cjs_default()(forwarded, WrappedComponent);\n    }\n\n    return hoist_non_react_statics_cjs_default()(Connect, WrappedComponent);\n  };\n\n  return wrapWithConnect;\n}\n\n/* harmony default export */ const components_connect = (connect);\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/components/Provider.js\n\n\n\n\n\nfunction Provider({\n  store,\n  context,\n  children,\n  serverState\n}) {\n  const contextValue = (0,react.useMemo)(() => {\n    const subscription = createSubscription(store);\n    return {\n      store,\n      subscription,\n      getServerState: serverState ? () => serverState : undefined\n    };\n  }, [store, serverState]);\n  const previousState = (0,react.useMemo)(() => store.getState(), [store]);\n  useIsomorphicLayoutEffect(() => {\n    const {\n      subscription\n    } = contextValue;\n    subscription.onStateChange = subscription.notifyNestedSubs;\n    subscription.trySubscribe();\n\n    if (previousState !== store.getState()) {\n      subscription.notifyNestedSubs();\n    }\n\n    return () => {\n      subscription.tryUnsubscribe();\n      subscription.onStateChange = undefined;\n    };\n  }, [contextValue, previousState]);\n  const Context = context || Context_ReactReduxContext; // @ts-ignore 'AnyAction' is assignable to the constraint of type 'A', but 'A' could be instantiated with a different subtype\n\n  return /*#__PURE__*/react.createElement(Context.Provider, {\n    value: contextValue\n  }, children);\n}\n\n/* harmony default export */ const components_Provider = (Provider);\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/hooks/useStore.js\n\n\n\n/**\r\n * Hook factory, which creates a `useStore` hook bound to a given context.\r\n *\r\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\r\n * @returns {Function} A `useStore` hook bound to the specified context.\r\n */\n\nfunction useStore_createStoreHook(context = ReactReduxContext) {\n  const useReduxContext = // @ts-ignore\n  context === ReactReduxContext ? useDefaultReduxContext : () => useContext(context);\n  return function useStore() {\n    const {\n      store\n    } = useReduxContext(); // @ts-ignore\n\n    return store;\n  };\n}\n/**\r\n * A hook to access the redux store.\r\n *\r\n * @returns {any} the redux store\r\n *\r\n * @example\r\n *\r\n * import React from 'react'\r\n * import { useStore } from 'react-redux'\r\n *\r\n * export const ExampleComponent = () => {\r\n *   const store = useStore()\r\n *   return <div>{store.getState()}</div>\r\n * }\r\n */\n\nconst useStore = /*#__PURE__*/(/* unused pure expression or super */ null && (useStore_createStoreHook()));\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/hooks/useDispatch.js\n\n\n/**\r\n * Hook factory, which creates a `useDispatch` hook bound to a given context.\r\n *\r\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\r\n * @returns {Function} A `useDispatch` hook bound to the specified context.\r\n */\n\nfunction createDispatchHook(context = ReactReduxContext) {\n  const useStore = // @ts-ignore\n  context === ReactReduxContext ? useDefaultStore : createStoreHook(context);\n  return function useDispatch() {\n    const store = useStore(); // @ts-ignore\n\n    return store.dispatch;\n  };\n}\n/**\r\n * A hook to access the redux `dispatch` function.\r\n *\r\n * @returns {any|function} redux store's `dispatch` function\r\n *\r\n * @example\r\n *\r\n * import React, { useCallback } from 'react'\r\n * import { useDispatch } from 'react-redux'\r\n *\r\n * export const CounterComponent = ({ value }) => {\r\n *   const dispatch = useDispatch()\r\n *   const increaseCounter = useCallback(() => dispatch({ type: 'increase-counter' }), [])\r\n *   return (\r\n *     <div>\r\n *       <span>{value}</span>\r\n *       <button onClick={increaseCounter}>Increase counter</button>\r\n *     </div>\r\n *   )\r\n * }\r\n */\n\nconst useDispatch = /*#__PURE__*/(/* unused pure expression or super */ null && (createDispatchHook()));\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/exports.js\n\n\n\n\n\n\n\n\n\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/index.js\n// The primary entry point assumes we're working with standard ReactDOM/RN, but\n// older versions that do not include `useSyncExternalStore` (React 16.9 - 17.x).\n// Because of that, the useSyncExternalStore compat shim is needed.\n\n\n\n\n\n\ninitializeUseSelector(with_selector.useSyncExternalStoreWithSelector);\ninitializeConnect(shim.useSyncExternalStore); // Enable batched updates in our subscriptions for use\n// with standard React renderers (ReactDOM, React Native)\n\nsetBatch(react_dom.unstable_batchedUpdates);\n\n\n// EXTERNAL MODULE: ./node_modules/react-is/index.js\nvar node_modules_react_is = __webpack_require__(864);\n// EXTERNAL MODULE: ./node_modules/shallowequal/index.js\nvar shallowequal = __webpack_require__(774);\nvar shallowequal_default = /*#__PURE__*/__webpack_require__.n(shallowequal);\n;// CONCATENATED MODULE: ./node_modules/@emotion/stylis/dist/stylis.browser.esm.js\nfunction stylis_min (W) {\n  function M(d, c, e, h, a) {\n    for (var m = 0, b = 0, v = 0, n = 0, q, g, x = 0, K = 0, k, u = k = q = 0, l = 0, r = 0, I = 0, t = 0, B = e.length, J = B - 1, y, f = '', p = '', F = '', G = '', C; l < B;) {\n      g = e.charCodeAt(l);\n      l === J && 0 !== b + n + v + m && (0 !== b && (g = 47 === b ? 10 : 47), n = v = m = 0, B++, J++);\n\n      if (0 === b + n + v + m) {\n        if (l === J && (0 < r && (f = f.replace(N, '')), 0 < f.trim().length)) {\n          switch (g) {\n            case 32:\n            case 9:\n            case 59:\n            case 13:\n            case 10:\n              break;\n\n            default:\n              f += e.charAt(l);\n          }\n\n          g = 59;\n        }\n\n        switch (g) {\n          case 123:\n            f = f.trim();\n            q = f.charCodeAt(0);\n            k = 1;\n\n            for (t = ++l; l < B;) {\n              switch (g = e.charCodeAt(l)) {\n                case 123:\n                  k++;\n                  break;\n\n                case 125:\n                  k--;\n                  break;\n\n                case 47:\n                  switch (g = e.charCodeAt(l + 1)) {\n                    case 42:\n                    case 47:\n                      a: {\n                        for (u = l + 1; u < J; ++u) {\n                          switch (e.charCodeAt(u)) {\n                            case 47:\n                              if (42 === g && 42 === e.charCodeAt(u - 1) && l + 2 !== u) {\n                                l = u + 1;\n                                break a;\n                              }\n\n                              break;\n\n                            case 10:\n                              if (47 === g) {\n                                l = u + 1;\n                                break a;\n                              }\n\n                          }\n                        }\n\n                        l = u;\n                      }\n\n                  }\n\n                  break;\n\n                case 91:\n                  g++;\n\n                case 40:\n                  g++;\n\n                case 34:\n                case 39:\n                  for (; l++ < J && e.charCodeAt(l) !== g;) {\n                  }\n\n              }\n\n              if (0 === k) break;\n              l++;\n            }\n\n            k = e.substring(t, l);\n            0 === q && (q = (f = f.replace(ca, '').trim()).charCodeAt(0));\n\n            switch (q) {\n              case 64:\n                0 < r && (f = f.replace(N, ''));\n                g = f.charCodeAt(1);\n\n                switch (g) {\n                  case 100:\n                  case 109:\n                  case 115:\n                  case 45:\n                    r = c;\n                    break;\n\n                  default:\n                    r = O;\n                }\n\n                k = M(c, r, k, g, a + 1);\n                t = k.length;\n                0 < A && (r = X(O, f, I), C = H(3, k, r, c, D, z, t, g, a, h), f = r.join(''), void 0 !== C && 0 === (t = (k = C.trim()).length) && (g = 0, k = ''));\n                if (0 < t) switch (g) {\n                  case 115:\n                    f = f.replace(da, ea);\n\n                  case 100:\n                  case 109:\n                  case 45:\n                    k = f + '{' + k + '}';\n                    break;\n\n                  case 107:\n                    f = f.replace(fa, '$1 $2');\n                    k = f + '{' + k + '}';\n                    k = 1 === w || 2 === w && L('@' + k, 3) ? '@-webkit-' + k + '@' + k : '@' + k;\n                    break;\n\n                  default:\n                    k = f + k, 112 === h && (k = (p += k, ''));\n                } else k = '';\n                break;\n\n              default:\n                k = M(c, X(c, f, I), k, h, a + 1);\n            }\n\n            F += k;\n            k = I = r = u = q = 0;\n            f = '';\n            g = e.charCodeAt(++l);\n            break;\n\n          case 125:\n          case 59:\n            f = (0 < r ? f.replace(N, '') : f).trim();\n            if (1 < (t = f.length)) switch (0 === u && (q = f.charCodeAt(0), 45 === q || 96 < q && 123 > q) && (t = (f = f.replace(' ', ':')).length), 0 < A && void 0 !== (C = H(1, f, c, d, D, z, p.length, h, a, h)) && 0 === (t = (f = C.trim()).length) && (f = '\\x00\\x00'), q = f.charCodeAt(0), g = f.charCodeAt(1), q) {\n              case 0:\n                break;\n\n              case 64:\n                if (105 === g || 99 === g) {\n                  G += f + e.charAt(l);\n                  break;\n                }\n\n              default:\n                58 !== f.charCodeAt(t - 1) && (p += P(f, q, g, f.charCodeAt(2)));\n            }\n            I = r = u = q = 0;\n            f = '';\n            g = e.charCodeAt(++l);\n        }\n      }\n\n      switch (g) {\n        case 13:\n        case 10:\n          47 === b ? b = 0 : 0 === 1 + q && 107 !== h && 0 < f.length && (r = 1, f += '\\x00');\n          0 < A * Y && H(0, f, c, d, D, z, p.length, h, a, h);\n          z = 1;\n          D++;\n          break;\n\n        case 59:\n        case 125:\n          if (0 === b + n + v + m) {\n            z++;\n            break;\n          }\n\n        default:\n          z++;\n          y = e.charAt(l);\n\n          switch (g) {\n            case 9:\n            case 32:\n              if (0 === n + m + b) switch (x) {\n                case 44:\n                case 58:\n                case 9:\n                case 32:\n                  y = '';\n                  break;\n\n                default:\n                  32 !== g && (y = ' ');\n              }\n              break;\n\n            case 0:\n              y = '\\\\0';\n              break;\n\n            case 12:\n              y = '\\\\f';\n              break;\n\n            case 11:\n              y = '\\\\v';\n              break;\n\n            case 38:\n              0 === n + b + m && (r = I = 1, y = '\\f' + y);\n              break;\n\n            case 108:\n              if (0 === n + b + m + E && 0 < u) switch (l - u) {\n                case 2:\n                  112 === x && 58 === e.charCodeAt(l - 3) && (E = x);\n\n                case 8:\n                  111 === K && (E = K);\n              }\n              break;\n\n            case 58:\n              0 === n + b + m && (u = l);\n              break;\n\n            case 44:\n              0 === b + v + n + m && (r = 1, y += '\\r');\n              break;\n\n            case 34:\n            case 39:\n              0 === b && (n = n === g ? 0 : 0 === n ? g : n);\n              break;\n\n            case 91:\n              0 === n + b + v && m++;\n              break;\n\n            case 93:\n              0 === n + b + v && m--;\n              break;\n\n            case 41:\n              0 === n + b + m && v--;\n              break;\n\n            case 40:\n              if (0 === n + b + m) {\n                if (0 === q) switch (2 * x + 3 * K) {\n                  case 533:\n                    break;\n\n                  default:\n                    q = 1;\n                }\n                v++;\n              }\n\n              break;\n\n            case 64:\n              0 === b + v + n + m + u + k && (k = 1);\n              break;\n\n            case 42:\n            case 47:\n              if (!(0 < n + m + v)) switch (b) {\n                case 0:\n                  switch (2 * g + 3 * e.charCodeAt(l + 1)) {\n                    case 235:\n                      b = 47;\n                      break;\n\n                    case 220:\n                      t = l, b = 42;\n                  }\n\n                  break;\n\n                case 42:\n                  47 === g && 42 === x && t + 2 !== l && (33 === e.charCodeAt(t + 2) && (p += e.substring(t, l + 1)), y = '', b = 0);\n              }\n          }\n\n          0 === b && (f += y);\n      }\n\n      K = x;\n      x = g;\n      l++;\n    }\n\n    t = p.length;\n\n    if (0 < t) {\n      r = c;\n      if (0 < A && (C = H(2, p, r, d, D, z, t, h, a, h), void 0 !== C && 0 === (p = C).length)) return G + p + F;\n      p = r.join(',') + '{' + p + '}';\n\n      if (0 !== w * E) {\n        2 !== w || L(p, 2) || (E = 0);\n\n        switch (E) {\n          case 111:\n            p = p.replace(ha, ':-moz-$1') + p;\n            break;\n\n          case 112:\n            p = p.replace(Q, '::-webkit-input-$1') + p.replace(Q, '::-moz-$1') + p.replace(Q, ':-ms-input-$1') + p;\n        }\n\n        E = 0;\n      }\n    }\n\n    return G + p + F;\n  }\n\n  function X(d, c, e) {\n    var h = c.trim().split(ia);\n    c = h;\n    var a = h.length,\n        m = d.length;\n\n    switch (m) {\n      case 0:\n      case 1:\n        var b = 0;\n\n        for (d = 0 === m ? '' : d[0] + ' '; b < a; ++b) {\n          c[b] = Z(d, c[b], e).trim();\n        }\n\n        break;\n\n      default:\n        var v = b = 0;\n\n        for (c = []; b < a; ++b) {\n          for (var n = 0; n < m; ++n) {\n            c[v++] = Z(d[n] + ' ', h[b], e).trim();\n          }\n        }\n\n    }\n\n    return c;\n  }\n\n  function Z(d, c, e) {\n    var h = c.charCodeAt(0);\n    33 > h && (h = (c = c.trim()).charCodeAt(0));\n\n    switch (h) {\n      case 38:\n        return c.replace(F, '$1' + d.trim());\n\n      case 58:\n        return d.trim() + c.replace(F, '$1' + d.trim());\n\n      default:\n        if (0 < 1 * e && 0 < c.indexOf('\\f')) return c.replace(F, (58 === d.charCodeAt(0) ? '' : '$1') + d.trim());\n    }\n\n    return d + c;\n  }\n\n  function P(d, c, e, h) {\n    var a = d + ';',\n        m = 2 * c + 3 * e + 4 * h;\n\n    if (944 === m) {\n      d = a.indexOf(':', 9) + 1;\n      var b = a.substring(d, a.length - 1).trim();\n      b = a.substring(0, d).trim() + b + ';';\n      return 1 === w || 2 === w && L(b, 1) ? '-webkit-' + b + b : b;\n    }\n\n    if (0 === w || 2 === w && !L(a, 1)) return a;\n\n    switch (m) {\n      case 1015:\n        return 97 === a.charCodeAt(10) ? '-webkit-' + a + a : a;\n\n      case 951:\n        return 116 === a.charCodeAt(3) ? '-webkit-' + a + a : a;\n\n      case 963:\n        return 110 === a.charCodeAt(5) ? '-webkit-' + a + a : a;\n\n      case 1009:\n        if (100 !== a.charCodeAt(4)) break;\n\n      case 969:\n      case 942:\n        return '-webkit-' + a + a;\n\n      case 978:\n        return '-webkit-' + a + '-moz-' + a + a;\n\n      case 1019:\n      case 983:\n        return '-webkit-' + a + '-moz-' + a + '-ms-' + a + a;\n\n      case 883:\n        if (45 === a.charCodeAt(8)) return '-webkit-' + a + a;\n        if (0 < a.indexOf('image-set(', 11)) return a.replace(ja, '$1-webkit-$2') + a;\n        break;\n\n      case 932:\n        if (45 === a.charCodeAt(4)) switch (a.charCodeAt(5)) {\n          case 103:\n            return '-webkit-box-' + a.replace('-grow', '') + '-webkit-' + a + '-ms-' + a.replace('grow', 'positive') + a;\n\n          case 115:\n            return '-webkit-' + a + '-ms-' + a.replace('shrink', 'negative') + a;\n\n          case 98:\n            return '-webkit-' + a + '-ms-' + a.replace('basis', 'preferred-size') + a;\n        }\n        return '-webkit-' + a + '-ms-' + a + a;\n\n      case 964:\n        return '-webkit-' + a + '-ms-flex-' + a + a;\n\n      case 1023:\n        if (99 !== a.charCodeAt(8)) break;\n        b = a.substring(a.indexOf(':', 15)).replace('flex-', '').replace('space-between', 'justify');\n        return '-webkit-box-pack' + b + '-webkit-' + a + '-ms-flex-pack' + b + a;\n\n      case 1005:\n        return ka.test(a) ? a.replace(aa, ':-webkit-') + a.replace(aa, ':-moz-') + a : a;\n\n      case 1e3:\n        b = a.substring(13).trim();\n        c = b.indexOf('-') + 1;\n\n        switch (b.charCodeAt(0) + b.charCodeAt(c)) {\n          case 226:\n            b = a.replace(G, 'tb');\n            break;\n\n          case 232:\n            b = a.replace(G, 'tb-rl');\n            break;\n\n          case 220:\n            b = a.replace(G, 'lr');\n            break;\n\n          default:\n            return a;\n        }\n\n        return '-webkit-' + a + '-ms-' + b + a;\n\n      case 1017:\n        if (-1 === a.indexOf('sticky', 9)) break;\n\n      case 975:\n        c = (a = d).length - 10;\n        b = (33 === a.charCodeAt(c) ? a.substring(0, c) : a).substring(d.indexOf(':', 7) + 1).trim();\n\n        switch (m = b.charCodeAt(0) + (b.charCodeAt(7) | 0)) {\n          case 203:\n            if (111 > b.charCodeAt(8)) break;\n\n          case 115:\n            a = a.replace(b, '-webkit-' + b) + ';' + a;\n            break;\n\n          case 207:\n          case 102:\n            a = a.replace(b, '-webkit-' + (102 < m ? 'inline-' : '') + 'box') + ';' + a.replace(b, '-webkit-' + b) + ';' + a.replace(b, '-ms-' + b + 'box') + ';' + a;\n        }\n\n        return a + ';';\n\n      case 938:\n        if (45 === a.charCodeAt(5)) switch (a.charCodeAt(6)) {\n          case 105:\n            return b = a.replace('-items', ''), '-webkit-' + a + '-webkit-box-' + b + '-ms-flex-' + b + a;\n\n          case 115:\n            return '-webkit-' + a + '-ms-flex-item-' + a.replace(ba, '') + a;\n\n          default:\n            return '-webkit-' + a + '-ms-flex-line-pack' + a.replace('align-content', '').replace(ba, '') + a;\n        }\n        break;\n\n      case 973:\n      case 989:\n        if (45 !== a.charCodeAt(3) || 122 === a.charCodeAt(4)) break;\n\n      case 931:\n      case 953:\n        if (!0 === la.test(d)) return 115 === (b = d.substring(d.indexOf(':') + 1)).charCodeAt(0) ? P(d.replace('stretch', 'fill-available'), c, e, h).replace(':fill-available', ':stretch') : a.replace(b, '-webkit-' + b) + a.replace(b, '-moz-' + b.replace('fill-', '')) + a;\n        break;\n\n      case 962:\n        if (a = '-webkit-' + a + (102 === a.charCodeAt(5) ? '-ms-' + a : '') + a, 211 === e + h && 105 === a.charCodeAt(13) && 0 < a.indexOf('transform', 10)) return a.substring(0, a.indexOf(';', 27) + 1).replace(ma, '$1-webkit-$2') + a;\n    }\n\n    return a;\n  }\n\n  function L(d, c) {\n    var e = d.indexOf(1 === c ? ':' : '{'),\n        h = d.substring(0, 3 !== c ? e : 10);\n    e = d.substring(e + 1, d.length - 1);\n    return R(2 !== c ? h : h.replace(na, '$1'), e, c);\n  }\n\n  function ea(d, c) {\n    var e = P(c, c.charCodeAt(0), c.charCodeAt(1), c.charCodeAt(2));\n    return e !== c + ';' ? e.replace(oa, ' or ($1)').substring(4) : '(' + c + ')';\n  }\n\n  function H(d, c, e, h, a, m, b, v, n, q) {\n    for (var g = 0, x = c, w; g < A; ++g) {\n      switch (w = S[g].call(B, d, x, e, h, a, m, b, v, n, q)) {\n        case void 0:\n        case !1:\n        case !0:\n        case null:\n          break;\n\n        default:\n          x = w;\n      }\n    }\n\n    if (x !== c) return x;\n  }\n\n  function T(d) {\n    switch (d) {\n      case void 0:\n      case null:\n        A = S.length = 0;\n        break;\n\n      default:\n        if ('function' === typeof d) S[A++] = d;else if ('object' === typeof d) for (var c = 0, e = d.length; c < e; ++c) {\n          T(d[c]);\n        } else Y = !!d | 0;\n    }\n\n    return T;\n  }\n\n  function U(d) {\n    d = d.prefix;\n    void 0 !== d && (R = null, d ? 'function' !== typeof d ? w = 1 : (w = 2, R = d) : w = 0);\n    return U;\n  }\n\n  function B(d, c) {\n    var e = d;\n    33 > e.charCodeAt(0) && (e = e.trim());\n    V = e;\n    e = [V];\n\n    if (0 < A) {\n      var h = H(-1, c, e, e, D, z, 0, 0, 0, 0);\n      void 0 !== h && 'string' === typeof h && (c = h);\n    }\n\n    var a = M(O, e, c, 0, 0);\n    0 < A && (h = H(-2, a, e, e, D, z, a.length, 0, 0, 0), void 0 !== h && (a = h));\n    V = '';\n    E = 0;\n    z = D = 1;\n    return a;\n  }\n\n  var ca = /^\\0+/g,\n      N = /[\\0\\r\\f]/g,\n      aa = /: */g,\n      ka = /zoo|gra/,\n      ma = /([,: ])(transform)/g,\n      ia = /,\\r+?/g,\n      F = /([\\t\\r\\n ])*\\f?&/g,\n      fa = /@(k\\w+)\\s*(\\S*)\\s*/,\n      Q = /::(place)/g,\n      ha = /:(read-only)/g,\n      G = /[svh]\\w+-[tblr]{2}/,\n      da = /\\(\\s*(.*)\\s*\\)/g,\n      oa = /([\\s\\S]*?);/g,\n      ba = /-self|flex-/g,\n      na = /[^]*?(:[rp][el]a[\\w-]+)[^]*/,\n      la = /stretch|:\\s*\\w+\\-(?:conte|avail)/,\n      ja = /([^-])(image-set\\()/,\n      z = 1,\n      D = 1,\n      E = 0,\n      w = 1,\n      O = [],\n      S = [],\n      A = 0,\n      R = null,\n      Y = 0,\n      V = '';\n  B.use = T;\n  B.set = U;\n  void 0 !== W && U(W);\n  return B;\n}\n\n/* harmony default export */ const stylis_browser_esm = (stylis_min);\n\n;// CONCATENATED MODULE: ./node_modules/@emotion/unitless/dist/unitless.browser.esm.js\nvar unitlessKeys = {\n  animationIterationCount: 1,\n  borderImageOutset: 1,\n  borderImageSlice: 1,\n  borderImageWidth: 1,\n  boxFlex: 1,\n  boxFlexGroup: 1,\n  boxOrdinalGroup: 1,\n  columnCount: 1,\n  columns: 1,\n  flex: 1,\n  flexGrow: 1,\n  flexPositive: 1,\n  flexShrink: 1,\n  flexNegative: 1,\n  flexOrder: 1,\n  gridRow: 1,\n  gridRowEnd: 1,\n  gridRowSpan: 1,\n  gridRowStart: 1,\n  gridColumn: 1,\n  gridColumnEnd: 1,\n  gridColumnSpan: 1,\n  gridColumnStart: 1,\n  msGridRow: 1,\n  msGridRowSpan: 1,\n  msGridColumn: 1,\n  msGridColumnSpan: 1,\n  fontWeight: 1,\n  lineHeight: 1,\n  opacity: 1,\n  order: 1,\n  orphans: 1,\n  tabSize: 1,\n  widows: 1,\n  zIndex: 1,\n  zoom: 1,\n  WebkitLineClamp: 1,\n  // SVG-related properties\n  fillOpacity: 1,\n  floodOpacity: 1,\n  stopOpacity: 1,\n  strokeDasharray: 1,\n  strokeDashoffset: 1,\n  strokeMiterlimit: 1,\n  strokeOpacity: 1,\n  strokeWidth: 1\n};\n\n/* harmony default export */ const unitless_browser_esm = (unitlessKeys);\n\n;// CONCATENATED MODULE: ./node_modules/@emotion/memoize/dist/emotion-memoize.browser.esm.js\nfunction memoize(fn) {\n  var cache = Object.create(null);\n  return function (arg) {\n    if (cache[arg] === undefined) cache[arg] = fn(arg);\n    return cache[arg];\n  };\n}\n\n/* harmony default export */ const emotion_memoize_browser_esm = (memoize);\n\n;// CONCATENATED MODULE: ./node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.browser.esm.js\n\n\nvar reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23\n\nvar isPropValid = /* #__PURE__ */emotion_memoize_browser_esm(function (prop) {\n  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111\n  /* o */\n  && prop.charCodeAt(1) === 110\n  /* n */\n  && prop.charCodeAt(2) < 91;\n}\n/* Z+1 */\n);\n\n/* harmony default export */ const emotion_is_prop_valid_browser_esm = (isPropValid);\n\n;// CONCATENATED MODULE: ./node_modules/styled-components/dist/styled-components.browser.esm.js\nfunction v(){return(v=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}var g=function(e,t){for(var n=[e[0]],r=0,o=t.length;r<o;r+=1)n.push(t[r],e[r+1]);return n},S=function(t){return null!==t&&\"object\"==typeof t&&\"[object Object]\"===(t.toString?t.toString():Object.prototype.toString.call(t))&&!(0,node_modules_react_is.typeOf)(t)},w=Object.freeze([]),E=Object.freeze({});function b(e){return\"function\"==typeof e}function _(e){return false||e.displayName||e.name||\"Component\"}function N(e){return e&&\"string\"==typeof e.styledComponentId}var A=\"undefined\"!=typeof process&&(process.env.REACT_APP_SC_ATTR||process.env.SC_ATTR)||\"data-styled\",C=\"5.3.5\",I=\"undefined\"!=typeof window&&\"HTMLElement\"in window,P=Boolean(\"boolean\"==typeof SC_DISABLE_SPEEDY?SC_DISABLE_SPEEDY:\"undefined\"!=typeof process&&void 0!==process.env.REACT_APP_SC_DISABLE_SPEEDY&&\"\"!==process.env.REACT_APP_SC_DISABLE_SPEEDY?\"false\"!==process.env.REACT_APP_SC_DISABLE_SPEEDY&&process.env.REACT_APP_SC_DISABLE_SPEEDY:\"undefined\"!=typeof process&&void 0!==process.env.SC_DISABLE_SPEEDY&&\"\"!==process.env.SC_DISABLE_SPEEDY?\"false\"!==process.env.SC_DISABLE_SPEEDY&&process.env.SC_DISABLE_SPEEDY:\"production\"!==\"production\"),O={},R= false?0:{};function D(){for(var e=arguments.length<=0?void 0:arguments[0],t=[],n=1,r=arguments.length;n<r;n+=1)t.push(n<0||arguments.length<=n?void 0:arguments[n]);return t.forEach((function(t){e=e.replace(/%[a-z]/,t)})),e}function j(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];throw true?new Error(\"An error occurred. See https://git.io/JUIaE#\"+e+\" for more information.\"+(n.length>0?\" Args: \"+n.join(\", \"):\"\")):0}var T=function(){function e(e){this.groupSizes=new Uint32Array(512),this.length=512,this.tag=e}var t=e.prototype;return t.indexOfGroup=function(e){for(var t=0,n=0;n<e;n++)t+=this.groupSizes[n];return t},t.insertRules=function(e,t){if(e>=this.groupSizes.length){for(var n=this.groupSizes,r=n.length,o=r;e>=o;)(o<<=1)<0&&j(16,\"\"+e);this.groupSizes=new Uint32Array(o),this.groupSizes.set(n),this.length=o;for(var s=r;s<o;s++)this.groupSizes[s]=0}for(var i=this.indexOfGroup(e+1),a=0,c=t.length;a<c;a++)this.tag.insertRule(i,t[a])&&(this.groupSizes[e]++,i++)},t.clearGroup=function(e){if(e<this.length){var t=this.groupSizes[e],n=this.indexOfGroup(e),r=n+t;this.groupSizes[e]=0;for(var o=n;o<r;o++)this.tag.deleteRule(n)}},t.getGroup=function(e){var t=\"\";if(e>=this.length||0===this.groupSizes[e])return t;for(var n=this.groupSizes[e],r=this.indexOfGroup(e),o=r+n,s=r;s<o;s++)t+=this.tag.getRule(s)+\"/*!sc*/\\n\";return t},e}(),x=new Map,k=new Map,V=1,B=function(e){if(x.has(e))return x.get(e);for(;k.has(V);)V++;var t=V++;return false&&0,x.set(e,t),k.set(t,e),t},z=function(e){return k.get(e)},M=function(e,t){t>=V&&(V=t+1),x.set(e,t),k.set(t,e)},G=\"style[\"+A+'][data-styled-version=\"5.3.5\"]',L=new RegExp(\"^\"+A+'\\\\.g(\\\\d+)\\\\[id=\"([\\\\w\\\\d-]+)\"\\\\].*?\"([^\"]*)'),F=function(e,t,n){for(var r,o=n.split(\",\"),s=0,i=o.length;s<i;s++)(r=o[s])&&e.registerName(t,r)},Y=function(e,t){for(var n=(t.textContent||\"\").split(\"/*!sc*/\\n\"),r=[],o=0,s=n.length;o<s;o++){var i=n[o].trim();if(i){var a=i.match(L);if(a){var c=0|parseInt(a[1],10),u=a[2];0!==c&&(M(u,c),F(e,u,a[3]),e.getTag().insertRules(c,r)),r.length=0}else r.push(i)}}},q=function(){return\"undefined\"!=typeof window&&void 0!==window.__webpack_nonce__?window.__webpack_nonce__:null},H=function(e){var t=document.head,n=e||t,r=document.createElement(\"style\"),o=function(e){for(var t=e.childNodes,n=t.length;n>=0;n--){var r=t[n];if(r&&1===r.nodeType&&r.hasAttribute(A))return r}}(n),s=void 0!==o?o.nextSibling:null;r.setAttribute(A,\"active\"),r.setAttribute(\"data-styled-version\",\"5.3.5\");var i=q();return i&&r.setAttribute(\"nonce\",i),n.insertBefore(r,s),r},$=function(){function e(e){var t=this.element=H(e);t.appendChild(document.createTextNode(\"\")),this.sheet=function(e){if(e.sheet)return e.sheet;for(var t=document.styleSheets,n=0,r=t.length;n<r;n++){var o=t[n];if(o.ownerNode===e)return o}j(17)}(t),this.length=0}var t=e.prototype;return t.insertRule=function(e,t){try{return this.sheet.insertRule(t,e),this.length++,!0}catch(e){return!1}},t.deleteRule=function(e){this.sheet.deleteRule(e),this.length--},t.getRule=function(e){var t=this.sheet.cssRules[e];return void 0!==t&&\"string\"==typeof t.cssText?t.cssText:\"\"},e}(),W=function(){function e(e){var t=this.element=H(e);this.nodes=t.childNodes,this.length=0}var t=e.prototype;return t.insertRule=function(e,t){if(e<=this.length&&e>=0){var n=document.createTextNode(t),r=this.nodes[e];return this.element.insertBefore(n,r||null),this.length++,!0}return!1},t.deleteRule=function(e){this.element.removeChild(this.nodes[e]),this.length--},t.getRule=function(e){return e<this.length?this.nodes[e].textContent:\"\"},e}(),U=function(){function e(e){this.rules=[],this.length=0}var t=e.prototype;return t.insertRule=function(e,t){return e<=this.length&&(this.rules.splice(e,0,t),this.length++,!0)},t.deleteRule=function(e){this.rules.splice(e,1),this.length--},t.getRule=function(e){return e<this.length?this.rules[e]:\"\"},e}(),J=I,X={isServer:!I,useCSSOMInjection:!P},Z=function(){function e(e,t,n){void 0===e&&(e=E),void 0===t&&(t={}),this.options=v({},X,{},e),this.gs=t,this.names=new Map(n),this.server=!!e.isServer,!this.server&&I&&J&&(J=!1,function(e){for(var t=document.querySelectorAll(G),n=0,r=t.length;n<r;n++){var o=t[n];o&&\"active\"!==o.getAttribute(A)&&(Y(e,o),o.parentNode&&o.parentNode.removeChild(o))}}(this))}e.registerId=function(e){return B(e)};var t=e.prototype;return t.reconstructWithOptions=function(t,n){return void 0===n&&(n=!0),new e(v({},this.options,{},t),this.gs,n&&this.names||void 0)},t.allocateGSInstance=function(e){return this.gs[e]=(this.gs[e]||0)+1},t.getTag=function(){return this.tag||(this.tag=(n=(t=this.options).isServer,r=t.useCSSOMInjection,o=t.target,e=n?new U(o):r?new $(o):new W(o),new T(e)));var e,t,n,r,o},t.hasNameForId=function(e,t){return this.names.has(e)&&this.names.get(e).has(t)},t.registerName=function(e,t){if(B(e),this.names.has(e))this.names.get(e).add(t);else{var n=new Set;n.add(t),this.names.set(e,n)}},t.insertRules=function(e,t,n){this.registerName(e,t),this.getTag().insertRules(B(e),n)},t.clearNames=function(e){this.names.has(e)&&this.names.get(e).clear()},t.clearRules=function(e){this.getTag().clearGroup(B(e)),this.clearNames(e)},t.clearTag=function(){this.tag=void 0},t.toString=function(){return function(e){for(var t=e.getTag(),n=t.length,r=\"\",o=0;o<n;o++){var s=z(o);if(void 0!==s){var i=e.names.get(s),a=t.getGroup(o);if(i&&a&&i.size){var c=A+\".g\"+o+'[id=\"'+s+'\"]',u=\"\";void 0!==i&&i.forEach((function(e){e.length>0&&(u+=e+\",\")})),r+=\"\"+a+c+'{content:\"'+u+'\"}/*!sc*/\\n'}}}return r}(this)},e}(),K=/(a)(d)/gi,Q=function(e){return String.fromCharCode(e+(e>25?39:97))};function ee(e){var t,n=\"\";for(t=Math.abs(e);t>52;t=t/52|0)n=Q(t%52)+n;return(Q(t%52)+n).replace(K,\"$1-$2\")}var te=function(e,t){for(var n=t.length;n;)e=33*e^t.charCodeAt(--n);return e},ne=function(e){return te(5381,e)};function re(e){for(var t=0;t<e.length;t+=1){var n=e[t];if(b(n)&&!N(n))return!1}return!0}var oe=ne(\"5.3.5\"),se=function(){function e(e,t,n){this.rules=e,this.staticRulesId=\"\",this.isStatic= true&&(void 0===n||n.isStatic)&&re(e),this.componentId=t,this.baseHash=te(oe,t),this.baseStyle=n,Z.registerId(t)}return e.prototype.generateAndInjectStyles=function(e,t,n){var r=this.componentId,o=[];if(this.baseStyle&&o.push(this.baseStyle.generateAndInjectStyles(e,t,n)),this.isStatic&&!n.hash)if(this.staticRulesId&&t.hasNameForId(r,this.staticRulesId))o.push(this.staticRulesId);else{var s=Ne(this.rules,e,t,n).join(\"\"),i=ee(te(this.baseHash,s)>>>0);if(!t.hasNameForId(r,i)){var a=n(s,\".\"+i,void 0,r);t.insertRules(r,i,a)}o.push(i),this.staticRulesId=i}else{for(var c=this.rules.length,u=te(this.baseHash,n.hash),l=\"\",d=0;d<c;d++){var h=this.rules[d];if(\"string\"==typeof h)l+=h, false&&(0);else if(h){var p=Ne(h,e,t,n),f=Array.isArray(p)?p.join(\"\"):p;u=te(u,f+d),l+=f}}if(l){var m=ee(u>>>0);if(!t.hasNameForId(r,m)){var y=n(l,\".\"+m,void 0,r);t.insertRules(r,m,y)}o.push(m)}}return o.join(\" \")},e}(),ie=/^\\s*\\/\\/.*$/gm,ae=[\":\",\"[\",\".\",\"#\"];function ce(e){var t,n,r,o,s=void 0===e?E:e,i=s.options,a=void 0===i?E:i,c=s.plugins,u=void 0===c?w:c,l=new stylis_browser_esm(a),d=[],h=function(e){function t(t){if(t)try{e(t+\"}\")}catch(e){}}return function(n,r,o,s,i,a,c,u,l,d){switch(n){case 1:if(0===l&&64===r.charCodeAt(0))return e(r+\";\"),\"\";break;case 2:if(0===u)return r+\"/*|*/\";break;case 3:switch(u){case 102:case 112:return e(o[0]+r),\"\";default:return r+(0===d?\"/*|*/\":\"\")}case-2:r.split(\"/*|*/}\").forEach(t)}}}((function(e){d.push(e)})),f=function(e,r,s){return 0===r&&-1!==ae.indexOf(s[n.length])||s.match(o)?e:\".\"+t};function m(e,s,i,a){void 0===a&&(a=\"&\");var c=e.replace(ie,\"\"),u=s&&i?i+\" \"+s+\" { \"+c+\" }\":c;return t=a,n=s,r=new RegExp(\"\\\\\"+n+\"\\\\b\",\"g\"),o=new RegExp(\"(\\\\\"+n+\"\\\\b){2,}\"),l(i||!s?\"\":s,u)}return l.use([].concat(u,[function(e,t,o){2===e&&o.length&&o[0].lastIndexOf(n)>0&&(o[0]=o[0].replace(r,f))},h,function(e){if(-2===e){var t=d;return d=[],t}}])),m.hash=u.length?u.reduce((function(e,t){return t.name||j(15),te(e,t.name)}),5381).toString():\"\",m}var ue=react.createContext(),le=ue.Consumer,de=react.createContext(),he=(de.Consumer,new Z),pe=ce();function fe(){return (0,react.useContext)(ue)||he}function me(){return (0,react.useContext)(de)||pe}function ye(e){var t=(0,react.useState)(e.stylisPlugins),n=t[0],s=t[1],c=fe(),u=(0,react.useMemo)((function(){var t=c;return e.sheet?t=e.sheet:e.target&&(t=t.reconstructWithOptions({target:e.target},!1)),e.disableCSSOMInjection&&(t=t.reconstructWithOptions({useCSSOMInjection:!1})),t}),[e.disableCSSOMInjection,e.sheet,e.target]),l=(0,react.useMemo)((function(){return ce({options:{prefix:!e.disableVendorPrefixes},plugins:n})}),[e.disableVendorPrefixes,n]);return (0,react.useEffect)((function(){shallowequal_default()(n,e.stylisPlugins)||s(e.stylisPlugins)}),[e.stylisPlugins]),react.createElement(ue.Provider,{value:u},react.createElement(de.Provider,{value:l}, false?0:e.children))}var ve=function(){function e(e,t){var n=this;this.inject=function(e,t){void 0===t&&(t=pe);var r=n.name+t.hash;e.hasNameForId(n.id,r)||e.insertRules(n.id,r,t(n.rules,r,\"@keyframes\"))},this.toString=function(){return j(12,String(n.name))},this.name=e,this.id=\"sc-keyframes-\"+e,this.rules=t}return e.prototype.getName=function(e){return void 0===e&&(e=pe),this.name+e.hash},e}(),ge=/([A-Z])/,Se=/([A-Z])/g,we=/^ms-/,Ee=function(e){return\"-\"+e.toLowerCase()};function be(e){return ge.test(e)?e.replace(Se,Ee).replace(we,\"-ms-\"):e}var _e=function(e){return null==e||!1===e||\"\"===e};function Ne(e,n,r,o){if(Array.isArray(e)){for(var s,i=[],a=0,c=e.length;a<c;a+=1)\"\"!==(s=Ne(e[a],n,r,o))&&(Array.isArray(s)?i.push.apply(i,s):i.push(s));return i}if(_e(e))return\"\";if(N(e))return\".\"+e.styledComponentId;if(b(e)){if(\"function\"!=typeof(l=e)||l.prototype&&l.prototype.isReactComponent||!n)return e;var u=e(n);return false&&0,Ne(u,n,r,o)}var l;return e instanceof ve?r?(e.inject(r,o),e.getName(o)):e:S(e)?function e(t,n){var r,o,s=[];for(var i in t)t.hasOwnProperty(i)&&!_e(t[i])&&(Array.isArray(t[i])&&t[i].isCss||b(t[i])?s.push(be(i)+\":\",t[i],\";\"):S(t[i])?s.push.apply(s,e(t[i],i)):s.push(be(i)+\": \"+(r=i,null==(o=t[i])||\"boolean\"==typeof o||\"\"===o?\"\":\"number\"!=typeof o||0===o||r in unitless_browser_esm?String(o).trim():o+\"px\")+\";\"));return n?[n+\" {\"].concat(s,[\"}\"]):s}(e):e.toString()}var Ae=function(e){return Array.isArray(e)&&(e.isCss=!0),e};function Ce(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return b(e)||S(e)?Ae(Ne(g(w,[e].concat(n)))):0===n.length&&1===e.length&&\"string\"==typeof e[0]?e:Ae(Ne(g(e,n)))}var Ie=/invalid hook call/i,Pe=new Set,Oe=function(e,t){if(false){ var o, n, r; }},Re=function(e,t,n){return void 0===n&&(n=E),e.theme!==n.theme&&e.theme||t||n.theme},De=/[!\"#$%&'()*+,./:;<=>?@[\\\\\\]^`{|}~-]+/g,je=/(^-|-$)/g;function Te(e){return e.replace(De,\"-\").replace(je,\"\")}var xe=function(e){return ee(ne(e)>>>0)};function ke(e){return\"string\"==typeof e&&( true||0)}var Ve=function(e){return\"function\"==typeof e||\"object\"==typeof e&&null!==e&&!Array.isArray(e)},Be=function(e){return\"__proto__\"!==e&&\"constructor\"!==e&&\"prototype\"!==e};function ze(e,t,n){var r=e[n];Ve(t)&&Ve(r)?Me(r,t):e[n]=t}function Me(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];for(var o=0,s=n;o<s.length;o++){var i=s[o];if(Ve(i))for(var a in i)Be(a)&&ze(e,i[a],a)}return e}var Ge=react.createContext(),Le=Ge.Consumer;function Fe(e){var t=s(Ge),n=i((function(){return function(e,t){if(!e)return j(14);if(b(e)){var n=e(t);return true?n:0}return Array.isArray(e)||\"object\"!=typeof e?j(8):t?v({},t,{},e):e}(e.theme,t)}),[e.theme,t]);return e.children?r.createElement(Ge.Provider,{value:n},e.children):null}var Ye={};function qe(e,t,n){var o=N(e),i=!ke(e),a=t.attrs,c=void 0===a?w:a,d=t.componentId,h=void 0===d?function(e,t){var n=\"string\"!=typeof e?\"sc\":Te(e);Ye[n]=(Ye[n]||0)+1;var r=n+\"-\"+xe(\"5.3.5\"+n+Ye[n]);return t?t+\"-\"+r:r}(t.displayName,t.parentComponentId):d,p=t.displayName,f=void 0===p?function(e){return ke(e)?\"styled.\"+e:\"Styled(\"+_(e)+\")\"}(e):p,g=t.displayName&&t.componentId?Te(t.displayName)+\"-\"+t.componentId:t.componentId||h,S=o&&e.attrs?Array.prototype.concat(e.attrs,c).filter(Boolean):c,A=t.shouldForwardProp;o&&e.shouldForwardProp&&(A=t.shouldForwardProp?function(n,r,o){return e.shouldForwardProp(n,r,o)&&t.shouldForwardProp(n,r,o)}:e.shouldForwardProp);var C,I=new se(n,g,o?e.componentStyle:void 0),P=I.isStatic&&0===c.length,O=function(e,t){return function(e,t,n,r){var o=e.attrs,i=e.componentStyle,a=e.defaultProps,c=e.foldedComponentIds,d=e.shouldForwardProp,h=e.styledComponentId,p=e.target; false&&0;var f=function(e,t,n){void 0===e&&(e=E);var r=v({},t,{theme:e}),o={};return n.forEach((function(e){var t,n,s,i=e;for(t in b(i)&&(i=i(r)),i)r[t]=o[t]=\"className\"===t?(n=o[t],s=i[t],n&&s?n+\" \"+s:n||s):i[t]})),[r,o]}(Re(t,(0,react.useContext)(Ge),a)||E,t,o),y=f[0],g=f[1],S=function(e,t,n,r){var o=fe(),s=me(),i=t?e.generateAndInjectStyles(E,o,s):e.generateAndInjectStyles(n,o,s);return false&&0, false&&0,i}(i,r,y, false?0:void 0),w=n,_=g.$as||t.$as||g.as||t.as||p,N=ke(_),A=g!==t?v({},t,{},g):t,C={};for(var I in A)\"$\"!==I[0]&&\"as\"!==I&&(\"forwardedAs\"===I?C.as=A[I]:(d?d(I,emotion_is_prop_valid_browser_esm,_):!N||emotion_is_prop_valid_browser_esm(I))&&(C[I]=A[I]));return t.style&&g.style!==t.style&&(C.style=v({},t.style,{},g.style)),C.className=Array.prototype.concat(c,h,S!==h?S:null,t.className,g.className).filter(Boolean).join(\" \"),C.ref=w,(0,react.createElement)(_,C)}(C,e,t,P)};return O.displayName=f,(C=react.forwardRef(O)).attrs=S,C.componentStyle=I,C.displayName=f,C.shouldForwardProp=A,C.foldedComponentIds=o?Array.prototype.concat(e.foldedComponentIds,e.styledComponentId):w,C.styledComponentId=g,C.target=o?e.target:e,C.withComponent=function(e){var r=t.componentId,o=function(e,t){if(null==e)return{};var n,r,o={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(t,[\"componentId\"]),s=r&&r+\"-\"+(ke(e)?e:Te(_(e)));return qe(e,v({},o,{attrs:S,componentId:s}),n)},Object.defineProperty(C,\"defaultProps\",{get:function(){return this._foldedDefaultProps},set:function(t){this._foldedDefaultProps=o?Me({},e.defaultProps,t):t}}), false&&(0),C.toString=function(){return\".\"+C.styledComponentId},i&&hoist_non_react_statics_cjs_default()(C,e,{attrs:!0,componentStyle:!0,displayName:!0,foldedComponentIds:!0,shouldForwardProp:!0,styledComponentId:!0,target:!0,withComponent:!0}),C}var He=function(e){return function e(t,r,o){if(void 0===o&&(o=E),!(0,node_modules_react_is.isValidElementType)(r))return j(1,String(r));var s=function(){return t(r,o,Ce.apply(void 0,arguments))};return s.withConfig=function(n){return e(t,r,v({},o,{},n))},s.attrs=function(n){return e(t,r,v({},o,{attrs:Array.prototype.concat(o.attrs,n).filter(Boolean)}))},s}(qe,e)};[\"a\",\"abbr\",\"address\",\"area\",\"article\",\"aside\",\"audio\",\"b\",\"base\",\"bdi\",\"bdo\",\"big\",\"blockquote\",\"body\",\"br\",\"button\",\"canvas\",\"caption\",\"cite\",\"code\",\"col\",\"colgroup\",\"data\",\"datalist\",\"dd\",\"del\",\"details\",\"dfn\",\"dialog\",\"div\",\"dl\",\"dt\",\"em\",\"embed\",\"fieldset\",\"figcaption\",\"figure\",\"footer\",\"form\",\"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\",\"head\",\"header\",\"hgroup\",\"hr\",\"html\",\"i\",\"iframe\",\"img\",\"input\",\"ins\",\"kbd\",\"keygen\",\"label\",\"legend\",\"li\",\"link\",\"main\",\"map\",\"mark\",\"marquee\",\"menu\",\"menuitem\",\"meta\",\"meter\",\"nav\",\"noscript\",\"object\",\"ol\",\"optgroup\",\"option\",\"output\",\"p\",\"param\",\"picture\",\"pre\",\"progress\",\"q\",\"rp\",\"rt\",\"ruby\",\"s\",\"samp\",\"script\",\"section\",\"select\",\"small\",\"source\",\"span\",\"strong\",\"style\",\"sub\",\"summary\",\"sup\",\"table\",\"tbody\",\"td\",\"textarea\",\"tfoot\",\"th\",\"thead\",\"time\",\"title\",\"tr\",\"track\",\"u\",\"ul\",\"var\",\"video\",\"wbr\",\"circle\",\"clipPath\",\"defs\",\"ellipse\",\"foreignObject\",\"g\",\"image\",\"line\",\"linearGradient\",\"marker\",\"mask\",\"path\",\"pattern\",\"polygon\",\"polyline\",\"radialGradient\",\"rect\",\"stop\",\"svg\",\"text\",\"textPath\",\"tspan\"].forEach((function(e){He[e]=He(e)}));var $e=function(){function e(e,t){this.rules=e,this.componentId=t,this.isStatic=re(e),Z.registerId(this.componentId+1)}var t=e.prototype;return t.createStyles=function(e,t,n,r){var o=r(Ne(this.rules,t,n,r).join(\"\"),\"\"),s=this.componentId+e;n.insertRules(s,s,o)},t.removeStyles=function(e,t){t.clearRules(this.componentId+e)},t.renderStyles=function(e,t,n,r){e>2&&Z.registerId(this.componentId+e),this.removeStyles(e,n),this.createStyles(e,t,n,r)},e}();function We(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),o=1;o<t;o++)n[o-1]=arguments[o];var i=Ce.apply(void 0,[e].concat(n)),a=\"sc-global-\"+xe(JSON.stringify(i)),u=new $e(i,a);function l(e){var t=fe(),n=me(),o=s(Ge),l=c(t.allocateGSInstance(a)).current;return false&&0, false&&0,t.server&&h(l,e,t,o,n),d((function(){if(!t.server)return h(l,e,t,o,n),function(){return u.removeStyles(l,t)}}),[l,e,t,o,n]),null}function h(e,t,n,r,o){if(u.isStatic)u.renderStyles(e,O,n,o);else{var s=v({},t,{theme:Re(t,r,l.defaultProps)});u.renderStyles(e,s,n,o)}}return false&&0,r.memo(l)}function Ue(e){ false&&0;for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];var o=Ce.apply(void 0,[e].concat(n)).join(\"\"),s=xe(o);return new ve(s,o)}var Je=function(){function e(){var e=this;this._emitSheetCSS=function(){var t=e.instance.toString();if(!t)return\"\";var n=q();return\"<style \"+[n&&'nonce=\"'+n+'\"',A+'=\"true\"','data-styled-version=\"5.3.5\"'].filter(Boolean).join(\" \")+\">\"+t+\"</style>\"},this.getStyleTags=function(){return e.sealed?j(2):e._emitSheetCSS()},this.getStyleElement=function(){var t;if(e.sealed)return j(2);var n=((t={})[A]=\"\",t[\"data-styled-version\"]=\"5.3.5\",t.dangerouslySetInnerHTML={__html:e.instance.toString()},t),o=q();return o&&(n.nonce=o),[react.createElement(\"style\",v({},n,{key:\"sc-0-0\"}))]},this.seal=function(){e.sealed=!0},this.instance=new Z({isServer:!0}),this.sealed=!1}var t=e.prototype;return t.collectStyles=function(e){return this.sealed?j(2):react.createElement(ye,{sheet:this.instance},e)},t.interleaveWithNodeStream=function(e){return j(3)},e}(),Xe=function(e){var t=r.forwardRef((function(t,n){var o=s(Ge),i=e.defaultProps,a=Re(t,o,i);return false&&0,r.createElement(e,v({},t,{theme:a,ref:n}))}));return y(t,e),t.displayName=\"WithTheme(\"+_(e)+\")\",t},Ze=function(){return s(Ge)},Ke={StyleSheet:Z,masterSheet:he}; false&&0, false&&(0);/* harmony default export */ const styled_components_browser_esm = (He);\n//# sourceMappingURL=styled-components.browser.esm.js.map\n\n// EXTERNAL MODULE: ./node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(697);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n// EXTERNAL MODULE: ./node_modules/classnames/index.js\nvar classnames = __webpack_require__(184);\nvar classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);\n// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js\nvar jsx_runtime = __webpack_require__(893);\n;// CONCATENATED MODULE: ./node_modules/react-bootstrap/esm/ThemeProvider.js\n\n\n\nconst DEFAULT_BREAKPOINTS = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs'];\nconst ThemeContext = /*#__PURE__*/react.createContext({\n  prefixes: {},\n  breakpoints: DEFAULT_BREAKPOINTS\n});\nconst {\n  Consumer,\n  Provider: ThemeProvider_Provider\n} = ThemeContext;\n\nfunction ThemeProvider({\n  prefixes = {},\n  breakpoints = DEFAULT_BREAKPOINTS,\n  dir,\n  children\n}) {\n  const contextValue = useMemo(() => ({\n    prefixes: { ...prefixes\n    },\n    breakpoints,\n    dir\n  }), [prefixes, breakpoints, dir]);\n  return /*#__PURE__*/_jsx(ThemeProvider_Provider, {\n    value: contextValue,\n    children: children\n  });\n}\n\nfunction useBootstrapPrefix(prefix, defaultPrefix) {\n  const {\n    prefixes\n  } = (0,react.useContext)(ThemeContext);\n  return prefix || prefixes[defaultPrefix] || defaultPrefix;\n}\nfunction useBootstrapBreakpoints() {\n  const {\n    breakpoints\n  } = (0,react.useContext)(ThemeContext);\n  return breakpoints;\n}\nfunction useIsRTL() {\n  const {\n    dir\n  } = useContext(ThemeContext);\n  return dir === 'rtl';\n}\n\nfunction createBootstrapComponent(Component, opts) {\n  if (typeof opts === 'string') opts = {\n    prefix: opts\n  };\n  const isClassy = Component.prototype && Component.prototype.isReactComponent; // If it's a functional component make sure we don't break it with a ref\n\n  const {\n    prefix,\n    forwardRefAs = isClassy ? 'ref' : 'innerRef'\n  } = opts;\n  const Wrapped = /*#__PURE__*/React.forwardRef(({ ...props\n  }, ref) => {\n    props[forwardRefAs] = ref;\n    const bsPrefix = useBootstrapPrefix(props.bsPrefix, prefix);\n    return /*#__PURE__*/_jsx(Component, { ...props,\n      bsPrefix: bsPrefix\n    });\n  });\n  Wrapped.displayName = `Bootstrap(${Component.displayName || Component.name})`;\n  return Wrapped;\n}\n\n\n/* harmony default export */ const esm_ThemeProvider = ((/* unused pure expression or super */ null && (ThemeProvider)));\n;// CONCATENATED MODULE: ./node_modules/react-bootstrap/esm/Container.js\n\n\n\n\nconst defaultProps = {\n  fluid: false\n};\nconst Container = /*#__PURE__*/react.forwardRef(({\n  bsPrefix,\n  fluid,\n  // Need to define the default \"as\" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595\n  as: Component = 'div',\n  className,\n  ...props\n}, ref) => {\n  const prefix = useBootstrapPrefix(bsPrefix, 'container');\n  const suffix = typeof fluid === 'string' ? `-${fluid}` : '-fluid';\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Component, {\n    ref: ref,\n    ...props,\n    className: classnames_default()(className, fluid ? `${prefix}${suffix}` : prefix)\n  });\n});\nContainer.displayName = 'Container';\nContainer.defaultProps = defaultProps;\n/* harmony default export */ const esm_Container = (Container);\n;// CONCATENATED MODULE: ./node_modules/react-bootstrap/esm/Row.js\n\n\n\n\nconst Row = /*#__PURE__*/react.forwardRef(({\n  bsPrefix,\n  className,\n  // Need to define the default \"as\" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595\n  as: Component = 'div',\n  ...props\n}, ref) => {\n  const decoratedBsPrefix = useBootstrapPrefix(bsPrefix, 'row');\n  const breakpoints = useBootstrapBreakpoints();\n  const sizePrefix = `${decoratedBsPrefix}-cols`;\n  const classes = [];\n  breakpoints.forEach(brkPoint => {\n    const propValue = props[brkPoint];\n    delete props[brkPoint];\n    let cols;\n\n    if (propValue != null && typeof propValue === 'object') {\n      ({\n        cols\n      } = propValue);\n    } else {\n      cols = propValue;\n    }\n\n    const infix = brkPoint !== 'xs' ? `-${brkPoint}` : '';\n    if (cols != null) classes.push(`${sizePrefix}${infix}-${cols}`);\n  });\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Component, {\n    ref: ref,\n    ...props,\n    className: classnames_default()(className, decoratedBsPrefix, ...classes)\n  });\n});\nRow.displayName = 'Row';\n/* harmony default export */ const esm_Row = (Row);\n;// CONCATENATED MODULE: ./node_modules/react-bootstrap/esm/Col.js\n\n\n\n\nfunction useCol({\n  as,\n  bsPrefix,\n  className,\n  ...props\n}) {\n  bsPrefix = useBootstrapPrefix(bsPrefix, 'col');\n  const breakpoints = useBootstrapBreakpoints();\n  const spans = [];\n  const classes = [];\n  breakpoints.forEach(brkPoint => {\n    const propValue = props[brkPoint];\n    delete props[brkPoint];\n    let span;\n    let offset;\n    let order;\n\n    if (typeof propValue === 'object' && propValue != null) {\n      ({\n        span,\n        offset,\n        order\n      } = propValue);\n    } else {\n      span = propValue;\n    }\n\n    const infix = brkPoint !== 'xs' ? `-${brkPoint}` : '';\n    if (span) spans.push(span === true ? `${bsPrefix}${infix}` : `${bsPrefix}${infix}-${span}`);\n    if (order != null) classes.push(`order${infix}-${order}`);\n    if (offset != null) classes.push(`offset${infix}-${offset}`);\n  });\n  return [{ ...props,\n    className: classnames_default()(className, ...spans, ...classes)\n  }, {\n    as,\n    bsPrefix,\n    spans\n  }];\n}\nconst Col = /*#__PURE__*/react.forwardRef( // Need to define the default \"as\" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595\n(props, ref) => {\n  const [{\n    className,\n    ...colProps\n  }, {\n    as: Component = 'div',\n    bsPrefix,\n    spans\n  }] = useCol(props);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Component, { ...colProps,\n    ref: ref,\n    className: classnames_default()(className, !spans.length && bsPrefix)\n  });\n});\nCol.displayName = 'Col';\n/* harmony default export */ const esm_Col = (Col);\n;// CONCATENATED MODULE: ./src/constants/uiConstants.js\nvar dark = '#222';\nvar darkBlue = '#339';\nvar lightBlue = '#77d';\nvar borderRadius = '7px';\nvar dialDimensions = '120px';\nvar dialBaseDimensionsPx = 95;\nvar DIAL_TYPES = {\n  SCALAR: 'SCALAR',\n  COORDS: 'COORDS',\n  ANGLE: 'ANGLE',\n  VECTOR: 'VECTOR'\n};\n;// CONCATENATED MODULE: ./src/templates/DashboardTemplate.jsx\nvar DashboardTemplate_excluded = [\"SimulationView\", \"ContentView\"];\n\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5;\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DashboardTemplate_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DashboardTemplate_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction DashboardTemplate_extends() { DashboardTemplate_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return DashboardTemplate_extends.apply(this, arguments); }\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\n\n\n\n\n\nvar StyledContainer = styled_components_browser_esm(esm_Container)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\\n  font-family: monospace;\\n\"])));\nvar ContentContainer = styled_components_browser_esm.div(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\\n  display: flex;\\n  justify-content: center;\\n\"])));\nvar TopContainer = styled_components_browser_esm.div(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\\n  background-color: \", \";\\n  width: 600px;\\n  height: 600px;\\n\\n  @media only screen and (max-width: 600px) {\\n    width: 100vw;\\n    height: 100vw;\\n  }\\n\"])), darkBlue);\nvar DefaultSimulationView = styled_components_browser_esm.div(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"\\n  color: #fff;\\n\"])));\nvar DefaultContentView = styled_components_browser_esm.div(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"  \\n  background-color: #ddd;\\n  color: #222;\\n  width: 800px;\\n  \\n  @media only screen and (max-width: 800px) {\\n    width: 100vw;\\n  }\\n\"])));\n\nvar DefaultSimulationViewComponent = function DefaultSimulationViewComponent(_ref) {\n  var props = DashboardTemplate_extends({}, _ref);\n\n  return /*#__PURE__*/react.createElement(DefaultSimulationView, null, \"Simulaatio\");\n};\n\nvar DefaultContentViewComponent = function DefaultContentViewComponent(_ref2) {\n  var props = DashboardTemplate_extends({}, _ref2);\n\n  return /*#__PURE__*/react.createElement(DefaultContentView, null, \"Sis\\xE4lt\\xF6\");\n};\n\nvar DashboardTemplate = function DashboardTemplate(_ref3) {\n  var SimulationView = _ref3.SimulationView,\n      ContentView = _ref3.ContentView,\n      props = _objectWithoutProperties(_ref3, DashboardTemplate_excluded);\n\n  return /*#__PURE__*/react.createElement(StyledContainer, null, /*#__PURE__*/react.createElement(esm_Row, null, /*#__PURE__*/react.createElement(esm_Col, null, /*#__PURE__*/react.createElement(ContentContainer, null, /*#__PURE__*/react.createElement(TopContainer, null, /*#__PURE__*/react.createElement(SimulationView, null))))), /*#__PURE__*/react.createElement(esm_Row, null, /*#__PURE__*/react.createElement(esm_Col, null, /*#__PURE__*/react.createElement(ContentContainer, null, /*#__PURE__*/react.createElement(ContentView, null)))), /*#__PURE__*/react.createElement(esm_Row, null, /*#__PURE__*/react.createElement(esm_Col, null, /*#__PURE__*/react.createElement(\"div\", {\n    id: \"debugView\"\n  }))));\n};\nDashboardTemplate.defaultProps = {\n  SimulationView: DefaultSimulationViewComponent,\n  ContentView: DefaultContentViewComponent\n};\nDashboardTemplate.propTypes = {\n  SimulationView: (prop_types_default()).elementType,\n  ContentView: (prop_types_default()).elementType\n};\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\n;// CONCATENATED MODULE: ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\n/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\r\n/* eslint-disable require-jsdoc, valid-jsdoc */\r\nvar MapShim = (function () {\r\n    if (typeof Map !== 'undefined') {\r\n        return Map;\r\n    }\r\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\r\n    function getIndex(arr, key) {\r\n        var result = -1;\r\n        arr.some(function (entry, index) {\r\n            if (entry[0] === key) {\r\n                result = index;\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n        return result;\r\n    }\r\n    return /** @class */ (function () {\r\n        function class_1() {\r\n            this.__entries__ = [];\r\n        }\r\n        Object.defineProperty(class_1.prototype, \"size\", {\r\n            /**\r\n             * @returns {boolean}\r\n             */\r\n            get: function () {\r\n                return this.__entries__.length;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\r\n        class_1.prototype.get = function (key) {\r\n            var index = getIndex(this.__entries__, key);\r\n            var entry = this.__entries__[index];\r\n            return entry && entry[1];\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.set = function (key, value) {\r\n            var index = getIndex(this.__entries__, key);\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            }\r\n            else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.delete = function (key) {\r\n            var entries = this.__entries__;\r\n            var index = getIndex(entries, key);\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.has = function (key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        };\r\n        /**\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.clear = function () {\r\n            this.__entries__.splice(0);\r\n        };\r\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.forEach = function (callback, ctx) {\r\n            if (ctx === void 0) { ctx = null; }\r\n            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\r\n                var entry = _a[_i];\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        };\r\n        return class_1;\r\n    }());\r\n})();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\r\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\r\nvar global$1 = (function () {\r\n    if (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.Math === Math) {\r\n        return __webpack_require__.g;\r\n    }\r\n    if (typeof self !== 'undefined' && self.Math === Math) {\r\n        return self;\r\n    }\r\n    if (typeof window !== 'undefined' && window.Math === Math) {\r\n        return window;\r\n    }\r\n    // eslint-disable-next-line no-new-func\r\n    return Function('return this')();\r\n})();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\r\nvar requestAnimationFrame$1 = (function () {\r\n    if (typeof requestAnimationFrame === 'function') {\r\n        // It's required to use a bounded function because IE sometimes throws\r\n        // an \"Invalid calling object\" error if rAF is invoked without the global\r\n        // object on the left hand side.\r\n        return requestAnimationFrame.bind(global$1);\r\n    }\r\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\r\n})();\n\n// Defines minimum timeout before adding a trailing call.\r\nvar trailingTimeout = 2;\r\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\r\nfunction throttle (callback, delay) {\r\n    var leadingCall = false, trailingCall = false, lastCallTime = 0;\r\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function resolvePending() {\r\n        if (leadingCall) {\r\n            leadingCall = false;\r\n            callback();\r\n        }\r\n        if (trailingCall) {\r\n            proxy();\r\n        }\r\n    }\r\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function timeoutCallback() {\r\n        requestAnimationFrame$1(resolvePending);\r\n    }\r\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function proxy() {\r\n        var timeStamp = Date.now();\r\n        if (leadingCall) {\r\n            // Reject immediately following calls.\r\n            if (timeStamp - lastCallTime < trailingTimeout) {\r\n                return;\r\n            }\r\n            // Schedule new call to be in invoked when the pending one is resolved.\r\n            // This is important for \"transitions\" which never actually start\r\n            // immediately so there is a chance that we might miss one if change\r\n            // happens amids the pending invocation.\r\n            trailingCall = true;\r\n        }\r\n        else {\r\n            leadingCall = true;\r\n            trailingCall = false;\r\n            setTimeout(timeoutCallback, delay);\r\n        }\r\n        lastCallTime = timeStamp;\r\n    }\r\n    return proxy;\r\n}\n\n// Minimum delay before invoking the update of observers.\r\nvar REFRESH_DELAY = 20;\r\n// A list of substrings of CSS properties used to find transition events that\r\n// might affect dimensions of observed elements.\r\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\r\n// Check if MutationObserver is available.\r\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\r\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\r\nvar ResizeObserverController = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserverController.\r\n     *\r\n     * @private\r\n     */\r\n    function ResizeObserverController() {\r\n        /**\r\n         * Indicates whether DOM listeners have been added.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.connected_ = false;\r\n        /**\r\n         * Tells that controller has subscribed for Mutation Events.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.mutationEventsAdded_ = false;\r\n        /**\r\n         * Keeps reference to the instance of MutationObserver.\r\n         *\r\n         * @private {MutationObserver}\r\n         */\r\n        this.mutationsObserver_ = null;\r\n        /**\r\n         * A list of connected observers.\r\n         *\r\n         * @private {Array<ResizeObserverSPI>}\r\n         */\r\n        this.observers_ = [];\r\n        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\r\n        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\r\n    }\r\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be added.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.addObserver = function (observer) {\r\n        if (!~this.observers_.indexOf(observer)) {\r\n            this.observers_.push(observer);\r\n        }\r\n        // Add listeners if they haven't been added yet.\r\n        if (!this.connected_) {\r\n            this.connect_();\r\n        }\r\n    };\r\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.removeObserver = function (observer) {\r\n        var observers = this.observers_;\r\n        var index = observers.indexOf(observer);\r\n        // Remove observer if it's present in registry.\r\n        if (~index) {\r\n            observers.splice(index, 1);\r\n        }\r\n        // Remove listeners if controller has no connected observers.\r\n        if (!observers.length && this.connected_) {\r\n            this.disconnect_();\r\n        }\r\n    };\r\n    /**\r\n     * Invokes the update of observers. It will continue running updates insofar\r\n     * it detects changes.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.refresh = function () {\r\n        var changesDetected = this.updateObservers_();\r\n        // Continue running updates if changes have been detected as there might\r\n        // be future ones caused by CSS transitions.\r\n        if (changesDetected) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Updates every observer from observers list and notifies them of queued\r\n     * entries.\r\n     *\r\n     * @private\r\n     * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n     *      dimensions of it's elements.\r\n     */\r\n    ResizeObserverController.prototype.updateObservers_ = function () {\r\n        // Collect observers that have active observations.\r\n        var activeObservers = this.observers_.filter(function (observer) {\r\n            return observer.gatherActive(), observer.hasActive();\r\n        });\r\n        // Deliver notifications in a separate cycle in order to avoid any\r\n        // collisions between observers, e.g. when multiple instances of\r\n        // ResizeObserver are tracking the same element and the callback of one\r\n        // of them changes content dimensions of the observed target. Sometimes\r\n        // this may result in notifications being blocked for the rest of observers.\r\n        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\r\n        return activeObservers.length > 0;\r\n    };\r\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.connect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already added.\r\n        if (!isBrowser || this.connected_) {\r\n            return;\r\n        }\r\n        // Subscription to the \"Transitionend\" event is used as a workaround for\r\n        // delayed transitions. This way it's possible to capture at least the\r\n        // final state of an element.\r\n        document.addEventListener('transitionend', this.onTransitionEnd_);\r\n        window.addEventListener('resize', this.refresh);\r\n        if (mutationObserverSupported) {\r\n            this.mutationsObserver_ = new MutationObserver(this.refresh);\r\n            this.mutationsObserver_.observe(document, {\r\n                attributes: true,\r\n                childList: true,\r\n                characterData: true,\r\n                subtree: true\r\n            });\r\n        }\r\n        else {\r\n            document.addEventListener('DOMSubtreeModified', this.refresh);\r\n            this.mutationEventsAdded_ = true;\r\n        }\r\n        this.connected_ = true;\r\n    };\r\n    /**\r\n     * Removes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.disconnect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already removed.\r\n        if (!isBrowser || !this.connected_) {\r\n            return;\r\n        }\r\n        document.removeEventListener('transitionend', this.onTransitionEnd_);\r\n        window.removeEventListener('resize', this.refresh);\r\n        if (this.mutationsObserver_) {\r\n            this.mutationsObserver_.disconnect();\r\n        }\r\n        if (this.mutationEventsAdded_) {\r\n            document.removeEventListener('DOMSubtreeModified', this.refresh);\r\n        }\r\n        this.mutationsObserver_ = null;\r\n        this.mutationEventsAdded_ = false;\r\n        this.connected_ = false;\r\n    };\r\n    /**\r\n     * \"Transitionend\" event handler.\r\n     *\r\n     * @private\r\n     * @param {TransitionEvent} event\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\r\n        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;\r\n        // Detect whether transition may affect dimensions of an element.\r\n        var isReflowProperty = transitionKeys.some(function (key) {\r\n            return !!~propertyName.indexOf(key);\r\n        });\r\n        if (isReflowProperty) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Returns instance of the ResizeObserverController.\r\n     *\r\n     * @returns {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.getInstance = function () {\r\n        if (!this.instance_) {\r\n            this.instance_ = new ResizeObserverController();\r\n        }\r\n        return this.instance_;\r\n    };\r\n    /**\r\n     * Holds reference to the controller's instance.\r\n     *\r\n     * @private {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.instance_ = null;\r\n    return ResizeObserverController;\r\n}());\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\r\nvar defineConfigurable = (function (target, props) {\r\n    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\r\n        var key = _a[_i];\r\n        Object.defineProperty(target, key, {\r\n            value: props[key],\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return target;\r\n});\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\r\nvar getWindowOf = (function (target) {\r\n    // Assume that the element is an instance of Node, which means that it\r\n    // has the \"ownerDocument\" property from which we can retrieve a\r\n    // corresponding global object.\r\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\r\n    // Return the local global object if it's not possible extract one from\r\n    // provided element.\r\n    return ownerGlobal || global$1;\r\n});\n\n// Placeholder of an empty content rectangle.\r\nvar emptyRect = createRectInit(0, 0, 0, 0);\r\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\r\nfunction toFloat(value) {\r\n    return parseFloat(value) || 0;\r\n}\r\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\r\nfunction getBordersSize(styles) {\r\n    var positions = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        positions[_i - 1] = arguments[_i];\r\n    }\r\n    return positions.reduce(function (size, position) {\r\n        var value = styles['border-' + position + '-width'];\r\n        return size + toFloat(value);\r\n    }, 0);\r\n}\r\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\r\nfunction getPaddings(styles) {\r\n    var positions = ['top', 'right', 'bottom', 'left'];\r\n    var paddings = {};\r\n    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\r\n        var position = positions_1[_i];\r\n        var value = styles['padding-' + position];\r\n        paddings[position] = toFloat(value);\r\n    }\r\n    return paddings;\r\n}\r\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getSVGContentRect(target) {\r\n    var bbox = target.getBBox();\r\n    return createRectInit(0, 0, bbox.width, bbox.height);\r\n}\r\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getHTMLElementContentRect(target) {\r\n    // Client width & height properties can't be\r\n    // used exclusively as they provide rounded values.\r\n    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;\r\n    // By this condition we can catch all non-replaced inline, hidden and\r\n    // detached elements. Though elements with width & height properties less\r\n    // than 0.5 will be discarded as well.\r\n    //\r\n    // Without it we would need to implement separate methods for each of\r\n    // those cases and it's not possible to perform a precise and performance\r\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\r\n    // gives wrong results for elements with width & height less than 0.5.\r\n    if (!clientWidth && !clientHeight) {\r\n        return emptyRect;\r\n    }\r\n    var styles = getWindowOf(target).getComputedStyle(target);\r\n    var paddings = getPaddings(styles);\r\n    var horizPad = paddings.left + paddings.right;\r\n    var vertPad = paddings.top + paddings.bottom;\r\n    // Computed styles of width & height are being used because they are the\r\n    // only dimensions available to JS that contain non-rounded values. It could\r\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\r\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\r\n    var width = toFloat(styles.width), height = toFloat(styles.height);\r\n    // Width & height include paddings and borders when the 'border-box' box\r\n    // model is applied (except for IE).\r\n    if (styles.boxSizing === 'border-box') {\r\n        // Following conditions are required to handle Internet Explorer which\r\n        // doesn't include paddings and borders to computed CSS dimensions.\r\n        //\r\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\r\n        // properties then it's either IE, and thus we don't need to subtract\r\n        // anything, or an element merely doesn't have paddings/borders styles.\r\n        if (Math.round(width + horizPad) !== clientWidth) {\r\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\r\n        }\r\n        if (Math.round(height + vertPad) !== clientHeight) {\r\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\r\n        }\r\n    }\r\n    // Following steps can't be applied to the document's root element as its\r\n    // client[Width/Height] properties represent viewport area of the window.\r\n    // Besides, it's as well not necessary as the <html> itself neither has\r\n    // rendered scroll bars nor it can be clipped.\r\n    if (!isDocumentElement(target)) {\r\n        // In some browsers (only in Firefox, actually) CSS width & height\r\n        // include scroll bars size which can be removed at this step as scroll\r\n        // bars are the only difference between rounded dimensions + paddings\r\n        // and \"client\" properties, though that is not always true in Chrome.\r\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\r\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\r\n        // Chrome has a rather weird rounding of \"client\" properties.\r\n        // E.g. for an element with content width of 314.2px it sometimes gives\r\n        // the client width of 315px and for the width of 314.7px it may give\r\n        // 314px. And it doesn't happen all the time. So just ignore this delta\r\n        // as a non-relevant.\r\n        if (Math.abs(vertScrollbar) !== 1) {\r\n            width -= vertScrollbar;\r\n        }\r\n        if (Math.abs(horizScrollbar) !== 1) {\r\n            height -= horizScrollbar;\r\n        }\r\n    }\r\n    return createRectInit(paddings.left, paddings.top, width, height);\r\n}\r\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nvar isSVGGraphicsElement = (function () {\r\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\r\n    // interface.\r\n    if (typeof SVGGraphicsElement !== 'undefined') {\r\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\r\n    }\r\n    // If it's so, then check that element is at least an instance of the\r\n    // SVGElement and that it has the \"getBBox\" method.\r\n    // eslint-disable-next-line no-extra-parens\r\n    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&\r\n        typeof target.getBBox === 'function'); };\r\n})();\r\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nfunction isDocumentElement(target) {\r\n    return target === getWindowOf(target).document.documentElement;\r\n}\r\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getContentRect(target) {\r\n    if (!isBrowser) {\r\n        return emptyRect;\r\n    }\r\n    if (isSVGGraphicsElement(target)) {\r\n        return getSVGContentRect(target);\r\n    }\r\n    return getHTMLElementContentRect(target);\r\n}\r\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\r\nfunction createReadOnlyRect(_a) {\r\n    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\r\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\r\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\r\n    var rect = Object.create(Constr.prototype);\r\n    // Rectangle's properties are not writable and non-enumerable.\r\n    defineConfigurable(rect, {\r\n        x: x, y: y, width: width, height: height,\r\n        top: y,\r\n        right: x + width,\r\n        bottom: height + y,\r\n        left: x\r\n    });\r\n    return rect;\r\n}\r\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction createRectInit(x, y, width, height) {\r\n    return { x: x, y: y, width: width, height: height };\r\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\r\nvar ResizeObservation = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObservation.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */\r\n    function ResizeObservation(target) {\r\n        /**\r\n         * Broadcasted width of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastWidth = 0;\r\n        /**\r\n         * Broadcasted height of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastHeight = 0;\r\n        /**\r\n         * Reference to the last observed content rectangle.\r\n         *\r\n         * @private {DOMRectInit}\r\n         */\r\n        this.contentRect_ = createRectInit(0, 0, 0, 0);\r\n        this.target = target;\r\n    }\r\n    /**\r\n     * Updates content rectangle and tells whether it's width or height properties\r\n     * have changed since the last broadcast.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObservation.prototype.isActive = function () {\r\n        var rect = getContentRect(this.target);\r\n        this.contentRect_ = rect;\r\n        return (rect.width !== this.broadcastWidth ||\r\n            rect.height !== this.broadcastHeight);\r\n    };\r\n    /**\r\n     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n     * from the corresponding properties of the last observed content rectangle.\r\n     *\r\n     * @returns {DOMRectInit} Last observed content rectangle.\r\n     */\r\n    ResizeObservation.prototype.broadcastRect = function () {\r\n        var rect = this.contentRect_;\r\n        this.broadcastWidth = rect.width;\r\n        this.broadcastHeight = rect.height;\r\n        return rect;\r\n    };\r\n    return ResizeObservation;\r\n}());\n\nvar ResizeObserverEntry = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObserverEntry.\r\n     *\r\n     * @param {Element} target - Element that is being observed.\r\n     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.\r\n     */\r\n    function ResizeObserverEntry(target, rectInit) {\r\n        var contentRect = createReadOnlyRect(rectInit);\r\n        // According to the specification following properties are not writable\r\n        // and are also not enumerable in the native implementation.\r\n        //\r\n        // Property accessors are not being used as they'd require to define a\r\n        // private WeakMap storage which may cause memory leaks in browsers that\r\n        // don't support this type of collections.\r\n        defineConfigurable(this, { target: target, contentRect: contentRect });\r\n    }\r\n    return ResizeObserverEntry;\r\n}());\n\nvar ResizeObserverSPI = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n     *      when one of the observed elements changes it's content dimensions.\r\n     * @param {ResizeObserverController} controller - Controller instance which\r\n     *      is responsible for the updates of observer.\r\n     * @param {ResizeObserver} callbackCtx - Reference to the public\r\n     *      ResizeObserver instance which will be passed to callback function.\r\n     */\r\n    function ResizeObserverSPI(callback, controller, callbackCtx) {\r\n        /**\r\n         * Collection of resize observations that have detected changes in dimensions\r\n         * of elements.\r\n         *\r\n         * @private {Array<ResizeObservation>}\r\n         */\r\n        this.activeObservations_ = [];\r\n        /**\r\n         * Registry of the ResizeObservation instances.\r\n         *\r\n         * @private {Map<Element, ResizeObservation>}\r\n         */\r\n        this.observations_ = new MapShim();\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError('The callback provided as parameter 1 is not a function.');\r\n        }\r\n        this.callback_ = callback;\r\n        this.controller_ = controller;\r\n        this.callbackCtx_ = callbackCtx;\r\n    }\r\n    /**\r\n     * Starts observing provided element.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.observe = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is already being observed.\r\n        if (observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.set(target, new ResizeObservation(target));\r\n        this.controller_.addObserver(this);\r\n        // Force the update of observations.\r\n        this.controller_.refresh();\r\n    };\r\n    /**\r\n     * Stops observing provided element.\r\n     *\r\n     * @param {Element} target - Element to stop observing.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.unobserve = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is not being observed.\r\n        if (!observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.delete(target);\r\n        if (!observations.size) {\r\n            this.controller_.removeObserver(this);\r\n        }\r\n    };\r\n    /**\r\n     * Stops observing all elements.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.disconnect = function () {\r\n        this.clearActive();\r\n        this.observations_.clear();\r\n        this.controller_.removeObserver(this);\r\n    };\r\n    /**\r\n     * Collects observation instances the associated element of which has changed\r\n     * it's content rectangle.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.gatherActive = function () {\r\n        var _this = this;\r\n        this.clearActive();\r\n        this.observations_.forEach(function (observation) {\r\n            if (observation.isActive()) {\r\n                _this.activeObservations_.push(observation);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Invokes initial callback function with a list of ResizeObserverEntry\r\n     * instances collected from active resize observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.broadcastActive = function () {\r\n        // Do nothing if observer doesn't have active observations.\r\n        if (!this.hasActive()) {\r\n            return;\r\n        }\r\n        var ctx = this.callbackCtx_;\r\n        // Create ResizeObserverEntry instance for every active observation.\r\n        var entries = this.activeObservations_.map(function (observation) {\r\n            return new ResizeObserverEntry(observation.target, observation.broadcastRect());\r\n        });\r\n        this.callback_.call(ctx, entries, ctx);\r\n        this.clearActive();\r\n    };\r\n    /**\r\n     * Clears the collection of active observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.clearActive = function () {\r\n        this.activeObservations_.splice(0);\r\n    };\r\n    /**\r\n     * Tells whether observer has active observations.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObserverSPI.prototype.hasActive = function () {\r\n        return this.activeObservations_.length > 0;\r\n    };\r\n    return ResizeObserverSPI;\r\n}());\n\n// Registry of internal observers. If WeakMap is not available use current shim\r\n// for the Map collection as it has all required methods and because WeakMap\r\n// can't be fully polyfilled anyway.\r\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\r\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\r\nvar ResizeObserver = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n     *      dimensions of the observed elements change.\r\n     */\r\n    function ResizeObserver(callback) {\r\n        if (!(this instanceof ResizeObserver)) {\r\n            throw new TypeError('Cannot call a class as a function.');\r\n        }\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        var controller = ResizeObserverController.getInstance();\r\n        var observer = new ResizeObserverSPI(callback, controller, this);\r\n        observers.set(this, observer);\r\n    }\r\n    return ResizeObserver;\r\n}());\r\n// Expose public methods of ResizeObserver.\r\n[\r\n    'observe',\r\n    'unobserve',\r\n    'disconnect'\r\n].forEach(function (method) {\r\n    ResizeObserver.prototype[method] = function () {\r\n        var _a;\r\n        return (_a = observers.get(this))[method].apply(_a, arguments);\r\n    };\r\n});\n\nvar index = (function () {\r\n    // Export existing implementation if available.\r\n    if (typeof global$1.ResizeObserver !== 'undefined') {\r\n        return global$1.ResizeObserver;\r\n    }\r\n    return ResizeObserver;\r\n})();\n\n/* harmony default export */ const ResizeObserver_es = (index);\n\n;// CONCATENATED MODULE: ./node_modules/react-measure/dist/index.esm.js\n\n\n\n\n\n\n\nvar types = ['client', 'offset', 'scroll', 'bounds', 'margin'];\nfunction getTypes(props) {\n  var allowedTypes = [];\n  types.forEach(function (type) {\n    if (props[type]) {\n      allowedTypes.push(type);\n    }\n  });\n  return allowedTypes;\n}\n\nfunction index_esm_getContentRect(node, types) {\n  var calculations = {};\n\n  if (types.indexOf('client') > -1) {\n    calculations.client = {\n      top: node.clientTop,\n      left: node.clientLeft,\n      width: node.clientWidth,\n      height: node.clientHeight\n    };\n  }\n\n  if (types.indexOf('offset') > -1) {\n    calculations.offset = {\n      top: node.offsetTop,\n      left: node.offsetLeft,\n      width: node.offsetWidth,\n      height: node.offsetHeight\n    };\n  }\n\n  if (types.indexOf('scroll') > -1) {\n    calculations.scroll = {\n      top: node.scrollTop,\n      left: node.scrollLeft,\n      width: node.scrollWidth,\n      height: node.scrollHeight\n    };\n  }\n\n  if (types.indexOf('bounds') > -1) {\n    var rect = node.getBoundingClientRect();\n    calculations.bounds = {\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom,\n      left: rect.left,\n      width: rect.width,\n      height: rect.height\n    };\n  }\n\n  if (types.indexOf('margin') > -1) {\n    var styles = getComputedStyle(node);\n    calculations.margin = {\n      top: styles ? parseInt(styles.marginTop) : 0,\n      right: styles ? parseInt(styles.marginRight) : 0,\n      bottom: styles ? parseInt(styles.marginBottom) : 0,\n      left: styles ? parseInt(styles.marginLeft) : 0\n    };\n  }\n\n  return calculations;\n}\n\n/**\n * Returns the global window object associated with provided element.\n */\nfunction index_esm_getWindowOf(target) {\n  // Assume that the element is an instance of Node, which means that it\n  // has the \"ownerDocument\" property from which we can retrieve a\n  // corresponding global object.\n  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView; // Return the local window object if it's not possible extract one from\n  // provided element.\n\n  return ownerGlobal || window;\n}\n\nfunction withContentRect(types) {\n  return function (WrappedComponent) {\n    var _class, _temp;\n\n    return _temp = _class =\n    /*#__PURE__*/\n    function (_Component) {\n      _inheritsLoose(WithContentRect, _Component);\n\n      function WithContentRect() {\n        var _this;\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        _this = _Component.call.apply(_Component, [this].concat(args)) || this;\n        _this.state = {\n          contentRect: {\n            entry: {},\n            client: {},\n            offset: {},\n            scroll: {},\n            bounds: {},\n            margin: {}\n          }\n        };\n        _this._animationFrameID = null;\n        _this._resizeObserver = null;\n        _this._node = null;\n        _this._window = null;\n\n        _this.measure = function (entries) {\n          var contentRect = index_esm_getContentRect(_this._node, types || getTypes(_this.props));\n\n          if (entries) {\n            contentRect.entry = entries[0].contentRect;\n          }\n\n          _this._animationFrameID = _this._window.requestAnimationFrame(function () {\n            if (_this._resizeObserver !== null) {\n              _this.setState({\n                contentRect: contentRect\n              });\n\n              if (typeof _this.props.onResize === 'function') {\n                _this.props.onResize(contentRect);\n              }\n            }\n          });\n        };\n\n        _this._handleRef = function (node) {\n          if (_this._resizeObserver !== null && _this._node !== null) {\n            _this._resizeObserver.unobserve(_this._node);\n          }\n\n          _this._node = node;\n          _this._window = index_esm_getWindowOf(_this._node);\n          var innerRef = _this.props.innerRef;\n\n          if (innerRef) {\n            if (typeof innerRef === 'function') {\n              innerRef(_this._node);\n            } else {\n              innerRef.current = _this._node;\n            }\n          }\n\n          if (_this._resizeObserver !== null && _this._node !== null) {\n            _this._resizeObserver.observe(_this._node);\n          }\n        };\n\n        return _this;\n      }\n\n      var _proto = WithContentRect.prototype;\n\n      _proto.componentDidMount = function componentDidMount() {\n        this._resizeObserver = this._window !== null && this._window.ResizeObserver ? new this._window.ResizeObserver(this.measure) : new ResizeObserver_es(this.measure);\n\n        if (this._node !== null) {\n          this._resizeObserver.observe(this._node);\n\n          if (typeof this.props.onResize === 'function') {\n            this.props.onResize(index_esm_getContentRect(this._node, types || getTypes(this.props)));\n          }\n        }\n      };\n\n      _proto.componentWillUnmount = function componentWillUnmount() {\n        if (this._window !== null) {\n          this._window.cancelAnimationFrame(this._animationFrameID);\n        }\n\n        if (this._resizeObserver !== null) {\n          this._resizeObserver.disconnect();\n\n          this._resizeObserver = null;\n        }\n      };\n\n      _proto.render = function render() {\n        var _this$props = this.props,\n            innerRef = _this$props.innerRef,\n            onResize = _this$props.onResize,\n            props = _objectWithoutPropertiesLoose(_this$props, [\"innerRef\", \"onResize\"]);\n\n        return (0,react.createElement)(WrappedComponent, extends_extends({}, props, {\n          measureRef: this._handleRef,\n          measure: this.measure,\n          contentRect: this.state.contentRect\n        }));\n      };\n\n      return WithContentRect;\n    }(react.Component), _class.propTypes = {\n      client: (prop_types_default()).bool,\n      offset: (prop_types_default()).bool,\n      scroll: (prop_types_default()).bool,\n      bounds: (prop_types_default()).bool,\n      margin: (prop_types_default()).bool,\n      innerRef: prop_types_default().oneOfType([(prop_types_default()).object, (prop_types_default()).func]),\n      onResize: (prop_types_default()).func\n    }, _temp;\n  };\n}\n\nvar Measure = withContentRect()(function (_ref) {\n  var measure = _ref.measure,\n      measureRef = _ref.measureRef,\n      contentRect = _ref.contentRect,\n      children = _ref.children;\n  return children({\n    measure: measure,\n    measureRef: measureRef,\n    contentRect: contentRect\n  });\n});\nMeasure.displayName = 'Measure';\nMeasure.propTypes.children = (prop_types_default()).func;\n\n/* harmony default export */ const index_esm = (Measure);\n\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/Global.js\nvar PI_OVER_180 = Math.PI / 180;\nfunction detectBrowser() {\n    return (typeof window !== 'undefined' &&\n        ({}.toString.call(window) === '[object Window]' ||\n            {}.toString.call(window) === '[object global]'));\n}\nconst glob = typeof global !== 'undefined'\n    ? global\n    : typeof window !== 'undefined'\n        ? window\n        : typeof WorkerGlobalScope !== 'undefined'\n            ? self\n            : {};\nconst Global_Konva = {\n    _global: glob,\n    version: '8.3.9',\n    isBrowser: detectBrowser(),\n    isUnminified: /param/.test(function (param) { }.toString()),\n    dblClickWindow: 400,\n    getAngle(angle) {\n        return Global_Konva.angleDeg ? angle * PI_OVER_180 : angle;\n    },\n    enableTrace: false,\n    pointerEventsEnabled: true,\n    autoDrawEnabled: true,\n    hitOnDragEnabled: false,\n    capturePointerEventsEnabled: false,\n    _mouseListenClick: false,\n    _touchListenClick: false,\n    _pointerListenClick: false,\n    _mouseInDblClickWindow: false,\n    _touchInDblClickWindow: false,\n    _pointerInDblClickWindow: false,\n    _mouseDblClickPointerId: null,\n    _touchDblClickPointerId: null,\n    _pointerDblClickPointerId: null,\n    pixelRatio: (typeof window !== 'undefined' && window.devicePixelRatio) || 1,\n    dragDistance: 3,\n    angleDeg: true,\n    showWarnings: true,\n    dragButtons: [0, 1],\n    isDragging() {\n        return Global_Konva['DD'].isDragging;\n    },\n    isDragReady() {\n        return !!Global_Konva['DD'].node;\n    },\n    document: glob.document,\n    _injectGlobal(Konva) {\n        glob.Konva = Konva;\n    },\n};\nconst _registerNode = (NodeClass) => {\n    Global_Konva[NodeClass.prototype.getClassName()] = NodeClass;\n};\nGlobal_Konva._injectGlobal(Global_Konva);\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/Util.js\n\nclass Transform {\n    constructor(m = [1, 0, 0, 1, 0, 0]) {\n        this.dirty = false;\n        this.m = (m && m.slice()) || [1, 0, 0, 1, 0, 0];\n    }\n    reset() {\n        this.m[0] = 1;\n        this.m[1] = 0;\n        this.m[2] = 0;\n        this.m[3] = 1;\n        this.m[4] = 0;\n        this.m[5] = 0;\n    }\n    copy() {\n        return new Transform(this.m);\n    }\n    copyInto(tr) {\n        tr.m[0] = this.m[0];\n        tr.m[1] = this.m[1];\n        tr.m[2] = this.m[2];\n        tr.m[3] = this.m[3];\n        tr.m[4] = this.m[4];\n        tr.m[5] = this.m[5];\n    }\n    point(point) {\n        var m = this.m;\n        return {\n            x: m[0] * point.x + m[2] * point.y + m[4],\n            y: m[1] * point.x + m[3] * point.y + m[5],\n        };\n    }\n    translate(x, y) {\n        this.m[4] += this.m[0] * x + this.m[2] * y;\n        this.m[5] += this.m[1] * x + this.m[3] * y;\n        return this;\n    }\n    scale(sx, sy) {\n        this.m[0] *= sx;\n        this.m[1] *= sx;\n        this.m[2] *= sy;\n        this.m[3] *= sy;\n        return this;\n    }\n    rotate(rad) {\n        var c = Math.cos(rad);\n        var s = Math.sin(rad);\n        var m11 = this.m[0] * c + this.m[2] * s;\n        var m12 = this.m[1] * c + this.m[3] * s;\n        var m21 = this.m[0] * -s + this.m[2] * c;\n        var m22 = this.m[1] * -s + this.m[3] * c;\n        this.m[0] = m11;\n        this.m[1] = m12;\n        this.m[2] = m21;\n        this.m[3] = m22;\n        return this;\n    }\n    getTranslation() {\n        return {\n            x: this.m[4],\n            y: this.m[5],\n        };\n    }\n    skew(sx, sy) {\n        var m11 = this.m[0] + this.m[2] * sy;\n        var m12 = this.m[1] + this.m[3] * sy;\n        var m21 = this.m[2] + this.m[0] * sx;\n        var m22 = this.m[3] + this.m[1] * sx;\n        this.m[0] = m11;\n        this.m[1] = m12;\n        this.m[2] = m21;\n        this.m[3] = m22;\n        return this;\n    }\n    multiply(matrix) {\n        var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1];\n        var m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1];\n        var m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3];\n        var m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];\n        var dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4];\n        var dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];\n        this.m[0] = m11;\n        this.m[1] = m12;\n        this.m[2] = m21;\n        this.m[3] = m22;\n        this.m[4] = dx;\n        this.m[5] = dy;\n        return this;\n    }\n    invert() {\n        var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);\n        var m0 = this.m[3] * d;\n        var m1 = -this.m[1] * d;\n        var m2 = -this.m[2] * d;\n        var m3 = this.m[0] * d;\n        var m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);\n        var m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);\n        this.m[0] = m0;\n        this.m[1] = m1;\n        this.m[2] = m2;\n        this.m[3] = m3;\n        this.m[4] = m4;\n        this.m[5] = m5;\n        return this;\n    }\n    getMatrix() {\n        return this.m;\n    }\n    decompose() {\n        var a = this.m[0];\n        var b = this.m[1];\n        var c = this.m[2];\n        var d = this.m[3];\n        var e = this.m[4];\n        var f = this.m[5];\n        var delta = a * d - b * c;\n        let result = {\n            x: e,\n            y: f,\n            rotation: 0,\n            scaleX: 0,\n            scaleY: 0,\n            skewX: 0,\n            skewY: 0,\n        };\n        if (a != 0 || b != 0) {\n            var r = Math.sqrt(a * a + b * b);\n            result.rotation = b > 0 ? Math.acos(a / r) : -Math.acos(a / r);\n            result.scaleX = r;\n            result.scaleY = delta / r;\n            result.skewX = (a * c + b * d) / delta;\n            result.skewY = 0;\n        }\n        else if (c != 0 || d != 0) {\n            var s = Math.sqrt(c * c + d * d);\n            result.rotation =\n                Math.PI / 2 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s));\n            result.scaleX = delta / s;\n            result.scaleY = s;\n            result.skewX = 0;\n            result.skewY = (a * c + b * d) / delta;\n        }\n        else {\n        }\n        result.rotation = Util_Util._getRotation(result.rotation);\n        return result;\n    }\n}\nvar OBJECT_ARRAY = '[object Array]', OBJECT_NUMBER = '[object Number]', OBJECT_STRING = '[object String]', OBJECT_BOOLEAN = '[object Boolean]', PI_OVER_DEG180 = Math.PI / 180, DEG180_OVER_PI = 180 / Math.PI, HASH = '#', EMPTY_STRING = '', ZERO = '0', KONVA_WARNING = 'Konva warning: ', KONVA_ERROR = 'Konva error: ', RGB_PAREN = 'rgb(', COLORS = {\n    aliceblue: [240, 248, 255],\n    antiquewhite: [250, 235, 215],\n    aqua: [0, 255, 255],\n    aquamarine: [127, 255, 212],\n    azure: [240, 255, 255],\n    beige: [245, 245, 220],\n    bisque: [255, 228, 196],\n    black: [0, 0, 0],\n    blanchedalmond: [255, 235, 205],\n    blue: [0, 0, 255],\n    blueviolet: [138, 43, 226],\n    brown: [165, 42, 42],\n    burlywood: [222, 184, 135],\n    cadetblue: [95, 158, 160],\n    chartreuse: [127, 255, 0],\n    chocolate: [210, 105, 30],\n    coral: [255, 127, 80],\n    cornflowerblue: [100, 149, 237],\n    cornsilk: [255, 248, 220],\n    crimson: [220, 20, 60],\n    cyan: [0, 255, 255],\n    darkblue: [0, 0, 139],\n    darkcyan: [0, 139, 139],\n    darkgoldenrod: [184, 132, 11],\n    darkgray: [169, 169, 169],\n    darkgreen: [0, 100, 0],\n    darkgrey: [169, 169, 169],\n    darkkhaki: [189, 183, 107],\n    darkmagenta: [139, 0, 139],\n    darkolivegreen: [85, 107, 47],\n    darkorange: [255, 140, 0],\n    darkorchid: [153, 50, 204],\n    darkred: [139, 0, 0],\n    darksalmon: [233, 150, 122],\n    darkseagreen: [143, 188, 143],\n    darkslateblue: [72, 61, 139],\n    darkslategray: [47, 79, 79],\n    darkslategrey: [47, 79, 79],\n    darkturquoise: [0, 206, 209],\n    darkviolet: [148, 0, 211],\n    deeppink: [255, 20, 147],\n    deepskyblue: [0, 191, 255],\n    dimgray: [105, 105, 105],\n    dimgrey: [105, 105, 105],\n    dodgerblue: [30, 144, 255],\n    firebrick: [178, 34, 34],\n    floralwhite: [255, 255, 240],\n    forestgreen: [34, 139, 34],\n    fuchsia: [255, 0, 255],\n    gainsboro: [220, 220, 220],\n    ghostwhite: [248, 248, 255],\n    gold: [255, 215, 0],\n    goldenrod: [218, 165, 32],\n    gray: [128, 128, 128],\n    green: [0, 128, 0],\n    greenyellow: [173, 255, 47],\n    grey: [128, 128, 128],\n    honeydew: [240, 255, 240],\n    hotpink: [255, 105, 180],\n    indianred: [205, 92, 92],\n    indigo: [75, 0, 130],\n    ivory: [255, 255, 240],\n    khaki: [240, 230, 140],\n    lavender: [230, 230, 250],\n    lavenderblush: [255, 240, 245],\n    lawngreen: [124, 252, 0],\n    lemonchiffon: [255, 250, 205],\n    lightblue: [173, 216, 230],\n    lightcoral: [240, 128, 128],\n    lightcyan: [224, 255, 255],\n    lightgoldenrodyellow: [250, 250, 210],\n    lightgray: [211, 211, 211],\n    lightgreen: [144, 238, 144],\n    lightgrey: [211, 211, 211],\n    lightpink: [255, 182, 193],\n    lightsalmon: [255, 160, 122],\n    lightseagreen: [32, 178, 170],\n    lightskyblue: [135, 206, 250],\n    lightslategray: [119, 136, 153],\n    lightslategrey: [119, 136, 153],\n    lightsteelblue: [176, 196, 222],\n    lightyellow: [255, 255, 224],\n    lime: [0, 255, 0],\n    limegreen: [50, 205, 50],\n    linen: [250, 240, 230],\n    magenta: [255, 0, 255],\n    maroon: [128, 0, 0],\n    mediumaquamarine: [102, 205, 170],\n    mediumblue: [0, 0, 205],\n    mediumorchid: [186, 85, 211],\n    mediumpurple: [147, 112, 219],\n    mediumseagreen: [60, 179, 113],\n    mediumslateblue: [123, 104, 238],\n    mediumspringgreen: [0, 250, 154],\n    mediumturquoise: [72, 209, 204],\n    mediumvioletred: [199, 21, 133],\n    midnightblue: [25, 25, 112],\n    mintcream: [245, 255, 250],\n    mistyrose: [255, 228, 225],\n    moccasin: [255, 228, 181],\n    navajowhite: [255, 222, 173],\n    navy: [0, 0, 128],\n    oldlace: [253, 245, 230],\n    olive: [128, 128, 0],\n    olivedrab: [107, 142, 35],\n    orange: [255, 165, 0],\n    orangered: [255, 69, 0],\n    orchid: [218, 112, 214],\n    palegoldenrod: [238, 232, 170],\n    palegreen: [152, 251, 152],\n    paleturquoise: [175, 238, 238],\n    palevioletred: [219, 112, 147],\n    papayawhip: [255, 239, 213],\n    peachpuff: [255, 218, 185],\n    peru: [205, 133, 63],\n    pink: [255, 192, 203],\n    plum: [221, 160, 203],\n    powderblue: [176, 224, 230],\n    purple: [128, 0, 128],\n    rebeccapurple: [102, 51, 153],\n    red: [255, 0, 0],\n    rosybrown: [188, 143, 143],\n    royalblue: [65, 105, 225],\n    saddlebrown: [139, 69, 19],\n    salmon: [250, 128, 114],\n    sandybrown: [244, 164, 96],\n    seagreen: [46, 139, 87],\n    seashell: [255, 245, 238],\n    sienna: [160, 82, 45],\n    silver: [192, 192, 192],\n    skyblue: [135, 206, 235],\n    slateblue: [106, 90, 205],\n    slategray: [119, 128, 144],\n    slategrey: [119, 128, 144],\n    snow: [255, 255, 250],\n    springgreen: [0, 255, 127],\n    steelblue: [70, 130, 180],\n    tan: [210, 180, 140],\n    teal: [0, 128, 128],\n    thistle: [216, 191, 216],\n    transparent: [255, 255, 255, 0],\n    tomato: [255, 99, 71],\n    turquoise: [64, 224, 208],\n    violet: [238, 130, 238],\n    wheat: [245, 222, 179],\n    white: [255, 255, 255],\n    whitesmoke: [245, 245, 245],\n    yellow: [255, 255, 0],\n    yellowgreen: [154, 205, 5],\n}, RGB_REGEX = /rgb\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3})\\)/, animQueue = [];\nconst req = (typeof requestAnimationFrame !== 'undefined' && requestAnimationFrame) ||\n    function (f) {\n        setTimeout(f, 60);\n    };\nconst Util_Util = {\n    _isElement(obj) {\n        return !!(obj && obj.nodeType == 1);\n    },\n    _isFunction(obj) {\n        return !!(obj && obj.constructor && obj.call && obj.apply);\n    },\n    _isPlainObject(obj) {\n        return !!obj && obj.constructor === Object;\n    },\n    _isArray(obj) {\n        return Object.prototype.toString.call(obj) === OBJECT_ARRAY;\n    },\n    _isNumber(obj) {\n        return (Object.prototype.toString.call(obj) === OBJECT_NUMBER &&\n            !isNaN(obj) &&\n            isFinite(obj));\n    },\n    _isString(obj) {\n        return Object.prototype.toString.call(obj) === OBJECT_STRING;\n    },\n    _isBoolean(obj) {\n        return Object.prototype.toString.call(obj) === OBJECT_BOOLEAN;\n    },\n    isObject(val) {\n        return val instanceof Object;\n    },\n    isValidSelector(selector) {\n        if (typeof selector !== 'string') {\n            return false;\n        }\n        var firstChar = selector[0];\n        return (firstChar === '#' ||\n            firstChar === '.' ||\n            firstChar === firstChar.toUpperCase());\n    },\n    _sign(number) {\n        if (number === 0) {\n            return 1;\n        }\n        if (number > 0) {\n            return 1;\n        }\n        else {\n            return -1;\n        }\n    },\n    requestAnimFrame(callback) {\n        animQueue.push(callback);\n        if (animQueue.length === 1) {\n            req(function () {\n                const queue = animQueue;\n                animQueue = [];\n                queue.forEach(function (cb) {\n                    cb();\n                });\n            });\n        }\n    },\n    createCanvasElement() {\n        var canvas = document.createElement('canvas');\n        try {\n            canvas.style = canvas.style || {};\n        }\n        catch (e) { }\n        return canvas;\n    },\n    createImageElement() {\n        return document.createElement('img');\n    },\n    _isInDocument(el) {\n        while ((el = el.parentNode)) {\n            if (el == document) {\n                return true;\n            }\n        }\n        return false;\n    },\n    _urlToImage(url, callback) {\n        var imageObj = Util_Util.createImageElement();\n        imageObj.onload = function () {\n            callback(imageObj);\n        };\n        imageObj.src = url;\n    },\n    _rgbToHex(r, g, b) {\n        return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);\n    },\n    _hexToRgb(hex) {\n        hex = hex.replace(HASH, EMPTY_STRING);\n        var bigint = parseInt(hex, 16);\n        return {\n            r: (bigint >> 16) & 255,\n            g: (bigint >> 8) & 255,\n            b: bigint & 255,\n        };\n    },\n    getRandomColor() {\n        var randColor = ((Math.random() * 0xffffff) << 0).toString(16);\n        while (randColor.length < 6) {\n            randColor = ZERO + randColor;\n        }\n        return HASH + randColor;\n    },\n    getRGB(color) {\n        var rgb;\n        if (color in COLORS) {\n            rgb = COLORS[color];\n            return {\n                r: rgb[0],\n                g: rgb[1],\n                b: rgb[2],\n            };\n        }\n        else if (color[0] === HASH) {\n            return this._hexToRgb(color.substring(1));\n        }\n        else if (color.substr(0, 4) === RGB_PAREN) {\n            rgb = RGB_REGEX.exec(color.replace(/ /g, ''));\n            return {\n                r: parseInt(rgb[1], 10),\n                g: parseInt(rgb[2], 10),\n                b: parseInt(rgb[3], 10),\n            };\n        }\n        else {\n            return {\n                r: 0,\n                g: 0,\n                b: 0,\n            };\n        }\n    },\n    colorToRGBA(str) {\n        str = str || 'black';\n        return (Util_Util._namedColorToRBA(str) ||\n            Util_Util._hex3ColorToRGBA(str) ||\n            Util_Util._hex6ColorToRGBA(str) ||\n            Util_Util._rgbColorToRGBA(str) ||\n            Util_Util._rgbaColorToRGBA(str) ||\n            Util_Util._hslColorToRGBA(str));\n    },\n    _namedColorToRBA(str) {\n        var c = COLORS[str.toLowerCase()];\n        if (!c) {\n            return null;\n        }\n        return {\n            r: c[0],\n            g: c[1],\n            b: c[2],\n            a: 1,\n        };\n    },\n    _rgbColorToRGBA(str) {\n        if (str.indexOf('rgb(') === 0) {\n            str = str.match(/rgb\\(([^)]+)\\)/)[1];\n            var parts = str.split(/ *, */).map(Number);\n            return {\n                r: parts[0],\n                g: parts[1],\n                b: parts[2],\n                a: 1,\n            };\n        }\n    },\n    _rgbaColorToRGBA(str) {\n        if (str.indexOf('rgba(') === 0) {\n            str = str.match(/rgba\\(([^)]+)\\)/)[1];\n            var parts = str.split(/ *, */).map((n, index) => {\n                if (n.slice(-1) === '%') {\n                    return index === 3 ? parseInt(n) / 100 : (parseInt(n) / 100) * 255;\n                }\n                return Number(n);\n            });\n            return {\n                r: parts[0],\n                g: parts[1],\n                b: parts[2],\n                a: parts[3],\n            };\n        }\n    },\n    _hex6ColorToRGBA(str) {\n        if (str[0] === '#' && str.length === 7) {\n            return {\n                r: parseInt(str.slice(1, 3), 16),\n                g: parseInt(str.slice(3, 5), 16),\n                b: parseInt(str.slice(5, 7), 16),\n                a: 1,\n            };\n        }\n    },\n    _hex3ColorToRGBA(str) {\n        if (str[0] === '#' && str.length === 4) {\n            return {\n                r: parseInt(str[1] + str[1], 16),\n                g: parseInt(str[2] + str[2], 16),\n                b: parseInt(str[3] + str[3], 16),\n                a: 1,\n            };\n        }\n    },\n    _hslColorToRGBA(str) {\n        if (/hsl\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%\\)/g.test(str)) {\n            const [_, ...hsl] = /hsl\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%\\)/g.exec(str);\n            const h = Number(hsl[0]) / 360;\n            const s = Number(hsl[1]) / 100;\n            const l = Number(hsl[2]) / 100;\n            let t2;\n            let t3;\n            let val;\n            if (s === 0) {\n                val = l * 255;\n                return {\n                    r: Math.round(val),\n                    g: Math.round(val),\n                    b: Math.round(val),\n                    a: 1,\n                };\n            }\n            if (l < 0.5) {\n                t2 = l * (1 + s);\n            }\n            else {\n                t2 = l + s - l * s;\n            }\n            const t1 = 2 * l - t2;\n            const rgb = [0, 0, 0];\n            for (let i = 0; i < 3; i++) {\n                t3 = h + (1 / 3) * -(i - 1);\n                if (t3 < 0) {\n                    t3++;\n                }\n                if (t3 > 1) {\n                    t3--;\n                }\n                if (6 * t3 < 1) {\n                    val = t1 + (t2 - t1) * 6 * t3;\n                }\n                else if (2 * t3 < 1) {\n                    val = t2;\n                }\n                else if (3 * t3 < 2) {\n                    val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n                }\n                else {\n                    val = t1;\n                }\n                rgb[i] = val * 255;\n            }\n            return {\n                r: Math.round(rgb[0]),\n                g: Math.round(rgb[1]),\n                b: Math.round(rgb[2]),\n                a: 1,\n            };\n        }\n    },\n    haveIntersection(r1, r2) {\n        return !(r2.x > r1.x + r1.width ||\n            r2.x + r2.width < r1.x ||\n            r2.y > r1.y + r1.height ||\n            r2.y + r2.height < r1.y);\n    },\n    cloneObject(obj) {\n        var retObj = {};\n        for (var key in obj) {\n            if (this._isPlainObject(obj[key])) {\n                retObj[key] = this.cloneObject(obj[key]);\n            }\n            else if (this._isArray(obj[key])) {\n                retObj[key] = this.cloneArray(obj[key]);\n            }\n            else {\n                retObj[key] = obj[key];\n            }\n        }\n        return retObj;\n    },\n    cloneArray(arr) {\n        return arr.slice(0);\n    },\n    degToRad(deg) {\n        return deg * PI_OVER_DEG180;\n    },\n    radToDeg(rad) {\n        return rad * DEG180_OVER_PI;\n    },\n    _degToRad(deg) {\n        Util_Util.warn('Util._degToRad is removed. Please use public Util.degToRad instead.');\n        return Util_Util.degToRad(deg);\n    },\n    _radToDeg(rad) {\n        Util_Util.warn('Util._radToDeg is removed. Please use public Util.radToDeg instead.');\n        return Util_Util.radToDeg(rad);\n    },\n    _getRotation(radians) {\n        return Global_Konva.angleDeg ? Util_Util.radToDeg(radians) : radians;\n    },\n    _capitalize(str) {\n        return str.charAt(0).toUpperCase() + str.slice(1);\n    },\n    throw(str) {\n        throw new Error(KONVA_ERROR + str);\n    },\n    error(str) {\n        console.error(KONVA_ERROR + str);\n    },\n    warn(str) {\n        if (!Global_Konva.showWarnings) {\n            return;\n        }\n        console.warn(KONVA_WARNING + str);\n    },\n    each(obj, func) {\n        for (var key in obj) {\n            func(key, obj[key]);\n        }\n    },\n    _inRange(val, left, right) {\n        return left <= val && val < right;\n    },\n    _getProjectionToSegment(x1, y1, x2, y2, x3, y3) {\n        var x, y, dist;\n        var pd2 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n        if (pd2 == 0) {\n            x = x1;\n            y = y1;\n            dist = (x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2);\n        }\n        else {\n            var u = ((x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1)) / pd2;\n            if (u < 0) {\n                x = x1;\n                y = y1;\n                dist = (x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3);\n            }\n            else if (u > 1.0) {\n                x = x2;\n                y = y2;\n                dist = (x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3);\n            }\n            else {\n                x = x1 + u * (x2 - x1);\n                y = y1 + u * (y2 - y1);\n                dist = (x - x3) * (x - x3) + (y - y3) * (y - y3);\n            }\n        }\n        return [x, y, dist];\n    },\n    _getProjectionToLine(pt, line, isClosed) {\n        var pc = Util_Util.cloneObject(pt);\n        var dist = Number.MAX_VALUE;\n        line.forEach(function (p1, i) {\n            if (!isClosed && i === line.length - 1) {\n                return;\n            }\n            var p2 = line[(i + 1) % line.length];\n            var proj = Util_Util._getProjectionToSegment(p1.x, p1.y, p2.x, p2.y, pt.x, pt.y);\n            var px = proj[0], py = proj[1], pdist = proj[2];\n            if (pdist < dist) {\n                pc.x = px;\n                pc.y = py;\n                dist = pdist;\n            }\n        });\n        return pc;\n    },\n    _prepareArrayForTween(startArray, endArray, isClosed) {\n        var n, start = [], end = [];\n        if (startArray.length > endArray.length) {\n            var temp = endArray;\n            endArray = startArray;\n            startArray = temp;\n        }\n        for (n = 0; n < startArray.length; n += 2) {\n            start.push({\n                x: startArray[n],\n                y: startArray[n + 1],\n            });\n        }\n        for (n = 0; n < endArray.length; n += 2) {\n            end.push({\n                x: endArray[n],\n                y: endArray[n + 1],\n            });\n        }\n        var newStart = [];\n        end.forEach(function (point) {\n            var pr = Util_Util._getProjectionToLine(point, start, isClosed);\n            newStart.push(pr.x);\n            newStart.push(pr.y);\n        });\n        return newStart;\n    },\n    _prepareToStringify(obj) {\n        var desc;\n        obj.visitedByCircularReferenceRemoval = true;\n        for (var key in obj) {\n            if (!(obj.hasOwnProperty(key) && obj[key] && typeof obj[key] == 'object')) {\n                continue;\n            }\n            desc = Object.getOwnPropertyDescriptor(obj, key);\n            if (obj[key].visitedByCircularReferenceRemoval ||\n                Util_Util._isElement(obj[key])) {\n                if (desc.configurable) {\n                    delete obj[key];\n                }\n                else {\n                    return null;\n                }\n            }\n            else if (Util_Util._prepareToStringify(obj[key]) === null) {\n                if (desc.configurable) {\n                    delete obj[key];\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n        delete obj.visitedByCircularReferenceRemoval;\n        return obj;\n    },\n    _assign(target, source) {\n        for (var key in source) {\n            target[key] = source[key];\n        }\n        return target;\n    },\n    _getFirstPointerId(evt) {\n        if (!evt.touches) {\n            return evt.pointerId || 999;\n        }\n        else {\n            return evt.changedTouches[0].identifier;\n        }\n    },\n};\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/Validators.js\n\n\nfunction _formatValue(val) {\n    if (Util_Util._isString(val)) {\n        return '\"' + val + '\"';\n    }\n    if (Object.prototype.toString.call(val) === '[object Number]') {\n        return val;\n    }\n    if (Util_Util._isBoolean(val)) {\n        return val;\n    }\n    return Object.prototype.toString.call(val);\n}\nfunction RGBComponent(val) {\n    if (val > 255) {\n        return 255;\n    }\n    else if (val < 0) {\n        return 0;\n    }\n    return Math.round(val);\n}\nfunction alphaComponent(val) {\n    if (val > 1) {\n        return 1;\n    }\n    else if (val < 0.0001) {\n        return 0.0001;\n    }\n    return val;\n}\nfunction getNumberValidator() {\n    if (Global_Konva.isUnminified) {\n        return function (val, attr) {\n            if (!Util_Util._isNumber(val)) {\n                Util_Util.warn(_formatValue(val) +\n                    ' is a not valid value for \"' +\n                    attr +\n                    '\" attribute. The value should be a number.');\n            }\n            return val;\n        };\n    }\n}\nfunction getNumberOrArrayOfNumbersValidator(noOfElements) {\n    if (Global_Konva.isUnminified) {\n        return function (val, attr) {\n            let isNumber = Util_Util._isNumber(val);\n            let isValidArray = Util_Util._isArray(val) && val.length == noOfElements;\n            if (!isNumber && !isValidArray) {\n                Util_Util.warn(_formatValue(val) +\n                    ' is a not valid value for \"' +\n                    attr +\n                    '\" attribute. The value should be a number or Array<number>(' +\n                    noOfElements +\n                    ')');\n            }\n            return val;\n        };\n    }\n}\nfunction getNumberOrAutoValidator() {\n    if (Global_Konva.isUnminified) {\n        return function (val, attr) {\n            var isNumber = Util_Util._isNumber(val);\n            var isAuto = val === 'auto';\n            if (!(isNumber || isAuto)) {\n                Util_Util.warn(_formatValue(val) +\n                    ' is a not valid value for \"' +\n                    attr +\n                    '\" attribute. The value should be a number or \"auto\".');\n            }\n            return val;\n        };\n    }\n}\nfunction getStringValidator() {\n    if (Global_Konva.isUnminified) {\n        return function (val, attr) {\n            if (!Util_Util._isString(val)) {\n                Util_Util.warn(_formatValue(val) +\n                    ' is a not valid value for \"' +\n                    attr +\n                    '\" attribute. The value should be a string.');\n            }\n            return val;\n        };\n    }\n}\nfunction getStringOrGradientValidator() {\n    if (Global_Konva.isUnminified) {\n        return function (val, attr) {\n            const isString = Util_Util._isString(val);\n            const isGradient = Object.prototype.toString.call(val) === '[object CanvasGradient]' ||\n                (val && val.addColorStop);\n            if (!(isString || isGradient)) {\n                Util_Util.warn(_formatValue(val) +\n                    ' is a not valid value for \"' +\n                    attr +\n                    '\" attribute. The value should be a string or a native gradient.');\n            }\n            return val;\n        };\n    }\n}\nfunction getFunctionValidator() {\n    if (Konva.isUnminified) {\n        return function (val, attr) {\n            if (!Util._isFunction(val)) {\n                Util.warn(_formatValue(val) +\n                    ' is a not valid value for \"' +\n                    attr +\n                    '\" attribute. The value should be a function.');\n            }\n            return val;\n        };\n    }\n}\nfunction getNumberArrayValidator() {\n    if (Global_Konva.isUnminified) {\n        return function (val, attr) {\n            if (!Util_Util._isArray(val)) {\n                Util_Util.warn(_formatValue(val) +\n                    ' is a not valid value for \"' +\n                    attr +\n                    '\" attribute. The value should be a array of numbers.');\n            }\n            else {\n                val.forEach(function (item) {\n                    if (!Util_Util._isNumber(item)) {\n                        Util_Util.warn('\"' +\n                            attr +\n                            '\" attribute has non numeric element ' +\n                            item +\n                            '. Make sure that all elements are numbers.');\n                    }\n                });\n            }\n            return val;\n        };\n    }\n}\nfunction getBooleanValidator() {\n    if (Global_Konva.isUnminified) {\n        return function (val, attr) {\n            var isBool = val === true || val === false;\n            if (!isBool) {\n                Util_Util.warn(_formatValue(val) +\n                    ' is a not valid value for \"' +\n                    attr +\n                    '\" attribute. The value should be a boolean.');\n            }\n            return val;\n        };\n    }\n}\nfunction getComponentValidator(components) {\n    if (Global_Konva.isUnminified) {\n        return function (val, attr) {\n            if (!Util_Util.isObject(val)) {\n                Util_Util.warn(_formatValue(val) +\n                    ' is a not valid value for \"' +\n                    attr +\n                    '\" attribute. The value should be an object with properties ' +\n                    components);\n            }\n            return val;\n        };\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/Factory.js\n\n\nvar GET = 'get', SET = 'set';\nconst Factory = {\n    addGetterSetter(constructor, attr, def, validator, after) {\n        Factory.addGetter(constructor, attr, def);\n        Factory.addSetter(constructor, attr, validator, after);\n        Factory.addOverloadedGetterSetter(constructor, attr);\n    },\n    addGetter(constructor, attr, def) {\n        var method = GET + Util_Util._capitalize(attr);\n        constructor.prototype[method] =\n            constructor.prototype[method] ||\n                function () {\n                    var val = this.attrs[attr];\n                    return val === undefined ? def : val;\n                };\n    },\n    addSetter(constructor, attr, validator, after) {\n        var method = SET + Util_Util._capitalize(attr);\n        if (!constructor.prototype[method]) {\n            Factory.overWriteSetter(constructor, attr, validator, after);\n        }\n    },\n    overWriteSetter(constructor, attr, validator, after) {\n        var method = SET + Util_Util._capitalize(attr);\n        constructor.prototype[method] = function (val) {\n            if (validator && val !== undefined && val !== null) {\n                val = validator.call(this, val, attr);\n            }\n            this._setAttr(attr, val);\n            if (after) {\n                after.call(this);\n            }\n            return this;\n        };\n    },\n    addComponentsGetterSetter(constructor, attr, components, validator, after) {\n        var len = components.length, capitalize = Util_Util._capitalize, getter = GET + capitalize(attr), setter = SET + capitalize(attr), n, component;\n        constructor.prototype[getter] = function () {\n            var ret = {};\n            for (n = 0; n < len; n++) {\n                component = components[n];\n                ret[component] = this.getAttr(attr + capitalize(component));\n            }\n            return ret;\n        };\n        var basicValidator = getComponentValidator(components);\n        constructor.prototype[setter] = function (val) {\n            var oldVal = this.attrs[attr], key;\n            if (validator) {\n                val = validator.call(this, val);\n            }\n            if (basicValidator) {\n                basicValidator.call(this, val, attr);\n            }\n            for (key in val) {\n                if (!val.hasOwnProperty(key)) {\n                    continue;\n                }\n                this._setAttr(attr + capitalize(key), val[key]);\n            }\n            this._fireChangeEvent(attr, oldVal, val);\n            if (after) {\n                after.call(this);\n            }\n            return this;\n        };\n        Factory.addOverloadedGetterSetter(constructor, attr);\n    },\n    addOverloadedGetterSetter(constructor, attr) {\n        var capitalizedAttr = Util_Util._capitalize(attr), setter = SET + capitalizedAttr, getter = GET + capitalizedAttr;\n        constructor.prototype[attr] = function () {\n            if (arguments.length) {\n                this[setter](arguments[0]);\n                return this;\n            }\n            return this[getter]();\n        };\n    },\n    addDeprecatedGetterSetter(constructor, attr, def, validator) {\n        Util_Util.error('Adding deprecated ' + attr);\n        var method = GET + Util_Util._capitalize(attr);\n        var message = attr +\n            ' property is deprecated and will be removed soon. Look at Konva change log for more information.';\n        constructor.prototype[method] = function () {\n            Util_Util.error(message);\n            var val = this.attrs[attr];\n            return val === undefined ? def : val;\n        };\n        Factory.addSetter(constructor, attr, validator, function () {\n            Util_Util.error(message);\n        });\n        Factory.addOverloadedGetterSetter(constructor, attr);\n    },\n    backCompat(constructor, methods) {\n        Util_Util.each(methods, function (oldMethodName, newMethodName) {\n            var method = constructor.prototype[newMethodName];\n            var oldGetter = GET + Util_Util._capitalize(oldMethodName);\n            var oldSetter = SET + Util_Util._capitalize(oldMethodName);\n            function deprecated() {\n                method.apply(this, arguments);\n                Util_Util.error('\"' +\n                    oldMethodName +\n                    '\" method is deprecated and will be removed soon. Use \"\"' +\n                    newMethodName +\n                    '\" instead.');\n            }\n            constructor.prototype[oldMethodName] = deprecated;\n            constructor.prototype[oldGetter] = deprecated;\n            constructor.prototype[oldSetter] = deprecated;\n        });\n    },\n    afterSetFilter() {\n        this._filterUpToDate = false;\n    },\n};\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/Context.js\n\n\nfunction simplifyArray(arr) {\n    var retArr = [], len = arr.length, util = Util_Util, n, val;\n    for (n = 0; n < len; n++) {\n        val = arr[n];\n        if (util._isNumber(val)) {\n            val = Math.round(val * 1000) / 1000;\n        }\n        else if (!util._isString(val)) {\n            val = val + '';\n        }\n        retArr.push(val);\n    }\n    return retArr;\n}\nvar COMMA = ',', OPEN_PAREN = '(', CLOSE_PAREN = ')', OPEN_PAREN_BRACKET = '([', CLOSE_BRACKET_PAREN = '])', SEMICOLON = ';', DOUBLE_PAREN = '()', EQUALS = '=', CONTEXT_METHODS = [\n    'arc',\n    'arcTo',\n    'beginPath',\n    'bezierCurveTo',\n    'clearRect',\n    'clip',\n    'closePath',\n    'createLinearGradient',\n    'createPattern',\n    'createRadialGradient',\n    'drawImage',\n    'ellipse',\n    'fill',\n    'fillText',\n    'getImageData',\n    'createImageData',\n    'lineTo',\n    'moveTo',\n    'putImageData',\n    'quadraticCurveTo',\n    'rect',\n    'restore',\n    'rotate',\n    'save',\n    'scale',\n    'setLineDash',\n    'setTransform',\n    'stroke',\n    'strokeText',\n    'transform',\n    'translate',\n];\nvar CONTEXT_PROPERTIES = [\n    'fillStyle',\n    'strokeStyle',\n    'shadowColor',\n    'shadowBlur',\n    'shadowOffsetX',\n    'shadowOffsetY',\n    'lineCap',\n    'lineDashOffset',\n    'lineJoin',\n    'lineWidth',\n    'miterLimit',\n    'font',\n    'textAlign',\n    'textBaseline',\n    'globalAlpha',\n    'globalCompositeOperation',\n    'imageSmoothingEnabled',\n];\nconst traceArrMax = 100;\nclass Context_Context {\n    constructor(canvas) {\n        this.canvas = canvas;\n        this._context = canvas._canvas.getContext('2d');\n        if (Global_Konva.enableTrace) {\n            this.traceArr = [];\n            this._enableTrace();\n        }\n    }\n    fillShape(shape) {\n        if (shape.fillEnabled()) {\n            this._fill(shape);\n        }\n    }\n    _fill(shape) {\n    }\n    strokeShape(shape) {\n        if (shape.hasStroke()) {\n            this._stroke(shape);\n        }\n    }\n    _stroke(shape) {\n    }\n    fillStrokeShape(shape) {\n        if (shape.attrs.fillAfterStrokeEnabled) {\n            this.strokeShape(shape);\n            this.fillShape(shape);\n        }\n        else {\n            this.fillShape(shape);\n            this.strokeShape(shape);\n        }\n    }\n    getTrace(relaxed, rounded) {\n        var traceArr = this.traceArr, len = traceArr.length, str = '', n, trace, method, args;\n        for (n = 0; n < len; n++) {\n            trace = traceArr[n];\n            method = trace.method;\n            if (method) {\n                args = trace.args;\n                str += method;\n                if (relaxed) {\n                    str += DOUBLE_PAREN;\n                }\n                else {\n                    if (Util_Util._isArray(args[0])) {\n                        str += OPEN_PAREN_BRACKET + args.join(COMMA) + CLOSE_BRACKET_PAREN;\n                    }\n                    else {\n                        if (rounded) {\n                            args = args.map((a) => typeof a === 'number' ? Math.floor(a) : a);\n                        }\n                        str += OPEN_PAREN + args.join(COMMA) + CLOSE_PAREN;\n                    }\n                }\n            }\n            else {\n                str += trace.property;\n                if (!relaxed) {\n                    str += EQUALS + trace.val;\n                }\n            }\n            str += SEMICOLON;\n        }\n        return str;\n    }\n    clearTrace() {\n        this.traceArr = [];\n    }\n    _trace(str) {\n        var traceArr = this.traceArr, len;\n        traceArr.push(str);\n        len = traceArr.length;\n        if (len >= traceArrMax) {\n            traceArr.shift();\n        }\n    }\n    reset() {\n        var pixelRatio = this.getCanvas().getPixelRatio();\n        this.setTransform(1 * pixelRatio, 0, 0, 1 * pixelRatio, 0, 0);\n    }\n    getCanvas() {\n        return this.canvas;\n    }\n    clear(bounds) {\n        var canvas = this.getCanvas();\n        if (bounds) {\n            this.clearRect(bounds.x || 0, bounds.y || 0, bounds.width || 0, bounds.height || 0);\n        }\n        else {\n            this.clearRect(0, 0, canvas.getWidth() / canvas.pixelRatio, canvas.getHeight() / canvas.pixelRatio);\n        }\n    }\n    _applyLineCap(shape) {\n        var lineCap = shape.getLineCap();\n        if (lineCap) {\n            this.setAttr('lineCap', lineCap);\n        }\n    }\n    _applyOpacity(shape) {\n        var absOpacity = shape.getAbsoluteOpacity();\n        if (absOpacity !== 1) {\n            this.setAttr('globalAlpha', absOpacity);\n        }\n    }\n    _applyLineJoin(shape) {\n        var lineJoin = shape.attrs.lineJoin;\n        if (lineJoin) {\n            this.setAttr('lineJoin', lineJoin);\n        }\n    }\n    setAttr(attr, val) {\n        this._context[attr] = val;\n    }\n    arc(a0, a1, a2, a3, a4, a5) {\n        this._context.arc(a0, a1, a2, a3, a4, a5);\n    }\n    arcTo(a0, a1, a2, a3, a4) {\n        this._context.arcTo(a0, a1, a2, a3, a4);\n    }\n    beginPath() {\n        this._context.beginPath();\n    }\n    bezierCurveTo(a0, a1, a2, a3, a4, a5) {\n        this._context.bezierCurveTo(a0, a1, a2, a3, a4, a5);\n    }\n    clearRect(a0, a1, a2, a3) {\n        this._context.clearRect(a0, a1, a2, a3);\n    }\n    clip() {\n        this._context.clip();\n    }\n    closePath() {\n        this._context.closePath();\n    }\n    createImageData(a0, a1) {\n        var a = arguments;\n        if (a.length === 2) {\n            return this._context.createImageData(a0, a1);\n        }\n        else if (a.length === 1) {\n            return this._context.createImageData(a0);\n        }\n    }\n    createLinearGradient(a0, a1, a2, a3) {\n        return this._context.createLinearGradient(a0, a1, a2, a3);\n    }\n    createPattern(a0, a1) {\n        return this._context.createPattern(a0, a1);\n    }\n    createRadialGradient(a0, a1, a2, a3, a4, a5) {\n        return this._context.createRadialGradient(a0, a1, a2, a3, a4, a5);\n    }\n    drawImage(a0, a1, a2, a3, a4, a5, a6, a7, a8) {\n        var a = arguments, _context = this._context;\n        if (a.length === 3) {\n            _context.drawImage(a0, a1, a2);\n        }\n        else if (a.length === 5) {\n            _context.drawImage(a0, a1, a2, a3, a4);\n        }\n        else if (a.length === 9) {\n            _context.drawImage(a0, a1, a2, a3, a4, a5, a6, a7, a8);\n        }\n    }\n    ellipse(a0, a1, a2, a3, a4, a5, a6, a7) {\n        this._context.ellipse(a0, a1, a2, a3, a4, a5, a6, a7);\n    }\n    isPointInPath(x, y) {\n        return this._context.isPointInPath(x, y);\n    }\n    fill(path2d) {\n        if (path2d) {\n            this._context.fill(path2d);\n        }\n        else {\n            this._context.fill();\n        }\n    }\n    fillRect(x, y, width, height) {\n        this._context.fillRect(x, y, width, height);\n    }\n    strokeRect(x, y, width, height) {\n        this._context.strokeRect(x, y, width, height);\n    }\n    fillText(text, x, y, maxWidth) {\n        if (maxWidth) {\n            this._context.fillText(text, x, y, maxWidth);\n        }\n        else {\n            this._context.fillText(text, x, y);\n        }\n    }\n    measureText(text) {\n        return this._context.measureText(text);\n    }\n    getImageData(a0, a1, a2, a3) {\n        return this._context.getImageData(a0, a1, a2, a3);\n    }\n    lineTo(a0, a1) {\n        this._context.lineTo(a0, a1);\n    }\n    moveTo(a0, a1) {\n        this._context.moveTo(a0, a1);\n    }\n    rect(a0, a1, a2, a3) {\n        this._context.rect(a0, a1, a2, a3);\n    }\n    putImageData(a0, a1, a2) {\n        this._context.putImageData(a0, a1, a2);\n    }\n    quadraticCurveTo(a0, a1, a2, a3) {\n        this._context.quadraticCurveTo(a0, a1, a2, a3);\n    }\n    restore() {\n        this._context.restore();\n    }\n    rotate(a0) {\n        this._context.rotate(a0);\n    }\n    save() {\n        this._context.save();\n    }\n    scale(a0, a1) {\n        this._context.scale(a0, a1);\n    }\n    setLineDash(a0) {\n        if (this._context.setLineDash) {\n            this._context.setLineDash(a0);\n        }\n        else if ('mozDash' in this._context) {\n            this._context['mozDash'] = a0;\n        }\n        else if ('webkitLineDash' in this._context) {\n            this._context['webkitLineDash'] = a0;\n        }\n    }\n    getLineDash() {\n        return this._context.getLineDash();\n    }\n    setTransform(a0, a1, a2, a3, a4, a5) {\n        this._context.setTransform(a0, a1, a2, a3, a4, a5);\n    }\n    stroke(path2d) {\n        if (path2d) {\n            this._context.stroke(path2d);\n        }\n        else {\n            this._context.stroke();\n        }\n    }\n    strokeText(a0, a1, a2, a3) {\n        this._context.strokeText(a0, a1, a2, a3);\n    }\n    transform(a0, a1, a2, a3, a4, a5) {\n        this._context.transform(a0, a1, a2, a3, a4, a5);\n    }\n    translate(a0, a1) {\n        this._context.translate(a0, a1);\n    }\n    _enableTrace() {\n        var that = this, len = CONTEXT_METHODS.length, origSetter = this.setAttr, n, args;\n        var func = function (methodName) {\n            var origMethod = that[methodName], ret;\n            that[methodName] = function () {\n                args = simplifyArray(Array.prototype.slice.call(arguments, 0));\n                ret = origMethod.apply(that, arguments);\n                that._trace({\n                    method: methodName,\n                    args: args,\n                });\n                return ret;\n            };\n        };\n        for (n = 0; n < len; n++) {\n            func(CONTEXT_METHODS[n]);\n        }\n        that.setAttr = function () {\n            origSetter.apply(that, arguments);\n            var prop = arguments[0];\n            var val = arguments[1];\n            if (prop === 'shadowOffsetX' ||\n                prop === 'shadowOffsetY' ||\n                prop === 'shadowBlur') {\n                val = val / this.canvas.getPixelRatio();\n            }\n            that._trace({\n                property: prop,\n                val: val,\n            });\n        };\n    }\n    _applyGlobalCompositeOperation(node) {\n        const op = node.attrs.globalCompositeOperation;\n        var def = !op || op === 'source-over';\n        if (!def) {\n            this.setAttr('globalCompositeOperation', op);\n        }\n    }\n}\nCONTEXT_PROPERTIES.forEach(function (prop) {\n    Object.defineProperty(Context_Context.prototype, prop, {\n        get() {\n            return this._context[prop];\n        },\n        set(val) {\n            this._context[prop] = val;\n        },\n    });\n});\nclass SceneContext extends Context_Context {\n    _fillColor(shape) {\n        var fill = shape.fill();\n        this.setAttr('fillStyle', fill);\n        shape._fillFunc(this);\n    }\n    _fillPattern(shape) {\n        this.setAttr('fillStyle', shape._getFillPattern());\n        shape._fillFunc(this);\n    }\n    _fillLinearGradient(shape) {\n        var grd = shape._getLinearGradient();\n        if (grd) {\n            this.setAttr('fillStyle', grd);\n            shape._fillFunc(this);\n        }\n    }\n    _fillRadialGradient(shape) {\n        var grd = shape._getRadialGradient();\n        if (grd) {\n            this.setAttr('fillStyle', grd);\n            shape._fillFunc(this);\n        }\n    }\n    _fill(shape) {\n        var hasColor = shape.fill(), fillPriority = shape.getFillPriority();\n        if (hasColor && fillPriority === 'color') {\n            this._fillColor(shape);\n            return;\n        }\n        var hasPattern = shape.getFillPatternImage();\n        if (hasPattern && fillPriority === 'pattern') {\n            this._fillPattern(shape);\n            return;\n        }\n        var hasLinearGradient = shape.getFillLinearGradientColorStops();\n        if (hasLinearGradient && fillPriority === 'linear-gradient') {\n            this._fillLinearGradient(shape);\n            return;\n        }\n        var hasRadialGradient = shape.getFillRadialGradientColorStops();\n        if (hasRadialGradient && fillPriority === 'radial-gradient') {\n            this._fillRadialGradient(shape);\n            return;\n        }\n        if (hasColor) {\n            this._fillColor(shape);\n        }\n        else if (hasPattern) {\n            this._fillPattern(shape);\n        }\n        else if (hasLinearGradient) {\n            this._fillLinearGradient(shape);\n        }\n        else if (hasRadialGradient) {\n            this._fillRadialGradient(shape);\n        }\n    }\n    _strokeLinearGradient(shape) {\n        var start = shape.getStrokeLinearGradientStartPoint(), end = shape.getStrokeLinearGradientEndPoint(), colorStops = shape.getStrokeLinearGradientColorStops(), grd = this.createLinearGradient(start.x, start.y, end.x, end.y);\n        if (colorStops) {\n            for (var n = 0; n < colorStops.length; n += 2) {\n                grd.addColorStop(colorStops[n], colorStops[n + 1]);\n            }\n            this.setAttr('strokeStyle', grd);\n        }\n    }\n    _stroke(shape) {\n        var dash = shape.dash(), strokeScaleEnabled = shape.getStrokeScaleEnabled();\n        if (shape.hasStroke()) {\n            if (!strokeScaleEnabled) {\n                this.save();\n                var pixelRatio = this.getCanvas().getPixelRatio();\n                this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n            }\n            this._applyLineCap(shape);\n            if (dash && shape.dashEnabled()) {\n                this.setLineDash(dash);\n                this.setAttr('lineDashOffset', shape.dashOffset());\n            }\n            this.setAttr('lineWidth', shape.strokeWidth());\n            if (!shape.getShadowForStrokeEnabled()) {\n                this.setAttr('shadowColor', 'rgba(0,0,0,0)');\n            }\n            var hasLinearGradient = shape.getStrokeLinearGradientColorStops();\n            if (hasLinearGradient) {\n                this._strokeLinearGradient(shape);\n            }\n            else {\n                this.setAttr('strokeStyle', shape.stroke());\n            }\n            shape._strokeFunc(this);\n            if (!strokeScaleEnabled) {\n                this.restore();\n            }\n        }\n    }\n    _applyShadow(shape) {\n        var _a, _b, _c;\n        var color = (_a = shape.getShadowRGBA()) !== null && _a !== void 0 ? _a : 'black', blur = (_b = shape.getShadowBlur()) !== null && _b !== void 0 ? _b : 5, offset = (_c = shape.getShadowOffset()) !== null && _c !== void 0 ? _c : {\n            x: 0,\n            y: 0,\n        }, scale = shape.getAbsoluteScale(), ratio = this.canvas.getPixelRatio(), scaleX = scale.x * ratio, scaleY = scale.y * ratio;\n        this.setAttr('shadowColor', color);\n        this.setAttr('shadowBlur', blur * Math.min(Math.abs(scaleX), Math.abs(scaleY)));\n        this.setAttr('shadowOffsetX', offset.x * scaleX);\n        this.setAttr('shadowOffsetY', offset.y * scaleY);\n    }\n}\nclass HitContext extends Context_Context {\n    _fill(shape) {\n        this.save();\n        this.setAttr('fillStyle', shape.colorKey);\n        shape._fillFuncHit(this);\n        this.restore();\n    }\n    strokeShape(shape) {\n        if (shape.hasHitStroke()) {\n            this._stroke(shape);\n        }\n    }\n    _stroke(shape) {\n        if (shape.hasHitStroke()) {\n            var strokeScaleEnabled = shape.getStrokeScaleEnabled();\n            if (!strokeScaleEnabled) {\n                this.save();\n                var pixelRatio = this.getCanvas().getPixelRatio();\n                this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n            }\n            this._applyLineCap(shape);\n            var hitStrokeWidth = shape.hitStrokeWidth();\n            var strokeWidth = hitStrokeWidth === 'auto' ? shape.strokeWidth() : hitStrokeWidth;\n            this.setAttr('lineWidth', strokeWidth);\n            this.setAttr('strokeStyle', shape.colorKey);\n            shape._strokeFuncHit(this);\n            if (!strokeScaleEnabled) {\n                this.restore();\n            }\n        }\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/Canvas.js\n\n\n\n\n\nvar _pixelRatio;\nfunction getDevicePixelRatio() {\n    if (_pixelRatio) {\n        return _pixelRatio;\n    }\n    var canvas = Util_Util.createCanvasElement();\n    var context = canvas.getContext('2d');\n    _pixelRatio = (function () {\n        var devicePixelRatio = Global_Konva._global.devicePixelRatio || 1, backingStoreRatio = context.webkitBackingStorePixelRatio ||\n            context.mozBackingStorePixelRatio ||\n            context.msBackingStorePixelRatio ||\n            context.oBackingStorePixelRatio ||\n            context.backingStorePixelRatio ||\n            1;\n        return devicePixelRatio / backingStoreRatio;\n    })();\n    return _pixelRatio;\n}\nclass Canvas {\n    constructor(config) {\n        this.pixelRatio = 1;\n        this.width = 0;\n        this.height = 0;\n        this.isCache = false;\n        var conf = config || {};\n        var pixelRatio = conf.pixelRatio || Global_Konva.pixelRatio || getDevicePixelRatio();\n        this.pixelRatio = pixelRatio;\n        this._canvas = Util_Util.createCanvasElement();\n        this._canvas.style.padding = '0';\n        this._canvas.style.margin = '0';\n        this._canvas.style.border = '0';\n        this._canvas.style.background = 'transparent';\n        this._canvas.style.position = 'absolute';\n        this._canvas.style.top = '0';\n        this._canvas.style.left = '0';\n    }\n    getContext() {\n        return this.context;\n    }\n    getPixelRatio() {\n        return this.pixelRatio;\n    }\n    setPixelRatio(pixelRatio) {\n        var previousRatio = this.pixelRatio;\n        this.pixelRatio = pixelRatio;\n        this.setSize(this.getWidth() / previousRatio, this.getHeight() / previousRatio);\n    }\n    setWidth(width) {\n        this.width = this._canvas.width = width * this.pixelRatio;\n        this._canvas.style.width = width + 'px';\n        var pixelRatio = this.pixelRatio, _context = this.getContext()._context;\n        _context.scale(pixelRatio, pixelRatio);\n    }\n    setHeight(height) {\n        this.height = this._canvas.height = height * this.pixelRatio;\n        this._canvas.style.height = height + 'px';\n        var pixelRatio = this.pixelRatio, _context = this.getContext()._context;\n        _context.scale(pixelRatio, pixelRatio);\n    }\n    getWidth() {\n        return this.width;\n    }\n    getHeight() {\n        return this.height;\n    }\n    setSize(width, height) {\n        this.setWidth(width || 0);\n        this.setHeight(height || 0);\n    }\n    toDataURL(mimeType, quality) {\n        try {\n            return this._canvas.toDataURL(mimeType, quality);\n        }\n        catch (e) {\n            try {\n                return this._canvas.toDataURL();\n            }\n            catch (err) {\n                Util_Util.error('Unable to get data URL. ' +\n                    err.message +\n                    ' For more info read https://konvajs.org/docs/posts/Tainted_Canvas.html.');\n                return '';\n            }\n        }\n    }\n}\nFactory.addGetterSetter(Canvas, 'pixelRatio', undefined, getNumberValidator());\nclass SceneCanvas extends Canvas {\n    constructor(config = { width: 0, height: 0 }) {\n        super(config);\n        this.context = new SceneContext(this);\n        this.setSize(config.width, config.height);\n    }\n}\nclass HitCanvas extends Canvas {\n    constructor(config = { width: 0, height: 0 }) {\n        super(config);\n        this.hitCanvas = true;\n        this.context = new HitContext(this);\n        this.setSize(config.width, config.height);\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/DragAndDrop.js\n\n\nconst DD = {\n    get isDragging() {\n        var flag = false;\n        DD._dragElements.forEach((elem) => {\n            if (elem.dragStatus === 'dragging') {\n                flag = true;\n            }\n        });\n        return flag;\n    },\n    justDragged: false,\n    get node() {\n        var node;\n        DD._dragElements.forEach((elem) => {\n            node = elem.node;\n        });\n        return node;\n    },\n    _dragElements: new Map(),\n    _drag(evt) {\n        const nodesToFireEvents = [];\n        DD._dragElements.forEach((elem, key) => {\n            const { node } = elem;\n            const stage = node.getStage();\n            stage.setPointersPositions(evt);\n            if (elem.pointerId === undefined) {\n                elem.pointerId = Util_Util._getFirstPointerId(evt);\n            }\n            const pos = stage._changedPointerPositions.find((pos) => pos.id === elem.pointerId);\n            if (!pos) {\n                return;\n            }\n            if (elem.dragStatus !== 'dragging') {\n                var dragDistance = node.dragDistance();\n                var distance = Math.max(Math.abs(pos.x - elem.startPointerPos.x), Math.abs(pos.y - elem.startPointerPos.y));\n                if (distance < dragDistance) {\n                    return;\n                }\n                node.startDrag({ evt });\n                if (!node.isDragging()) {\n                    return;\n                }\n            }\n            node._setDragPosition(evt, elem);\n            nodesToFireEvents.push(node);\n        });\n        nodesToFireEvents.forEach((node) => {\n            node.fire('dragmove', {\n                type: 'dragmove',\n                target: node,\n                evt: evt,\n            }, true);\n        });\n    },\n    _endDragBefore(evt) {\n        DD._dragElements.forEach((elem) => {\n            const { node } = elem;\n            const stage = node.getStage();\n            if (evt) {\n                stage.setPointersPositions(evt);\n            }\n            const pos = stage._changedPointerPositions.find((pos) => pos.id === elem.pointerId);\n            if (!pos) {\n                return;\n            }\n            if (elem.dragStatus === 'dragging' || elem.dragStatus === 'stopped') {\n                DD.justDragged = true;\n                Global_Konva._mouseListenClick = false;\n                Global_Konva._touchListenClick = false;\n                Global_Konva._pointerListenClick = false;\n                elem.dragStatus = 'stopped';\n            }\n            const drawNode = elem.node.getLayer() ||\n                (elem.node instanceof Global_Konva.Stage && elem.node);\n            if (drawNode) {\n                drawNode.batchDraw();\n            }\n        });\n    },\n    _endDragAfter(evt) {\n        DD._dragElements.forEach((elem, key) => {\n            if (elem.dragStatus === 'stopped') {\n                elem.node.fire('dragend', {\n                    type: 'dragend',\n                    target: elem.node,\n                    evt: evt,\n                }, true);\n            }\n            if (elem.dragStatus !== 'dragging') {\n                DD._dragElements.delete(key);\n            }\n        });\n    },\n};\nif (Global_Konva.isBrowser) {\n    window.addEventListener('mouseup', DD._endDragBefore, true);\n    window.addEventListener('touchend', DD._endDragBefore, true);\n    window.addEventListener('mousemove', DD._drag);\n    window.addEventListener('touchmove', DD._drag);\n    window.addEventListener('mouseup', DD._endDragAfter, false);\n    window.addEventListener('touchend', DD._endDragAfter, false);\n}\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/Node.js\n\n\n\n\n\n\nvar ABSOLUTE_OPACITY = 'absoluteOpacity', ALL_LISTENERS = 'allEventListeners', ABSOLUTE_TRANSFORM = 'absoluteTransform', ABSOLUTE_SCALE = 'absoluteScale', CANVAS = 'canvas', CHANGE = 'Change', CHILDREN = 'children', KONVA = 'konva', LISTENING = 'listening', MOUSEENTER = 'mouseenter', MOUSELEAVE = 'mouseleave', NAME = 'name', Node_SET = 'set', SHAPE = 'Shape', SPACE = ' ', STAGE = 'stage', TRANSFORM = 'transform', UPPER_STAGE = 'Stage', VISIBLE = 'visible', TRANSFORM_CHANGE_STR = [\n    'xChange.konva',\n    'yChange.konva',\n    'scaleXChange.konva',\n    'scaleYChange.konva',\n    'skewXChange.konva',\n    'skewYChange.konva',\n    'rotationChange.konva',\n    'offsetXChange.konva',\n    'offsetYChange.konva',\n    'transformsEnabledChange.konva',\n].join(SPACE);\nlet idCounter = 1;\nclass Node {\n    constructor(config) {\n        this._id = idCounter++;\n        this.eventListeners = {};\n        this.attrs = {};\n        this.index = 0;\n        this._allEventListeners = null;\n        this.parent = null;\n        this._cache = new Map();\n        this._attachedDepsListeners = new Map();\n        this._lastPos = null;\n        this._batchingTransformChange = false;\n        this._needClearTransformCache = false;\n        this._filterUpToDate = false;\n        this._isUnderCache = false;\n        this._dragEventId = null;\n        this._shouldFireChangeEvents = false;\n        this.setAttrs(config);\n        this._shouldFireChangeEvents = true;\n    }\n    hasChildren() {\n        return false;\n    }\n    _clearCache(attr) {\n        if ((attr === TRANSFORM || attr === ABSOLUTE_TRANSFORM) &&\n            this._cache.get(attr)) {\n            this._cache.get(attr).dirty = true;\n        }\n        else if (attr) {\n            this._cache.delete(attr);\n        }\n        else {\n            this._cache.clear();\n        }\n    }\n    _getCache(attr, privateGetter) {\n        var cache = this._cache.get(attr);\n        var isTransform = attr === TRANSFORM || attr === ABSOLUTE_TRANSFORM;\n        var invalid = cache === undefined || (isTransform && cache.dirty === true);\n        if (invalid) {\n            cache = privateGetter.call(this);\n            this._cache.set(attr, cache);\n        }\n        return cache;\n    }\n    _calculate(name, deps, getter) {\n        if (!this._attachedDepsListeners.get(name)) {\n            const depsString = deps.map((dep) => dep + 'Change.konva').join(SPACE);\n            this.on(depsString, () => {\n                this._clearCache(name);\n            });\n            this._attachedDepsListeners.set(name, true);\n        }\n        return this._getCache(name, getter);\n    }\n    _getCanvasCache() {\n        return this._cache.get(CANVAS);\n    }\n    _clearSelfAndDescendantCache(attr) {\n        this._clearCache(attr);\n        if (attr === ABSOLUTE_TRANSFORM) {\n            this.fire('absoluteTransformChange');\n        }\n    }\n    clearCache() {\n        this._cache.delete(CANVAS);\n        this._clearSelfAndDescendantCache();\n        this._requestDraw();\n        return this;\n    }\n    cache(config) {\n        var conf = config || {};\n        var rect = {};\n        if (conf.x === undefined ||\n            conf.y === undefined ||\n            conf.width === undefined ||\n            conf.height === undefined) {\n            rect = this.getClientRect({\n                skipTransform: true,\n                relativeTo: this.getParent(),\n            });\n        }\n        var width = Math.ceil(conf.width || rect.width), height = Math.ceil(conf.height || rect.height), pixelRatio = conf.pixelRatio, x = conf.x === undefined ? Math.floor(rect.x) : conf.x, y = conf.y === undefined ? Math.floor(rect.y) : conf.y, offset = conf.offset || 0, drawBorder = conf.drawBorder || false, hitCanvasPixelRatio = conf.hitCanvasPixelRatio || 1;\n        if (!width || !height) {\n            Util_Util.error('Can not cache the node. Width or height of the node equals 0. Caching is skipped.');\n            return;\n        }\n        width += offset * 2 + 1;\n        height += offset * 2 + 1;\n        x -= offset;\n        y -= offset;\n        var cachedSceneCanvas = new SceneCanvas({\n            pixelRatio: pixelRatio,\n            width: width,\n            height: height,\n        }), cachedFilterCanvas = new SceneCanvas({\n            pixelRatio: pixelRatio,\n            width: 0,\n            height: 0,\n        }), cachedHitCanvas = new HitCanvas({\n            pixelRatio: hitCanvasPixelRatio,\n            width: width,\n            height: height,\n        }), sceneContext = cachedSceneCanvas.getContext(), hitContext = cachedHitCanvas.getContext();\n        cachedHitCanvas.isCache = true;\n        cachedSceneCanvas.isCache = true;\n        this._cache.delete(CANVAS);\n        this._filterUpToDate = false;\n        if (conf.imageSmoothingEnabled === false) {\n            cachedSceneCanvas.getContext()._context.imageSmoothingEnabled = false;\n            cachedFilterCanvas.getContext()._context.imageSmoothingEnabled = false;\n        }\n        sceneContext.save();\n        hitContext.save();\n        sceneContext.translate(-x, -y);\n        hitContext.translate(-x, -y);\n        this._isUnderCache = true;\n        this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);\n        this._clearSelfAndDescendantCache(ABSOLUTE_SCALE);\n        this.drawScene(cachedSceneCanvas, this);\n        this.drawHit(cachedHitCanvas, this);\n        this._isUnderCache = false;\n        sceneContext.restore();\n        hitContext.restore();\n        if (drawBorder) {\n            sceneContext.save();\n            sceneContext.beginPath();\n            sceneContext.rect(0, 0, width, height);\n            sceneContext.closePath();\n            sceneContext.setAttr('strokeStyle', 'red');\n            sceneContext.setAttr('lineWidth', 5);\n            sceneContext.stroke();\n            sceneContext.restore();\n        }\n        this._cache.set(CANVAS, {\n            scene: cachedSceneCanvas,\n            filter: cachedFilterCanvas,\n            hit: cachedHitCanvas,\n            x: x,\n            y: y,\n        });\n        this._requestDraw();\n        return this;\n    }\n    isCached() {\n        return this._cache.has(CANVAS);\n    }\n    getClientRect(config) {\n        throw new Error('abstract \"getClientRect\" method call');\n    }\n    _transformedRect(rect, top) {\n        var points = [\n            { x: rect.x, y: rect.y },\n            { x: rect.x + rect.width, y: rect.y },\n            { x: rect.x + rect.width, y: rect.y + rect.height },\n            { x: rect.x, y: rect.y + rect.height },\n        ];\n        var minX, minY, maxX, maxY;\n        var trans = this.getAbsoluteTransform(top);\n        points.forEach(function (point) {\n            var transformed = trans.point(point);\n            if (minX === undefined) {\n                minX = maxX = transformed.x;\n                minY = maxY = transformed.y;\n            }\n            minX = Math.min(minX, transformed.x);\n            minY = Math.min(minY, transformed.y);\n            maxX = Math.max(maxX, transformed.x);\n            maxY = Math.max(maxY, transformed.y);\n        });\n        return {\n            x: minX,\n            y: minY,\n            width: maxX - minX,\n            height: maxY - minY,\n        };\n    }\n    _drawCachedSceneCanvas(context) {\n        context.save();\n        context._applyOpacity(this);\n        context._applyGlobalCompositeOperation(this);\n        const canvasCache = this._getCanvasCache();\n        context.translate(canvasCache.x, canvasCache.y);\n        var cacheCanvas = this._getCachedSceneCanvas();\n        var ratio = cacheCanvas.pixelRatio;\n        context.drawImage(cacheCanvas._canvas, 0, 0, cacheCanvas.width / ratio, cacheCanvas.height / ratio);\n        context.restore();\n    }\n    _drawCachedHitCanvas(context) {\n        var canvasCache = this._getCanvasCache(), hitCanvas = canvasCache.hit;\n        context.save();\n        context.translate(canvasCache.x, canvasCache.y);\n        context.drawImage(hitCanvas._canvas, 0, 0, hitCanvas.width / hitCanvas.pixelRatio, hitCanvas.height / hitCanvas.pixelRatio);\n        context.restore();\n    }\n    _getCachedSceneCanvas() {\n        var filters = this.filters(), cachedCanvas = this._getCanvasCache(), sceneCanvas = cachedCanvas.scene, filterCanvas = cachedCanvas.filter, filterContext = filterCanvas.getContext(), len, imageData, n, filter;\n        if (filters) {\n            if (!this._filterUpToDate) {\n                var ratio = sceneCanvas.pixelRatio;\n                filterCanvas.setSize(sceneCanvas.width / sceneCanvas.pixelRatio, sceneCanvas.height / sceneCanvas.pixelRatio);\n                try {\n                    len = filters.length;\n                    filterContext.clear();\n                    filterContext.drawImage(sceneCanvas._canvas, 0, 0, sceneCanvas.getWidth() / ratio, sceneCanvas.getHeight() / ratio);\n                    imageData = filterContext.getImageData(0, 0, filterCanvas.getWidth(), filterCanvas.getHeight());\n                    for (n = 0; n < len; n++) {\n                        filter = filters[n];\n                        if (typeof filter !== 'function') {\n                            Util_Util.error('Filter should be type of function, but got ' +\n                                typeof filter +\n                                ' instead. Please check correct filters');\n                            continue;\n                        }\n                        filter.call(this, imageData);\n                        filterContext.putImageData(imageData, 0, 0);\n                    }\n                }\n                catch (e) {\n                    Util_Util.error('Unable to apply filter. ' +\n                        e.message +\n                        ' This post my help you https://konvajs.org/docs/posts/Tainted_Canvas.html.');\n                }\n                this._filterUpToDate = true;\n            }\n            return filterCanvas;\n        }\n        return sceneCanvas;\n    }\n    on(evtStr, handler) {\n        this._cache && this._cache.delete(ALL_LISTENERS);\n        if (arguments.length === 3) {\n            return this._delegate.apply(this, arguments);\n        }\n        var events = evtStr.split(SPACE), len = events.length, n, event, parts, baseEvent, name;\n        for (n = 0; n < len; n++) {\n            event = events[n];\n            parts = event.split('.');\n            baseEvent = parts[0];\n            name = parts[1] || '';\n            if (!this.eventListeners[baseEvent]) {\n                this.eventListeners[baseEvent] = [];\n            }\n            this.eventListeners[baseEvent].push({\n                name: name,\n                handler: handler,\n            });\n        }\n        return this;\n    }\n    off(evtStr, callback) {\n        var events = (evtStr || '').split(SPACE), len = events.length, n, t, event, parts, baseEvent, name;\n        this._cache && this._cache.delete(ALL_LISTENERS);\n        if (!evtStr) {\n            for (t in this.eventListeners) {\n                this._off(t);\n            }\n        }\n        for (n = 0; n < len; n++) {\n            event = events[n];\n            parts = event.split('.');\n            baseEvent = parts[0];\n            name = parts[1];\n            if (baseEvent) {\n                if (this.eventListeners[baseEvent]) {\n                    this._off(baseEvent, name, callback);\n                }\n            }\n            else {\n                for (t in this.eventListeners) {\n                    this._off(t, name, callback);\n                }\n            }\n        }\n        return this;\n    }\n    dispatchEvent(evt) {\n        var e = {\n            target: this,\n            type: evt.type,\n            evt: evt,\n        };\n        this.fire(evt.type, e);\n        return this;\n    }\n    addEventListener(type, handler) {\n        this.on(type, function (evt) {\n            handler.call(this, evt.evt);\n        });\n        return this;\n    }\n    removeEventListener(type) {\n        this.off(type);\n        return this;\n    }\n    _delegate(event, selector, handler) {\n        var stopNode = this;\n        this.on(event, function (evt) {\n            var targets = evt.target.findAncestors(selector, true, stopNode);\n            for (var i = 0; i < targets.length; i++) {\n                evt = Util_Util.cloneObject(evt);\n                evt.currentTarget = targets[i];\n                handler.call(targets[i], evt);\n            }\n        });\n    }\n    remove() {\n        if (this.isDragging()) {\n            this.stopDrag();\n        }\n        DD._dragElements[\"delete\"](this._id);\n        this._remove();\n        return this;\n    }\n    _clearCaches() {\n        this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);\n        this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);\n        this._clearSelfAndDescendantCache(ABSOLUTE_SCALE);\n        this._clearSelfAndDescendantCache(STAGE);\n        this._clearSelfAndDescendantCache(VISIBLE);\n        this._clearSelfAndDescendantCache(LISTENING);\n    }\n    _remove() {\n        this._clearCaches();\n        var parent = this.getParent();\n        if (parent && parent.children) {\n            parent.children.splice(this.index, 1);\n            parent._setChildrenIndices();\n            this.parent = null;\n        }\n    }\n    destroy() {\n        this.remove();\n        return this;\n    }\n    getAttr(attr) {\n        var method = 'get' + Util_Util._capitalize(attr);\n        if (Util_Util._isFunction(this[method])) {\n            return this[method]();\n        }\n        return this.attrs[attr];\n    }\n    getAncestors() {\n        var parent = this.getParent(), ancestors = [];\n        while (parent) {\n            ancestors.push(parent);\n            parent = parent.getParent();\n        }\n        return ancestors;\n    }\n    getAttrs() {\n        return this.attrs || {};\n    }\n    setAttrs(config) {\n        this._batchTransformChanges(() => {\n            var key, method;\n            if (!config) {\n                return this;\n            }\n            for (key in config) {\n                if (key === CHILDREN) {\n                    continue;\n                }\n                method = Node_SET + Util_Util._capitalize(key);\n                if (Util_Util._isFunction(this[method])) {\n                    this[method](config[key]);\n                }\n                else {\n                    this._setAttr(key, config[key]);\n                }\n            }\n        });\n        return this;\n    }\n    isListening() {\n        return this._getCache(LISTENING, this._isListening);\n    }\n    _isListening(relativeTo) {\n        const listening = this.listening();\n        if (!listening) {\n            return false;\n        }\n        const parent = this.getParent();\n        if (parent && parent !== relativeTo && this !== relativeTo) {\n            return parent._isListening(relativeTo);\n        }\n        else {\n            return true;\n        }\n    }\n    isVisible() {\n        return this._getCache(VISIBLE, this._isVisible);\n    }\n    _isVisible(relativeTo) {\n        const visible = this.visible();\n        if (!visible) {\n            return false;\n        }\n        const parent = this.getParent();\n        if (parent && parent !== relativeTo && this !== relativeTo) {\n            return parent._isVisible(relativeTo);\n        }\n        else {\n            return true;\n        }\n    }\n    shouldDrawHit(top, skipDragCheck = false) {\n        if (top) {\n            return this._isVisible(top) && this._isListening(top);\n        }\n        var layer = this.getLayer();\n        var layerUnderDrag = false;\n        DD._dragElements.forEach((elem) => {\n            if (elem.dragStatus !== 'dragging') {\n                return;\n            }\n            else if (elem.node.nodeType === 'Stage') {\n                layerUnderDrag = true;\n            }\n            else if (elem.node.getLayer() === layer) {\n                layerUnderDrag = true;\n            }\n        });\n        var dragSkip = !skipDragCheck && !Global_Konva.hitOnDragEnabled && layerUnderDrag;\n        return this.isListening() && this.isVisible() && !dragSkip;\n    }\n    show() {\n        this.visible(true);\n        return this;\n    }\n    hide() {\n        this.visible(false);\n        return this;\n    }\n    getZIndex() {\n        return this.index || 0;\n    }\n    getAbsoluteZIndex() {\n        var depth = this.getDepth(), that = this, index = 0, nodes, len, n, child;\n        function addChildren(children) {\n            nodes = [];\n            len = children.length;\n            for (n = 0; n < len; n++) {\n                child = children[n];\n                index++;\n                if (child.nodeType !== SHAPE) {\n                    nodes = nodes.concat(child.getChildren().slice());\n                }\n                if (child._id === that._id) {\n                    n = len;\n                }\n            }\n            if (nodes.length > 0 && nodes[0].getDepth() <= depth) {\n                addChildren(nodes);\n            }\n        }\n        if (that.nodeType !== UPPER_STAGE) {\n            addChildren(that.getStage().getChildren());\n        }\n        return index;\n    }\n    getDepth() {\n        var depth = 0, parent = this.parent;\n        while (parent) {\n            depth++;\n            parent = parent.parent;\n        }\n        return depth;\n    }\n    _batchTransformChanges(func) {\n        this._batchingTransformChange = true;\n        func();\n        this._batchingTransformChange = false;\n        if (this._needClearTransformCache) {\n            this._clearCache(TRANSFORM);\n            this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);\n        }\n        this._needClearTransformCache = false;\n    }\n    setPosition(pos) {\n        this._batchTransformChanges(() => {\n            this.x(pos.x);\n            this.y(pos.y);\n        });\n        return this;\n    }\n    getPosition() {\n        return {\n            x: this.x(),\n            y: this.y(),\n        };\n    }\n    getRelativePointerPosition() {\n        if (!this.getStage()) {\n            return null;\n        }\n        var pos = this.getStage().getPointerPosition();\n        if (!pos) {\n            return null;\n        }\n        var transform = this.getAbsoluteTransform().copy();\n        transform.invert();\n        return transform.point(pos);\n    }\n    getAbsolutePosition(top) {\n        let haveCachedParent = false;\n        let parent = this.parent;\n        while (parent) {\n            if (parent.isCached()) {\n                haveCachedParent = true;\n                break;\n            }\n            parent = parent.parent;\n        }\n        if (haveCachedParent && !top) {\n            top = true;\n        }\n        var absoluteMatrix = this.getAbsoluteTransform(top).getMatrix(), absoluteTransform = new Transform(), offset = this.offset();\n        absoluteTransform.m = absoluteMatrix.slice();\n        absoluteTransform.translate(offset.x, offset.y);\n        return absoluteTransform.getTranslation();\n    }\n    setAbsolutePosition(pos) {\n        var origTrans = this._clearTransform();\n        this.attrs.x = origTrans.x;\n        this.attrs.y = origTrans.y;\n        delete origTrans.x;\n        delete origTrans.y;\n        this._clearCache(TRANSFORM);\n        var it = this._getAbsoluteTransform().copy();\n        it.invert();\n        it.translate(pos.x, pos.y);\n        pos = {\n            x: this.attrs.x + it.getTranslation().x,\n            y: this.attrs.y + it.getTranslation().y,\n        };\n        this._setTransform(origTrans);\n        this.setPosition({ x: pos.x, y: pos.y });\n        this._clearCache(TRANSFORM);\n        this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);\n        return this;\n    }\n    _setTransform(trans) {\n        var key;\n        for (key in trans) {\n            this.attrs[key] = trans[key];\n        }\n    }\n    _clearTransform() {\n        var trans = {\n            x: this.x(),\n            y: this.y(),\n            rotation: this.rotation(),\n            scaleX: this.scaleX(),\n            scaleY: this.scaleY(),\n            offsetX: this.offsetX(),\n            offsetY: this.offsetY(),\n            skewX: this.skewX(),\n            skewY: this.skewY(),\n        };\n        this.attrs.x = 0;\n        this.attrs.y = 0;\n        this.attrs.rotation = 0;\n        this.attrs.scaleX = 1;\n        this.attrs.scaleY = 1;\n        this.attrs.offsetX = 0;\n        this.attrs.offsetY = 0;\n        this.attrs.skewX = 0;\n        this.attrs.skewY = 0;\n        return trans;\n    }\n    move(change) {\n        var changeX = change.x, changeY = change.y, x = this.x(), y = this.y();\n        if (changeX !== undefined) {\n            x += changeX;\n        }\n        if (changeY !== undefined) {\n            y += changeY;\n        }\n        this.setPosition({ x: x, y: y });\n        return this;\n    }\n    _eachAncestorReverse(func, top) {\n        var family = [], parent = this.getParent(), len, n;\n        if (top && top._id === this._id) {\n            return;\n        }\n        family.unshift(this);\n        while (parent && (!top || parent._id !== top._id)) {\n            family.unshift(parent);\n            parent = parent.parent;\n        }\n        len = family.length;\n        for (n = 0; n < len; n++) {\n            func(family[n]);\n        }\n    }\n    rotate(theta) {\n        this.rotation(this.rotation() + theta);\n        return this;\n    }\n    moveToTop() {\n        if (!this.parent) {\n            Util_Util.warn('Node has no parent. moveToTop function is ignored.');\n            return false;\n        }\n        var index = this.index, len = this.parent.getChildren().length;\n        if (index < len - 1) {\n            this.parent.children.splice(index, 1);\n            this.parent.children.push(this);\n            this.parent._setChildrenIndices();\n            return true;\n        }\n        return false;\n    }\n    moveUp() {\n        if (!this.parent) {\n            Util_Util.warn('Node has no parent. moveUp function is ignored.');\n            return false;\n        }\n        var index = this.index, len = this.parent.getChildren().length;\n        if (index < len - 1) {\n            this.parent.children.splice(index, 1);\n            this.parent.children.splice(index + 1, 0, this);\n            this.parent._setChildrenIndices();\n            return true;\n        }\n        return false;\n    }\n    moveDown() {\n        if (!this.parent) {\n            Util_Util.warn('Node has no parent. moveDown function is ignored.');\n            return false;\n        }\n        var index = this.index;\n        if (index > 0) {\n            this.parent.children.splice(index, 1);\n            this.parent.children.splice(index - 1, 0, this);\n            this.parent._setChildrenIndices();\n            return true;\n        }\n        return false;\n    }\n    moveToBottom() {\n        if (!this.parent) {\n            Util_Util.warn('Node has no parent. moveToBottom function is ignored.');\n            return false;\n        }\n        var index = this.index;\n        if (index > 0) {\n            this.parent.children.splice(index, 1);\n            this.parent.children.unshift(this);\n            this.parent._setChildrenIndices();\n            return true;\n        }\n        return false;\n    }\n    setZIndex(zIndex) {\n        if (!this.parent) {\n            Util_Util.warn('Node has no parent. zIndex parameter is ignored.');\n            return this;\n        }\n        if (zIndex < 0 || zIndex >= this.parent.children.length) {\n            Util_Util.warn('Unexpected value ' +\n                zIndex +\n                ' for zIndex property. zIndex is just index of a node in children of its parent. Expected value is from 0 to ' +\n                (this.parent.children.length - 1) +\n                '.');\n        }\n        var index = this.index;\n        this.parent.children.splice(index, 1);\n        this.parent.children.splice(zIndex, 0, this);\n        this.parent._setChildrenIndices();\n        return this;\n    }\n    getAbsoluteOpacity() {\n        return this._getCache(ABSOLUTE_OPACITY, this._getAbsoluteOpacity);\n    }\n    _getAbsoluteOpacity() {\n        var absOpacity = this.opacity();\n        var parent = this.getParent();\n        if (parent && !parent._isUnderCache) {\n            absOpacity *= parent.getAbsoluteOpacity();\n        }\n        return absOpacity;\n    }\n    moveTo(newContainer) {\n        if (this.getParent() !== newContainer) {\n            this._remove();\n            newContainer.add(this);\n        }\n        return this;\n    }\n    toObject() {\n        var obj = {}, attrs = this.getAttrs(), key, val, getter, defaultValue, nonPlainObject;\n        obj.attrs = {};\n        for (key in attrs) {\n            val = attrs[key];\n            nonPlainObject =\n                Util_Util.isObject(val) && !Util_Util._isPlainObject(val) && !Util_Util._isArray(val);\n            if (nonPlainObject) {\n                continue;\n            }\n            getter = typeof this[key] === 'function' && this[key];\n            delete attrs[key];\n            defaultValue = getter ? getter.call(this) : null;\n            attrs[key] = val;\n            if (defaultValue !== val) {\n                obj.attrs[key] = val;\n            }\n        }\n        obj.className = this.getClassName();\n        return Util_Util._prepareToStringify(obj);\n    }\n    toJSON() {\n        return JSON.stringify(this.toObject());\n    }\n    getParent() {\n        return this.parent;\n    }\n    findAncestors(selector, includeSelf, stopNode) {\n        var res = [];\n        if (includeSelf && this._isMatch(selector)) {\n            res.push(this);\n        }\n        var ancestor = this.parent;\n        while (ancestor) {\n            if (ancestor === stopNode) {\n                return res;\n            }\n            if (ancestor._isMatch(selector)) {\n                res.push(ancestor);\n            }\n            ancestor = ancestor.parent;\n        }\n        return res;\n    }\n    isAncestorOf(node) {\n        return false;\n    }\n    findAncestor(selector, includeSelf, stopNode) {\n        return this.findAncestors(selector, includeSelf, stopNode)[0];\n    }\n    _isMatch(selector) {\n        if (!selector) {\n            return false;\n        }\n        if (typeof selector === 'function') {\n            return selector(this);\n        }\n        var selectorArr = selector.replace(/ /g, '').split(','), len = selectorArr.length, n, sel;\n        for (n = 0; n < len; n++) {\n            sel = selectorArr[n];\n            if (!Util_Util.isValidSelector(sel)) {\n                Util_Util.warn('Selector \"' +\n                    sel +\n                    '\" is invalid. Allowed selectors examples are \"#foo\", \".bar\" or \"Group\".');\n                Util_Util.warn('If you have a custom shape with such className, please change it to start with upper letter like \"Triangle\".');\n                Util_Util.warn('Konva is awesome, right?');\n            }\n            if (sel.charAt(0) === '#') {\n                if (this.id() === sel.slice(1)) {\n                    return true;\n                }\n            }\n            else if (sel.charAt(0) === '.') {\n                if (this.hasName(sel.slice(1))) {\n                    return true;\n                }\n            }\n            else if (this.className === sel || this.nodeType === sel) {\n                return true;\n            }\n        }\n        return false;\n    }\n    getLayer() {\n        var parent = this.getParent();\n        return parent ? parent.getLayer() : null;\n    }\n    getStage() {\n        return this._getCache(STAGE, this._getStage);\n    }\n    _getStage() {\n        var parent = this.getParent();\n        if (parent) {\n            return parent.getStage();\n        }\n        else {\n            return undefined;\n        }\n    }\n    fire(eventType, evt = {}, bubble) {\n        evt.target = evt.target || this;\n        if (bubble) {\n            this._fireAndBubble(eventType, evt);\n        }\n        else {\n            this._fire(eventType, evt);\n        }\n        return this;\n    }\n    getAbsoluteTransform(top) {\n        if (top) {\n            return this._getAbsoluteTransform(top);\n        }\n        else {\n            return this._getCache(ABSOLUTE_TRANSFORM, this._getAbsoluteTransform);\n        }\n    }\n    _getAbsoluteTransform(top) {\n        var at;\n        if (top) {\n            at = new Transform();\n            this._eachAncestorReverse(function (node) {\n                var transformsEnabled = node.transformsEnabled();\n                if (transformsEnabled === 'all') {\n                    at.multiply(node.getTransform());\n                }\n                else if (transformsEnabled === 'position') {\n                    at.translate(node.x() - node.offsetX(), node.y() - node.offsetY());\n                }\n            }, top);\n            return at;\n        }\n        else {\n            at = this._cache.get(ABSOLUTE_TRANSFORM) || new Transform();\n            if (this.parent) {\n                this.parent.getAbsoluteTransform().copyInto(at);\n            }\n            else {\n                at.reset();\n            }\n            var transformsEnabled = this.transformsEnabled();\n            if (transformsEnabled === 'all') {\n                at.multiply(this.getTransform());\n            }\n            else if (transformsEnabled === 'position') {\n                const x = this.attrs.x || 0;\n                const y = this.attrs.y || 0;\n                const offsetX = this.attrs.offsetX || 0;\n                const offsetY = this.attrs.offsetY || 0;\n                at.translate(x - offsetX, y - offsetY);\n            }\n            at.dirty = false;\n            return at;\n        }\n    }\n    getAbsoluteScale(top) {\n        var parent = this;\n        while (parent) {\n            if (parent._isUnderCache) {\n                top = parent;\n            }\n            parent = parent.getParent();\n        }\n        const transform = this.getAbsoluteTransform(top);\n        const attrs = transform.decompose();\n        return {\n            x: attrs.scaleX,\n            y: attrs.scaleY,\n        };\n    }\n    getAbsoluteRotation() {\n        return this.getAbsoluteTransform().decompose().rotation;\n    }\n    getTransform() {\n        return this._getCache(TRANSFORM, this._getTransform);\n    }\n    _getTransform() {\n        var _a, _b;\n        var m = this._cache.get(TRANSFORM) || new Transform();\n        m.reset();\n        var x = this.x(), y = this.y(), rotation = Global_Konva.getAngle(this.rotation()), scaleX = (_a = this.attrs.scaleX) !== null && _a !== void 0 ? _a : 1, scaleY = (_b = this.attrs.scaleY) !== null && _b !== void 0 ? _b : 1, skewX = this.attrs.skewX || 0, skewY = this.attrs.skewY || 0, offsetX = this.attrs.offsetX || 0, offsetY = this.attrs.offsetY || 0;\n        if (x !== 0 || y !== 0) {\n            m.translate(x, y);\n        }\n        if (rotation !== 0) {\n            m.rotate(rotation);\n        }\n        if (skewX !== 0 || skewY !== 0) {\n            m.skew(skewX, skewY);\n        }\n        if (scaleX !== 1 || scaleY !== 1) {\n            m.scale(scaleX, scaleY);\n        }\n        if (offsetX !== 0 || offsetY !== 0) {\n            m.translate(-1 * offsetX, -1 * offsetY);\n        }\n        m.dirty = false;\n        return m;\n    }\n    clone(obj) {\n        var attrs = Util_Util.cloneObject(this.attrs), key, allListeners, len, n, listener;\n        for (key in obj) {\n            attrs[key] = obj[key];\n        }\n        var node = new this.constructor(attrs);\n        for (key in this.eventListeners) {\n            allListeners = this.eventListeners[key];\n            len = allListeners.length;\n            for (n = 0; n < len; n++) {\n                listener = allListeners[n];\n                if (listener.name.indexOf(KONVA) < 0) {\n                    if (!node.eventListeners[key]) {\n                        node.eventListeners[key] = [];\n                    }\n                    node.eventListeners[key].push(listener);\n                }\n            }\n        }\n        return node;\n    }\n    _toKonvaCanvas(config) {\n        config = config || {};\n        var box = this.getClientRect();\n        var stage = this.getStage(), x = config.x !== undefined ? config.x : Math.floor(box.x), y = config.y !== undefined ? config.y : Math.floor(box.y), pixelRatio = config.pixelRatio || 1, canvas = new SceneCanvas({\n            width: config.width || Math.ceil(box.width) || (stage ? stage.width() : 0),\n            height: config.height ||\n                Math.ceil(box.height) ||\n                (stage ? stage.height() : 0),\n            pixelRatio: pixelRatio,\n        }), context = canvas.getContext();\n        if (config.imageSmoothingEnabled === false) {\n            context._context.imageSmoothingEnabled = false;\n        }\n        context.save();\n        if (x || y) {\n            context.translate(-1 * x, -1 * y);\n        }\n        this.drawScene(canvas);\n        context.restore();\n        return canvas;\n    }\n    toCanvas(config) {\n        return this._toKonvaCanvas(config)._canvas;\n    }\n    toDataURL(config) {\n        config = config || {};\n        var mimeType = config.mimeType || null, quality = config.quality || null;\n        var url = this._toKonvaCanvas(config).toDataURL(mimeType, quality);\n        if (config.callback) {\n            config.callback(url);\n        }\n        return url;\n    }\n    toImage(config) {\n        if (!config || !config.callback) {\n            throw 'callback required for toImage method config argument';\n        }\n        var callback = config.callback;\n        delete config.callback;\n        Util_Util._urlToImage(this.toDataURL(config), function (img) {\n            callback(img);\n        });\n    }\n    setSize(size) {\n        this.width(size.width);\n        this.height(size.height);\n        return this;\n    }\n    getSize() {\n        return {\n            width: this.width(),\n            height: this.height(),\n        };\n    }\n    getClassName() {\n        return this.className || this.nodeType;\n    }\n    getType() {\n        return this.nodeType;\n    }\n    getDragDistance() {\n        if (this.attrs.dragDistance !== undefined) {\n            return this.attrs.dragDistance;\n        }\n        else if (this.parent) {\n            return this.parent.getDragDistance();\n        }\n        else {\n            return Global_Konva.dragDistance;\n        }\n    }\n    _off(type, name, callback) {\n        var evtListeners = this.eventListeners[type], i, evtName, handler;\n        for (i = 0; i < evtListeners.length; i++) {\n            evtName = evtListeners[i].name;\n            handler = evtListeners[i].handler;\n            if ((evtName !== 'konva' || name === 'konva') &&\n                (!name || evtName === name) &&\n                (!callback || callback === handler)) {\n                evtListeners.splice(i, 1);\n                if (evtListeners.length === 0) {\n                    delete this.eventListeners[type];\n                    break;\n                }\n                i--;\n            }\n        }\n    }\n    _fireChangeEvent(attr, oldVal, newVal) {\n        this._fire(attr + CHANGE, {\n            oldVal: oldVal,\n            newVal: newVal,\n        });\n    }\n    addName(name) {\n        if (!this.hasName(name)) {\n            var oldName = this.name();\n            var newName = oldName ? oldName + ' ' + name : name;\n            this.name(newName);\n        }\n        return this;\n    }\n    hasName(name) {\n        if (!name) {\n            return false;\n        }\n        const fullName = this.name();\n        if (!fullName) {\n            return false;\n        }\n        var names = (fullName || '').split(/\\s/g);\n        return names.indexOf(name) !== -1;\n    }\n    removeName(name) {\n        var names = (this.name() || '').split(/\\s/g);\n        var index = names.indexOf(name);\n        if (index !== -1) {\n            names.splice(index, 1);\n            this.name(names.join(' '));\n        }\n        return this;\n    }\n    setAttr(attr, val) {\n        var func = this[Node_SET + Util_Util._capitalize(attr)];\n        if (Util_Util._isFunction(func)) {\n            func.call(this, val);\n        }\n        else {\n            this._setAttr(attr, val);\n        }\n        return this;\n    }\n    _requestDraw() {\n        if (Global_Konva.autoDrawEnabled) {\n            const drawNode = this.getLayer() || this.getStage();\n            drawNode === null || drawNode === void 0 ? void 0 : drawNode.batchDraw();\n        }\n    }\n    _setAttr(key, val) {\n        var oldVal = this.attrs[key];\n        if (oldVal === val && !Util_Util.isObject(val)) {\n            return;\n        }\n        if (val === undefined || val === null) {\n            delete this.attrs[key];\n        }\n        else {\n            this.attrs[key] = val;\n        }\n        if (this._shouldFireChangeEvents) {\n            this._fireChangeEvent(key, oldVal, val);\n        }\n        this._requestDraw();\n    }\n    _setComponentAttr(key, component, val) {\n        var oldVal;\n        if (val !== undefined) {\n            oldVal = this.attrs[key];\n            if (!oldVal) {\n                this.attrs[key] = this.getAttr(key);\n            }\n            this.attrs[key][component] = val;\n            this._fireChangeEvent(key, oldVal, val);\n        }\n    }\n    _fireAndBubble(eventType, evt, compareShape) {\n        if (evt && this.nodeType === SHAPE) {\n            evt.target = this;\n        }\n        var shouldStop = (eventType === MOUSEENTER || eventType === MOUSELEAVE) &&\n            ((compareShape &&\n                (this === compareShape ||\n                    (this.isAncestorOf && this.isAncestorOf(compareShape)))) ||\n                (this.nodeType === 'Stage' && !compareShape));\n        if (!shouldStop) {\n            this._fire(eventType, evt);\n            var stopBubble = (eventType === MOUSEENTER || eventType === MOUSELEAVE) &&\n                compareShape &&\n                compareShape.isAncestorOf &&\n                compareShape.isAncestorOf(this) &&\n                !compareShape.isAncestorOf(this.parent);\n            if (((evt && !evt.cancelBubble) || !evt) &&\n                this.parent &&\n                this.parent.isListening() &&\n                !stopBubble) {\n                if (compareShape && compareShape.parent) {\n                    this._fireAndBubble.call(this.parent, eventType, evt, compareShape);\n                }\n                else {\n                    this._fireAndBubble.call(this.parent, eventType, evt);\n                }\n            }\n        }\n    }\n    _getProtoListeners(eventType) {\n        let listeners = this._cache.get(ALL_LISTENERS);\n        if (!listeners) {\n            listeners = {};\n            let obj = Object.getPrototypeOf(this);\n            while (obj) {\n                if (!obj.eventListeners) {\n                    obj = Object.getPrototypeOf(obj);\n                    continue;\n                }\n                for (var event in obj.eventListeners) {\n                    const newEvents = obj.eventListeners[event];\n                    const oldEvents = listeners[event] || [];\n                    listeners[event] = newEvents.concat(oldEvents);\n                }\n                obj = Object.getPrototypeOf(obj);\n            }\n            this._cache.set(ALL_LISTENERS, listeners);\n        }\n        return listeners[eventType];\n    }\n    _fire(eventType, evt) {\n        evt = evt || {};\n        evt.currentTarget = this;\n        evt.type = eventType;\n        const topListeners = this._getProtoListeners(eventType);\n        if (topListeners) {\n            for (var i = 0; i < topListeners.length; i++) {\n                topListeners[i].handler.call(this, evt);\n            }\n        }\n        const selfListeners = this.eventListeners[eventType];\n        if (selfListeners) {\n            for (var i = 0; i < selfListeners.length; i++) {\n                selfListeners[i].handler.call(this, evt);\n            }\n        }\n    }\n    draw() {\n        this.drawScene();\n        this.drawHit();\n        return this;\n    }\n    _createDragElement(evt) {\n        var pointerId = evt ? evt.pointerId : undefined;\n        var stage = this.getStage();\n        var ap = this.getAbsolutePosition();\n        var pos = stage._getPointerById(pointerId) ||\n            stage._changedPointerPositions[0] ||\n            ap;\n        DD._dragElements.set(this._id, {\n            node: this,\n            startPointerPos: pos,\n            offset: {\n                x: pos.x - ap.x,\n                y: pos.y - ap.y,\n            },\n            dragStatus: 'ready',\n            pointerId,\n        });\n    }\n    startDrag(evt, bubbleEvent = true) {\n        if (!DD._dragElements.has(this._id)) {\n            this._createDragElement(evt);\n        }\n        const elem = DD._dragElements.get(this._id);\n        elem.dragStatus = 'dragging';\n        this.fire('dragstart', {\n            type: 'dragstart',\n            target: this,\n            evt: evt && evt.evt,\n        }, bubbleEvent);\n    }\n    _setDragPosition(evt, elem) {\n        const pos = this.getStage()._getPointerById(elem.pointerId);\n        if (!pos) {\n            return;\n        }\n        var newNodePos = {\n            x: pos.x - elem.offset.x,\n            y: pos.y - elem.offset.y,\n        };\n        var dbf = this.dragBoundFunc();\n        if (dbf !== undefined) {\n            const bounded = dbf.call(this, newNodePos, evt);\n            if (!bounded) {\n                Util_Util.warn('dragBoundFunc did not return any value. That is unexpected behavior. You must return new absolute position from dragBoundFunc.');\n            }\n            else {\n                newNodePos = bounded;\n            }\n        }\n        if (!this._lastPos ||\n            this._lastPos.x !== newNodePos.x ||\n            this._lastPos.y !== newNodePos.y) {\n            this.setAbsolutePosition(newNodePos);\n            this._requestDraw();\n        }\n        this._lastPos = newNodePos;\n    }\n    stopDrag(evt) {\n        const elem = DD._dragElements.get(this._id);\n        if (elem) {\n            elem.dragStatus = 'stopped';\n        }\n        DD._endDragBefore(evt);\n        DD._endDragAfter(evt);\n    }\n    setDraggable(draggable) {\n        this._setAttr('draggable', draggable);\n        this._dragChange();\n    }\n    isDragging() {\n        const elem = DD._dragElements.get(this._id);\n        return elem ? elem.dragStatus === 'dragging' : false;\n    }\n    _listenDrag() {\n        this._dragCleanup();\n        this.on('mousedown.konva touchstart.konva', function (evt) {\n            var shouldCheckButton = evt.evt['button'] !== undefined;\n            var canDrag = !shouldCheckButton || Global_Konva.dragButtons.indexOf(evt.evt['button']) >= 0;\n            if (!canDrag) {\n                return;\n            }\n            if (this.isDragging()) {\n                return;\n            }\n            var hasDraggingChild = false;\n            DD._dragElements.forEach((elem) => {\n                if (this.isAncestorOf(elem.node)) {\n                    hasDraggingChild = true;\n                }\n            });\n            if (!hasDraggingChild) {\n                this._createDragElement(evt);\n            }\n        });\n    }\n    _dragChange() {\n        if (this.attrs.draggable) {\n            this._listenDrag();\n        }\n        else {\n            this._dragCleanup();\n            var stage = this.getStage();\n            if (!stage) {\n                return;\n            }\n            const dragElement = DD._dragElements.get(this._id);\n            const isDragging = dragElement && dragElement.dragStatus === 'dragging';\n            const isReady = dragElement && dragElement.dragStatus === 'ready';\n            if (isDragging) {\n                this.stopDrag();\n            }\n            else if (isReady) {\n                DD._dragElements[\"delete\"](this._id);\n            }\n        }\n    }\n    _dragCleanup() {\n        this.off('mousedown.konva');\n        this.off('touchstart.konva');\n    }\n    isClientRectOnScreen(margin = { x: 0, y: 0 }) {\n        const stage = this.getStage();\n        if (!stage) {\n            return false;\n        }\n        const screenRect = {\n            x: -margin.x,\n            y: -margin.y,\n            width: stage.width() + 2 * margin.x,\n            height: stage.height() + 2 * margin.y,\n        };\n        return Util_Util.haveIntersection(screenRect, this.getClientRect());\n    }\n    static create(data, container) {\n        if (Util_Util._isString(data)) {\n            data = JSON.parse(data);\n        }\n        return this._createNode(data, container);\n    }\n    static _createNode(obj, container) {\n        var className = Node.prototype.getClassName.call(obj), children = obj.children, no, len, n;\n        if (container) {\n            obj.attrs.container = container;\n        }\n        if (!Global_Konva[className]) {\n            Util_Util.warn('Can not find a node with class name \"' +\n                className +\n                '\". Fallback to \"Shape\".');\n            className = 'Shape';\n        }\n        const Class = Global_Konva[className];\n        no = new Class(obj.attrs);\n        if (children) {\n            len = children.length;\n            for (n = 0; n < len; n++) {\n                no.add(Node._createNode(children[n]));\n            }\n        }\n        return no;\n    }\n}\nNode.prototype.nodeType = 'Node';\nNode.prototype._attrsAffectingSize = [];\nNode.prototype.eventListeners = {};\nNode.prototype.on.call(Node.prototype, TRANSFORM_CHANGE_STR, function () {\n    if (this._batchingTransformChange) {\n        this._needClearTransformCache = true;\n        return;\n    }\n    this._clearCache(TRANSFORM);\n    this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);\n});\nNode.prototype.on.call(Node.prototype, 'visibleChange.konva', function () {\n    this._clearSelfAndDescendantCache(VISIBLE);\n});\nNode.prototype.on.call(Node.prototype, 'listeningChange.konva', function () {\n    this._clearSelfAndDescendantCache(LISTENING);\n});\nNode.prototype.on.call(Node.prototype, 'opacityChange.konva', function () {\n    this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);\n});\nconst addGetterSetter = Factory.addGetterSetter;\naddGetterSetter(Node, 'zIndex');\naddGetterSetter(Node, 'absolutePosition');\naddGetterSetter(Node, 'position');\naddGetterSetter(Node, 'x', 0, getNumberValidator());\naddGetterSetter(Node, 'y', 0, getNumberValidator());\naddGetterSetter(Node, 'globalCompositeOperation', 'source-over', getStringValidator());\naddGetterSetter(Node, 'opacity', 1, getNumberValidator());\naddGetterSetter(Node, 'name', '', getStringValidator());\naddGetterSetter(Node, 'id', '', getStringValidator());\naddGetterSetter(Node, 'rotation', 0, getNumberValidator());\nFactory.addComponentsGetterSetter(Node, 'scale', ['x', 'y']);\naddGetterSetter(Node, 'scaleX', 1, getNumberValidator());\naddGetterSetter(Node, 'scaleY', 1, getNumberValidator());\nFactory.addComponentsGetterSetter(Node, 'skew', ['x', 'y']);\naddGetterSetter(Node, 'skewX', 0, getNumberValidator());\naddGetterSetter(Node, 'skewY', 0, getNumberValidator());\nFactory.addComponentsGetterSetter(Node, 'offset', ['x', 'y']);\naddGetterSetter(Node, 'offsetX', 0, getNumberValidator());\naddGetterSetter(Node, 'offsetY', 0, getNumberValidator());\naddGetterSetter(Node, 'dragDistance', null, getNumberValidator());\naddGetterSetter(Node, 'width', 0, getNumberValidator());\naddGetterSetter(Node, 'height', 0, getNumberValidator());\naddGetterSetter(Node, 'listening', true, getBooleanValidator());\naddGetterSetter(Node, 'preventDefault', true, getBooleanValidator());\naddGetterSetter(Node, 'filters', null, function (val) {\n    this._filterUpToDate = false;\n    return val;\n});\naddGetterSetter(Node, 'visible', true, getBooleanValidator());\naddGetterSetter(Node, 'transformsEnabled', 'all', getStringValidator());\naddGetterSetter(Node, 'size');\naddGetterSetter(Node, 'dragBoundFunc');\naddGetterSetter(Node, 'draggable', false, getBooleanValidator());\nFactory.backCompat(Node, {\n    rotateDeg: 'rotate',\n    setRotationDeg: 'setRotation',\n    getRotationDeg: 'getRotation',\n});\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/Container.js\n\n\n\nclass Container_Container extends Node {\n    constructor() {\n        super(...arguments);\n        this.children = [];\n    }\n    getChildren(filterFunc) {\n        if (!filterFunc) {\n            return this.children || [];\n        }\n        const children = this.children || [];\n        var results = [];\n        children.forEach(function (child) {\n            if (filterFunc(child)) {\n                results.push(child);\n            }\n        });\n        return results;\n    }\n    hasChildren() {\n        return this.getChildren().length > 0;\n    }\n    removeChildren() {\n        this.getChildren().forEach((child) => {\n            child.parent = null;\n            child.index = 0;\n            child.remove();\n        });\n        this.children = [];\n        this._requestDraw();\n        return this;\n    }\n    destroyChildren() {\n        this.getChildren().forEach((child) => {\n            child.parent = null;\n            child.index = 0;\n            child.destroy();\n        });\n        this.children = [];\n        this._requestDraw();\n        return this;\n    }\n    add(...children) {\n        if (arguments.length > 1) {\n            for (var i = 0; i < arguments.length; i++) {\n                this.add(arguments[i]);\n            }\n            return this;\n        }\n        var child = children[0];\n        if (child.getParent()) {\n            child.moveTo(this);\n            return this;\n        }\n        this._validateAdd(child);\n        child.index = this.getChildren().length;\n        child.parent = this;\n        child._clearCaches();\n        this.getChildren().push(child);\n        this._fire('add', {\n            child: child,\n        });\n        this._requestDraw();\n        return this;\n    }\n    destroy() {\n        if (this.hasChildren()) {\n            this.destroyChildren();\n        }\n        super.destroy();\n        return this;\n    }\n    find(selector) {\n        return this._generalFind(selector, false);\n    }\n    findOne(selector) {\n        var result = this._generalFind(selector, true);\n        return result.length > 0 ? result[0] : undefined;\n    }\n    _generalFind(selector, findOne) {\n        var retArr = [];\n        this._descendants((node) => {\n            const valid = node._isMatch(selector);\n            if (valid) {\n                retArr.push(node);\n            }\n            if (valid && findOne) {\n                return true;\n            }\n            return false;\n        });\n        return retArr;\n    }\n    _descendants(fn) {\n        let shouldStop = false;\n        const children = this.getChildren();\n        for (const child of children) {\n            shouldStop = fn(child);\n            if (shouldStop) {\n                return true;\n            }\n            if (!child.hasChildren()) {\n                continue;\n            }\n            shouldStop = child._descendants(fn);\n            if (shouldStop) {\n                return true;\n            }\n        }\n        return false;\n    }\n    toObject() {\n        var obj = Node.prototype.toObject.call(this);\n        obj.children = [];\n        this.getChildren().forEach((child) => {\n            obj.children.push(child.toObject());\n        });\n        return obj;\n    }\n    isAncestorOf(node) {\n        var parent = node.getParent();\n        while (parent) {\n            if (parent._id === this._id) {\n                return true;\n            }\n            parent = parent.getParent();\n        }\n        return false;\n    }\n    clone(obj) {\n        var node = Node.prototype.clone.call(this, obj);\n        this.getChildren().forEach(function (no) {\n            node.add(no.clone());\n        });\n        return node;\n    }\n    getAllIntersections(pos) {\n        var arr = [];\n        this.find('Shape').forEach(function (shape) {\n            if (shape.isVisible() && shape.intersects(pos)) {\n                arr.push(shape);\n            }\n        });\n        return arr;\n    }\n    _clearSelfAndDescendantCache(attr) {\n        var _a;\n        super._clearSelfAndDescendantCache(attr);\n        if (this.isCached()) {\n            return;\n        }\n        (_a = this.children) === null || _a === void 0 ? void 0 : _a.forEach(function (node) {\n            node._clearSelfAndDescendantCache(attr);\n        });\n    }\n    _setChildrenIndices() {\n        var _a;\n        (_a = this.children) === null || _a === void 0 ? void 0 : _a.forEach(function (child, n) {\n            child.index = n;\n        });\n        this._requestDraw();\n    }\n    drawScene(can, top) {\n        var layer = this.getLayer(), canvas = can || (layer && layer.getCanvas()), context = canvas && canvas.getContext(), cachedCanvas = this._getCanvasCache(), cachedSceneCanvas = cachedCanvas && cachedCanvas.scene;\n        var caching = canvas && canvas.isCache;\n        if (!this.isVisible() && !caching) {\n            return this;\n        }\n        if (cachedSceneCanvas) {\n            context.save();\n            var m = this.getAbsoluteTransform(top).getMatrix();\n            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n            this._drawCachedSceneCanvas(context);\n            context.restore();\n        }\n        else {\n            this._drawChildren('drawScene', canvas, top);\n        }\n        return this;\n    }\n    drawHit(can, top) {\n        if (!this.shouldDrawHit(top)) {\n            return this;\n        }\n        var layer = this.getLayer(), canvas = can || (layer && layer.hitCanvas), context = canvas && canvas.getContext(), cachedCanvas = this._getCanvasCache(), cachedHitCanvas = cachedCanvas && cachedCanvas.hit;\n        if (cachedHitCanvas) {\n            context.save();\n            var m = this.getAbsoluteTransform(top).getMatrix();\n            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n            this._drawCachedHitCanvas(context);\n            context.restore();\n        }\n        else {\n            this._drawChildren('drawHit', canvas, top);\n        }\n        return this;\n    }\n    _drawChildren(drawMethod, canvas, top) {\n        var _a;\n        var context = canvas && canvas.getContext(), clipWidth = this.clipWidth(), clipHeight = this.clipHeight(), clipFunc = this.clipFunc(), hasClip = (clipWidth && clipHeight) || clipFunc;\n        const selfCache = top === this;\n        if (hasClip) {\n            context.save();\n            var transform = this.getAbsoluteTransform(top);\n            var m = transform.getMatrix();\n            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n            context.beginPath();\n            if (clipFunc) {\n                clipFunc.call(this, context, this);\n            }\n            else {\n                var clipX = this.clipX();\n                var clipY = this.clipY();\n                context.rect(clipX, clipY, clipWidth, clipHeight);\n            }\n            context.clip();\n            m = transform.copy().invert().getMatrix();\n            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n        }\n        var hasComposition = !selfCache &&\n            this.globalCompositeOperation() !== 'source-over' &&\n            drawMethod === 'drawScene';\n        if (hasComposition) {\n            context.save();\n            context._applyGlobalCompositeOperation(this);\n        }\n        (_a = this.children) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n            child[drawMethod](canvas, top);\n        });\n        if (hasComposition) {\n            context.restore();\n        }\n        if (hasClip) {\n            context.restore();\n        }\n    }\n    getClientRect(config) {\n        var _a;\n        config = config || {};\n        var skipTransform = config.skipTransform;\n        var relativeTo = config.relativeTo;\n        var minX, minY, maxX, maxY;\n        var selfRect = {\n            x: Infinity,\n            y: Infinity,\n            width: 0,\n            height: 0,\n        };\n        var that = this;\n        (_a = this.children) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n            if (!child.visible()) {\n                return;\n            }\n            var rect = child.getClientRect({\n                relativeTo: that,\n                skipShadow: config.skipShadow,\n                skipStroke: config.skipStroke,\n            });\n            if (rect.width === 0 && rect.height === 0) {\n                return;\n            }\n            if (minX === undefined) {\n                minX = rect.x;\n                minY = rect.y;\n                maxX = rect.x + rect.width;\n                maxY = rect.y + rect.height;\n            }\n            else {\n                minX = Math.min(minX, rect.x);\n                minY = Math.min(minY, rect.y);\n                maxX = Math.max(maxX, rect.x + rect.width);\n                maxY = Math.max(maxY, rect.y + rect.height);\n            }\n        });\n        var shapes = this.find('Shape');\n        var hasVisible = false;\n        for (var i = 0; i < shapes.length; i++) {\n            var shape = shapes[i];\n            if (shape._isVisible(this)) {\n                hasVisible = true;\n                break;\n            }\n        }\n        if (hasVisible && minX !== undefined) {\n            selfRect = {\n                x: minX,\n                y: minY,\n                width: maxX - minX,\n                height: maxY - minY,\n            };\n        }\n        else {\n            selfRect = {\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0,\n            };\n        }\n        if (!skipTransform) {\n            return this._transformedRect(selfRect, relativeTo);\n        }\n        return selfRect;\n    }\n}\nFactory.addComponentsGetterSetter(Container_Container, 'clip', [\n    'x',\n    'y',\n    'width',\n    'height',\n]);\nFactory.addGetterSetter(Container_Container, 'clipX', undefined, getNumberValidator());\nFactory.addGetterSetter(Container_Container, 'clipY', undefined, getNumberValidator());\nFactory.addGetterSetter(Container_Container, 'clipWidth', undefined, getNumberValidator());\nFactory.addGetterSetter(Container_Container, 'clipHeight', undefined, getNumberValidator());\nFactory.addGetterSetter(Container_Container, 'clipFunc');\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/PointerEvents.js\n\nconst Captures = new Map();\nconst SUPPORT_POINTER_EVENTS = Global_Konva._global.PointerEvent !== undefined;\nfunction getCapturedShape(pointerId) {\n    return Captures.get(pointerId);\n}\nfunction createEvent(evt) {\n    return {\n        evt,\n        pointerId: evt.pointerId,\n    };\n}\nfunction hasPointerCapture(pointerId, shape) {\n    return Captures.get(pointerId) === shape;\n}\nfunction setPointerCapture(pointerId, shape) {\n    releaseCapture(pointerId);\n    const stage = shape.getStage();\n    if (!stage)\n        return;\n    Captures.set(pointerId, shape);\n    if (SUPPORT_POINTER_EVENTS) {\n        shape._fire('gotpointercapture', createEvent(new PointerEvent('gotpointercapture')));\n    }\n}\nfunction releaseCapture(pointerId, target) {\n    const shape = Captures.get(pointerId);\n    if (!shape)\n        return;\n    const stage = shape.getStage();\n    if (stage && stage.content) {\n    }\n    Captures.delete(pointerId);\n    if (SUPPORT_POINTER_EVENTS) {\n        shape._fire('lostpointercapture', createEvent(new PointerEvent('lostpointercapture')));\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/Stage.js\n\n\n\n\n\n\n\n\nvar Stage_STAGE = 'Stage', STRING = 'string', PX = 'px', MOUSEOUT = 'mouseout', Stage_MOUSELEAVE = 'mouseleave', MOUSEOVER = 'mouseover', Stage_MOUSEENTER = 'mouseenter', MOUSEMOVE = 'mousemove', MOUSEDOWN = 'mousedown', MOUSEUP = 'mouseup', POINTERMOVE = 'pointermove', POINTERDOWN = 'pointerdown', POINTERUP = 'pointerup', POINTERCANCEL = 'pointercancel', LOSTPOINTERCAPTURE = 'lostpointercapture', POINTEROUT = 'pointerout', POINTERLEAVE = 'pointerleave', POINTEROVER = 'pointerover', POINTERENTER = 'pointerenter', CONTEXTMENU = 'contextmenu', TOUCHSTART = 'touchstart', TOUCHEND = 'touchend', TOUCHMOVE = 'touchmove', TOUCHCANCEL = 'touchcancel', WHEEL = 'wheel', MAX_LAYERS_NUMBER = 5, EVENTS = [\n    [Stage_MOUSEENTER, '_pointerenter'],\n    [MOUSEDOWN, '_pointerdown'],\n    [MOUSEMOVE, '_pointermove'],\n    [MOUSEUP, '_pointerup'],\n    [Stage_MOUSELEAVE, '_pointerleave'],\n    [TOUCHSTART, '_pointerdown'],\n    [TOUCHMOVE, '_pointermove'],\n    [TOUCHEND, '_pointerup'],\n    [TOUCHCANCEL, '_pointercancel'],\n    [MOUSEOVER, '_pointerover'],\n    [WHEEL, '_wheel'],\n    [CONTEXTMENU, '_contextmenu'],\n    [POINTERDOWN, '_pointerdown'],\n    [POINTERMOVE, '_pointermove'],\n    [POINTERUP, '_pointerup'],\n    [POINTERCANCEL, '_pointercancel'],\n    [LOSTPOINTERCAPTURE, '_lostpointercapture'],\n];\nconst EVENTS_MAP = {\n    mouse: {\n        [POINTEROUT]: MOUSEOUT,\n        [POINTERLEAVE]: Stage_MOUSELEAVE,\n        [POINTEROVER]: MOUSEOVER,\n        [POINTERENTER]: Stage_MOUSEENTER,\n        [POINTERMOVE]: MOUSEMOVE,\n        [POINTERDOWN]: MOUSEDOWN,\n        [POINTERUP]: MOUSEUP,\n        [POINTERCANCEL]: 'mousecancel',\n        pointerclick: 'click',\n        pointerdblclick: 'dblclick',\n    },\n    touch: {\n        [POINTEROUT]: 'touchout',\n        [POINTERLEAVE]: 'touchleave',\n        [POINTEROVER]: 'touchover',\n        [POINTERENTER]: 'touchenter',\n        [POINTERMOVE]: TOUCHMOVE,\n        [POINTERDOWN]: TOUCHSTART,\n        [POINTERUP]: TOUCHEND,\n        [POINTERCANCEL]: TOUCHCANCEL,\n        pointerclick: 'tap',\n        pointerdblclick: 'dbltap',\n    },\n    pointer: {\n        [POINTEROUT]: POINTEROUT,\n        [POINTERLEAVE]: POINTERLEAVE,\n        [POINTEROVER]: POINTEROVER,\n        [POINTERENTER]: POINTERENTER,\n        [POINTERMOVE]: POINTERMOVE,\n        [POINTERDOWN]: POINTERDOWN,\n        [POINTERUP]: POINTERUP,\n        [POINTERCANCEL]: POINTERCANCEL,\n        pointerclick: 'pointerclick',\n        pointerdblclick: 'pointerdblclick',\n    },\n};\nconst getEventType = (type) => {\n    if (type.indexOf('pointer') >= 0) {\n        return 'pointer';\n    }\n    if (type.indexOf('touch') >= 0) {\n        return 'touch';\n    }\n    return 'mouse';\n};\nconst getEventsMap = (eventType) => {\n    const type = getEventType(eventType);\n    if (type === 'pointer') {\n        return Global_Konva.pointerEventsEnabled && EVENTS_MAP.pointer;\n    }\n    if (type === 'touch') {\n        return EVENTS_MAP.touch;\n    }\n    if (type === 'mouse') {\n        return EVENTS_MAP.mouse;\n    }\n};\nfunction checkNoClip(attrs = {}) {\n    if (attrs.clipFunc || attrs.clipWidth || attrs.clipHeight) {\n        Util_Util.warn('Stage does not support clipping. Please use clip for Layers or Groups.');\n    }\n    return attrs;\n}\nconst NO_POINTERS_MESSAGE = `Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);`;\nconst stages = [];\nclass Stage extends Container_Container {\n    constructor(config) {\n        super(checkNoClip(config));\n        this._pointerPositions = [];\n        this._changedPointerPositions = [];\n        this._buildDOM();\n        this._bindContentEvents();\n        stages.push(this);\n        this.on('widthChange.konva heightChange.konva', this._resizeDOM);\n        this.on('visibleChange.konva', this._checkVisibility);\n        this.on('clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva', () => {\n            checkNoClip(this.attrs);\n        });\n        this._checkVisibility();\n    }\n    _validateAdd(child) {\n        const isLayer = child.getType() === 'Layer';\n        const isFastLayer = child.getType() === 'FastLayer';\n        const valid = isLayer || isFastLayer;\n        if (!valid) {\n            Util_Util[\"throw\"]('You may only add layers to the stage.');\n        }\n    }\n    _checkVisibility() {\n        if (!this.content) {\n            return;\n        }\n        const style = this.visible() ? '' : 'none';\n        this.content.style.display = style;\n    }\n    setContainer(container) {\n        if (typeof container === STRING) {\n            if (container.charAt(0) === '.') {\n                var className = container.slice(1);\n                container = document.getElementsByClassName(className)[0];\n            }\n            else {\n                var id;\n                if (container.charAt(0) !== '#') {\n                    id = container;\n                }\n                else {\n                    id = container.slice(1);\n                }\n                container = document.getElementById(id);\n            }\n            if (!container) {\n                throw 'Can not find container in document with id ' + id;\n            }\n        }\n        this._setAttr('container', container);\n        if (this.content) {\n            if (this.content.parentElement) {\n                this.content.parentElement.removeChild(this.content);\n            }\n            container.appendChild(this.content);\n        }\n        return this;\n    }\n    shouldDrawHit() {\n        return true;\n    }\n    clear() {\n        var layers = this.children, len = layers.length, n;\n        for (n = 0; n < len; n++) {\n            layers[n].clear();\n        }\n        return this;\n    }\n    clone(obj) {\n        if (!obj) {\n            obj = {};\n        }\n        obj.container =\n            typeof document !== 'undefined' && document.createElement('div');\n        return Container_Container.prototype.clone.call(this, obj);\n    }\n    destroy() {\n        super.destroy();\n        var content = this.content;\n        if (content && Util_Util._isInDocument(content)) {\n            this.container().removeChild(content);\n        }\n        var index = stages.indexOf(this);\n        if (index > -1) {\n            stages.splice(index, 1);\n        }\n        return this;\n    }\n    getPointerPosition() {\n        const pos = this._pointerPositions[0] || this._changedPointerPositions[0];\n        if (!pos) {\n            Util_Util.warn(NO_POINTERS_MESSAGE);\n            return null;\n        }\n        return {\n            x: pos.x,\n            y: pos.y,\n        };\n    }\n    _getPointerById(id) {\n        return this._pointerPositions.find((p) => p.id === id);\n    }\n    getPointersPositions() {\n        return this._pointerPositions;\n    }\n    getStage() {\n        return this;\n    }\n    getContent() {\n        return this.content;\n    }\n    _toKonvaCanvas(config) {\n        config = config || {};\n        config.x = config.x || 0;\n        config.y = config.y || 0;\n        config.width = config.width || this.width();\n        config.height = config.height || this.height();\n        var canvas = new SceneCanvas({\n            width: config.width,\n            height: config.height,\n            pixelRatio: config.pixelRatio || 1,\n        });\n        var _context = canvas.getContext()._context;\n        var layers = this.children;\n        if (config.x || config.y) {\n            _context.translate(-1 * config.x, -1 * config.y);\n        }\n        layers.forEach(function (layer) {\n            if (!layer.isVisible()) {\n                return;\n            }\n            var layerCanvas = layer._toKonvaCanvas(config);\n            _context.drawImage(layerCanvas._canvas, config.x, config.y, layerCanvas.getWidth() / layerCanvas.getPixelRatio(), layerCanvas.getHeight() / layerCanvas.getPixelRatio());\n        });\n        return canvas;\n    }\n    getIntersection(pos) {\n        if (!pos) {\n            return null;\n        }\n        var layers = this.children, len = layers.length, end = len - 1, n;\n        for (n = end; n >= 0; n--) {\n            const shape = layers[n].getIntersection(pos);\n            if (shape) {\n                return shape;\n            }\n        }\n        return null;\n    }\n    _resizeDOM() {\n        var width = this.width();\n        var height = this.height();\n        if (this.content) {\n            this.content.style.width = width + PX;\n            this.content.style.height = height + PX;\n        }\n        this.bufferCanvas.setSize(width, height);\n        this.bufferHitCanvas.setSize(width, height);\n        this.children.forEach((layer) => {\n            layer.setSize({ width, height });\n            layer.draw();\n        });\n    }\n    add(layer, ...rest) {\n        if (arguments.length > 1) {\n            for (var i = 0; i < arguments.length; i++) {\n                this.add(arguments[i]);\n            }\n            return this;\n        }\n        super.add(layer);\n        var length = this.children.length;\n        if (length > MAX_LAYERS_NUMBER) {\n            Util_Util.warn('The stage has ' +\n                length +\n                ' layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group.');\n        }\n        layer.setSize({ width: this.width(), height: this.height() });\n        layer.draw();\n        if (Global_Konva.isBrowser) {\n            this.content.appendChild(layer.canvas._canvas);\n        }\n        return this;\n    }\n    getParent() {\n        return null;\n    }\n    getLayer() {\n        return null;\n    }\n    hasPointerCapture(pointerId) {\n        return hasPointerCapture(pointerId, this);\n    }\n    setPointerCapture(pointerId) {\n        setPointerCapture(pointerId, this);\n    }\n    releaseCapture(pointerId) {\n        releaseCapture(pointerId, this);\n    }\n    getLayers() {\n        return this.children;\n    }\n    _bindContentEvents() {\n        if (!Global_Konva.isBrowser) {\n            return;\n        }\n        EVENTS.forEach(([event, methodName]) => {\n            this.content.addEventListener(event, (evt) => {\n                this[methodName](evt);\n            });\n        });\n    }\n    _pointerenter(evt) {\n        this.setPointersPositions(evt);\n        const events = getEventsMap(evt.type);\n        this._fire(events.pointerenter, {\n            evt: evt,\n            target: this,\n            currentTarget: this,\n        });\n    }\n    _pointerover(evt) {\n        this.setPointersPositions(evt);\n        const events = getEventsMap(evt.type);\n        this._fire(events.pointerover, {\n            evt: evt,\n            target: this,\n            currentTarget: this,\n        });\n    }\n    _getTargetShape(evenType) {\n        let shape = this[evenType + 'targetShape'];\n        if (shape && !shape.getStage()) {\n            shape = null;\n        }\n        return shape;\n    }\n    _pointerleave(evt) {\n        const events = getEventsMap(evt.type);\n        const eventType = getEventType(evt.type);\n        if (!events) {\n            return;\n        }\n        this.setPointersPositions(evt);\n        var targetShape = this._getTargetShape(eventType);\n        var eventsEnabled = !DD.isDragging || Global_Konva.hitOnDragEnabled;\n        if (targetShape && eventsEnabled) {\n            targetShape._fireAndBubble(events.pointerout, { evt: evt });\n            targetShape._fireAndBubble(events.pointerleave, { evt: evt });\n            this._fire(events.pointerleave, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n            });\n            this[eventType + 'targetShape'] = null;\n        }\n        else if (eventsEnabled) {\n            this._fire(events.pointerleave, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n            });\n            this._fire(events.pointerout, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n            });\n        }\n        this.pointerPos = undefined;\n        this._pointerPositions = [];\n    }\n    _pointerdown(evt) {\n        const events = getEventsMap(evt.type);\n        const eventType = getEventType(evt.type);\n        if (!events) {\n            return;\n        }\n        this.setPointersPositions(evt);\n        var triggeredOnShape = false;\n        this._changedPointerPositions.forEach((pos) => {\n            var shape = this.getIntersection(pos);\n            DD.justDragged = false;\n            Global_Konva['_' + eventType + 'ListenClick'] = true;\n            const hasShape = shape && shape.isListening();\n            if (!hasShape) {\n                return;\n            }\n            if (Global_Konva.capturePointerEventsEnabled) {\n                shape.setPointerCapture(pos.id);\n            }\n            this[eventType + 'ClickStartShape'] = shape;\n            shape._fireAndBubble(events.pointerdown, {\n                evt: evt,\n                pointerId: pos.id,\n            });\n            triggeredOnShape = true;\n            const isTouch = evt.type.indexOf('touch') >= 0;\n            if (shape.preventDefault() && evt.cancelable && isTouch) {\n                evt.preventDefault();\n            }\n        });\n        if (!triggeredOnShape) {\n            this._fire(events.pointerdown, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n                pointerId: this._pointerPositions[0].id,\n            });\n        }\n    }\n    _pointermove(evt) {\n        const events = getEventsMap(evt.type);\n        const eventType = getEventType(evt.type);\n        if (!events) {\n            return;\n        }\n        if (DD.isDragging && DD.node.preventDefault() && evt.cancelable) {\n            evt.preventDefault();\n        }\n        this.setPointersPositions(evt);\n        var eventsEnabled = !DD.isDragging || Global_Konva.hitOnDragEnabled;\n        if (!eventsEnabled) {\n            return;\n        }\n        var processedShapesIds = {};\n        let triggeredOnShape = false;\n        var targetShape = this._getTargetShape(eventType);\n        this._changedPointerPositions.forEach((pos) => {\n            const shape = (getCapturedShape(pos.id) ||\n                this.getIntersection(pos));\n            const pointerId = pos.id;\n            const event = { evt: evt, pointerId };\n            var differentTarget = targetShape !== shape;\n            if (differentTarget && targetShape) {\n                targetShape._fireAndBubble(events.pointerout, Object.assign({}, event), shape);\n                targetShape._fireAndBubble(events.pointerleave, Object.assign({}, event), shape);\n            }\n            if (shape) {\n                if (processedShapesIds[shape._id]) {\n                    return;\n                }\n                processedShapesIds[shape._id] = true;\n            }\n            if (shape && shape.isListening()) {\n                triggeredOnShape = true;\n                if (differentTarget) {\n                    shape._fireAndBubble(events.pointerover, Object.assign({}, event), targetShape);\n                    shape._fireAndBubble(events.pointerenter, Object.assign({}, event), targetShape);\n                    this[eventType + 'targetShape'] = shape;\n                }\n                shape._fireAndBubble(events.pointermove, Object.assign({}, event));\n            }\n            else {\n                if (targetShape) {\n                    this._fire(events.pointerover, {\n                        evt: evt,\n                        target: this,\n                        currentTarget: this,\n                        pointerId,\n                    });\n                    this[eventType + 'targetShape'] = null;\n                }\n            }\n        });\n        if (!triggeredOnShape) {\n            this._fire(events.pointermove, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n                pointerId: this._changedPointerPositions[0].id,\n            });\n        }\n    }\n    _pointerup(evt) {\n        const events = getEventsMap(evt.type);\n        const eventType = getEventType(evt.type);\n        if (!events) {\n            return;\n        }\n        this.setPointersPositions(evt);\n        const clickStartShape = this[eventType + 'ClickStartShape'];\n        const clickEndShape = this[eventType + 'ClickEndShape'];\n        var processedShapesIds = {};\n        let triggeredOnShape = false;\n        this._changedPointerPositions.forEach((pos) => {\n            const shape = (getCapturedShape(pos.id) ||\n                this.getIntersection(pos));\n            if (shape) {\n                shape.releaseCapture(pos.id);\n                if (processedShapesIds[shape._id]) {\n                    return;\n                }\n                processedShapesIds[shape._id] = true;\n            }\n            const pointerId = pos.id;\n            const event = { evt: evt, pointerId };\n            let fireDblClick = false;\n            if (Global_Konva['_' + eventType + 'InDblClickWindow']) {\n                fireDblClick = true;\n                clearTimeout(this[eventType + 'DblTimeout']);\n            }\n            else if (!DD.justDragged) {\n                Global_Konva['_' + eventType + 'InDblClickWindow'] = true;\n                clearTimeout(this[eventType + 'DblTimeout']);\n            }\n            this[eventType + 'DblTimeout'] = setTimeout(function () {\n                Global_Konva['_' + eventType + 'InDblClickWindow'] = false;\n            }, Global_Konva.dblClickWindow);\n            if (shape && shape.isListening()) {\n                triggeredOnShape = true;\n                this[eventType + 'ClickEndShape'] = shape;\n                shape._fireAndBubble(events.pointerup, Object.assign({}, event));\n                if (Global_Konva['_' + eventType + 'ListenClick'] &&\n                    clickStartShape &&\n                    clickStartShape === shape) {\n                    shape._fireAndBubble(events.pointerclick, Object.assign({}, event));\n                    if (fireDblClick && clickEndShape && clickEndShape === shape) {\n                        shape._fireAndBubble(events.pointerdblclick, Object.assign({}, event));\n                    }\n                }\n            }\n            else {\n                this[eventType + 'ClickEndShape'] = null;\n                if (Global_Konva['_' + eventType + 'ListenClick']) {\n                    this._fire(events.pointerclick, {\n                        evt: evt,\n                        target: this,\n                        currentTarget: this,\n                        pointerId,\n                    });\n                }\n                if (fireDblClick) {\n                    this._fire(events.pointerdblclick, {\n                        evt: evt,\n                        target: this,\n                        currentTarget: this,\n                        pointerId,\n                    });\n                }\n            }\n        });\n        if (!triggeredOnShape) {\n            this._fire(events.pointerup, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n                pointerId: this._changedPointerPositions[0].id,\n            });\n        }\n        Global_Konva['_' + eventType + 'ListenClick'] = false;\n        if (evt.cancelable) {\n            evt.preventDefault();\n        }\n    }\n    _contextmenu(evt) {\n        this.setPointersPositions(evt);\n        var shape = this.getIntersection(this.getPointerPosition());\n        if (shape && shape.isListening()) {\n            shape._fireAndBubble(CONTEXTMENU, { evt: evt });\n        }\n        else {\n            this._fire(CONTEXTMENU, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n            });\n        }\n    }\n    _wheel(evt) {\n        this.setPointersPositions(evt);\n        var shape = this.getIntersection(this.getPointerPosition());\n        if (shape && shape.isListening()) {\n            shape._fireAndBubble(WHEEL, { evt: evt });\n        }\n        else {\n            this._fire(WHEEL, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n            });\n        }\n    }\n    _pointercancel(evt) {\n        this.setPointersPositions(evt);\n        const shape = getCapturedShape(evt.pointerId) ||\n            this.getIntersection(this.getPointerPosition());\n        if (shape) {\n            shape._fireAndBubble(POINTERUP, createEvent(evt));\n        }\n        releaseCapture(evt.pointerId);\n    }\n    _lostpointercapture(evt) {\n        releaseCapture(evt.pointerId);\n    }\n    setPointersPositions(evt) {\n        var contentPosition = this._getContentPosition(), x = null, y = null;\n        evt = evt ? evt : window.event;\n        if (evt.touches !== undefined) {\n            this._pointerPositions = [];\n            this._changedPointerPositions = [];\n            Array.prototype.forEach.call(evt.touches, (touch) => {\n                this._pointerPositions.push({\n                    id: touch.identifier,\n                    x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,\n                    y: (touch.clientY - contentPosition.top) / contentPosition.scaleY,\n                });\n            });\n            Array.prototype.forEach.call(evt.changedTouches || evt.touches, (touch) => {\n                this._changedPointerPositions.push({\n                    id: touch.identifier,\n                    x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,\n                    y: (touch.clientY - contentPosition.top) / contentPosition.scaleY,\n                });\n            });\n        }\n        else {\n            x = (evt.clientX - contentPosition.left) / contentPosition.scaleX;\n            y = (evt.clientY - contentPosition.top) / contentPosition.scaleY;\n            this.pointerPos = {\n                x: x,\n                y: y,\n            };\n            this._pointerPositions = [{ x, y, id: Util_Util._getFirstPointerId(evt) }];\n            this._changedPointerPositions = [\n                { x, y, id: Util_Util._getFirstPointerId(evt) },\n            ];\n        }\n    }\n    _setPointerPosition(evt) {\n        Util_Util.warn('Method _setPointerPosition is deprecated. Use \"stage.setPointersPositions(event)\" instead.');\n        this.setPointersPositions(evt);\n    }\n    _getContentPosition() {\n        if (!this.content || !this.content.getBoundingClientRect) {\n            return {\n                top: 0,\n                left: 0,\n                scaleX: 1,\n                scaleY: 1,\n            };\n        }\n        var rect = this.content.getBoundingClientRect();\n        return {\n            top: rect.top,\n            left: rect.left,\n            scaleX: rect.width / this.content.clientWidth || 1,\n            scaleY: rect.height / this.content.clientHeight || 1,\n        };\n    }\n    _buildDOM() {\n        this.bufferCanvas = new SceneCanvas({\n            width: this.width(),\n            height: this.height(),\n        });\n        this.bufferHitCanvas = new HitCanvas({\n            pixelRatio: 1,\n            width: this.width(),\n            height: this.height(),\n        });\n        if (!Global_Konva.isBrowser) {\n            return;\n        }\n        var container = this.container();\n        if (!container) {\n            throw 'Stage has no container. A container is required.';\n        }\n        container.innerHTML = '';\n        this.content = document.createElement('div');\n        this.content.style.position = 'relative';\n        this.content.style.userSelect = 'none';\n        this.content.className = 'konvajs-content';\n        this.content.setAttribute('role', 'presentation');\n        container.appendChild(this.content);\n        this._resizeDOM();\n    }\n    cache() {\n        Util_Util.warn('Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.');\n        return this;\n    }\n    clearCache() {\n        return this;\n    }\n    batchDraw() {\n        this.getChildren().forEach(function (layer) {\n            layer.batchDraw();\n        });\n        return this;\n    }\n}\nStage.prototype.nodeType = Stage_STAGE;\n_registerNode(Stage);\nFactory.addGetterSetter(Stage, 'container');\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/Shape.js\n\n\n\n\n\n\n\nvar HAS_SHADOW = 'hasShadow';\nvar SHADOW_RGBA = 'shadowRGBA';\nvar patternImage = 'patternImage';\nvar linearGradient = 'linearGradient';\nvar radialGradient = 'radialGradient';\nlet dummyContext;\nfunction getDummyContext() {\n    if (dummyContext) {\n        return dummyContext;\n    }\n    dummyContext = Util_Util.createCanvasElement().getContext('2d');\n    return dummyContext;\n}\nconst shapes = {};\nfunction _fillFunc(context) {\n    context.fill();\n}\nfunction _strokeFunc(context) {\n    context.stroke();\n}\nfunction _fillFuncHit(context) {\n    context.fill();\n}\nfunction _strokeFuncHit(context) {\n    context.stroke();\n}\nfunction _clearHasShadowCache() {\n    this._clearCache(HAS_SHADOW);\n}\nfunction _clearGetShadowRGBACache() {\n    this._clearCache(SHADOW_RGBA);\n}\nfunction _clearFillPatternCache() {\n    this._clearCache(patternImage);\n}\nfunction _clearLinearGradientCache() {\n    this._clearCache(linearGradient);\n}\nfunction _clearRadialGradientCache() {\n    this._clearCache(radialGradient);\n}\nclass Shape extends Node {\n    constructor(config) {\n        super(config);\n        let key;\n        while (true) {\n            key = Util_Util.getRandomColor();\n            if (key && !(key in shapes)) {\n                break;\n            }\n        }\n        this.colorKey = key;\n        shapes[key] = this;\n    }\n    getContext() {\n        Util_Util.warn('shape.getContext() method is deprecated. Please do not use it.');\n        return this.getLayer().getContext();\n    }\n    getCanvas() {\n        Util_Util.warn('shape.getCanvas() method is deprecated. Please do not use it.');\n        return this.getLayer().getCanvas();\n    }\n    getSceneFunc() {\n        return this.attrs.sceneFunc || this['_sceneFunc'];\n    }\n    getHitFunc() {\n        return this.attrs.hitFunc || this['_hitFunc'];\n    }\n    hasShadow() {\n        return this._getCache(HAS_SHADOW, this._hasShadow);\n    }\n    _hasShadow() {\n        return (this.shadowEnabled() &&\n            this.shadowOpacity() !== 0 &&\n            !!(this.shadowColor() ||\n                this.shadowBlur() ||\n                this.shadowOffsetX() ||\n                this.shadowOffsetY()));\n    }\n    _getFillPattern() {\n        return this._getCache(patternImage, this.__getFillPattern);\n    }\n    __getFillPattern() {\n        if (this.fillPatternImage()) {\n            var ctx = getDummyContext();\n            const pattern = ctx.createPattern(this.fillPatternImage(), this.fillPatternRepeat() || 'repeat');\n            if (pattern && pattern.setTransform) {\n                const tr = new Transform();\n                tr.translate(this.fillPatternX(), this.fillPatternY());\n                tr.rotate(Global_Konva.getAngle(this.fillPatternRotation()));\n                tr.scale(this.fillPatternScaleX(), this.fillPatternScaleY());\n                tr.translate(-1 * this.fillPatternOffsetX(), -1 * this.fillPatternOffsetY());\n                const m = tr.getMatrix();\n                const matrix = typeof DOMMatrix === 'undefined'\n                    ? {\n                        a: m[0],\n                        b: m[1],\n                        c: m[2],\n                        d: m[3],\n                        e: m[4],\n                        f: m[5],\n                    }\n                    : new DOMMatrix(m);\n                pattern.setTransform(matrix);\n            }\n            return pattern;\n        }\n    }\n    _getLinearGradient() {\n        return this._getCache(linearGradient, this.__getLinearGradient);\n    }\n    __getLinearGradient() {\n        var colorStops = this.fillLinearGradientColorStops();\n        if (colorStops) {\n            var ctx = getDummyContext();\n            var start = this.fillLinearGradientStartPoint();\n            var end = this.fillLinearGradientEndPoint();\n            var grd = ctx.createLinearGradient(start.x, start.y, end.x, end.y);\n            for (var n = 0; n < colorStops.length; n += 2) {\n                grd.addColorStop(colorStops[n], colorStops[n + 1]);\n            }\n            return grd;\n        }\n    }\n    _getRadialGradient() {\n        return this._getCache(radialGradient, this.__getRadialGradient);\n    }\n    __getRadialGradient() {\n        var colorStops = this.fillRadialGradientColorStops();\n        if (colorStops) {\n            var ctx = getDummyContext();\n            var start = this.fillRadialGradientStartPoint();\n            var end = this.fillRadialGradientEndPoint();\n            var grd = ctx.createRadialGradient(start.x, start.y, this.fillRadialGradientStartRadius(), end.x, end.y, this.fillRadialGradientEndRadius());\n            for (var n = 0; n < colorStops.length; n += 2) {\n                grd.addColorStop(colorStops[n], colorStops[n + 1]);\n            }\n            return grd;\n        }\n    }\n    getShadowRGBA() {\n        return this._getCache(SHADOW_RGBA, this._getShadowRGBA);\n    }\n    _getShadowRGBA() {\n        if (this.hasShadow()) {\n            var rgba = Util_Util.colorToRGBA(this.shadowColor());\n            return ('rgba(' +\n                rgba.r +\n                ',' +\n                rgba.g +\n                ',' +\n                rgba.b +\n                ',' +\n                rgba.a * (this.shadowOpacity() || 1) +\n                ')');\n        }\n    }\n    hasFill() {\n        return this._calculate('hasFill', [\n            'fillEnabled',\n            'fill',\n            'fillPatternImage',\n            'fillLinearGradientColorStops',\n            'fillRadialGradientColorStops',\n        ], () => {\n            return (this.fillEnabled() &&\n                !!(this.fill() ||\n                    this.fillPatternImage() ||\n                    this.fillLinearGradientColorStops() ||\n                    this.fillRadialGradientColorStops()));\n        });\n    }\n    hasStroke() {\n        return this._calculate('hasStroke', [\n            'strokeEnabled',\n            'strokeWidth',\n            'stroke',\n            'strokeLinearGradientColorStops',\n        ], () => {\n            return (this.strokeEnabled() &&\n                this.strokeWidth() &&\n                !!(this.stroke() || this.strokeLinearGradientColorStops()));\n        });\n    }\n    hasHitStroke() {\n        const width = this.hitStrokeWidth();\n        if (width === 'auto') {\n            return this.hasStroke();\n        }\n        return this.strokeEnabled() && !!width;\n    }\n    intersects(point) {\n        var stage = this.getStage(), bufferHitCanvas = stage.bufferHitCanvas, p;\n        bufferHitCanvas.getContext().clear();\n        this.drawHit(bufferHitCanvas, null, true);\n        p = bufferHitCanvas.context.getImageData(Math.round(point.x), Math.round(point.y), 1, 1).data;\n        return p[3] > 0;\n    }\n    destroy() {\n        Node.prototype.destroy.call(this);\n        delete shapes[this.colorKey];\n        delete this.colorKey;\n        return this;\n    }\n    _useBufferCanvas(forceFill) {\n        var _a;\n        if (!this.getStage()) {\n            return false;\n        }\n        const perfectDrawEnabled = (_a = this.attrs.perfectDrawEnabled) !== null && _a !== void 0 ? _a : true;\n        if (!perfectDrawEnabled) {\n            return false;\n        }\n        const hasFill = forceFill || this.hasFill();\n        const hasStroke = this.hasStroke();\n        const isTransparent = this.getAbsoluteOpacity() !== 1;\n        if (hasFill && hasStroke && isTransparent) {\n            return true;\n        }\n        const hasShadow = this.hasShadow();\n        const strokeForShadow = this.shadowForStrokeEnabled();\n        if (hasFill && hasStroke && hasShadow && strokeForShadow) {\n            return true;\n        }\n        return false;\n    }\n    setStrokeHitEnabled(val) {\n        Util_Util.warn('strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead.');\n        if (val) {\n            this.hitStrokeWidth('auto');\n        }\n        else {\n            this.hitStrokeWidth(0);\n        }\n    }\n    getStrokeHitEnabled() {\n        if (this.hitStrokeWidth() === 0) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n    getSelfRect() {\n        var size = this.size();\n        return {\n            x: this._centroid ? -size.width / 2 : 0,\n            y: this._centroid ? -size.height / 2 : 0,\n            width: size.width,\n            height: size.height,\n        };\n    }\n    getClientRect(config = {}) {\n        const skipTransform = config.skipTransform;\n        const relativeTo = config.relativeTo;\n        const fillRect = this.getSelfRect();\n        const applyStroke = !config.skipStroke && this.hasStroke();\n        const strokeWidth = (applyStroke && this.strokeWidth()) || 0;\n        const fillAndStrokeWidth = fillRect.width + strokeWidth;\n        const fillAndStrokeHeight = fillRect.height + strokeWidth;\n        const applyShadow = !config.skipShadow && this.hasShadow();\n        const shadowOffsetX = applyShadow ? this.shadowOffsetX() : 0;\n        const shadowOffsetY = applyShadow ? this.shadowOffsetY() : 0;\n        const preWidth = fillAndStrokeWidth + Math.abs(shadowOffsetX);\n        const preHeight = fillAndStrokeHeight + Math.abs(shadowOffsetY);\n        const blurRadius = (applyShadow && this.shadowBlur()) || 0;\n        const width = preWidth + blurRadius * 2;\n        const height = preHeight + blurRadius * 2;\n        const rect = {\n            width: width,\n            height: height,\n            x: -(strokeWidth / 2 + blurRadius) +\n                Math.min(shadowOffsetX, 0) +\n                fillRect.x,\n            y: -(strokeWidth / 2 + blurRadius) +\n                Math.min(shadowOffsetY, 0) +\n                fillRect.y,\n        };\n        if (!skipTransform) {\n            return this._transformedRect(rect, relativeTo);\n        }\n        return rect;\n    }\n    drawScene(can, top) {\n        var layer = this.getLayer(), canvas = can || layer.getCanvas(), context = canvas.getContext(), cachedCanvas = this._getCanvasCache(), drawFunc = this.getSceneFunc(), hasShadow = this.hasShadow(), stage, bufferCanvas, bufferContext;\n        var skipBuffer = canvas.isCache;\n        var cachingSelf = top === this;\n        if (!this.isVisible() && !cachingSelf) {\n            return this;\n        }\n        if (cachedCanvas) {\n            context.save();\n            var m = this.getAbsoluteTransform(top).getMatrix();\n            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n            this._drawCachedSceneCanvas(context);\n            context.restore();\n            return this;\n        }\n        if (!drawFunc) {\n            return this;\n        }\n        context.save();\n        if (this._useBufferCanvas() && !skipBuffer) {\n            stage = this.getStage();\n            bufferCanvas = stage.bufferCanvas;\n            bufferContext = bufferCanvas.getContext();\n            bufferContext.clear();\n            bufferContext.save();\n            bufferContext._applyLineJoin(this);\n            var o = this.getAbsoluteTransform(top).getMatrix();\n            bufferContext.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\n            drawFunc.call(this, bufferContext, this);\n            bufferContext.restore();\n            var ratio = bufferCanvas.pixelRatio;\n            if (hasShadow) {\n                context._applyShadow(this);\n            }\n            context._applyOpacity(this);\n            context._applyGlobalCompositeOperation(this);\n            context.drawImage(bufferCanvas._canvas, 0, 0, bufferCanvas.width / ratio, bufferCanvas.height / ratio);\n        }\n        else {\n            context._applyLineJoin(this);\n            if (!cachingSelf) {\n                var o = this.getAbsoluteTransform(top).getMatrix();\n                context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\n                context._applyOpacity(this);\n                context._applyGlobalCompositeOperation(this);\n            }\n            if (hasShadow) {\n                context._applyShadow(this);\n            }\n            drawFunc.call(this, context, this);\n        }\n        context.restore();\n        return this;\n    }\n    drawHit(can, top, skipDragCheck = false) {\n        if (!this.shouldDrawHit(top, skipDragCheck)) {\n            return this;\n        }\n        var layer = this.getLayer(), canvas = can || layer.hitCanvas, context = canvas && canvas.getContext(), drawFunc = this.hitFunc() || this.sceneFunc(), cachedCanvas = this._getCanvasCache(), cachedHitCanvas = cachedCanvas && cachedCanvas.hit;\n        if (!this.colorKey) {\n            Util_Util.warn('Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()');\n        }\n        if (cachedHitCanvas) {\n            context.save();\n            var m = this.getAbsoluteTransform(top).getMatrix();\n            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n            this._drawCachedHitCanvas(context);\n            context.restore();\n            return this;\n        }\n        if (!drawFunc) {\n            return this;\n        }\n        context.save();\n        context._applyLineJoin(this);\n        const selfCache = this === top;\n        if (!selfCache) {\n            var o = this.getAbsoluteTransform(top).getMatrix();\n            context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\n        }\n        drawFunc.call(this, context, this);\n        context.restore();\n        return this;\n    }\n    drawHitFromCache(alphaThreshold = 0) {\n        var cachedCanvas = this._getCanvasCache(), sceneCanvas = this._getCachedSceneCanvas(), hitCanvas = cachedCanvas.hit, hitContext = hitCanvas.getContext(), hitWidth = hitCanvas.getWidth(), hitHeight = hitCanvas.getHeight(), hitImageData, hitData, len, rgbColorKey, i, alpha;\n        hitContext.clear();\n        hitContext.drawImage(sceneCanvas._canvas, 0, 0, hitWidth, hitHeight);\n        try {\n            hitImageData = hitContext.getImageData(0, 0, hitWidth, hitHeight);\n            hitData = hitImageData.data;\n            len = hitData.length;\n            rgbColorKey = Util_Util._hexToRgb(this.colorKey);\n            for (i = 0; i < len; i += 4) {\n                alpha = hitData[i + 3];\n                if (alpha > alphaThreshold) {\n                    hitData[i] = rgbColorKey.r;\n                    hitData[i + 1] = rgbColorKey.g;\n                    hitData[i + 2] = rgbColorKey.b;\n                    hitData[i + 3] = 255;\n                }\n                else {\n                    hitData[i + 3] = 0;\n                }\n            }\n            hitContext.putImageData(hitImageData, 0, 0);\n        }\n        catch (e) {\n            Util_Util.error('Unable to draw hit graph from cached scene canvas. ' + e.message);\n        }\n        return this;\n    }\n    hasPointerCapture(pointerId) {\n        return hasPointerCapture(pointerId, this);\n    }\n    setPointerCapture(pointerId) {\n        setPointerCapture(pointerId, this);\n    }\n    releaseCapture(pointerId) {\n        releaseCapture(pointerId, this);\n    }\n}\nShape.prototype._fillFunc = _fillFunc;\nShape.prototype._strokeFunc = _strokeFunc;\nShape.prototype._fillFuncHit = _fillFuncHit;\nShape.prototype._strokeFuncHit = _strokeFuncHit;\nShape.prototype._centroid = false;\nShape.prototype.nodeType = 'Shape';\n_registerNode(Shape);\nShape.prototype.eventListeners = {};\nShape.prototype.on.call(Shape.prototype, 'shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearHasShadowCache);\nShape.prototype.on.call(Shape.prototype, 'shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearGetShadowRGBACache);\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva', _clearFillPatternCache);\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva', _clearLinearGradientCache);\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva', _clearRadialGradientCache);\nFactory.addGetterSetter(Shape, 'stroke', undefined, getStringOrGradientValidator());\nFactory.addGetterSetter(Shape, 'strokeWidth', 2, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillAfterStrokeEnabled', false);\nFactory.addGetterSetter(Shape, 'hitStrokeWidth', 'auto', getNumberOrAutoValidator());\nFactory.addGetterSetter(Shape, 'strokeHitEnabled', true, getBooleanValidator());\nFactory.addGetterSetter(Shape, 'perfectDrawEnabled', true, getBooleanValidator());\nFactory.addGetterSetter(Shape, 'shadowForStrokeEnabled', true, getBooleanValidator());\nFactory.addGetterSetter(Shape, 'lineJoin');\nFactory.addGetterSetter(Shape, 'lineCap');\nFactory.addGetterSetter(Shape, 'sceneFunc');\nFactory.addGetterSetter(Shape, 'hitFunc');\nFactory.addGetterSetter(Shape, 'dash');\nFactory.addGetterSetter(Shape, 'dashOffset', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'shadowColor', undefined, getStringValidator());\nFactory.addGetterSetter(Shape, 'shadowBlur', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'shadowOpacity', 1, getNumberValidator());\nFactory.addComponentsGetterSetter(Shape, 'shadowOffset', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'shadowOffsetX', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'shadowOffsetY', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillPatternImage');\nFactory.addGetterSetter(Shape, 'fill', undefined, getStringOrGradientValidator());\nFactory.addGetterSetter(Shape, 'fillPatternX', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillPatternY', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillLinearGradientColorStops');\nFactory.addGetterSetter(Shape, 'strokeLinearGradientColorStops');\nFactory.addGetterSetter(Shape, 'fillRadialGradientStartRadius', 0);\nFactory.addGetterSetter(Shape, 'fillRadialGradientEndRadius', 0);\nFactory.addGetterSetter(Shape, 'fillRadialGradientColorStops');\nFactory.addGetterSetter(Shape, 'fillPatternRepeat', 'repeat');\nFactory.addGetterSetter(Shape, 'fillEnabled', true);\nFactory.addGetterSetter(Shape, 'strokeEnabled', true);\nFactory.addGetterSetter(Shape, 'shadowEnabled', true);\nFactory.addGetterSetter(Shape, 'dashEnabled', true);\nFactory.addGetterSetter(Shape, 'strokeScaleEnabled', true);\nFactory.addGetterSetter(Shape, 'fillPriority', 'color');\nFactory.addComponentsGetterSetter(Shape, 'fillPatternOffset', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'fillPatternOffsetX', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillPatternOffsetY', 0, getNumberValidator());\nFactory.addComponentsGetterSetter(Shape, 'fillPatternScale', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'fillPatternScaleX', 1, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillPatternScaleY', 1, getNumberValidator());\nFactory.addComponentsGetterSetter(Shape, 'fillLinearGradientStartPoint', [\n    'x',\n    'y',\n]);\nFactory.addComponentsGetterSetter(Shape, 'strokeLinearGradientStartPoint', [\n    'x',\n    'y',\n]);\nFactory.addGetterSetter(Shape, 'fillLinearGradientStartPointX', 0);\nFactory.addGetterSetter(Shape, 'strokeLinearGradientStartPointX', 0);\nFactory.addGetterSetter(Shape, 'fillLinearGradientStartPointY', 0);\nFactory.addGetterSetter(Shape, 'strokeLinearGradientStartPointY', 0);\nFactory.addComponentsGetterSetter(Shape, 'fillLinearGradientEndPoint', [\n    'x',\n    'y',\n]);\nFactory.addComponentsGetterSetter(Shape, 'strokeLinearGradientEndPoint', [\n    'x',\n    'y',\n]);\nFactory.addGetterSetter(Shape, 'fillLinearGradientEndPointX', 0);\nFactory.addGetterSetter(Shape, 'strokeLinearGradientEndPointX', 0);\nFactory.addGetterSetter(Shape, 'fillLinearGradientEndPointY', 0);\nFactory.addGetterSetter(Shape, 'strokeLinearGradientEndPointY', 0);\nFactory.addComponentsGetterSetter(Shape, 'fillRadialGradientStartPoint', [\n    'x',\n    'y',\n]);\nFactory.addGetterSetter(Shape, 'fillRadialGradientStartPointX', 0);\nFactory.addGetterSetter(Shape, 'fillRadialGradientStartPointY', 0);\nFactory.addComponentsGetterSetter(Shape, 'fillRadialGradientEndPoint', [\n    'x',\n    'y',\n]);\nFactory.addGetterSetter(Shape, 'fillRadialGradientEndPointX', 0);\nFactory.addGetterSetter(Shape, 'fillRadialGradientEndPointY', 0);\nFactory.addGetterSetter(Shape, 'fillPatternRotation', 0);\nFactory.backCompat(Shape, {\n    dashArray: 'dash',\n    getDashArray: 'getDash',\n    setDashArray: 'getDash',\n    drawFunc: 'sceneFunc',\n    getDrawFunc: 'getSceneFunc',\n    setDrawFunc: 'setSceneFunc',\n    drawHitFunc: 'hitFunc',\n    getDrawHitFunc: 'getHitFunc',\n    setDrawHitFunc: 'setHitFunc',\n});\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/Layer.js\n\n\n\n\n\n\n\n\nvar Layer_HASH = '#', BEFORE_DRAW = 'beforeDraw', DRAW = 'draw', INTERSECTION_OFFSETS = [\n    { x: 0, y: 0 },\n    { x: -1, y: -1 },\n    { x: 1, y: -1 },\n    { x: 1, y: 1 },\n    { x: -1, y: 1 },\n], INTERSECTION_OFFSETS_LEN = INTERSECTION_OFFSETS.length;\nclass Layer extends Container_Container {\n    constructor(config) {\n        super(config);\n        this.canvas = new SceneCanvas();\n        this.hitCanvas = new HitCanvas({\n            pixelRatio: 1,\n        });\n        this._waitingForDraw = false;\n        this.on('visibleChange.konva', this._checkVisibility);\n        this._checkVisibility();\n        this.on('imageSmoothingEnabledChange.konva', this._setSmoothEnabled);\n        this._setSmoothEnabled();\n    }\n    createPNGStream() {\n        const c = this.canvas._canvas;\n        return c.createPNGStream();\n    }\n    getCanvas() {\n        return this.canvas;\n    }\n    getNativeCanvasElement() {\n        return this.canvas._canvas;\n    }\n    getHitCanvas() {\n        return this.hitCanvas;\n    }\n    getContext() {\n        return this.getCanvas().getContext();\n    }\n    clear(bounds) {\n        this.getContext().clear(bounds);\n        this.getHitCanvas().getContext().clear(bounds);\n        return this;\n    }\n    setZIndex(index) {\n        super.setZIndex(index);\n        var stage = this.getStage();\n        if (stage && stage.content) {\n            stage.content.removeChild(this.getNativeCanvasElement());\n            if (index < stage.children.length - 1) {\n                stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[index + 1].getCanvas()._canvas);\n            }\n            else {\n                stage.content.appendChild(this.getNativeCanvasElement());\n            }\n        }\n        return this;\n    }\n    moveToTop() {\n        Node.prototype.moveToTop.call(this);\n        var stage = this.getStage();\n        if (stage && stage.content) {\n            stage.content.removeChild(this.getNativeCanvasElement());\n            stage.content.appendChild(this.getNativeCanvasElement());\n        }\n        return true;\n    }\n    moveUp() {\n        var moved = Node.prototype.moveUp.call(this);\n        if (!moved) {\n            return false;\n        }\n        var stage = this.getStage();\n        if (!stage || !stage.content) {\n            return false;\n        }\n        stage.content.removeChild(this.getNativeCanvasElement());\n        if (this.index < stage.children.length - 1) {\n            stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[this.index + 1].getCanvas()._canvas);\n        }\n        else {\n            stage.content.appendChild(this.getNativeCanvasElement());\n        }\n        return true;\n    }\n    moveDown() {\n        if (Node.prototype.moveDown.call(this)) {\n            var stage = this.getStage();\n            if (stage) {\n                var children = stage.children;\n                if (stage.content) {\n                    stage.content.removeChild(this.getNativeCanvasElement());\n                    stage.content.insertBefore(this.getNativeCanvasElement(), children[this.index + 1].getCanvas()._canvas);\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    moveToBottom() {\n        if (Node.prototype.moveToBottom.call(this)) {\n            var stage = this.getStage();\n            if (stage) {\n                var children = stage.children;\n                if (stage.content) {\n                    stage.content.removeChild(this.getNativeCanvasElement());\n                    stage.content.insertBefore(this.getNativeCanvasElement(), children[1].getCanvas()._canvas);\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    getLayer() {\n        return this;\n    }\n    remove() {\n        var _canvas = this.getNativeCanvasElement();\n        Node.prototype.remove.call(this);\n        if (_canvas && _canvas.parentNode && Util_Util._isInDocument(_canvas)) {\n            _canvas.parentNode.removeChild(_canvas);\n        }\n        return this;\n    }\n    getStage() {\n        return this.parent;\n    }\n    setSize({ width, height }) {\n        this.canvas.setSize(width, height);\n        this.hitCanvas.setSize(width, height);\n        this._setSmoothEnabled();\n        return this;\n    }\n    _validateAdd(child) {\n        var type = child.getType();\n        if (type !== 'Group' && type !== 'Shape') {\n            Util_Util[\"throw\"]('You may only add groups and shapes to a layer.');\n        }\n    }\n    _toKonvaCanvas(config) {\n        config = config || {};\n        config.width = config.width || this.getWidth();\n        config.height = config.height || this.getHeight();\n        config.x = config.x !== undefined ? config.x : this.x();\n        config.y = config.y !== undefined ? config.y : this.y();\n        return Node.prototype._toKonvaCanvas.call(this, config);\n    }\n    _checkVisibility() {\n        const visible = this.visible();\n        if (visible) {\n            this.canvas._canvas.style.display = 'block';\n        }\n        else {\n            this.canvas._canvas.style.display = 'none';\n        }\n    }\n    _setSmoothEnabled() {\n        this.getContext()._context.imageSmoothingEnabled =\n            this.imageSmoothingEnabled();\n    }\n    getWidth() {\n        if (this.parent) {\n            return this.parent.width();\n        }\n    }\n    setWidth() {\n        Util_Util.warn('Can not change width of layer. Use \"stage.width(value)\" function instead.');\n    }\n    getHeight() {\n        if (this.parent) {\n            return this.parent.height();\n        }\n    }\n    setHeight() {\n        Util_Util.warn('Can not change height of layer. Use \"stage.height(value)\" function instead.');\n    }\n    batchDraw() {\n        if (!this._waitingForDraw) {\n            this._waitingForDraw = true;\n            Util_Util.requestAnimFrame(() => {\n                this.draw();\n                this._waitingForDraw = false;\n            });\n        }\n        return this;\n    }\n    getIntersection(pos) {\n        if (!this.isListening() || !this.isVisible()) {\n            return null;\n        }\n        var spiralSearchDistance = 1;\n        var continueSearch = false;\n        while (true) {\n            for (let i = 0; i < INTERSECTION_OFFSETS_LEN; i++) {\n                const intersectionOffset = INTERSECTION_OFFSETS[i];\n                const obj = this._getIntersection({\n                    x: pos.x + intersectionOffset.x * spiralSearchDistance,\n                    y: pos.y + intersectionOffset.y * spiralSearchDistance,\n                });\n                const shape = obj.shape;\n                if (shape) {\n                    return shape;\n                }\n                continueSearch = !!obj.antialiased;\n                if (!obj.antialiased) {\n                    break;\n                }\n            }\n            if (continueSearch) {\n                spiralSearchDistance += 1;\n            }\n            else {\n                return null;\n            }\n        }\n    }\n    _getIntersection(pos) {\n        const ratio = this.hitCanvas.pixelRatio;\n        const p = this.hitCanvas.context.getImageData(Math.round(pos.x * ratio), Math.round(pos.y * ratio), 1, 1).data;\n        const p3 = p[3];\n        if (p3 === 255) {\n            const colorKey = Util_Util._rgbToHex(p[0], p[1], p[2]);\n            const shape = shapes[Layer_HASH + colorKey];\n            if (shape) {\n                return {\n                    shape: shape,\n                };\n            }\n            return {\n                antialiased: true,\n            };\n        }\n        else if (p3 > 0) {\n            return {\n                antialiased: true,\n            };\n        }\n        return {};\n    }\n    drawScene(can, top) {\n        var layer = this.getLayer(), canvas = can || (layer && layer.getCanvas());\n        this._fire(BEFORE_DRAW, {\n            node: this,\n        });\n        if (this.clearBeforeDraw()) {\n            canvas.getContext().clear();\n        }\n        Container_Container.prototype.drawScene.call(this, canvas, top);\n        this._fire(DRAW, {\n            node: this,\n        });\n        return this;\n    }\n    drawHit(can, top) {\n        var layer = this.getLayer(), canvas = can || (layer && layer.hitCanvas);\n        if (layer && layer.clearBeforeDraw()) {\n            layer.getHitCanvas().getContext().clear();\n        }\n        Container_Container.prototype.drawHit.call(this, canvas, top);\n        return this;\n    }\n    enableHitGraph() {\n        this.hitGraphEnabled(true);\n        return this;\n    }\n    disableHitGraph() {\n        this.hitGraphEnabled(false);\n        return this;\n    }\n    setHitGraphEnabled(val) {\n        Util_Util.warn('hitGraphEnabled method is deprecated. Please use layer.listening() instead.');\n        this.listening(val);\n    }\n    getHitGraphEnabled(val) {\n        Util_Util.warn('hitGraphEnabled method is deprecated. Please use layer.listening() instead.');\n        return this.listening();\n    }\n    toggleHitCanvas() {\n        if (!this.parent || !this.parent['content']) {\n            return;\n        }\n        var parent = this.parent;\n        var added = !!this.hitCanvas._canvas.parentNode;\n        if (added) {\n            parent.content.removeChild(this.hitCanvas._canvas);\n        }\n        else {\n            parent.content.appendChild(this.hitCanvas._canvas);\n        }\n    }\n}\nLayer.prototype.nodeType = 'Layer';\n_registerNode(Layer);\nFactory.addGetterSetter(Layer, 'imageSmoothingEnabled', true);\nFactory.addGetterSetter(Layer, 'clearBeforeDraw', true);\nFactory.addGetterSetter(Layer, 'hitGraphEnabled', true, getBooleanValidator());\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/FastLayer.js\n\n\n\nclass FastLayer extends Layer {\n    constructor(attrs) {\n        super(attrs);\n        this.listening(false);\n        Util_Util.warn('Konva.Fast layer is deprecated. Please use \"new Konva.Layer({ listening: false })\" instead.');\n    }\n}\nFastLayer.prototype.nodeType = 'FastLayer';\n_registerNode(FastLayer);\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/Group.js\n\n\n\nclass Group extends Container_Container {\n    _validateAdd(child) {\n        var type = child.getType();\n        if (type !== 'Group' && type !== 'Shape') {\n            Util_Util[\"throw\"]('You may only add groups and shapes to groups.');\n        }\n    }\n}\nGroup.prototype.nodeType = 'Group';\n_registerNode(Group);\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/Animation.js\n\n\nvar now = (function () {\n    if (glob.performance && glob.performance.now) {\n        return function () {\n            return glob.performance.now();\n        };\n    }\n    return function () {\n        return new Date().getTime();\n    };\n})();\nclass Animation {\n    constructor(func, layers) {\n        this.id = Animation.animIdCounter++;\n        this.frame = {\n            time: 0,\n            timeDiff: 0,\n            lastTime: now(),\n            frameRate: 0,\n        };\n        this.func = func;\n        this.setLayers(layers);\n    }\n    setLayers(layers) {\n        var lays = [];\n        if (!layers) {\n            lays = [];\n        }\n        else if (layers.length > 0) {\n            lays = layers;\n        }\n        else {\n            lays = [layers];\n        }\n        this.layers = lays;\n        return this;\n    }\n    getLayers() {\n        return this.layers;\n    }\n    addLayer(layer) {\n        var layers = this.layers, len = layers.length, n;\n        for (n = 0; n < len; n++) {\n            if (layers[n]._id === layer._id) {\n                return false;\n            }\n        }\n        this.layers.push(layer);\n        return true;\n    }\n    isRunning() {\n        var a = Animation, animations = a.animations, len = animations.length, n;\n        for (n = 0; n < len; n++) {\n            if (animations[n].id === this.id) {\n                return true;\n            }\n        }\n        return false;\n    }\n    start() {\n        this.stop();\n        this.frame.timeDiff = 0;\n        this.frame.lastTime = now();\n        Animation._addAnimation(this);\n        return this;\n    }\n    stop() {\n        Animation._removeAnimation(this);\n        return this;\n    }\n    _updateFrameObject(time) {\n        this.frame.timeDiff = time - this.frame.lastTime;\n        this.frame.lastTime = time;\n        this.frame.time += this.frame.timeDiff;\n        this.frame.frameRate = 1000 / this.frame.timeDiff;\n    }\n    static _addAnimation(anim) {\n        this.animations.push(anim);\n        this._handleAnimation();\n    }\n    static _removeAnimation(anim) {\n        var id = anim.id, animations = this.animations, len = animations.length, n;\n        for (n = 0; n < len; n++) {\n            if (animations[n].id === id) {\n                this.animations.splice(n, 1);\n                break;\n            }\n        }\n    }\n    static _runFrames() {\n        var layerHash = {}, animations = this.animations, anim, layers, func, n, i, layersLen, layer, key, needRedraw;\n        for (n = 0; n < animations.length; n++) {\n            anim = animations[n];\n            layers = anim.layers;\n            func = anim.func;\n            anim._updateFrameObject(now());\n            layersLen = layers.length;\n            if (func) {\n                needRedraw = func.call(anim, anim.frame) !== false;\n            }\n            else {\n                needRedraw = true;\n            }\n            if (!needRedraw) {\n                continue;\n            }\n            for (i = 0; i < layersLen; i++) {\n                layer = layers[i];\n                if (layer._id !== undefined) {\n                    layerHash[layer._id] = layer;\n                }\n            }\n        }\n        for (key in layerHash) {\n            if (!layerHash.hasOwnProperty(key)) {\n                continue;\n            }\n            layerHash[key].batchDraw();\n        }\n    }\n    static _animationLoop() {\n        var Anim = Animation;\n        if (Anim.animations.length) {\n            Anim._runFrames();\n            Util_Util.requestAnimFrame(Anim._animationLoop);\n        }\n        else {\n            Anim.animRunning = false;\n        }\n    }\n    static _handleAnimation() {\n        if (!this.animRunning) {\n            this.animRunning = true;\n            Util_Util.requestAnimFrame(this._animationLoop);\n        }\n    }\n}\nAnimation.animations = [];\nAnimation.animIdCounter = 0;\nAnimation.animRunning = false;\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/Tween.js\n\n\n\n\nvar blacklist = {\n    node: 1,\n    duration: 1,\n    easing: 1,\n    onFinish: 1,\n    yoyo: 1,\n}, PAUSED = 1, PLAYING = 2, REVERSING = 3, Tween_idCounter = 0, colorAttrs = ['fill', 'stroke', 'shadowColor'];\nclass TweenEngine {\n    constructor(prop, propFunc, func, begin, finish, duration, yoyo) {\n        this.prop = prop;\n        this.propFunc = propFunc;\n        this.begin = begin;\n        this._pos = begin;\n        this.duration = duration;\n        this._change = 0;\n        this.prevPos = 0;\n        this.yoyo = yoyo;\n        this._time = 0;\n        this._position = 0;\n        this._startTime = 0;\n        this._finish = 0;\n        this.func = func;\n        this._change = finish - this.begin;\n        this.pause();\n    }\n    fire(str) {\n        var handler = this[str];\n        if (handler) {\n            handler();\n        }\n    }\n    setTime(t) {\n        if (t > this.duration) {\n            if (this.yoyo) {\n                this._time = this.duration;\n                this.reverse();\n            }\n            else {\n                this.finish();\n            }\n        }\n        else if (t < 0) {\n            if (this.yoyo) {\n                this._time = 0;\n                this.play();\n            }\n            else {\n                this.reset();\n            }\n        }\n        else {\n            this._time = t;\n            this.update();\n        }\n    }\n    getTime() {\n        return this._time;\n    }\n    setPosition(p) {\n        this.prevPos = this._pos;\n        this.propFunc(p);\n        this._pos = p;\n    }\n    getPosition(t) {\n        if (t === undefined) {\n            t = this._time;\n        }\n        return this.func(t, this.begin, this._change, this.duration);\n    }\n    play() {\n        this.state = PLAYING;\n        this._startTime = this.getTimer() - this._time;\n        this.onEnterFrame();\n        this.fire('onPlay');\n    }\n    reverse() {\n        this.state = REVERSING;\n        this._time = this.duration - this._time;\n        this._startTime = this.getTimer() - this._time;\n        this.onEnterFrame();\n        this.fire('onReverse');\n    }\n    seek(t) {\n        this.pause();\n        this._time = t;\n        this.update();\n        this.fire('onSeek');\n    }\n    reset() {\n        this.pause();\n        this._time = 0;\n        this.update();\n        this.fire('onReset');\n    }\n    finish() {\n        this.pause();\n        this._time = this.duration;\n        this.update();\n        this.fire('onFinish');\n    }\n    update() {\n        this.setPosition(this.getPosition(this._time));\n        this.fire('onUpdate');\n    }\n    onEnterFrame() {\n        var t = this.getTimer() - this._startTime;\n        if (this.state === PLAYING) {\n            this.setTime(t);\n        }\n        else if (this.state === REVERSING) {\n            this.setTime(this.duration - t);\n        }\n    }\n    pause() {\n        this.state = PAUSED;\n        this.fire('onPause');\n    }\n    getTimer() {\n        return new Date().getTime();\n    }\n}\nclass Tween {\n    constructor(config) {\n        var that = this, node = config.node, nodeId = node._id, duration, easing = config.easing || Easings.Linear, yoyo = !!config.yoyo, key;\n        if (typeof config.duration === 'undefined') {\n            duration = 0.3;\n        }\n        else if (config.duration === 0) {\n            duration = 0.001;\n        }\n        else {\n            duration = config.duration;\n        }\n        this.node = node;\n        this._id = Tween_idCounter++;\n        var layers = node.getLayer() ||\n            (node instanceof Global_Konva.Stage ? node.getLayers() : null);\n        if (!layers) {\n            Util_Util.error('Tween constructor have `node` that is not in a layer. Please add node into layer first.');\n        }\n        this.anim = new Animation(function () {\n            that.tween.onEnterFrame();\n        }, layers);\n        this.tween = new TweenEngine(key, function (i) {\n            that._tweenFunc(i);\n        }, easing, 0, 1, duration * 1000, yoyo);\n        this._addListeners();\n        if (!Tween.attrs[nodeId]) {\n            Tween.attrs[nodeId] = {};\n        }\n        if (!Tween.attrs[nodeId][this._id]) {\n            Tween.attrs[nodeId][this._id] = {};\n        }\n        if (!Tween.tweens[nodeId]) {\n            Tween.tweens[nodeId] = {};\n        }\n        for (key in config) {\n            if (blacklist[key] === undefined) {\n                this._addAttr(key, config[key]);\n            }\n        }\n        this.reset();\n        this.onFinish = config.onFinish;\n        this.onReset = config.onReset;\n        this.onUpdate = config.onUpdate;\n    }\n    _addAttr(key, end) {\n        var node = this.node, nodeId = node._id, start, diff, tweenId, n, len, trueEnd, trueStart, endRGBA;\n        tweenId = Tween.tweens[nodeId][key];\n        if (tweenId) {\n            delete Tween.attrs[nodeId][tweenId][key];\n        }\n        start = node.getAttr(key);\n        if (Util_Util._isArray(end)) {\n            diff = [];\n            len = Math.max(end.length, start.length);\n            if (key === 'points' && end.length !== start.length) {\n                if (end.length > start.length) {\n                    trueStart = start;\n                    start = Util_Util._prepareArrayForTween(start, end, node.closed());\n                }\n                else {\n                    trueEnd = end;\n                    end = Util_Util._prepareArrayForTween(end, start, node.closed());\n                }\n            }\n            if (key.indexOf('fill') === 0) {\n                for (n = 0; n < len; n++) {\n                    if (n % 2 === 0) {\n                        diff.push(end[n] - start[n]);\n                    }\n                    else {\n                        var startRGBA = Util_Util.colorToRGBA(start[n]);\n                        endRGBA = Util_Util.colorToRGBA(end[n]);\n                        start[n] = startRGBA;\n                        diff.push({\n                            r: endRGBA.r - startRGBA.r,\n                            g: endRGBA.g - startRGBA.g,\n                            b: endRGBA.b - startRGBA.b,\n                            a: endRGBA.a - startRGBA.a,\n                        });\n                    }\n                }\n            }\n            else {\n                for (n = 0; n < len; n++) {\n                    diff.push(end[n] - start[n]);\n                }\n            }\n        }\n        else if (colorAttrs.indexOf(key) !== -1) {\n            start = Util_Util.colorToRGBA(start);\n            endRGBA = Util_Util.colorToRGBA(end);\n            diff = {\n                r: endRGBA.r - start.r,\n                g: endRGBA.g - start.g,\n                b: endRGBA.b - start.b,\n                a: endRGBA.a - start.a,\n            };\n        }\n        else {\n            diff = end - start;\n        }\n        Tween.attrs[nodeId][this._id][key] = {\n            start: start,\n            diff: diff,\n            end: end,\n            trueEnd: trueEnd,\n            trueStart: trueStart,\n        };\n        Tween.tweens[nodeId][key] = this._id;\n    }\n    _tweenFunc(i) {\n        var node = this.node, attrs = Tween.attrs[node._id][this._id], key, attr, start, diff, newVal, n, len, end;\n        for (key in attrs) {\n            attr = attrs[key];\n            start = attr.start;\n            diff = attr.diff;\n            end = attr.end;\n            if (Util_Util._isArray(start)) {\n                newVal = [];\n                len = Math.max(start.length, end.length);\n                if (key.indexOf('fill') === 0) {\n                    for (n = 0; n < len; n++) {\n                        if (n % 2 === 0) {\n                            newVal.push((start[n] || 0) + diff[n] * i);\n                        }\n                        else {\n                            newVal.push('rgba(' +\n                                Math.round(start[n].r + diff[n].r * i) +\n                                ',' +\n                                Math.round(start[n].g + diff[n].g * i) +\n                                ',' +\n                                Math.round(start[n].b + diff[n].b * i) +\n                                ',' +\n                                (start[n].a + diff[n].a * i) +\n                                ')');\n                        }\n                    }\n                }\n                else {\n                    for (n = 0; n < len; n++) {\n                        newVal.push((start[n] || 0) + diff[n] * i);\n                    }\n                }\n            }\n            else if (colorAttrs.indexOf(key) !== -1) {\n                newVal =\n                    'rgba(' +\n                        Math.round(start.r + diff.r * i) +\n                        ',' +\n                        Math.round(start.g + diff.g * i) +\n                        ',' +\n                        Math.round(start.b + diff.b * i) +\n                        ',' +\n                        (start.a + diff.a * i) +\n                        ')';\n            }\n            else {\n                newVal = start + diff * i;\n            }\n            node.setAttr(key, newVal);\n        }\n    }\n    _addListeners() {\n        this.tween.onPlay = () => {\n            this.anim.start();\n        };\n        this.tween.onReverse = () => {\n            this.anim.start();\n        };\n        this.tween.onPause = () => {\n            this.anim.stop();\n        };\n        this.tween.onFinish = () => {\n            var node = this.node;\n            var attrs = Tween.attrs[node._id][this._id];\n            if (attrs.points && attrs.points.trueEnd) {\n                node.setAttr('points', attrs.points.trueEnd);\n            }\n            if (this.onFinish) {\n                this.onFinish.call(this);\n            }\n        };\n        this.tween.onReset = () => {\n            var node = this.node;\n            var attrs = Tween.attrs[node._id][this._id];\n            if (attrs.points && attrs.points.trueStart) {\n                node.points(attrs.points.trueStart);\n            }\n            if (this.onReset) {\n                this.onReset();\n            }\n        };\n        this.tween.onUpdate = () => {\n            if (this.onUpdate) {\n                this.onUpdate.call(this);\n            }\n        };\n    }\n    play() {\n        this.tween.play();\n        return this;\n    }\n    reverse() {\n        this.tween.reverse();\n        return this;\n    }\n    reset() {\n        this.tween.reset();\n        return this;\n    }\n    seek(t) {\n        this.tween.seek(t * 1000);\n        return this;\n    }\n    pause() {\n        this.tween.pause();\n        return this;\n    }\n    finish() {\n        this.tween.finish();\n        return this;\n    }\n    destroy() {\n        var nodeId = this.node._id, thisId = this._id, attrs = Tween.tweens[nodeId], key;\n        this.pause();\n        for (key in attrs) {\n            delete Tween.tweens[nodeId][key];\n        }\n        delete Tween.attrs[nodeId][thisId];\n    }\n}\nTween.attrs = {};\nTween.tweens = {};\nNode.prototype.to = function (params) {\n    var onFinish = params.onFinish;\n    params.node = this;\n    params.onFinish = function () {\n        this.destroy();\n        if (onFinish) {\n            onFinish();\n        }\n    };\n    var tween = new Tween(params);\n    tween.play();\n};\nconst Easings = {\n    BackEaseIn(t, b, c, d) {\n        var s = 1.70158;\n        return c * (t /= d) * t * ((s + 1) * t - s) + b;\n    },\n    BackEaseOut(t, b, c, d) {\n        var s = 1.70158;\n        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;\n    },\n    BackEaseInOut(t, b, c, d) {\n        var s = 1.70158;\n        if ((t /= d / 2) < 1) {\n            return (c / 2) * (t * t * (((s *= 1.525) + 1) * t - s)) + b;\n        }\n        return (c / 2) * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;\n    },\n    ElasticEaseIn(t, b, c, d, a, p) {\n        var s = 0;\n        if (t === 0) {\n            return b;\n        }\n        if ((t /= d) === 1) {\n            return b + c;\n        }\n        if (!p) {\n            p = d * 0.3;\n        }\n        if (!a || a < Math.abs(c)) {\n            a = c;\n            s = p / 4;\n        }\n        else {\n            s = (p / (2 * Math.PI)) * Math.asin(c / a);\n        }\n        return (-(a *\n            Math.pow(2, 10 * (t -= 1)) *\n            Math.sin(((t * d - s) * (2 * Math.PI)) / p)) + b);\n    },\n    ElasticEaseOut(t, b, c, d, a, p) {\n        var s = 0;\n        if (t === 0) {\n            return b;\n        }\n        if ((t /= d) === 1) {\n            return b + c;\n        }\n        if (!p) {\n            p = d * 0.3;\n        }\n        if (!a || a < Math.abs(c)) {\n            a = c;\n            s = p / 4;\n        }\n        else {\n            s = (p / (2 * Math.PI)) * Math.asin(c / a);\n        }\n        return (a * Math.pow(2, -10 * t) * Math.sin(((t * d - s) * (2 * Math.PI)) / p) +\n            c +\n            b);\n    },\n    ElasticEaseInOut(t, b, c, d, a, p) {\n        var s = 0;\n        if (t === 0) {\n            return b;\n        }\n        if ((t /= d / 2) === 2) {\n            return b + c;\n        }\n        if (!p) {\n            p = d * (0.3 * 1.5);\n        }\n        if (!a || a < Math.abs(c)) {\n            a = c;\n            s = p / 4;\n        }\n        else {\n            s = (p / (2 * Math.PI)) * Math.asin(c / a);\n        }\n        if (t < 1) {\n            return (-0.5 *\n                (a *\n                    Math.pow(2, 10 * (t -= 1)) *\n                    Math.sin(((t * d - s) * (2 * Math.PI)) / p)) +\n                b);\n        }\n        return (a *\n            Math.pow(2, -10 * (t -= 1)) *\n            Math.sin(((t * d - s) * (2 * Math.PI)) / p) *\n            0.5 +\n            c +\n            b);\n    },\n    BounceEaseOut(t, b, c, d) {\n        if ((t /= d) < 1 / 2.75) {\n            return c * (7.5625 * t * t) + b;\n        }\n        else if (t < 2 / 2.75) {\n            return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;\n        }\n        else if (t < 2.5 / 2.75) {\n            return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;\n        }\n        else {\n            return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;\n        }\n    },\n    BounceEaseIn(t, b, c, d) {\n        return c - Easings.BounceEaseOut(d - t, 0, c, d) + b;\n    },\n    BounceEaseInOut(t, b, c, d) {\n        if (t < d / 2) {\n            return Easings.BounceEaseIn(t * 2, 0, c, d) * 0.5 + b;\n        }\n        else {\n            return Easings.BounceEaseOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;\n        }\n    },\n    EaseIn(t, b, c, d) {\n        return c * (t /= d) * t + b;\n    },\n    EaseOut(t, b, c, d) {\n        return -c * (t /= d) * (t - 2) + b;\n    },\n    EaseInOut(t, b, c, d) {\n        if ((t /= d / 2) < 1) {\n            return (c / 2) * t * t + b;\n        }\n        return (-c / 2) * (--t * (t - 2) - 1) + b;\n    },\n    StrongEaseIn(t, b, c, d) {\n        return c * (t /= d) * t * t * t * t + b;\n    },\n    StrongEaseOut(t, b, c, d) {\n        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;\n    },\n    StrongEaseInOut(t, b, c, d) {\n        if ((t /= d / 2) < 1) {\n            return (c / 2) * t * t * t * t * t + b;\n        }\n        return (c / 2) * ((t -= 2) * t * t * t * t + 2) + b;\n    },\n    Linear(t, b, c, d) {\n        return (c * t) / d + b;\n    },\n};\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/_CoreInternals.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst _CoreInternals_Konva = Util_Util._assign(Global_Konva, {\n    Util: Util_Util,\n    Transform: Transform,\n    Node: Node,\n    Container: Container_Container,\n    Stage: Stage,\n    stages: stages,\n    Layer: Layer,\n    FastLayer: FastLayer,\n    Group: Group,\n    DD: DD,\n    Shape: Shape,\n    shapes: shapes,\n    Animation: Animation,\n    Tween: Tween,\n    Easings: Easings,\n    Context: Context_Context,\n    Canvas: Canvas,\n});\n/* harmony default export */ const _CoreInternals = ((/* unused pure expression or super */ null && (_CoreInternals_Konva)));\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/shapes/Arc.js\n\n\n\n\n\nclass Arc extends Shape {\n    _sceneFunc(context) {\n        var angle = Global_Konva.getAngle(this.angle()), clockwise = this.clockwise();\n        context.beginPath();\n        context.arc(0, 0, this.outerRadius(), 0, angle, clockwise);\n        context.arc(0, 0, this.innerRadius(), angle, 0, !clockwise);\n        context.closePath();\n        context.fillStrokeShape(this);\n    }\n    getWidth() {\n        return this.outerRadius() * 2;\n    }\n    getHeight() {\n        return this.outerRadius() * 2;\n    }\n    setWidth(width) {\n        this.outerRadius(width / 2);\n    }\n    setHeight(height) {\n        this.outerRadius(height / 2);\n    }\n    getSelfRect() {\n        const innerRadius = this.innerRadius();\n        const outerRadius = this.outerRadius();\n        const clockwise = this.clockwise();\n        const angle = Global_Konva.getAngle(clockwise ? 360 - this.angle() : this.angle());\n        const boundLeftRatio = Math.cos(Math.min(angle, Math.PI));\n        const boundRightRatio = 1;\n        const boundTopRatio = Math.sin(Math.min(Math.max(Math.PI, angle), (3 * Math.PI) / 2));\n        const boundBottomRatio = Math.sin(Math.min(angle, Math.PI / 2));\n        const boundLeft = boundLeftRatio * (boundLeftRatio > 0 ? innerRadius : outerRadius);\n        const boundRight = boundRightRatio * (boundRightRatio > 0 ? outerRadius : innerRadius);\n        const boundTop = boundTopRatio * (boundTopRatio > 0 ? innerRadius : outerRadius);\n        const boundBottom = boundBottomRatio * (boundBottomRatio > 0 ? outerRadius : innerRadius);\n        return {\n            x: boundLeft,\n            y: clockwise ? -1 * boundBottom : boundTop,\n            width: boundRight - boundLeft,\n            height: boundBottom - boundTop,\n        };\n    }\n}\nArc.prototype._centroid = true;\nArc.prototype.className = 'Arc';\nArc.prototype._attrsAffectingSize = ['innerRadius', 'outerRadius'];\n_registerNode(Arc);\nFactory.addGetterSetter(Arc, 'innerRadius', 0, getNumberValidator());\nFactory.addGetterSetter(Arc, 'outerRadius', 0, getNumberValidator());\nFactory.addGetterSetter(Arc, 'angle', 0, getNumberValidator());\nFactory.addGetterSetter(Arc, 'clockwise', false, getBooleanValidator());\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/shapes/Line.js\n\n\n\n\nfunction getControlPoints(x0, y0, x1, y1, x2, y2, t) {\n    var d01 = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2)), d12 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)), fa = (t * d01) / (d01 + d12), fb = (t * d12) / (d01 + d12), p1x = x1 - fa * (x2 - x0), p1y = y1 - fa * (y2 - y0), p2x = x1 + fb * (x2 - x0), p2y = y1 + fb * (y2 - y0);\n    return [p1x, p1y, p2x, p2y];\n}\nfunction expandPoints(p, tension) {\n    var len = p.length, allPoints = [], n, cp;\n    for (n = 2; n < len - 2; n += 2) {\n        cp = getControlPoints(p[n - 2], p[n - 1], p[n], p[n + 1], p[n + 2], p[n + 3], tension);\n        if (isNaN(cp[0])) {\n            continue;\n        }\n        allPoints.push(cp[0]);\n        allPoints.push(cp[1]);\n        allPoints.push(p[n]);\n        allPoints.push(p[n + 1]);\n        allPoints.push(cp[2]);\n        allPoints.push(cp[3]);\n    }\n    return allPoints;\n}\nclass Line extends Shape {\n    constructor(config) {\n        super(config);\n        this.on('pointsChange.konva tensionChange.konva closedChange.konva bezierChange.konva', function () {\n            this._clearCache('tensionPoints');\n        });\n    }\n    _sceneFunc(context) {\n        var points = this.points(), length = points.length, tension = this.tension(), closed = this.closed(), bezier = this.bezier(), tp, len, n;\n        if (!length) {\n            return;\n        }\n        context.beginPath();\n        context.moveTo(points[0], points[1]);\n        if (tension !== 0 && length > 4) {\n            tp = this.getTensionPoints();\n            len = tp.length;\n            n = closed ? 0 : 4;\n            if (!closed) {\n                context.quadraticCurveTo(tp[0], tp[1], tp[2], tp[3]);\n            }\n            while (n < len - 2) {\n                context.bezierCurveTo(tp[n++], tp[n++], tp[n++], tp[n++], tp[n++], tp[n++]);\n            }\n            if (!closed) {\n                context.quadraticCurveTo(tp[len - 2], tp[len - 1], points[length - 2], points[length - 1]);\n            }\n        }\n        else if (bezier) {\n            n = 2;\n            while (n < length) {\n                context.bezierCurveTo(points[n++], points[n++], points[n++], points[n++], points[n++], points[n++]);\n            }\n        }\n        else {\n            for (n = 2; n < length; n += 2) {\n                context.lineTo(points[n], points[n + 1]);\n            }\n        }\n        if (closed) {\n            context.closePath();\n            context.fillStrokeShape(this);\n        }\n        else {\n            context.strokeShape(this);\n        }\n    }\n    getTensionPoints() {\n        return this._getCache('tensionPoints', this._getTensionPoints);\n    }\n    _getTensionPoints() {\n        if (this.closed()) {\n            return this._getTensionPointsClosed();\n        }\n        else {\n            return expandPoints(this.points(), this.tension());\n        }\n    }\n    _getTensionPointsClosed() {\n        var p = this.points(), len = p.length, tension = this.tension(), firstControlPoints = getControlPoints(p[len - 2], p[len - 1], p[0], p[1], p[2], p[3], tension), lastControlPoints = getControlPoints(p[len - 4], p[len - 3], p[len - 2], p[len - 1], p[0], p[1], tension), middle = expandPoints(p, tension), tp = [firstControlPoints[2], firstControlPoints[3]]\n            .concat(middle)\n            .concat([\n            lastControlPoints[0],\n            lastControlPoints[1],\n            p[len - 2],\n            p[len - 1],\n            lastControlPoints[2],\n            lastControlPoints[3],\n            firstControlPoints[0],\n            firstControlPoints[1],\n            p[0],\n            p[1],\n        ]);\n        return tp;\n    }\n    getWidth() {\n        return this.getSelfRect().width;\n    }\n    getHeight() {\n        return this.getSelfRect().height;\n    }\n    getSelfRect() {\n        var points = this.points();\n        if (points.length < 4) {\n            return {\n                x: points[0] || 0,\n                y: points[1] || 0,\n                width: 0,\n                height: 0,\n            };\n        }\n        if (this.tension() !== 0) {\n            points = [\n                points[0],\n                points[1],\n                ...this._getTensionPoints(),\n                points[points.length - 2],\n                points[points.length - 1],\n            ];\n        }\n        else {\n            points = this.points();\n        }\n        var minX = points[0];\n        var maxX = points[0];\n        var minY = points[1];\n        var maxY = points[1];\n        var x, y;\n        for (var i = 0; i < points.length / 2; i++) {\n            x = points[i * 2];\n            y = points[i * 2 + 1];\n            minX = Math.min(minX, x);\n            maxX = Math.max(maxX, x);\n            minY = Math.min(minY, y);\n            maxY = Math.max(maxY, y);\n        }\n        return {\n            x: minX,\n            y: minY,\n            width: maxX - minX,\n            height: maxY - minY,\n        };\n    }\n}\nLine.prototype.className = 'Line';\nLine.prototype._attrsAffectingSize = ['points', 'bezier', 'tension'];\n_registerNode(Line);\nFactory.addGetterSetter(Line, 'closed', false);\nFactory.addGetterSetter(Line, 'bezier', false);\nFactory.addGetterSetter(Line, 'tension', 0, getNumberValidator());\nFactory.addGetterSetter(Line, 'points', [], getNumberArrayValidator());\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/shapes/Path.js\n\n\n\nclass Path extends Shape {\n    constructor(config) {\n        super(config);\n        this.dataArray = [];\n        this.pathLength = 0;\n        this.dataArray = Path.parsePathData(this.data());\n        this.pathLength = 0;\n        for (var i = 0; i < this.dataArray.length; ++i) {\n            this.pathLength += this.dataArray[i].pathLength;\n        }\n        this.on('dataChange.konva', function () {\n            this.dataArray = Path.parsePathData(this.data());\n            this.pathLength = 0;\n            for (var i = 0; i < this.dataArray.length; ++i) {\n                this.pathLength += this.dataArray[i].pathLength;\n            }\n        });\n    }\n    _sceneFunc(context) {\n        var ca = this.dataArray;\n        context.beginPath();\n        var isClosed = false;\n        for (var n = 0; n < ca.length; n++) {\n            var c = ca[n].command;\n            var p = ca[n].points;\n            switch (c) {\n                case 'L':\n                    context.lineTo(p[0], p[1]);\n                    break;\n                case 'M':\n                    context.moveTo(p[0], p[1]);\n                    break;\n                case 'C':\n                    context.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5]);\n                    break;\n                case 'Q':\n                    context.quadraticCurveTo(p[0], p[1], p[2], p[3]);\n                    break;\n                case 'A':\n                    var cx = p[0], cy = p[1], rx = p[2], ry = p[3], theta = p[4], dTheta = p[5], psi = p[6], fs = p[7];\n                    var r = rx > ry ? rx : ry;\n                    var scaleX = rx > ry ? 1 : rx / ry;\n                    var scaleY = rx > ry ? ry / rx : 1;\n                    context.translate(cx, cy);\n                    context.rotate(psi);\n                    context.scale(scaleX, scaleY);\n                    context.arc(0, 0, r, theta, theta + dTheta, 1 - fs);\n                    context.scale(1 / scaleX, 1 / scaleY);\n                    context.rotate(-psi);\n                    context.translate(-cx, -cy);\n                    break;\n                case 'z':\n                    isClosed = true;\n                    context.closePath();\n                    break;\n            }\n        }\n        if (!isClosed && !this.hasFill()) {\n            context.strokeShape(this);\n        }\n        else {\n            context.fillStrokeShape(this);\n        }\n    }\n    getSelfRect() {\n        var points = [];\n        this.dataArray.forEach(function (data) {\n            if (data.command === 'A') {\n                var start = data.points[4];\n                var dTheta = data.points[5];\n                var end = data.points[4] + dTheta;\n                var inc = Math.PI / 180.0;\n                if (Math.abs(start - end) < inc) {\n                    inc = Math.abs(start - end);\n                }\n                if (dTheta < 0) {\n                    for (let t = start - inc; t > end; t -= inc) {\n                        const point = Path.getPointOnEllipticalArc(data.points[0], data.points[1], data.points[2], data.points[3], t, 0);\n                        points.push(point.x, point.y);\n                    }\n                }\n                else {\n                    for (let t = start + inc; t < end; t += inc) {\n                        const point = Path.getPointOnEllipticalArc(data.points[0], data.points[1], data.points[2], data.points[3], t, 0);\n                        points.push(point.x, point.y);\n                    }\n                }\n            }\n            else if (data.command === 'C') {\n                for (let t = 0.0; t <= 1; t += 0.01) {\n                    const point = Path.getPointOnCubicBezier(t, data.start.x, data.start.y, data.points[0], data.points[1], data.points[2], data.points[3], data.points[4], data.points[5]);\n                    points.push(point.x, point.y);\n                }\n            }\n            else {\n                points = points.concat(data.points);\n            }\n        });\n        var minX = points[0];\n        var maxX = points[0];\n        var minY = points[1];\n        var maxY = points[1];\n        var x, y;\n        for (var i = 0; i < points.length / 2; i++) {\n            x = points[i * 2];\n            y = points[i * 2 + 1];\n            if (!isNaN(x)) {\n                minX = Math.min(minX, x);\n                maxX = Math.max(maxX, x);\n            }\n            if (!isNaN(y)) {\n                minY = Math.min(minY, y);\n                maxY = Math.max(maxY, y);\n            }\n        }\n        return {\n            x: minX,\n            y: minY,\n            width: maxX - minX,\n            height: maxY - minY,\n        };\n    }\n    getLength() {\n        return this.pathLength;\n    }\n    getPointAtLength(length) {\n        var point, i = 0, ii = this.dataArray.length;\n        if (!ii) {\n            return null;\n        }\n        while (i < ii && length > this.dataArray[i].pathLength) {\n            length -= this.dataArray[i].pathLength;\n            ++i;\n        }\n        if (i === ii) {\n            point = this.dataArray[i - 1].points.slice(-2);\n            return {\n                x: point[0],\n                y: point[1],\n            };\n        }\n        if (length < 0.01) {\n            point = this.dataArray[i].points.slice(0, 2);\n            return {\n                x: point[0],\n                y: point[1],\n            };\n        }\n        var cp = this.dataArray[i];\n        var p = cp.points;\n        switch (cp.command) {\n            case 'L':\n                return Path.getPointOnLine(length, cp.start.x, cp.start.y, p[0], p[1]);\n            case 'C':\n                return Path.getPointOnCubicBezier(length / cp.pathLength, cp.start.x, cp.start.y, p[0], p[1], p[2], p[3], p[4], p[5]);\n            case 'Q':\n                return Path.getPointOnQuadraticBezier(length / cp.pathLength, cp.start.x, cp.start.y, p[0], p[1], p[2], p[3]);\n            case 'A':\n                var cx = p[0], cy = p[1], rx = p[2], ry = p[3], theta = p[4], dTheta = p[5], psi = p[6];\n                theta += (dTheta * length) / cp.pathLength;\n                return Path.getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi);\n        }\n        return null;\n    }\n    static getLineLength(x1, y1, x2, y2) {\n        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    }\n    static getPointOnLine(dist, P1x, P1y, P2x, P2y, fromX, fromY) {\n        if (fromX === undefined) {\n            fromX = P1x;\n        }\n        if (fromY === undefined) {\n            fromY = P1y;\n        }\n        var m = (P2y - P1y) / (P2x - P1x + 0.00000001);\n        var run = Math.sqrt((dist * dist) / (1 + m * m));\n        if (P2x < P1x) {\n            run *= -1;\n        }\n        var rise = m * run;\n        var pt;\n        if (P2x === P1x) {\n            pt = {\n                x: fromX,\n                y: fromY + rise,\n            };\n        }\n        else if ((fromY - P1y) / (fromX - P1x + 0.00000001) === m) {\n            pt = {\n                x: fromX + run,\n                y: fromY + rise,\n            };\n        }\n        else {\n            var ix, iy;\n            var len = this.getLineLength(P1x, P1y, P2x, P2y);\n            var u = (fromX - P1x) * (P2x - P1x) + (fromY - P1y) * (P2y - P1y);\n            u = u / (len * len);\n            ix = P1x + u * (P2x - P1x);\n            iy = P1y + u * (P2y - P1y);\n            var pRise = this.getLineLength(fromX, fromY, ix, iy);\n            var pRun = Math.sqrt(dist * dist - pRise * pRise);\n            run = Math.sqrt((pRun * pRun) / (1 + m * m));\n            if (P2x < P1x) {\n                run *= -1;\n            }\n            rise = m * run;\n            pt = {\n                x: ix + run,\n                y: iy + rise,\n            };\n        }\n        return pt;\n    }\n    static getPointOnCubicBezier(pct, P1x, P1y, P2x, P2y, P3x, P3y, P4x, P4y) {\n        function CB1(t) {\n            return t * t * t;\n        }\n        function CB2(t) {\n            return 3 * t * t * (1 - t);\n        }\n        function CB3(t) {\n            return 3 * t * (1 - t) * (1 - t);\n        }\n        function CB4(t) {\n            return (1 - t) * (1 - t) * (1 - t);\n        }\n        var x = P4x * CB1(pct) + P3x * CB2(pct) + P2x * CB3(pct) + P1x * CB4(pct);\n        var y = P4y * CB1(pct) + P3y * CB2(pct) + P2y * CB3(pct) + P1y * CB4(pct);\n        return {\n            x: x,\n            y: y,\n        };\n    }\n    static getPointOnQuadraticBezier(pct, P1x, P1y, P2x, P2y, P3x, P3y) {\n        function QB1(t) {\n            return t * t;\n        }\n        function QB2(t) {\n            return 2 * t * (1 - t);\n        }\n        function QB3(t) {\n            return (1 - t) * (1 - t);\n        }\n        var x = P3x * QB1(pct) + P2x * QB2(pct) + P1x * QB3(pct);\n        var y = P3y * QB1(pct) + P2y * QB2(pct) + P1y * QB3(pct);\n        return {\n            x: x,\n            y: y,\n        };\n    }\n    static getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {\n        var cosPsi = Math.cos(psi), sinPsi = Math.sin(psi);\n        var pt = {\n            x: rx * Math.cos(theta),\n            y: ry * Math.sin(theta),\n        };\n        return {\n            x: cx + (pt.x * cosPsi - pt.y * sinPsi),\n            y: cy + (pt.x * sinPsi + pt.y * cosPsi),\n        };\n    }\n    static parsePathData(data) {\n        if (!data) {\n            return [];\n        }\n        var cs = data;\n        var cc = [\n            'm',\n            'M',\n            'l',\n            'L',\n            'v',\n            'V',\n            'h',\n            'H',\n            'z',\n            'Z',\n            'c',\n            'C',\n            'q',\n            'Q',\n            't',\n            'T',\n            's',\n            'S',\n            'a',\n            'A',\n        ];\n        cs = cs.replace(new RegExp(' ', 'g'), ',');\n        for (var n = 0; n < cc.length; n++) {\n            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n        }\n        var arr = cs.split('|');\n        var ca = [];\n        var coords = [];\n        var cpx = 0;\n        var cpy = 0;\n        var re = /([-+]?((\\d+\\.\\d+)|((\\d+)|(\\.\\d+)))(?:e[-+]?\\d+)?)/gi;\n        var match;\n        for (n = 1; n < arr.length; n++) {\n            var str = arr[n];\n            var c = str.charAt(0);\n            str = str.slice(1);\n            coords.length = 0;\n            while ((match = re.exec(str))) {\n                coords.push(match[0]);\n            }\n            var p = [];\n            for (var j = 0, jlen = coords.length; j < jlen; j++) {\n                if (coords[j] === '00') {\n                    p.push(0, 0);\n                    continue;\n                }\n                var parsed = parseFloat(coords[j]);\n                if (!isNaN(parsed)) {\n                    p.push(parsed);\n                }\n                else {\n                    p.push(0);\n                }\n            }\n            while (p.length > 0) {\n                if (isNaN(p[0])) {\n                    break;\n                }\n                var cmd = null;\n                var points = [];\n                var startX = cpx, startY = cpy;\n                var prevCmd, ctlPtx, ctlPty;\n                var rx, ry, psi, fa, fs, x1, y1;\n                switch (c) {\n                    case 'l':\n                        cpx += p.shift();\n                        cpy += p.shift();\n                        cmd = 'L';\n                        points.push(cpx, cpy);\n                        break;\n                    case 'L':\n                        cpx = p.shift();\n                        cpy = p.shift();\n                        points.push(cpx, cpy);\n                        break;\n                    case 'm':\n                        var dx = p.shift();\n                        var dy = p.shift();\n                        cpx += dx;\n                        cpy += dy;\n                        cmd = 'M';\n                        if (ca.length > 2 && ca[ca.length - 1].command === 'z') {\n                            for (var idx = ca.length - 2; idx >= 0; idx--) {\n                                if (ca[idx].command === 'M') {\n                                    cpx = ca[idx].points[0] + dx;\n                                    cpy = ca[idx].points[1] + dy;\n                                    break;\n                                }\n                            }\n                        }\n                        points.push(cpx, cpy);\n                        c = 'l';\n                        break;\n                    case 'M':\n                        cpx = p.shift();\n                        cpy = p.shift();\n                        cmd = 'M';\n                        points.push(cpx, cpy);\n                        c = 'L';\n                        break;\n                    case 'h':\n                        cpx += p.shift();\n                        cmd = 'L';\n                        points.push(cpx, cpy);\n                        break;\n                    case 'H':\n                        cpx = p.shift();\n                        cmd = 'L';\n                        points.push(cpx, cpy);\n                        break;\n                    case 'v':\n                        cpy += p.shift();\n                        cmd = 'L';\n                        points.push(cpx, cpy);\n                        break;\n                    case 'V':\n                        cpy = p.shift();\n                        cmd = 'L';\n                        points.push(cpx, cpy);\n                        break;\n                    case 'C':\n                        points.push(p.shift(), p.shift(), p.shift(), p.shift());\n                        cpx = p.shift();\n                        cpy = p.shift();\n                        points.push(cpx, cpy);\n                        break;\n                    case 'c':\n                        points.push(cpx + p.shift(), cpy + p.shift(), cpx + p.shift(), cpy + p.shift());\n                        cpx += p.shift();\n                        cpy += p.shift();\n                        cmd = 'C';\n                        points.push(cpx, cpy);\n                        break;\n                    case 'S':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        prevCmd = ca[ca.length - 1];\n                        if (prevCmd.command === 'C') {\n                            ctlPtx = cpx + (cpx - prevCmd.points[2]);\n                            ctlPty = cpy + (cpy - prevCmd.points[3]);\n                        }\n                        points.push(ctlPtx, ctlPty, p.shift(), p.shift());\n                        cpx = p.shift();\n                        cpy = p.shift();\n                        cmd = 'C';\n                        points.push(cpx, cpy);\n                        break;\n                    case 's':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        prevCmd = ca[ca.length - 1];\n                        if (prevCmd.command === 'C') {\n                            ctlPtx = cpx + (cpx - prevCmd.points[2]);\n                            ctlPty = cpy + (cpy - prevCmd.points[3]);\n                        }\n                        points.push(ctlPtx, ctlPty, cpx + p.shift(), cpy + p.shift());\n                        cpx += p.shift();\n                        cpy += p.shift();\n                        cmd = 'C';\n                        points.push(cpx, cpy);\n                        break;\n                    case 'Q':\n                        points.push(p.shift(), p.shift());\n                        cpx = p.shift();\n                        cpy = p.shift();\n                        points.push(cpx, cpy);\n                        break;\n                    case 'q':\n                        points.push(cpx + p.shift(), cpy + p.shift());\n                        cpx += p.shift();\n                        cpy += p.shift();\n                        cmd = 'Q';\n                        points.push(cpx, cpy);\n                        break;\n                    case 'T':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        prevCmd = ca[ca.length - 1];\n                        if (prevCmd.command === 'Q') {\n                            ctlPtx = cpx + (cpx - prevCmd.points[0]);\n                            ctlPty = cpy + (cpy - prevCmd.points[1]);\n                        }\n                        cpx = p.shift();\n                        cpy = p.shift();\n                        cmd = 'Q';\n                        points.push(ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 't':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        prevCmd = ca[ca.length - 1];\n                        if (prevCmd.command === 'Q') {\n                            ctlPtx = cpx + (cpx - prevCmd.points[0]);\n                            ctlPty = cpy + (cpy - prevCmd.points[1]);\n                        }\n                        cpx += p.shift();\n                        cpy += p.shift();\n                        cmd = 'Q';\n                        points.push(ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 'A':\n                        rx = p.shift();\n                        ry = p.shift();\n                        psi = p.shift();\n                        fa = p.shift();\n                        fs = p.shift();\n                        x1 = cpx;\n                        y1 = cpy;\n                        cpx = p.shift();\n                        cpy = p.shift();\n                        cmd = 'A';\n                        points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);\n                        break;\n                    case 'a':\n                        rx = p.shift();\n                        ry = p.shift();\n                        psi = p.shift();\n                        fa = p.shift();\n                        fs = p.shift();\n                        x1 = cpx;\n                        y1 = cpy;\n                        cpx += p.shift();\n                        cpy += p.shift();\n                        cmd = 'A';\n                        points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);\n                        break;\n                }\n                ca.push({\n                    command: cmd || c,\n                    points: points,\n                    start: {\n                        x: startX,\n                        y: startY,\n                    },\n                    pathLength: this.calcLength(startX, startY, cmd || c, points),\n                });\n            }\n            if (c === 'z' || c === 'Z') {\n                ca.push({\n                    command: 'z',\n                    points: [],\n                    start: undefined,\n                    pathLength: 0,\n                });\n            }\n        }\n        return ca;\n    }\n    static calcLength(x, y, cmd, points) {\n        var len, p1, p2, t;\n        var path = Path;\n        switch (cmd) {\n            case 'L':\n                return path.getLineLength(x, y, points[0], points[1]);\n            case 'C':\n                len = 0.0;\n                p1 = path.getPointOnCubicBezier(0, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);\n                for (t = 0.01; t <= 1; t += 0.01) {\n                    p2 = path.getPointOnCubicBezier(t, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);\n                    len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                    p1 = p2;\n                }\n                return len;\n            case 'Q':\n                len = 0.0;\n                p1 = path.getPointOnQuadraticBezier(0, x, y, points[0], points[1], points[2], points[3]);\n                for (t = 0.01; t <= 1; t += 0.01) {\n                    p2 = path.getPointOnQuadraticBezier(t, x, y, points[0], points[1], points[2], points[3]);\n                    len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                    p1 = p2;\n                }\n                return len;\n            case 'A':\n                len = 0.0;\n                var start = points[4];\n                var dTheta = points[5];\n                var end = points[4] + dTheta;\n                var inc = Math.PI / 180.0;\n                if (Math.abs(start - end) < inc) {\n                    inc = Math.abs(start - end);\n                }\n                p1 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);\n                if (dTheta < 0) {\n                    for (t = start - inc; t > end; t -= inc) {\n                        p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);\n                        len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                        p1 = p2;\n                    }\n                }\n                else {\n                    for (t = start + inc; t < end; t += inc) {\n                        p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);\n                        len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                        p1 = p2;\n                    }\n                }\n                p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);\n                len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                return len;\n        }\n        return 0;\n    }\n    static convertEndpointToCenterParameterization(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg) {\n        var psi = psiDeg * (Math.PI / 180.0);\n        var xp = (Math.cos(psi) * (x1 - x2)) / 2.0 + (Math.sin(psi) * (y1 - y2)) / 2.0;\n        var yp = (-1 * Math.sin(psi) * (x1 - x2)) / 2.0 +\n            (Math.cos(psi) * (y1 - y2)) / 2.0;\n        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n        if (lambda > 1) {\n            rx *= Math.sqrt(lambda);\n            ry *= Math.sqrt(lambda);\n        }\n        var f = Math.sqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) /\n            (rx * rx * (yp * yp) + ry * ry * (xp * xp)));\n        if (fa === fs) {\n            f *= -1;\n        }\n        if (isNaN(f)) {\n            f = 0;\n        }\n        var cxp = (f * rx * yp) / ry;\n        var cyp = (f * -ry * xp) / rx;\n        var cx = (x1 + x2) / 2.0 + Math.cos(psi) * cxp - Math.sin(psi) * cyp;\n        var cy = (y1 + y2) / 2.0 + Math.sin(psi) * cxp + Math.cos(psi) * cyp;\n        var vMag = function (v) {\n            return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n        };\n        var vRatio = function (u, v) {\n            return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n        };\n        var vAngle = function (u, v) {\n            return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\n        };\n        var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);\n        var u = [(xp - cxp) / rx, (yp - cyp) / ry];\n        var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];\n        var dTheta = vAngle(u, v);\n        if (vRatio(u, v) <= -1) {\n            dTheta = Math.PI;\n        }\n        if (vRatio(u, v) >= 1) {\n            dTheta = 0;\n        }\n        if (fs === 0 && dTheta > 0) {\n            dTheta = dTheta - 2 * Math.PI;\n        }\n        if (fs === 1 && dTheta < 0) {\n            dTheta = dTheta + 2 * Math.PI;\n        }\n        return [cx, cy, rx, ry, theta, dTheta, psi, fs];\n    }\n}\nPath.prototype.className = 'Path';\nPath.prototype._attrsAffectingSize = ['data'];\n_registerNode(Path);\nFactory.addGetterSetter(Path, 'data');\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/shapes/Arrow.js\n\n\n\n\n\nclass Arrow extends Line {\n    _sceneFunc(ctx) {\n        super._sceneFunc(ctx);\n        var PI2 = Math.PI * 2;\n        var points = this.points();\n        var tp = points;\n        var fromTension = this.tension() !== 0 && points.length > 4;\n        if (fromTension) {\n            tp = this.getTensionPoints();\n        }\n        var length = this.pointerLength();\n        var n = points.length;\n        var dx, dy;\n        if (fromTension) {\n            const lp = [\n                tp[tp.length - 4],\n                tp[tp.length - 3],\n                tp[tp.length - 2],\n                tp[tp.length - 1],\n                points[n - 2],\n                points[n - 1],\n            ];\n            const lastLength = Path.calcLength(tp[tp.length - 4], tp[tp.length - 3], 'C', lp);\n            const previous = Path.getPointOnQuadraticBezier(Math.min(1, 1 - length / lastLength), lp[0], lp[1], lp[2], lp[3], lp[4], lp[5]);\n            dx = points[n - 2] - previous.x;\n            dy = points[n - 1] - previous.y;\n        }\n        else {\n            dx = points[n - 2] - points[n - 4];\n            dy = points[n - 1] - points[n - 3];\n        }\n        var radians = (Math.atan2(dy, dx) + PI2) % PI2;\n        var width = this.pointerWidth();\n        if (this.pointerAtEnding()) {\n            ctx.save();\n            ctx.beginPath();\n            ctx.translate(points[n - 2], points[n - 1]);\n            ctx.rotate(radians);\n            ctx.moveTo(0, 0);\n            ctx.lineTo(-length, width / 2);\n            ctx.lineTo(-length, -width / 2);\n            ctx.closePath();\n            ctx.restore();\n            this.__fillStroke(ctx);\n        }\n        if (this.pointerAtBeginning()) {\n            ctx.save();\n            ctx.beginPath();\n            ctx.translate(points[0], points[1]);\n            if (fromTension) {\n                dx = (tp[0] + tp[2]) / 2 - points[0];\n                dy = (tp[1] + tp[3]) / 2 - points[1];\n            }\n            else {\n                dx = points[2] - points[0];\n                dy = points[3] - points[1];\n            }\n            ctx.rotate((Math.atan2(-dy, -dx) + PI2) % PI2);\n            ctx.moveTo(0, 0);\n            ctx.lineTo(-length, width / 2);\n            ctx.lineTo(-length, -width / 2);\n            ctx.closePath();\n            ctx.restore();\n            this.__fillStroke(ctx);\n        }\n    }\n    __fillStroke(ctx) {\n        var isDashEnabled = this.dashEnabled();\n        if (isDashEnabled) {\n            this.attrs.dashEnabled = false;\n            ctx.setLineDash([]);\n        }\n        ctx.fillStrokeShape(this);\n        if (isDashEnabled) {\n            this.attrs.dashEnabled = true;\n        }\n    }\n    getSelfRect() {\n        const lineRect = super.getSelfRect();\n        const offset = this.pointerWidth() / 2;\n        return {\n            x: lineRect.x - offset,\n            y: lineRect.y - offset,\n            width: lineRect.width + offset * 2,\n            height: lineRect.height + offset * 2,\n        };\n    }\n}\nArrow.prototype.className = 'Arrow';\n_registerNode(Arrow);\nFactory.addGetterSetter(Arrow, 'pointerLength', 10, getNumberValidator());\nFactory.addGetterSetter(Arrow, 'pointerWidth', 10, getNumberValidator());\nFactory.addGetterSetter(Arrow, 'pointerAtBeginning', false);\nFactory.addGetterSetter(Arrow, 'pointerAtEnding', true);\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/shapes/Circle.js\n\n\n\n\nclass Circle extends Shape {\n    _sceneFunc(context) {\n        context.beginPath();\n        context.arc(0, 0, this.attrs.radius || 0, 0, Math.PI * 2, false);\n        context.closePath();\n        context.fillStrokeShape(this);\n    }\n    getWidth() {\n        return this.radius() * 2;\n    }\n    getHeight() {\n        return this.radius() * 2;\n    }\n    setWidth(width) {\n        if (this.radius() !== width / 2) {\n            this.radius(width / 2);\n        }\n    }\n    setHeight(height) {\n        if (this.radius() !== height / 2) {\n            this.radius(height / 2);\n        }\n    }\n}\nCircle.prototype._centroid = true;\nCircle.prototype.className = 'Circle';\nCircle.prototype._attrsAffectingSize = ['radius'];\n_registerNode(Circle);\nFactory.addGetterSetter(Circle, 'radius', 0, getNumberValidator());\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/shapes/Ellipse.js\n\n\n\n\nclass Ellipse extends Shape {\n    _sceneFunc(context) {\n        var rx = this.radiusX(), ry = this.radiusY();\n        context.beginPath();\n        context.save();\n        if (rx !== ry) {\n            context.scale(1, ry / rx);\n        }\n        context.arc(0, 0, rx, 0, Math.PI * 2, false);\n        context.restore();\n        context.closePath();\n        context.fillStrokeShape(this);\n    }\n    getWidth() {\n        return this.radiusX() * 2;\n    }\n    getHeight() {\n        return this.radiusY() * 2;\n    }\n    setWidth(width) {\n        this.radiusX(width / 2);\n    }\n    setHeight(height) {\n        this.radiusY(height / 2);\n    }\n}\nEllipse.prototype.className = 'Ellipse';\nEllipse.prototype._centroid = true;\nEllipse.prototype._attrsAffectingSize = ['radiusX', 'radiusY'];\n_registerNode(Ellipse);\nFactory.addComponentsGetterSetter(Ellipse, 'radius', ['x', 'y']);\nFactory.addGetterSetter(Ellipse, 'radiusX', 0, getNumberValidator());\nFactory.addGetterSetter(Ellipse, 'radiusY', 0, getNumberValidator());\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/shapes/Image.js\n\n\n\n\n\nclass Image extends Shape {\n    constructor(attrs) {\n        super(attrs);\n        this.on('imageChange.konva', () => {\n            this._setImageLoad();\n        });\n        this._setImageLoad();\n    }\n    _setImageLoad() {\n        const image = this.image();\n        if (image && image.complete) {\n            return;\n        }\n        if (image && image.readyState === 4) {\n            return;\n        }\n        if (image && image['addEventListener']) {\n            image['addEventListener']('load', () => {\n                this._requestDraw();\n            });\n        }\n    }\n    _useBufferCanvas() {\n        return super._useBufferCanvas(true);\n    }\n    _sceneFunc(context) {\n        const width = this.getWidth();\n        const height = this.getHeight();\n        const image = this.attrs.image;\n        let params;\n        if (image) {\n            const cropWidth = this.attrs.cropWidth;\n            const cropHeight = this.attrs.cropHeight;\n            if (cropWidth && cropHeight) {\n                params = [\n                    image,\n                    this.cropX(),\n                    this.cropY(),\n                    cropWidth,\n                    cropHeight,\n                    0,\n                    0,\n                    width,\n                    height,\n                ];\n            }\n            else {\n                params = [image, 0, 0, width, height];\n            }\n        }\n        if (this.hasFill() || this.hasStroke()) {\n            context.beginPath();\n            context.rect(0, 0, width, height);\n            context.closePath();\n            context.fillStrokeShape(this);\n        }\n        if (image) {\n            context.drawImage.apply(context, params);\n        }\n    }\n    _hitFunc(context) {\n        var width = this.width(), height = this.height();\n        context.beginPath();\n        context.rect(0, 0, width, height);\n        context.closePath();\n        context.fillStrokeShape(this);\n    }\n    getWidth() {\n        var _a, _b;\n        return (_a = this.attrs.width) !== null && _a !== void 0 ? _a : (_b = this.image()) === null || _b === void 0 ? void 0 : _b.width;\n    }\n    getHeight() {\n        var _a, _b;\n        return (_a = this.attrs.height) !== null && _a !== void 0 ? _a : (_b = this.image()) === null || _b === void 0 ? void 0 : _b.height;\n    }\n    static fromURL(url, callback, onError = null) {\n        var img = Util_Util.createImageElement();\n        img.onload = function () {\n            var image = new Image({\n                image: img,\n            });\n            callback(image);\n        };\n        img.onerror = onError;\n        img.crossOrigin = 'Anonymous';\n        img.src = url;\n    }\n}\nImage.prototype.className = 'Image';\n_registerNode(Image);\nFactory.addGetterSetter(Image, 'image');\nFactory.addComponentsGetterSetter(Image, 'crop', ['x', 'y', 'width', 'height']);\nFactory.addGetterSetter(Image, 'cropX', 0, getNumberValidator());\nFactory.addGetterSetter(Image, 'cropY', 0, getNumberValidator());\nFactory.addGetterSetter(Image, 'cropWidth', 0, getNumberValidator());\nFactory.addGetterSetter(Image, 'cropHeight', 0, getNumberValidator());\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/shapes/Label.js\n\n\n\n\n\nvar ATTR_CHANGE_LIST = [\n    'fontFamily',\n    'fontSize',\n    'fontStyle',\n    'padding',\n    'lineHeight',\n    'text',\n    'width',\n    'height',\n], CHANGE_KONVA = 'Change.konva', NONE = 'none', UP = 'up', RIGHT = 'right', DOWN = 'down', LEFT = 'left', attrChangeListLen = ATTR_CHANGE_LIST.length;\nclass Label extends Group {\n    constructor(config) {\n        super(config);\n        this.on('add.konva', function (evt) {\n            this._addListeners(evt.child);\n            this._sync();\n        });\n    }\n    getText() {\n        return this.find('Text')[0];\n    }\n    getTag() {\n        return this.find('Tag')[0];\n    }\n    _addListeners(text) {\n        var that = this, n;\n        var func = function () {\n            that._sync();\n        };\n        for (n = 0; n < attrChangeListLen; n++) {\n            text.on(ATTR_CHANGE_LIST[n] + CHANGE_KONVA, func);\n        }\n    }\n    getWidth() {\n        return this.getText().width();\n    }\n    getHeight() {\n        return this.getText().height();\n    }\n    _sync() {\n        var text = this.getText(), tag = this.getTag(), width, height, pointerDirection, pointerWidth, x, y, pointerHeight;\n        if (text && tag) {\n            width = text.width();\n            height = text.height();\n            pointerDirection = tag.pointerDirection();\n            pointerWidth = tag.pointerWidth();\n            pointerHeight = tag.pointerHeight();\n            x = 0;\n            y = 0;\n            switch (pointerDirection) {\n                case UP:\n                    x = width / 2;\n                    y = -1 * pointerHeight;\n                    break;\n                case RIGHT:\n                    x = width + pointerWidth;\n                    y = height / 2;\n                    break;\n                case DOWN:\n                    x = width / 2;\n                    y = height + pointerHeight;\n                    break;\n                case LEFT:\n                    x = -1 * pointerWidth;\n                    y = height / 2;\n                    break;\n            }\n            tag.setAttrs({\n                x: -1 * x,\n                y: -1 * y,\n                width: width,\n                height: height,\n            });\n            text.setAttrs({\n                x: -1 * x,\n                y: -1 * y,\n            });\n        }\n    }\n}\nLabel.prototype.className = 'Label';\n_registerNode(Label);\nclass Tag extends Shape {\n    _sceneFunc(context) {\n        var width = this.width(), height = this.height(), pointerDirection = this.pointerDirection(), pointerWidth = this.pointerWidth(), pointerHeight = this.pointerHeight(), cornerRadius = this.cornerRadius();\n        let topLeft = 0;\n        let topRight = 0;\n        let bottomLeft = 0;\n        let bottomRight = 0;\n        if (typeof cornerRadius === 'number') {\n            topLeft = topRight = bottomLeft = bottomRight = Math.min(cornerRadius, width / 2, height / 2);\n        }\n        else {\n            topLeft = Math.min(cornerRadius[0] || 0, width / 2, height / 2);\n            topRight = Math.min(cornerRadius[1] || 0, width / 2, height / 2);\n            bottomRight = Math.min(cornerRadius[2] || 0, width / 2, height / 2);\n            bottomLeft = Math.min(cornerRadius[3] || 0, width / 2, height / 2);\n        }\n        context.beginPath();\n        context.moveTo(topLeft, 0);\n        if (pointerDirection === UP) {\n            context.lineTo((width - pointerWidth) / 2, 0);\n            context.lineTo(width / 2, -1 * pointerHeight);\n            context.lineTo((width + pointerWidth) / 2, 0);\n        }\n        context.lineTo(width - topRight, 0);\n        context.arc(width - topRight, topRight, topRight, (Math.PI * 3) / 2, 0, false);\n        if (pointerDirection === RIGHT) {\n            context.lineTo(width, (height - pointerHeight) / 2);\n            context.lineTo(width + pointerWidth, height / 2);\n            context.lineTo(width, (height + pointerHeight) / 2);\n        }\n        context.lineTo(width, height - bottomRight);\n        context.arc(width - bottomRight, height - bottomRight, bottomRight, 0, Math.PI / 2, false);\n        if (pointerDirection === DOWN) {\n            context.lineTo((width + pointerWidth) / 2, height);\n            context.lineTo(width / 2, height + pointerHeight);\n            context.lineTo((width - pointerWidth) / 2, height);\n        }\n        context.lineTo(bottomLeft, height);\n        context.arc(bottomLeft, height - bottomLeft, bottomLeft, Math.PI / 2, Math.PI, false);\n        if (pointerDirection === LEFT) {\n            context.lineTo(0, (height + pointerHeight) / 2);\n            context.lineTo(-1 * pointerWidth, height / 2);\n            context.lineTo(0, (height - pointerHeight) / 2);\n        }\n        context.lineTo(0, topLeft);\n        context.arc(topLeft, topLeft, topLeft, Math.PI, (Math.PI * 3) / 2, false);\n        context.closePath();\n        context.fillStrokeShape(this);\n    }\n    getSelfRect() {\n        var x = 0, y = 0, pointerWidth = this.pointerWidth(), pointerHeight = this.pointerHeight(), direction = this.pointerDirection(), width = this.width(), height = this.height();\n        if (direction === UP) {\n            y -= pointerHeight;\n            height += pointerHeight;\n        }\n        else if (direction === DOWN) {\n            height += pointerHeight;\n        }\n        else if (direction === LEFT) {\n            x -= pointerWidth * 1.5;\n            width += pointerWidth;\n        }\n        else if (direction === RIGHT) {\n            width += pointerWidth * 1.5;\n        }\n        return {\n            x: x,\n            y: y,\n            width: width,\n            height: height,\n        };\n    }\n}\nTag.prototype.className = 'Tag';\n_registerNode(Tag);\nFactory.addGetterSetter(Tag, 'pointerDirection', NONE);\nFactory.addGetterSetter(Tag, 'pointerWidth', 0, getNumberValidator());\nFactory.addGetterSetter(Tag, 'pointerHeight', 0, getNumberValidator());\nFactory.addGetterSetter(Tag, 'cornerRadius', 0, getNumberOrArrayOfNumbersValidator(4));\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/shapes/Rect.js\n\n\n\n\nclass Rect extends Shape {\n    _sceneFunc(context) {\n        var cornerRadius = this.cornerRadius(), width = this.width(), height = this.height();\n        context.beginPath();\n        if (!cornerRadius) {\n            context.rect(0, 0, width, height);\n        }\n        else {\n            let topLeft = 0;\n            let topRight = 0;\n            let bottomLeft = 0;\n            let bottomRight = 0;\n            if (typeof cornerRadius === 'number') {\n                topLeft = topRight = bottomLeft = bottomRight = Math.min(cornerRadius, width / 2, height / 2);\n            }\n            else {\n                topLeft = Math.min(cornerRadius[0] || 0, width / 2, height / 2);\n                topRight = Math.min(cornerRadius[1] || 0, width / 2, height / 2);\n                bottomRight = Math.min(cornerRadius[2] || 0, width / 2, height / 2);\n                bottomLeft = Math.min(cornerRadius[3] || 0, width / 2, height / 2);\n            }\n            context.moveTo(topLeft, 0);\n            context.lineTo(width - topRight, 0);\n            context.arc(width - topRight, topRight, topRight, (Math.PI * 3) / 2, 0, false);\n            context.lineTo(width, height - bottomRight);\n            context.arc(width - bottomRight, height - bottomRight, bottomRight, 0, Math.PI / 2, false);\n            context.lineTo(bottomLeft, height);\n            context.arc(bottomLeft, height - bottomLeft, bottomLeft, Math.PI / 2, Math.PI, false);\n            context.lineTo(0, topLeft);\n            context.arc(topLeft, topLeft, topLeft, Math.PI, (Math.PI * 3) / 2, false);\n        }\n        context.closePath();\n        context.fillStrokeShape(this);\n    }\n}\nRect.prototype.className = 'Rect';\n_registerNode(Rect);\nFactory.addGetterSetter(Rect, 'cornerRadius', 0, getNumberOrArrayOfNumbersValidator(4));\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/shapes/RegularPolygon.js\n\n\n\n\nclass RegularPolygon extends Shape {\n    _sceneFunc(context) {\n        const points = this._getPoints();\n        context.beginPath();\n        context.moveTo(points[0].x, points[0].y);\n        for (var n = 1; n < points.length; n++) {\n            context.lineTo(points[n].x, points[n].y);\n        }\n        context.closePath();\n        context.fillStrokeShape(this);\n    }\n    _getPoints() {\n        const sides = this.attrs.sides;\n        const radius = this.attrs.radius || 0;\n        const points = [];\n        for (var n = 0; n < sides; n++) {\n            points.push({\n                x: radius * Math.sin((n * 2 * Math.PI) / sides),\n                y: -1 * radius * Math.cos((n * 2 * Math.PI) / sides),\n            });\n        }\n        return points;\n    }\n    getSelfRect() {\n        const points = this._getPoints();\n        var minX = points[0].x;\n        var maxX = points[0].y;\n        var minY = points[0].x;\n        var maxY = points[0].y;\n        points.forEach((point) => {\n            minX = Math.min(minX, point.x);\n            maxX = Math.max(maxX, point.x);\n            minY = Math.min(minY, point.y);\n            maxY = Math.max(maxY, point.y);\n        });\n        return {\n            x: minX,\n            y: minY,\n            width: maxX - minX,\n            height: maxY - minY,\n        };\n    }\n    getWidth() {\n        return this.radius() * 2;\n    }\n    getHeight() {\n        return this.radius() * 2;\n    }\n    setWidth(width) {\n        this.radius(width / 2);\n    }\n    setHeight(height) {\n        this.radius(height / 2);\n    }\n}\nRegularPolygon.prototype.className = 'RegularPolygon';\nRegularPolygon.prototype._centroid = true;\nRegularPolygon.prototype._attrsAffectingSize = ['radius'];\n_registerNode(RegularPolygon);\nFactory.addGetterSetter(RegularPolygon, 'radius', 0, getNumberValidator());\nFactory.addGetterSetter(RegularPolygon, 'sides', 0, getNumberValidator());\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/shapes/Ring.js\n\n\n\n\nvar PIx2 = Math.PI * 2;\nclass Ring extends Shape {\n    _sceneFunc(context) {\n        context.beginPath();\n        context.arc(0, 0, this.innerRadius(), 0, PIx2, false);\n        context.moveTo(this.outerRadius(), 0);\n        context.arc(0, 0, this.outerRadius(), PIx2, 0, true);\n        context.closePath();\n        context.fillStrokeShape(this);\n    }\n    getWidth() {\n        return this.outerRadius() * 2;\n    }\n    getHeight() {\n        return this.outerRadius() * 2;\n    }\n    setWidth(width) {\n        this.outerRadius(width / 2);\n    }\n    setHeight(height) {\n        this.outerRadius(height / 2);\n    }\n}\nRing.prototype.className = 'Ring';\nRing.prototype._centroid = true;\nRing.prototype._attrsAffectingSize = ['innerRadius', 'outerRadius'];\n_registerNode(Ring);\nFactory.addGetterSetter(Ring, 'innerRadius', 0, getNumberValidator());\nFactory.addGetterSetter(Ring, 'outerRadius', 0, getNumberValidator());\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/shapes/Sprite.js\n\n\n\n\n\nclass Sprite extends Shape {\n    constructor(config) {\n        super(config);\n        this._updated = true;\n        this.anim = new Animation(() => {\n            var updated = this._updated;\n            this._updated = false;\n            return updated;\n        });\n        this.on('animationChange.konva', function () {\n            this.frameIndex(0);\n        });\n        this.on('frameIndexChange.konva', function () {\n            this._updated = true;\n        });\n        this.on('frameRateChange.konva', function () {\n            if (!this.anim.isRunning()) {\n                return;\n            }\n            clearInterval(this.interval);\n            this._setInterval();\n        });\n    }\n    _sceneFunc(context) {\n        var anim = this.animation(), index = this.frameIndex(), ix4 = index * 4, set = this.animations()[anim], offsets = this.frameOffsets(), x = set[ix4 + 0], y = set[ix4 + 1], width = set[ix4 + 2], height = set[ix4 + 3], image = this.image();\n        if (this.hasFill() || this.hasStroke()) {\n            context.beginPath();\n            context.rect(0, 0, width, height);\n            context.closePath();\n            context.fillStrokeShape(this);\n        }\n        if (image) {\n            if (offsets) {\n                var offset = offsets[anim], ix2 = index * 2;\n                context.drawImage(image, x, y, width, height, offset[ix2 + 0], offset[ix2 + 1], width, height);\n            }\n            else {\n                context.drawImage(image, x, y, width, height, 0, 0, width, height);\n            }\n        }\n    }\n    _hitFunc(context) {\n        var anim = this.animation(), index = this.frameIndex(), ix4 = index * 4, set = this.animations()[anim], offsets = this.frameOffsets(), width = set[ix4 + 2], height = set[ix4 + 3];\n        context.beginPath();\n        if (offsets) {\n            var offset = offsets[anim];\n            var ix2 = index * 2;\n            context.rect(offset[ix2 + 0], offset[ix2 + 1], width, height);\n        }\n        else {\n            context.rect(0, 0, width, height);\n        }\n        context.closePath();\n        context.fillShape(this);\n    }\n    _useBufferCanvas() {\n        return super._useBufferCanvas(true);\n    }\n    _setInterval() {\n        var that = this;\n        this.interval = setInterval(function () {\n            that._updateIndex();\n        }, 1000 / this.frameRate());\n    }\n    start() {\n        if (this.isRunning()) {\n            return;\n        }\n        var layer = this.getLayer();\n        this.anim.setLayers(layer);\n        this._setInterval();\n        this.anim.start();\n    }\n    stop() {\n        this.anim.stop();\n        clearInterval(this.interval);\n    }\n    isRunning() {\n        return this.anim.isRunning();\n    }\n    _updateIndex() {\n        var index = this.frameIndex(), animation = this.animation(), animations = this.animations(), anim = animations[animation], len = anim.length / 4;\n        if (index < len - 1) {\n            this.frameIndex(index + 1);\n        }\n        else {\n            this.frameIndex(0);\n        }\n    }\n}\nSprite.prototype.className = 'Sprite';\n_registerNode(Sprite);\nFactory.addGetterSetter(Sprite, 'animation');\nFactory.addGetterSetter(Sprite, 'animations');\nFactory.addGetterSetter(Sprite, 'frameOffsets');\nFactory.addGetterSetter(Sprite, 'image');\nFactory.addGetterSetter(Sprite, 'frameIndex', 0, getNumberValidator());\nFactory.addGetterSetter(Sprite, 'frameRate', 17, getNumberValidator());\nFactory.backCompat(Sprite, {\n    index: 'frameIndex',\n    getIndex: 'getFrameIndex',\n    setIndex: 'setFrameIndex',\n});\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/shapes/Star.js\n\n\n\n\nclass Star extends Shape {\n    _sceneFunc(context) {\n        var innerRadius = this.innerRadius(), outerRadius = this.outerRadius(), numPoints = this.numPoints();\n        context.beginPath();\n        context.moveTo(0, 0 - outerRadius);\n        for (var n = 1; n < numPoints * 2; n++) {\n            var radius = n % 2 === 0 ? outerRadius : innerRadius;\n            var x = radius * Math.sin((n * Math.PI) / numPoints);\n            var y = -1 * radius * Math.cos((n * Math.PI) / numPoints);\n            context.lineTo(x, y);\n        }\n        context.closePath();\n        context.fillStrokeShape(this);\n    }\n    getWidth() {\n        return this.outerRadius() * 2;\n    }\n    getHeight() {\n        return this.outerRadius() * 2;\n    }\n    setWidth(width) {\n        this.outerRadius(width / 2);\n    }\n    setHeight(height) {\n        this.outerRadius(height / 2);\n    }\n}\nStar.prototype.className = 'Star';\nStar.prototype._centroid = true;\nStar.prototype._attrsAffectingSize = ['innerRadius', 'outerRadius'];\n_registerNode(Star);\nFactory.addGetterSetter(Star, 'numPoints', 5, getNumberValidator());\nFactory.addGetterSetter(Star, 'innerRadius', 0, getNumberValidator());\nFactory.addGetterSetter(Star, 'outerRadius', 0, getNumberValidator());\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/shapes/Text.js\n\n\n\n\n\nfunction stringToArray(string) {\n    return Array.from(string);\n}\nvar AUTO = 'auto', CENTER = 'center', JUSTIFY = 'justify', Text_CHANGE_KONVA = 'Change.konva', CONTEXT_2D = '2d', DASH = '-', Text_LEFT = 'left', TEXT = 'text', TEXT_UPPER = 'Text', TOP = 'top', BOTTOM = 'bottom', MIDDLE = 'middle', NORMAL = 'normal', PX_SPACE = 'px ', Text_SPACE = ' ', Text_RIGHT = 'right', WORD = 'word', CHAR = 'char', Text_NONE = 'none', ELLIPSIS = '…', Text_ATTR_CHANGE_LIST = [\n    'fontFamily',\n    'fontSize',\n    'fontStyle',\n    'fontVariant',\n    'padding',\n    'align',\n    'verticalAlign',\n    'lineHeight',\n    'text',\n    'width',\n    'height',\n    'wrap',\n    'ellipsis',\n    'letterSpacing',\n], Text_attrChangeListLen = Text_ATTR_CHANGE_LIST.length;\nfunction normalizeFontFamily(fontFamily) {\n    return fontFamily\n        .split(',')\n        .map((family) => {\n        family = family.trim();\n        const hasSpace = family.indexOf(' ') >= 0;\n        const hasQuotes = family.indexOf('\"') >= 0 || family.indexOf(\"'\") >= 0;\n        if (hasSpace && !hasQuotes) {\n            family = `\"${family}\"`;\n        }\n        return family;\n    })\n        .join(', ');\n}\nvar Text_dummyContext;\nfunction Text_getDummyContext() {\n    if (Text_dummyContext) {\n        return Text_dummyContext;\n    }\n    Text_dummyContext = Util_Util.createCanvasElement().getContext(CONTEXT_2D);\n    return Text_dummyContext;\n}\nfunction Text_fillFunc(context) {\n    context.fillText(this._partialText, this._partialTextX, this._partialTextY);\n}\nfunction Text_strokeFunc(context) {\n    context.strokeText(this._partialText, this._partialTextX, this._partialTextY);\n}\nfunction checkDefaultFill(config) {\n    config = config || {};\n    if (!config.fillLinearGradientColorStops &&\n        !config.fillRadialGradientColorStops &&\n        !config.fillPatternImage) {\n        config.fill = config.fill || 'black';\n    }\n    return config;\n}\nclass Text extends Shape {\n    constructor(config) {\n        super(checkDefaultFill(config));\n        this._partialTextX = 0;\n        this._partialTextY = 0;\n        for (var n = 0; n < Text_attrChangeListLen; n++) {\n            this.on(Text_ATTR_CHANGE_LIST[n] + Text_CHANGE_KONVA, this._setTextData);\n        }\n        this._setTextData();\n    }\n    _sceneFunc(context) {\n        var textArr = this.textArr, textArrLen = textArr.length;\n        if (!this.text()) {\n            return;\n        }\n        var padding = this.padding(), fontSize = this.fontSize(), lineHeightPx = this.lineHeight() * fontSize, verticalAlign = this.verticalAlign(), alignY = 0, align = this.align(), totalWidth = this.getWidth(), letterSpacing = this.letterSpacing(), fill = this.fill(), textDecoration = this.textDecoration(), shouldUnderline = textDecoration.indexOf('underline') !== -1, shouldLineThrough = textDecoration.indexOf('line-through') !== -1, n;\n        var translateY = 0;\n        var translateY = lineHeightPx / 2;\n        var lineTranslateX = 0;\n        var lineTranslateY = 0;\n        context.setAttr('font', this._getContextFont());\n        context.setAttr('textBaseline', MIDDLE);\n        context.setAttr('textAlign', Text_LEFT);\n        if (verticalAlign === MIDDLE) {\n            alignY = (this.getHeight() - textArrLen * lineHeightPx - padding * 2) / 2;\n        }\n        else if (verticalAlign === BOTTOM) {\n            alignY = this.getHeight() - textArrLen * lineHeightPx - padding * 2;\n        }\n        context.translate(padding, alignY + padding);\n        for (n = 0; n < textArrLen; n++) {\n            var lineTranslateX = 0;\n            var lineTranslateY = 0;\n            var obj = textArr[n], text = obj.text, width = obj.width, lastLine = obj.lastInParagraph, spacesNumber, oneWord, lineWidth;\n            context.save();\n            if (align === Text_RIGHT) {\n                lineTranslateX += totalWidth - width - padding * 2;\n            }\n            else if (align === CENTER) {\n                lineTranslateX += (totalWidth - width - padding * 2) / 2;\n            }\n            if (shouldUnderline) {\n                context.save();\n                context.beginPath();\n                context.moveTo(lineTranslateX, translateY + lineTranslateY + Math.round(fontSize / 2));\n                spacesNumber = text.split(' ').length - 1;\n                oneWord = spacesNumber === 0;\n                lineWidth =\n                    align === JUSTIFY && lastLine && !oneWord\n                        ? totalWidth - padding * 2\n                        : width;\n                context.lineTo(lineTranslateX + Math.round(lineWidth), translateY + lineTranslateY + Math.round(fontSize / 2));\n                context.lineWidth = fontSize / 15;\n                context.strokeStyle = fill;\n                context.stroke();\n                context.restore();\n            }\n            if (shouldLineThrough) {\n                context.save();\n                context.beginPath();\n                context.moveTo(lineTranslateX, translateY + lineTranslateY);\n                spacesNumber = text.split(' ').length - 1;\n                oneWord = spacesNumber === 0;\n                lineWidth =\n                    align === JUSTIFY && lastLine && !oneWord\n                        ? totalWidth - padding * 2\n                        : width;\n                context.lineTo(lineTranslateX + Math.round(lineWidth), translateY + lineTranslateY);\n                context.lineWidth = fontSize / 15;\n                context.strokeStyle = fill;\n                context.stroke();\n                context.restore();\n            }\n            if (letterSpacing !== 0 || align === JUSTIFY) {\n                spacesNumber = text.split(' ').length - 1;\n                var array = stringToArray(text);\n                for (var li = 0; li < array.length; li++) {\n                    var letter = array[li];\n                    if (letter === ' ' && !lastLine && align === JUSTIFY) {\n                        lineTranslateX += (totalWidth - padding * 2 - width) / spacesNumber;\n                    }\n                    this._partialTextX = lineTranslateX;\n                    this._partialTextY = translateY + lineTranslateY;\n                    this._partialText = letter;\n                    context.fillStrokeShape(this);\n                    lineTranslateX += this.measureSize(letter).width + letterSpacing;\n                }\n            }\n            else {\n                this._partialTextX = lineTranslateX;\n                this._partialTextY = translateY + lineTranslateY;\n                this._partialText = text;\n                context.fillStrokeShape(this);\n            }\n            context.restore();\n            if (textArrLen > 1) {\n                translateY += lineHeightPx;\n            }\n        }\n    }\n    _hitFunc(context) {\n        var width = this.getWidth(), height = this.getHeight();\n        context.beginPath();\n        context.rect(0, 0, width, height);\n        context.closePath();\n        context.fillStrokeShape(this);\n    }\n    setText(text) {\n        var str = Util_Util._isString(text)\n            ? text\n            : text === null || text === undefined\n                ? ''\n                : text + '';\n        this._setAttr(TEXT, str);\n        return this;\n    }\n    getWidth() {\n        var isAuto = this.attrs.width === AUTO || this.attrs.width === undefined;\n        return isAuto ? this.getTextWidth() + this.padding() * 2 : this.attrs.width;\n    }\n    getHeight() {\n        var isAuto = this.attrs.height === AUTO || this.attrs.height === undefined;\n        return isAuto\n            ? this.fontSize() * this.textArr.length * this.lineHeight() +\n                this.padding() * 2\n            : this.attrs.height;\n    }\n    getTextWidth() {\n        return this.textWidth;\n    }\n    getTextHeight() {\n        Util_Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');\n        return this.textHeight;\n    }\n    measureSize(text) {\n        var _context = Text_getDummyContext(), fontSize = this.fontSize(), metrics;\n        _context.save();\n        _context.font = this._getContextFont();\n        metrics = _context.measureText(text);\n        _context.restore();\n        return {\n            width: metrics.width,\n            height: fontSize,\n        };\n    }\n    _getContextFont() {\n        return (this.fontStyle() +\n            Text_SPACE +\n            this.fontVariant() +\n            Text_SPACE +\n            (this.fontSize() + PX_SPACE) +\n            normalizeFontFamily(this.fontFamily()));\n    }\n    _addTextLine(line) {\n        if (this.align() === JUSTIFY) {\n            line = line.trim();\n        }\n        var width = this._getTextWidth(line);\n        return this.textArr.push({\n            text: line,\n            width: width,\n            lastInParagraph: false,\n        });\n    }\n    _getTextWidth(text) {\n        var letterSpacing = this.letterSpacing();\n        var length = text.length;\n        return (Text_getDummyContext().measureText(text).width +\n            (length ? letterSpacing * (length - 1) : 0));\n    }\n    _setTextData() {\n        var lines = this.text().split('\\n'), fontSize = +this.fontSize(), textWidth = 0, lineHeightPx = this.lineHeight() * fontSize, width = this.attrs.width, height = this.attrs.height, fixedWidth = width !== AUTO && width !== undefined, fixedHeight = height !== AUTO && height !== undefined, padding = this.padding(), maxWidth = width - padding * 2, maxHeightPx = height - padding * 2, currentHeightPx = 0, wrap = this.wrap(), shouldWrap = wrap !== Text_NONE, wrapAtWord = wrap !== CHAR && shouldWrap, shouldAddEllipsis = this.ellipsis();\n        this.textArr = [];\n        Text_getDummyContext().font = this._getContextFont();\n        var additionalWidth = shouldAddEllipsis ? this._getTextWidth(ELLIPSIS) : 0;\n        for (var i = 0, max = lines.length; i < max; ++i) {\n            var line = lines[i];\n            var lineWidth = this._getTextWidth(line);\n            if (fixedWidth && lineWidth > maxWidth) {\n                while (line.length > 0) {\n                    var low = 0, high = line.length, match = '', matchWidth = 0;\n                    while (low < high) {\n                        var mid = (low + high) >>> 1, substr = line.slice(0, mid + 1), substrWidth = this._getTextWidth(substr) + additionalWidth;\n                        if (substrWidth <= maxWidth) {\n                            low = mid + 1;\n                            match = substr;\n                            matchWidth = substrWidth;\n                        }\n                        else {\n                            high = mid;\n                        }\n                    }\n                    if (match) {\n                        if (wrapAtWord) {\n                            var wrapIndex;\n                            var nextChar = line[match.length];\n                            var nextIsSpaceOrDash = nextChar === Text_SPACE || nextChar === DASH;\n                            if (nextIsSpaceOrDash && matchWidth <= maxWidth) {\n                                wrapIndex = match.length;\n                            }\n                            else {\n                                wrapIndex =\n                                    Math.max(match.lastIndexOf(Text_SPACE), match.lastIndexOf(DASH)) +\n                                        1;\n                            }\n                            if (wrapIndex > 0) {\n                                low = wrapIndex;\n                                match = match.slice(0, low);\n                                matchWidth = this._getTextWidth(match);\n                            }\n                        }\n                        match = match.trimRight();\n                        this._addTextLine(match);\n                        textWidth = Math.max(textWidth, matchWidth);\n                        currentHeightPx += lineHeightPx;\n                        if (!shouldWrap ||\n                            (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx)) {\n                            var lastLine = this.textArr[this.textArr.length - 1];\n                            if (lastLine) {\n                                if (shouldAddEllipsis) {\n                                    var haveSpace = this._getTextWidth(lastLine.text + ELLIPSIS) < maxWidth;\n                                    if (!haveSpace) {\n                                        lastLine.text = lastLine.text.slice(0, lastLine.text.length - 3);\n                                    }\n                                    this.textArr.splice(this.textArr.length - 1, 1);\n                                    this._addTextLine(lastLine.text + ELLIPSIS);\n                                }\n                            }\n                            break;\n                        }\n                        line = line.slice(low);\n                        line = line.trimLeft();\n                        if (line.length > 0) {\n                            lineWidth = this._getTextWidth(line);\n                            if (lineWidth <= maxWidth) {\n                                this._addTextLine(line);\n                                currentHeightPx += lineHeightPx;\n                                textWidth = Math.max(textWidth, lineWidth);\n                                break;\n                            }\n                        }\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n            else {\n                this._addTextLine(line);\n                currentHeightPx += lineHeightPx;\n                textWidth = Math.max(textWidth, lineWidth);\n            }\n            if (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx) {\n                break;\n            }\n            if (this.textArr[this.textArr.length - 1]) {\n                this.textArr[this.textArr.length - 1].lastInParagraph = true;\n            }\n        }\n        this.textHeight = fontSize;\n        this.textWidth = textWidth;\n    }\n    getStrokeScaleEnabled() {\n        return true;\n    }\n}\nText.prototype._fillFunc = Text_fillFunc;\nText.prototype._strokeFunc = Text_strokeFunc;\nText.prototype.className = TEXT_UPPER;\nText.prototype._attrsAffectingSize = [\n    'text',\n    'fontSize',\n    'padding',\n    'wrap',\n    'lineHeight',\n    'letterSpacing',\n];\n_registerNode(Text);\nFactory.overWriteSetter(Text, 'width', getNumberOrAutoValidator());\nFactory.overWriteSetter(Text, 'height', getNumberOrAutoValidator());\nFactory.addGetterSetter(Text, 'fontFamily', 'Arial');\nFactory.addGetterSetter(Text, 'fontSize', 12, getNumberValidator());\nFactory.addGetterSetter(Text, 'fontStyle', NORMAL);\nFactory.addGetterSetter(Text, 'fontVariant', NORMAL);\nFactory.addGetterSetter(Text, 'padding', 0, getNumberValidator());\nFactory.addGetterSetter(Text, 'align', Text_LEFT);\nFactory.addGetterSetter(Text, 'verticalAlign', TOP);\nFactory.addGetterSetter(Text, 'lineHeight', 1, getNumberValidator());\nFactory.addGetterSetter(Text, 'wrap', WORD);\nFactory.addGetterSetter(Text, 'ellipsis', false, getBooleanValidator());\nFactory.addGetterSetter(Text, 'letterSpacing', 0, getNumberValidator());\nFactory.addGetterSetter(Text, 'text', '', getStringValidator());\nFactory.addGetterSetter(Text, 'textDecoration', '');\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/shapes/TextPath.js\n\n\n\n\n\n\n\nvar TextPath_EMPTY_STRING = '', TextPath_NORMAL = 'normal';\nfunction TextPath_fillFunc(context) {\n    context.fillText(this.partialText, 0, 0);\n}\nfunction TextPath_strokeFunc(context) {\n    context.strokeText(this.partialText, 0, 0);\n}\nclass TextPath extends Shape {\n    constructor(config) {\n        super(config);\n        this.dummyCanvas = Util_Util.createCanvasElement();\n        this.dataArray = [];\n        this.dataArray = Path.parsePathData(this.attrs.data);\n        this.on('dataChange.konva', function () {\n            this.dataArray = Path.parsePathData(this.attrs.data);\n            this._setTextData();\n        });\n        this.on('textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva fontFamilyChange.konva', this._setTextData);\n        this._setTextData();\n    }\n    _sceneFunc(context) {\n        context.setAttr('font', this._getContextFont());\n        context.setAttr('textBaseline', this.textBaseline());\n        context.setAttr('textAlign', 'left');\n        context.save();\n        var textDecoration = this.textDecoration();\n        var fill = this.fill();\n        var fontSize = this.fontSize();\n        var glyphInfo = this.glyphInfo;\n        if (textDecoration === 'underline') {\n            context.beginPath();\n        }\n        for (var i = 0; i < glyphInfo.length; i++) {\n            context.save();\n            var p0 = glyphInfo[i].p0;\n            context.translate(p0.x, p0.y);\n            context.rotate(glyphInfo[i].rotation);\n            this.partialText = glyphInfo[i].text;\n            context.fillStrokeShape(this);\n            if (textDecoration === 'underline') {\n                if (i === 0) {\n                    context.moveTo(0, fontSize / 2 + 1);\n                }\n                context.lineTo(fontSize, fontSize / 2 + 1);\n            }\n            context.restore();\n        }\n        if (textDecoration === 'underline') {\n            context.strokeStyle = fill;\n            context.lineWidth = fontSize / 20;\n            context.stroke();\n        }\n        context.restore();\n    }\n    _hitFunc(context) {\n        context.beginPath();\n        var glyphInfo = this.glyphInfo;\n        if (glyphInfo.length >= 1) {\n            var p0 = glyphInfo[0].p0;\n            context.moveTo(p0.x, p0.y);\n        }\n        for (var i = 0; i < glyphInfo.length; i++) {\n            var p1 = glyphInfo[i].p1;\n            context.lineTo(p1.x, p1.y);\n        }\n        context.setAttr('lineWidth', this.fontSize());\n        context.setAttr('strokeStyle', this.colorKey);\n        context.stroke();\n    }\n    getTextWidth() {\n        return this.textWidth;\n    }\n    getTextHeight() {\n        Util_Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');\n        return this.textHeight;\n    }\n    setText(text) {\n        return Text.prototype.setText.call(this, text);\n    }\n    _getContextFont() {\n        return Text.prototype._getContextFont.call(this);\n    }\n    _getTextSize(text) {\n        var dummyCanvas = this.dummyCanvas;\n        var _context = dummyCanvas.getContext('2d');\n        _context.save();\n        _context.font = this._getContextFont();\n        var metrics = _context.measureText(text);\n        _context.restore();\n        return {\n            width: metrics.width,\n            height: parseInt(this.attrs.fontSize, 10),\n        };\n    }\n    _setTextData() {\n        var that = this;\n        var size = this._getTextSize(this.attrs.text);\n        var letterSpacing = this.letterSpacing();\n        var align = this.align();\n        var kerningFunc = this.kerningFunc();\n        this.textWidth = size.width;\n        this.textHeight = size.height;\n        var textFullWidth = Math.max(this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing, 0);\n        this.glyphInfo = [];\n        var fullPathWidth = 0;\n        for (var l = 0; l < that.dataArray.length; l++) {\n            if (that.dataArray[l].pathLength > 0) {\n                fullPathWidth += that.dataArray[l].pathLength;\n            }\n        }\n        var offset = 0;\n        if (align === 'center') {\n            offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);\n        }\n        if (align === 'right') {\n            offset = Math.max(0, fullPathWidth - textFullWidth);\n        }\n        var charArr = stringToArray(this.text());\n        var spacesNumber = this.text().split(' ').length - 1;\n        var p0, p1, pathCmd;\n        var pIndex = -1;\n        var currentT = 0;\n        var getNextPathSegment = function () {\n            currentT = 0;\n            var pathData = that.dataArray;\n            for (var j = pIndex + 1; j < pathData.length; j++) {\n                if (pathData[j].pathLength > 0) {\n                    pIndex = j;\n                    return pathData[j];\n                }\n                else if (pathData[j].command === 'M') {\n                    p0 = {\n                        x: pathData[j].points[0],\n                        y: pathData[j].points[1],\n                    };\n                }\n            }\n            return {};\n        };\n        var findSegmentToFitCharacter = function (c) {\n            var glyphWidth = that._getTextSize(c).width + letterSpacing;\n            if (c === ' ' && align === 'justify') {\n                glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n            }\n            var currLen = 0;\n            var attempts = 0;\n            p1 = undefined;\n            while (Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 &&\n                attempts < 20) {\n                attempts++;\n                var cumulativePathLength = currLen;\n                while (pathCmd === undefined) {\n                    pathCmd = getNextPathSegment();\n                    if (pathCmd &&\n                        cumulativePathLength + pathCmd.pathLength < glyphWidth) {\n                        cumulativePathLength += pathCmd.pathLength;\n                        pathCmd = undefined;\n                    }\n                }\n                if (pathCmd === {} || p0 === undefined) {\n                    return undefined;\n                }\n                var needNewSegment = false;\n                switch (pathCmd.command) {\n                    case 'L':\n                        if (Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {\n                            p1 = Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);\n                        }\n                        else {\n                            pathCmd = undefined;\n                        }\n                        break;\n                    case 'A':\n                        var start = pathCmd.points[4];\n                        var dTheta = pathCmd.points[5];\n                        var end = pathCmd.points[4] + dTheta;\n                        if (currentT === 0) {\n                            currentT = start + 0.00000001;\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += ((Math.PI / 180.0) * dTheta) / Math.abs(dTheta);\n                        }\n                        else {\n                            currentT -= ((Math.PI / 360.0) * dTheta) / Math.abs(dTheta);\n                        }\n                        if ((dTheta < 0 && currentT < end) ||\n                            (dTheta >= 0 && currentT > end)) {\n                            currentT = end;\n                            needNewSegment = true;\n                        }\n                        p1 = Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);\n                        break;\n                    case 'C':\n                        if (currentT === 0) {\n                            if (glyphWidth > pathCmd.pathLength) {\n                                currentT = 0.00000001;\n                            }\n                            else {\n                                currentT = glyphWidth / pathCmd.pathLength;\n                            }\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength / 2;\n                        }\n                        else {\n                            currentT = Math.max(currentT - (currLen - glyphWidth) / pathCmd.pathLength / 2, 0);\n                        }\n                        if (currentT > 1.0) {\n                            currentT = 1.0;\n                            needNewSegment = true;\n                        }\n                        p1 = Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);\n                        break;\n                    case 'Q':\n                        if (currentT === 0) {\n                            currentT = glyphWidth / pathCmd.pathLength;\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength;\n                        }\n                        else {\n                            currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\n                        }\n                        if (currentT > 1.0) {\n                            currentT = 1.0;\n                            needNewSegment = true;\n                        }\n                        p1 = Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);\n                        break;\n                }\n                if (p1 !== undefined) {\n                    currLen = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n                }\n                if (needNewSegment) {\n                    needNewSegment = false;\n                    pathCmd = undefined;\n                }\n            }\n        };\n        var testChar = 'C';\n        var glyphWidth = that._getTextSize(testChar).width + letterSpacing;\n        var lettersInOffset = offset / glyphWidth - 1;\n        for (var k = 0; k < lettersInOffset; k++) {\n            findSegmentToFitCharacter(testChar);\n            if (p0 === undefined || p1 === undefined) {\n                break;\n            }\n            p0 = p1;\n        }\n        for (var i = 0; i < charArr.length; i++) {\n            findSegmentToFitCharacter(charArr[i]);\n            if (p0 === undefined || p1 === undefined) {\n                break;\n            }\n            var width = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n            var kern = 0;\n            if (kerningFunc) {\n                try {\n                    kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();\n                }\n                catch (e) {\n                    kern = 0;\n                }\n            }\n            p0.x += kern;\n            p1.x += kern;\n            this.textWidth += kern;\n            var midpoint = Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);\n            var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);\n            this.glyphInfo.push({\n                transposeX: midpoint.x,\n                transposeY: midpoint.y,\n                text: charArr[i],\n                rotation: rotation,\n                p0: p0,\n                p1: p1,\n            });\n            p0 = p1;\n        }\n    }\n    getSelfRect() {\n        if (!this.glyphInfo.length) {\n            return {\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0,\n            };\n        }\n        var points = [];\n        this.glyphInfo.forEach(function (info) {\n            points.push(info.p0.x);\n            points.push(info.p0.y);\n            points.push(info.p1.x);\n            points.push(info.p1.y);\n        });\n        var minX = points[0] || 0;\n        var maxX = points[0] || 0;\n        var minY = points[1] || 0;\n        var maxY = points[1] || 0;\n        var x, y;\n        for (var i = 0; i < points.length / 2; i++) {\n            x = points[i * 2];\n            y = points[i * 2 + 1];\n            minX = Math.min(minX, x);\n            maxX = Math.max(maxX, x);\n            minY = Math.min(minY, y);\n            maxY = Math.max(maxY, y);\n        }\n        var fontSize = this.fontSize();\n        return {\n            x: minX - fontSize / 2,\n            y: minY - fontSize / 2,\n            width: maxX - minX + fontSize,\n            height: maxY - minY + fontSize,\n        };\n    }\n}\nTextPath.prototype._fillFunc = TextPath_fillFunc;\nTextPath.prototype._strokeFunc = TextPath_strokeFunc;\nTextPath.prototype._fillFuncHit = TextPath_fillFunc;\nTextPath.prototype._strokeFuncHit = TextPath_strokeFunc;\nTextPath.prototype.className = 'TextPath';\nTextPath.prototype._attrsAffectingSize = ['text', 'fontSize', 'data'];\n_registerNode(TextPath);\nFactory.addGetterSetter(TextPath, 'data');\nFactory.addGetterSetter(TextPath, 'fontFamily', 'Arial');\nFactory.addGetterSetter(TextPath, 'fontSize', 12, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'fontStyle', TextPath_NORMAL);\nFactory.addGetterSetter(TextPath, 'align', 'left');\nFactory.addGetterSetter(TextPath, 'letterSpacing', 0, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'textBaseline', 'middle');\nFactory.addGetterSetter(TextPath, 'fontVariant', TextPath_NORMAL);\nFactory.addGetterSetter(TextPath, 'text', TextPath_EMPTY_STRING);\nFactory.addGetterSetter(TextPath, 'textDecoration', null);\nFactory.addGetterSetter(TextPath, 'kerningFunc', null);\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/shapes/Transformer.js\n\n\n\n\n\n\n\n\n\nvar EVENTS_NAME = 'tr-konva';\nvar Transformer_ATTR_CHANGE_LIST = [\n    'resizeEnabledChange',\n    'rotateAnchorOffsetChange',\n    'rotateEnabledChange',\n    'enabledAnchorsChange',\n    'anchorSizeChange',\n    'borderEnabledChange',\n    'borderStrokeChange',\n    'borderStrokeWidthChange',\n    'borderDashChange',\n    'anchorStrokeChange',\n    'anchorStrokeWidthChange',\n    'anchorFillChange',\n    'anchorCornerRadiusChange',\n    'ignoreStrokeChange',\n]\n    .map((e) => e + `.${EVENTS_NAME}`)\n    .join(' ');\nvar NODES_RECT = 'nodesRect';\nvar Transformer_TRANSFORM_CHANGE_STR = [\n    'widthChange',\n    'heightChange',\n    'scaleXChange',\n    'scaleYChange',\n    'skewXChange',\n    'skewYChange',\n    'rotationChange',\n    'offsetXChange',\n    'offsetYChange',\n    'transformsEnabledChange',\n    'strokeWidthChange',\n];\nvar ANGLES = {\n    'top-left': -45,\n    'top-center': 0,\n    'top-right': 45,\n    'middle-right': -90,\n    'middle-left': 90,\n    'bottom-left': -135,\n    'bottom-center': 180,\n    'bottom-right': 135,\n};\nconst TOUCH_DEVICE = \"ontouchstart\" in Global_Konva._global;\nfunction getCursor(anchorName, rad) {\n    if (anchorName === 'rotater') {\n        return 'crosshair';\n    }\n    rad += Util_Util.degToRad(ANGLES[anchorName] || 0);\n    var angle = ((Util_Util.radToDeg(rad) % 360) + 360) % 360;\n    if (Util_Util._inRange(angle, 315 + 22.5, 360) || Util_Util._inRange(angle, 0, 22.5)) {\n        return 'ns-resize';\n    }\n    else if (Util_Util._inRange(angle, 45 - 22.5, 45 + 22.5)) {\n        return 'nesw-resize';\n    }\n    else if (Util_Util._inRange(angle, 90 - 22.5, 90 + 22.5)) {\n        return 'ew-resize';\n    }\n    else if (Util_Util._inRange(angle, 135 - 22.5, 135 + 22.5)) {\n        return 'nwse-resize';\n    }\n    else if (Util_Util._inRange(angle, 180 - 22.5, 180 + 22.5)) {\n        return 'ns-resize';\n    }\n    else if (Util_Util._inRange(angle, 225 - 22.5, 225 + 22.5)) {\n        return 'nesw-resize';\n    }\n    else if (Util_Util._inRange(angle, 270 - 22.5, 270 + 22.5)) {\n        return 'ew-resize';\n    }\n    else if (Util_Util._inRange(angle, 315 - 22.5, 315 + 22.5)) {\n        return 'nwse-resize';\n    }\n    else {\n        Util_Util.error('Transformer has unknown angle for cursor detection: ' + angle);\n        return 'pointer';\n    }\n}\nvar ANCHORS_NAMES = [\n    'top-left',\n    'top-center',\n    'top-right',\n    'middle-right',\n    'middle-left',\n    'bottom-left',\n    'bottom-center',\n    'bottom-right',\n];\nvar MAX_SAFE_INTEGER = 100000000;\nfunction getCenter(shape) {\n    return {\n        x: shape.x +\n            (shape.width / 2) * Math.cos(shape.rotation) +\n            (shape.height / 2) * Math.sin(-shape.rotation),\n        y: shape.y +\n            (shape.height / 2) * Math.cos(shape.rotation) +\n            (shape.width / 2) * Math.sin(shape.rotation),\n    };\n}\nfunction rotateAroundPoint(shape, angleRad, point) {\n    const x = point.x +\n        (shape.x - point.x) * Math.cos(angleRad) -\n        (shape.y - point.y) * Math.sin(angleRad);\n    const y = point.y +\n        (shape.x - point.x) * Math.sin(angleRad) +\n        (shape.y - point.y) * Math.cos(angleRad);\n    return Object.assign(Object.assign({}, shape), { rotation: shape.rotation + angleRad, x,\n        y });\n}\nfunction rotateAroundCenter(shape, deltaRad) {\n    const center = getCenter(shape);\n    return rotateAroundPoint(shape, deltaRad, center);\n}\nfunction getSnap(snaps, newRotationRad, tol) {\n    let snapped = newRotationRad;\n    for (let i = 0; i < snaps.length; i++) {\n        const angle = Global_Konva.getAngle(snaps[i]);\n        const absDiff = Math.abs(angle - newRotationRad) % (Math.PI * 2);\n        const dif = Math.min(absDiff, Math.PI * 2 - absDiff);\n        if (dif < tol) {\n            snapped = angle;\n        }\n    }\n    return snapped;\n}\nclass Transformer extends Group {\n    constructor(config) {\n        super(config);\n        this._transforming = false;\n        this._createElements();\n        this._handleMouseMove = this._handleMouseMove.bind(this);\n        this._handleMouseUp = this._handleMouseUp.bind(this);\n        this.update = this.update.bind(this);\n        this.on(Transformer_ATTR_CHANGE_LIST, this.update);\n        if (this.getNode()) {\n            this.update();\n        }\n    }\n    attachTo(node) {\n        this.setNode(node);\n        return this;\n    }\n    setNode(node) {\n        Util_Util.warn('tr.setNode(shape), tr.node(shape) and tr.attachTo(shape) methods are deprecated. Please use tr.nodes(nodesArray) instead.');\n        return this.setNodes([node]);\n    }\n    getNode() {\n        return this._nodes && this._nodes[0];\n    }\n    _getEventNamespace() {\n        return EVENTS_NAME + this._id;\n    }\n    setNodes(nodes = []) {\n        if (this._nodes && this._nodes.length) {\n            this.detach();\n        }\n        this._nodes = nodes;\n        if (nodes.length === 1 && this.useSingleNodeRotation()) {\n            this.rotation(nodes[0].getAbsoluteRotation());\n        }\n        else {\n            this.rotation(0);\n        }\n        this._nodes.forEach((node) => {\n            const onChange = () => {\n                if (this.nodes().length === 1 && this.useSingleNodeRotation()) {\n                    this.rotation(this.nodes()[0].getAbsoluteRotation());\n                }\n                this._resetTransformCache();\n                if (!this._transforming && !this.isDragging()) {\n                    this.update();\n                }\n            };\n            const additionalEvents = node._attrsAffectingSize\n                .map((prop) => prop + 'Change.' + this._getEventNamespace())\n                .join(' ');\n            node.on(additionalEvents, onChange);\n            node.on(Transformer_TRANSFORM_CHANGE_STR.map((e) => e + `.${this._getEventNamespace()}`).join(' '), onChange);\n            node.on(`absoluteTransformChange.${this._getEventNamespace()}`, onChange);\n            this._proxyDrag(node);\n        });\n        this._resetTransformCache();\n        var elementsCreated = !!this.findOne('.top-left');\n        if (elementsCreated) {\n            this.update();\n        }\n        return this;\n    }\n    _proxyDrag(node) {\n        let lastPos;\n        node.on(`dragstart.${this._getEventNamespace()}`, (e) => {\n            lastPos = node.getAbsolutePosition();\n            if (!this.isDragging() && node !== this.findOne('.back')) {\n                this.startDrag(e, false);\n            }\n        });\n        node.on(`dragmove.${this._getEventNamespace()}`, (e) => {\n            if (!lastPos) {\n                return;\n            }\n            const abs = node.getAbsolutePosition();\n            const dx = abs.x - lastPos.x;\n            const dy = abs.y - lastPos.y;\n            this.nodes().forEach((otherNode) => {\n                if (otherNode === node) {\n                    return;\n                }\n                if (otherNode.isDragging()) {\n                    return;\n                }\n                const otherAbs = otherNode.getAbsolutePosition();\n                otherNode.setAbsolutePosition({\n                    x: otherAbs.x + dx,\n                    y: otherAbs.y + dy,\n                });\n                otherNode.startDrag(e);\n            });\n            lastPos = null;\n        });\n    }\n    getNodes() {\n        return this._nodes || [];\n    }\n    getActiveAnchor() {\n        return this._movingAnchorName;\n    }\n    detach() {\n        if (this._nodes) {\n            this._nodes.forEach((node) => {\n                node.off('.' + this._getEventNamespace());\n            });\n        }\n        this._nodes = [];\n        this._resetTransformCache();\n    }\n    _resetTransformCache() {\n        this._clearCache(NODES_RECT);\n        this._clearCache('transform');\n        this._clearSelfAndDescendantCache('absoluteTransform');\n    }\n    _getNodeRect() {\n        return this._getCache(NODES_RECT, this.__getNodeRect);\n    }\n    __getNodeShape(node, rot = this.rotation(), relative) {\n        var rect = node.getClientRect({\n            skipTransform: true,\n            skipShadow: true,\n            skipStroke: this.ignoreStroke(),\n        });\n        var absScale = node.getAbsoluteScale(relative);\n        var absPos = node.getAbsolutePosition(relative);\n        var dx = rect.x * absScale.x - node.offsetX() * absScale.x;\n        var dy = rect.y * absScale.y - node.offsetY() * absScale.y;\n        const rotation = (Global_Konva.getAngle(node.getAbsoluteRotation()) + Math.PI * 2) %\n            (Math.PI * 2);\n        const box = {\n            x: absPos.x + dx * Math.cos(rotation) + dy * Math.sin(-rotation),\n            y: absPos.y + dy * Math.cos(rotation) + dx * Math.sin(rotation),\n            width: rect.width * absScale.x,\n            height: rect.height * absScale.y,\n            rotation: rotation,\n        };\n        return rotateAroundPoint(box, -Global_Konva.getAngle(rot), {\n            x: 0,\n            y: 0,\n        });\n    }\n    __getNodeRect() {\n        var node = this.getNode();\n        if (!node) {\n            return {\n                x: -MAX_SAFE_INTEGER,\n                y: -MAX_SAFE_INTEGER,\n                width: 0,\n                height: 0,\n                rotation: 0,\n            };\n        }\n        const totalPoints = [];\n        this.nodes().map((node) => {\n            const box = node.getClientRect({\n                skipTransform: true,\n                skipShadow: true,\n                skipStroke: this.ignoreStroke(),\n            });\n            var points = [\n                { x: box.x, y: box.y },\n                { x: box.x + box.width, y: box.y },\n                { x: box.x + box.width, y: box.y + box.height },\n                { x: box.x, y: box.y + box.height },\n            ];\n            var trans = node.getAbsoluteTransform();\n            points.forEach(function (point) {\n                var transformed = trans.point(point);\n                totalPoints.push(transformed);\n            });\n        });\n        const tr = new Transform();\n        tr.rotate(-Global_Konva.getAngle(this.rotation()));\n        var minX, minY, maxX, maxY;\n        totalPoints.forEach(function (point) {\n            var transformed = tr.point(point);\n            if (minX === undefined) {\n                minX = maxX = transformed.x;\n                minY = maxY = transformed.y;\n            }\n            minX = Math.min(minX, transformed.x);\n            minY = Math.min(minY, transformed.y);\n            maxX = Math.max(maxX, transformed.x);\n            maxY = Math.max(maxY, transformed.y);\n        });\n        tr.invert();\n        const p = tr.point({ x: minX, y: minY });\n        return {\n            x: p.x,\n            y: p.y,\n            width: maxX - minX,\n            height: maxY - minY,\n            rotation: Global_Konva.getAngle(this.rotation()),\n        };\n    }\n    getX() {\n        return this._getNodeRect().x;\n    }\n    getY() {\n        return this._getNodeRect().y;\n    }\n    getWidth() {\n        return this._getNodeRect().width;\n    }\n    getHeight() {\n        return this._getNodeRect().height;\n    }\n    _createElements() {\n        this._createBack();\n        ANCHORS_NAMES.forEach(function (name) {\n            this._createAnchor(name);\n        }.bind(this));\n        this._createAnchor('rotater');\n    }\n    _createAnchor(name) {\n        var anchor = new Rect({\n            stroke: 'rgb(0, 161, 255)',\n            fill: 'white',\n            strokeWidth: 1,\n            name: name + ' _anchor',\n            dragDistance: 0,\n            draggable: true,\n            hitStrokeWidth: TOUCH_DEVICE ? 10 : 'auto',\n        });\n        var self = this;\n        anchor.on('mousedown touchstart', function (e) {\n            self._handleMouseDown(e);\n        });\n        anchor.on('dragstart', (e) => {\n            anchor.stopDrag();\n            e.cancelBubble = true;\n        });\n        anchor.on('dragend', (e) => {\n            e.cancelBubble = true;\n        });\n        anchor.on('mouseenter', () => {\n            var rad = Global_Konva.getAngle(this.rotation());\n            var cursor = getCursor(name, rad);\n            anchor.getStage().content &&\n                (anchor.getStage().content.style.cursor = cursor);\n            this._cursorChange = true;\n        });\n        anchor.on('mouseout', () => {\n            anchor.getStage().content &&\n                (anchor.getStage().content.style.cursor = '');\n            this._cursorChange = false;\n        });\n        this.add(anchor);\n    }\n    _createBack() {\n        var back = new Shape({\n            name: 'back',\n            width: 0,\n            height: 0,\n            draggable: true,\n            sceneFunc(ctx) {\n                var tr = this.getParent();\n                var padding = tr.padding();\n                ctx.beginPath();\n                ctx.rect(-padding, -padding, this.width() + padding * 2, this.height() + padding * 2);\n                ctx.moveTo(this.width() / 2, -padding);\n                if (tr.rotateEnabled()) {\n                    ctx.lineTo(this.width() / 2, -tr.rotateAnchorOffset() * Util_Util._sign(this.height()) - padding);\n                }\n                ctx.fillStrokeShape(this);\n            },\n            hitFunc: (ctx, shape) => {\n                if (!this.shouldOverdrawWholeArea()) {\n                    return;\n                }\n                var padding = this.padding();\n                ctx.beginPath();\n                ctx.rect(-padding, -padding, shape.width() + padding * 2, shape.height() + padding * 2);\n                ctx.fillStrokeShape(shape);\n            },\n        });\n        this.add(back);\n        this._proxyDrag(back);\n        back.on('dragstart', (e) => {\n            e.cancelBubble = true;\n        });\n        back.on('dragmove', (e) => {\n            e.cancelBubble = true;\n        });\n        back.on('dragend', (e) => {\n            e.cancelBubble = true;\n        });\n        this.on('dragmove', (e) => {\n            this.update();\n        });\n    }\n    _handleMouseDown(e) {\n        this._movingAnchorName = e.target.name().split(' ')[0];\n        var attrs = this._getNodeRect();\n        var width = attrs.width;\n        var height = attrs.height;\n        var hypotenuse = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));\n        this.sin = Math.abs(height / hypotenuse);\n        this.cos = Math.abs(width / hypotenuse);\n        if (typeof window !== 'undefined') {\n            window.addEventListener('mousemove', this._handleMouseMove);\n            window.addEventListener('touchmove', this._handleMouseMove);\n            window.addEventListener('mouseup', this._handleMouseUp, true);\n            window.addEventListener('touchend', this._handleMouseUp, true);\n        }\n        this._transforming = true;\n        var ap = e.target.getAbsolutePosition();\n        var pos = e.target.getStage().getPointerPosition();\n        this._anchorDragOffset = {\n            x: pos.x - ap.x,\n            y: pos.y - ap.y,\n        };\n        this._fire('transformstart', { evt: e.evt, target: this.getNode() });\n        this._nodes.forEach((target) => {\n            target._fire('transformstart', { evt: e.evt, target });\n        });\n    }\n    _handleMouseMove(e) {\n        var x, y, newHypotenuse;\n        var anchorNode = this.findOne('.' + this._movingAnchorName);\n        var stage = anchorNode.getStage();\n        stage.setPointersPositions(e);\n        const pp = stage.getPointerPosition();\n        let newNodePos = {\n            x: pp.x - this._anchorDragOffset.x,\n            y: pp.y - this._anchorDragOffset.y,\n        };\n        const oldAbs = anchorNode.getAbsolutePosition();\n        if (this.anchorDragBoundFunc()) {\n            newNodePos = this.anchorDragBoundFunc()(oldAbs, newNodePos, e);\n        }\n        anchorNode.setAbsolutePosition(newNodePos);\n        const newAbs = anchorNode.getAbsolutePosition();\n        if (oldAbs.x === newAbs.x && oldAbs.y === newAbs.y) {\n            return;\n        }\n        if (this._movingAnchorName === 'rotater') {\n            var attrs = this._getNodeRect();\n            x = anchorNode.x() - attrs.width / 2;\n            y = -anchorNode.y() + attrs.height / 2;\n            let delta = Math.atan2(-y, x) + Math.PI / 2;\n            if (attrs.height < 0) {\n                delta -= Math.PI;\n            }\n            var oldRotation = Global_Konva.getAngle(this.rotation());\n            const newRotation = oldRotation + delta;\n            const tol = Global_Konva.getAngle(this.rotationSnapTolerance());\n            const snappedRot = getSnap(this.rotationSnaps(), newRotation, tol);\n            const diff = snappedRot - attrs.rotation;\n            const shape = rotateAroundCenter(attrs, diff);\n            this._fitNodesInto(shape, e);\n            return;\n        }\n        var keepProportion = this.keepRatio() || e.shiftKey;\n        var centeredScaling = this.centeredScaling() || e.altKey;\n        if (this._movingAnchorName === 'top-left') {\n            if (keepProportion) {\n                var comparePoint = centeredScaling\n                    ? {\n                        x: this.width() / 2,\n                        y: this.height() / 2,\n                    }\n                    : {\n                        x: this.findOne('.bottom-right').x(),\n                        y: this.findOne('.bottom-right').y(),\n                    };\n                newHypotenuse = Math.sqrt(Math.pow(comparePoint.x - anchorNode.x(), 2) +\n                    Math.pow(comparePoint.y - anchorNode.y(), 2));\n                var reverseX = this.findOne('.top-left').x() > comparePoint.x ? -1 : 1;\n                var reverseY = this.findOne('.top-left').y() > comparePoint.y ? -1 : 1;\n                x = newHypotenuse * this.cos * reverseX;\n                y = newHypotenuse * this.sin * reverseY;\n                this.findOne('.top-left').x(comparePoint.x - x);\n                this.findOne('.top-left').y(comparePoint.y - y);\n            }\n        }\n        else if (this._movingAnchorName === 'top-center') {\n            this.findOne('.top-left').y(anchorNode.y());\n        }\n        else if (this._movingAnchorName === 'top-right') {\n            if (keepProportion) {\n                var comparePoint = centeredScaling\n                    ? {\n                        x: this.width() / 2,\n                        y: this.height() / 2,\n                    }\n                    : {\n                        x: this.findOne('.bottom-left').x(),\n                        y: this.findOne('.bottom-left').y(),\n                    };\n                newHypotenuse = Math.sqrt(Math.pow(anchorNode.x() - comparePoint.x, 2) +\n                    Math.pow(comparePoint.y - anchorNode.y(), 2));\n                var reverseX = this.findOne('.top-right').x() < comparePoint.x ? -1 : 1;\n                var reverseY = this.findOne('.top-right').y() > comparePoint.y ? -1 : 1;\n                x = newHypotenuse * this.cos * reverseX;\n                y = newHypotenuse * this.sin * reverseY;\n                this.findOne('.top-right').x(comparePoint.x + x);\n                this.findOne('.top-right').y(comparePoint.y - y);\n            }\n            var pos = anchorNode.position();\n            this.findOne('.top-left').y(pos.y);\n            this.findOne('.bottom-right').x(pos.x);\n        }\n        else if (this._movingAnchorName === 'middle-left') {\n            this.findOne('.top-left').x(anchorNode.x());\n        }\n        else if (this._movingAnchorName === 'middle-right') {\n            this.findOne('.bottom-right').x(anchorNode.x());\n        }\n        else if (this._movingAnchorName === 'bottom-left') {\n            if (keepProportion) {\n                var comparePoint = centeredScaling\n                    ? {\n                        x: this.width() / 2,\n                        y: this.height() / 2,\n                    }\n                    : {\n                        x: this.findOne('.top-right').x(),\n                        y: this.findOne('.top-right').y(),\n                    };\n                newHypotenuse = Math.sqrt(Math.pow(comparePoint.x - anchorNode.x(), 2) +\n                    Math.pow(anchorNode.y() - comparePoint.y, 2));\n                var reverseX = comparePoint.x < anchorNode.x() ? -1 : 1;\n                var reverseY = anchorNode.y() < comparePoint.y ? -1 : 1;\n                x = newHypotenuse * this.cos * reverseX;\n                y = newHypotenuse * this.sin * reverseY;\n                anchorNode.x(comparePoint.x - x);\n                anchorNode.y(comparePoint.y + y);\n            }\n            pos = anchorNode.position();\n            this.findOne('.top-left').x(pos.x);\n            this.findOne('.bottom-right').y(pos.y);\n        }\n        else if (this._movingAnchorName === 'bottom-center') {\n            this.findOne('.bottom-right').y(anchorNode.y());\n        }\n        else if (this._movingAnchorName === 'bottom-right') {\n            if (keepProportion) {\n                var comparePoint = centeredScaling\n                    ? {\n                        x: this.width() / 2,\n                        y: this.height() / 2,\n                    }\n                    : {\n                        x: this.findOne('.top-left').x(),\n                        y: this.findOne('.top-left').y(),\n                    };\n                newHypotenuse = Math.sqrt(Math.pow(anchorNode.x() - comparePoint.x, 2) +\n                    Math.pow(anchorNode.y() - comparePoint.y, 2));\n                var reverseX = this.findOne('.bottom-right').x() < comparePoint.x ? -1 : 1;\n                var reverseY = this.findOne('.bottom-right').y() < comparePoint.y ? -1 : 1;\n                x = newHypotenuse * this.cos * reverseX;\n                y = newHypotenuse * this.sin * reverseY;\n                this.findOne('.bottom-right').x(comparePoint.x + x);\n                this.findOne('.bottom-right').y(comparePoint.y + y);\n            }\n        }\n        else {\n            console.error(new Error('Wrong position argument of selection resizer: ' +\n                this._movingAnchorName));\n        }\n        var centeredScaling = this.centeredScaling() || e.altKey;\n        if (centeredScaling) {\n            var topLeft = this.findOne('.top-left');\n            var bottomRight = this.findOne('.bottom-right');\n            var topOffsetX = topLeft.x();\n            var topOffsetY = topLeft.y();\n            var bottomOffsetX = this.getWidth() - bottomRight.x();\n            var bottomOffsetY = this.getHeight() - bottomRight.y();\n            bottomRight.move({\n                x: -topOffsetX,\n                y: -topOffsetY,\n            });\n            topLeft.move({\n                x: bottomOffsetX,\n                y: bottomOffsetY,\n            });\n        }\n        var absPos = this.findOne('.top-left').getAbsolutePosition();\n        x = absPos.x;\n        y = absPos.y;\n        var width = this.findOne('.bottom-right').x() - this.findOne('.top-left').x();\n        var height = this.findOne('.bottom-right').y() - this.findOne('.top-left').y();\n        this._fitNodesInto({\n            x: x,\n            y: y,\n            width: width,\n            height: height,\n            rotation: Global_Konva.getAngle(this.rotation()),\n        }, e);\n    }\n    _handleMouseUp(e) {\n        this._removeEvents(e);\n    }\n    getAbsoluteTransform() {\n        return this.getTransform();\n    }\n    _removeEvents(e) {\n        if (this._transforming) {\n            this._transforming = false;\n            if (typeof window !== 'undefined') {\n                window.removeEventListener('mousemove', this._handleMouseMove);\n                window.removeEventListener('touchmove', this._handleMouseMove);\n                window.removeEventListener('mouseup', this._handleMouseUp, true);\n                window.removeEventListener('touchend', this._handleMouseUp, true);\n            }\n            var node = this.getNode();\n            this._fire('transformend', { evt: e, target: node });\n            if (node) {\n                this._nodes.forEach((target) => {\n                    target._fire('transformend', { evt: e, target });\n                });\n            }\n            this._movingAnchorName = null;\n        }\n    }\n    _fitNodesInto(newAttrs, evt) {\n        var oldAttrs = this._getNodeRect();\n        const minSize = 1;\n        if (Util_Util._inRange(newAttrs.width, -this.padding() * 2 - minSize, minSize)) {\n            this.update();\n            return;\n        }\n        if (Util_Util._inRange(newAttrs.height, -this.padding() * 2 - minSize, minSize)) {\n            this.update();\n            return;\n        }\n        const allowNegativeScale = this.flipEnabled();\n        var t = new Transform();\n        t.rotate(Global_Konva.getAngle(this.rotation()));\n        if (this._movingAnchorName &&\n            newAttrs.width < 0 &&\n            this._movingAnchorName.indexOf('left') >= 0) {\n            const offset = t.point({\n                x: -this.padding() * 2,\n                y: 0,\n            });\n            newAttrs.x += offset.x;\n            newAttrs.y += offset.y;\n            newAttrs.width += this.padding() * 2;\n            this._movingAnchorName = this._movingAnchorName.replace('left', 'right');\n            this._anchorDragOffset.x -= offset.x;\n            this._anchorDragOffset.y -= offset.y;\n            if (!allowNegativeScale) {\n                this.update();\n                return;\n            }\n        }\n        else if (this._movingAnchorName &&\n            newAttrs.width < 0 &&\n            this._movingAnchorName.indexOf('right') >= 0) {\n            const offset = t.point({\n                x: this.padding() * 2,\n                y: 0,\n            });\n            this._movingAnchorName = this._movingAnchorName.replace('right', 'left');\n            this._anchorDragOffset.x -= offset.x;\n            this._anchorDragOffset.y -= offset.y;\n            newAttrs.width += this.padding() * 2;\n            if (!allowNegativeScale) {\n                this.update();\n                return;\n            }\n        }\n        if (this._movingAnchorName &&\n            newAttrs.height < 0 &&\n            this._movingAnchorName.indexOf('top') >= 0) {\n            const offset = t.point({\n                x: 0,\n                y: -this.padding() * 2,\n            });\n            newAttrs.x += offset.x;\n            newAttrs.y += offset.y;\n            this._movingAnchorName = this._movingAnchorName.replace('top', 'bottom');\n            this._anchorDragOffset.x -= offset.x;\n            this._anchorDragOffset.y -= offset.y;\n            newAttrs.height += this.padding() * 2;\n            if (!allowNegativeScale) {\n                this.update();\n                return;\n            }\n        }\n        else if (this._movingAnchorName &&\n            newAttrs.height < 0 &&\n            this._movingAnchorName.indexOf('bottom') >= 0) {\n            const offset = t.point({\n                x: 0,\n                y: this.padding() * 2,\n            });\n            this._movingAnchorName = this._movingAnchorName.replace('bottom', 'top');\n            this._anchorDragOffset.x -= offset.x;\n            this._anchorDragOffset.y -= offset.y;\n            newAttrs.height += this.padding() * 2;\n            if (!allowNegativeScale) {\n                this.update();\n                return;\n            }\n        }\n        if (this.boundBoxFunc()) {\n            const bounded = this.boundBoxFunc()(oldAttrs, newAttrs);\n            if (bounded) {\n                newAttrs = bounded;\n            }\n            else {\n                Util_Util.warn('boundBoxFunc returned falsy. You should return new bound rect from it!');\n            }\n        }\n        const baseSize = 10000000;\n        const oldTr = new Transform();\n        oldTr.translate(oldAttrs.x, oldAttrs.y);\n        oldTr.rotate(oldAttrs.rotation);\n        oldTr.scale(oldAttrs.width / baseSize, oldAttrs.height / baseSize);\n        const newTr = new Transform();\n        newTr.translate(newAttrs.x, newAttrs.y);\n        newTr.rotate(newAttrs.rotation);\n        newTr.scale(newAttrs.width / baseSize, newAttrs.height / baseSize);\n        const delta = newTr.multiply(oldTr.invert());\n        this._nodes.forEach((node) => {\n            var _a;\n            const parentTransform = node.getParent().getAbsoluteTransform();\n            const localTransform = node.getTransform().copy();\n            localTransform.translate(node.offsetX(), node.offsetY());\n            const newLocalTransform = new Transform();\n            newLocalTransform\n                .multiply(parentTransform.copy().invert())\n                .multiply(delta)\n                .multiply(parentTransform)\n                .multiply(localTransform);\n            const attrs = newLocalTransform.decompose();\n            node.setAttrs(attrs);\n            this._fire('transform', { evt: evt, target: node });\n            node._fire('transform', { evt: evt, target: node });\n            (_a = node.getLayer()) === null || _a === void 0 ? void 0 : _a.batchDraw();\n        });\n        this.rotation(Util_Util._getRotation(newAttrs.rotation));\n        this._resetTransformCache();\n        this.update();\n        this.getLayer().batchDraw();\n    }\n    forceUpdate() {\n        this._resetTransformCache();\n        this.update();\n    }\n    _batchChangeChild(selector, attrs) {\n        const anchor = this.findOne(selector);\n        anchor.setAttrs(attrs);\n    }\n    update() {\n        var _a;\n        var attrs = this._getNodeRect();\n        this.rotation(Util_Util._getRotation(attrs.rotation));\n        var width = attrs.width;\n        var height = attrs.height;\n        var enabledAnchors = this.enabledAnchors();\n        var resizeEnabled = this.resizeEnabled();\n        var padding = this.padding();\n        var anchorSize = this.anchorSize();\n        this.find('._anchor').forEach((node) => {\n            node.setAttrs({\n                width: anchorSize,\n                height: anchorSize,\n                offsetX: anchorSize / 2,\n                offsetY: anchorSize / 2,\n                stroke: this.anchorStroke(),\n                strokeWidth: this.anchorStrokeWidth(),\n                fill: this.anchorFill(),\n                cornerRadius: this.anchorCornerRadius(),\n            });\n        });\n        this._batchChangeChild('.top-left', {\n            x: 0,\n            y: 0,\n            offsetX: anchorSize / 2 + padding,\n            offsetY: anchorSize / 2 + padding,\n            visible: resizeEnabled && enabledAnchors.indexOf('top-left') >= 0,\n        });\n        this._batchChangeChild('.top-center', {\n            x: width / 2,\n            y: 0,\n            offsetY: anchorSize / 2 + padding,\n            visible: resizeEnabled && enabledAnchors.indexOf('top-center') >= 0,\n        });\n        this._batchChangeChild('.top-right', {\n            x: width,\n            y: 0,\n            offsetX: anchorSize / 2 - padding,\n            offsetY: anchorSize / 2 + padding,\n            visible: resizeEnabled && enabledAnchors.indexOf('top-right') >= 0,\n        });\n        this._batchChangeChild('.middle-left', {\n            x: 0,\n            y: height / 2,\n            offsetX: anchorSize / 2 + padding,\n            visible: resizeEnabled && enabledAnchors.indexOf('middle-left') >= 0,\n        });\n        this._batchChangeChild('.middle-right', {\n            x: width,\n            y: height / 2,\n            offsetX: anchorSize / 2 - padding,\n            visible: resizeEnabled && enabledAnchors.indexOf('middle-right') >= 0,\n        });\n        this._batchChangeChild('.bottom-left', {\n            x: 0,\n            y: height,\n            offsetX: anchorSize / 2 + padding,\n            offsetY: anchorSize / 2 - padding,\n            visible: resizeEnabled && enabledAnchors.indexOf('bottom-left') >= 0,\n        });\n        this._batchChangeChild('.bottom-center', {\n            x: width / 2,\n            y: height,\n            offsetY: anchorSize / 2 - padding,\n            visible: resizeEnabled && enabledAnchors.indexOf('bottom-center') >= 0,\n        });\n        this._batchChangeChild('.bottom-right', {\n            x: width,\n            y: height,\n            offsetX: anchorSize / 2 - padding,\n            offsetY: anchorSize / 2 - padding,\n            visible: resizeEnabled && enabledAnchors.indexOf('bottom-right') >= 0,\n        });\n        this._batchChangeChild('.rotater', {\n            x: width / 2,\n            y: -this.rotateAnchorOffset() * Util_Util._sign(height) - padding,\n            visible: this.rotateEnabled(),\n        });\n        this._batchChangeChild('.back', {\n            width: width,\n            height: height,\n            visible: this.borderEnabled(),\n            stroke: this.borderStroke(),\n            strokeWidth: this.borderStrokeWidth(),\n            dash: this.borderDash(),\n            x: 0,\n            y: 0,\n        });\n        (_a = this.getLayer()) === null || _a === void 0 ? void 0 : _a.batchDraw();\n    }\n    isTransforming() {\n        return this._transforming;\n    }\n    stopTransform() {\n        if (this._transforming) {\n            this._removeEvents();\n            var anchorNode = this.findOne('.' + this._movingAnchorName);\n            if (anchorNode) {\n                anchorNode.stopDrag();\n            }\n        }\n    }\n    destroy() {\n        if (this.getStage() && this._cursorChange) {\n            this.getStage().content && (this.getStage().content.style.cursor = '');\n        }\n        Group.prototype.destroy.call(this);\n        this.detach();\n        this._removeEvents();\n        return this;\n    }\n    toObject() {\n        return Node.prototype.toObject.call(this);\n    }\n}\nfunction validateAnchors(val) {\n    if (!(val instanceof Array)) {\n        Util_Util.warn('enabledAnchors value should be an array');\n    }\n    if (val instanceof Array) {\n        val.forEach(function (name) {\n            if (ANCHORS_NAMES.indexOf(name) === -1) {\n                Util_Util.warn('Unknown anchor name: ' +\n                    name +\n                    '. Available names are: ' +\n                    ANCHORS_NAMES.join(', '));\n            }\n        });\n    }\n    return val || [];\n}\nTransformer.prototype.className = 'Transformer';\n_registerNode(Transformer);\nFactory.addGetterSetter(Transformer, 'enabledAnchors', ANCHORS_NAMES, validateAnchors);\nFactory.addGetterSetter(Transformer, 'flipEnabled', true, getBooleanValidator());\nFactory.addGetterSetter(Transformer, 'resizeEnabled', true);\nFactory.addGetterSetter(Transformer, 'anchorSize', 10, getNumberValidator());\nFactory.addGetterSetter(Transformer, 'rotateEnabled', true);\nFactory.addGetterSetter(Transformer, 'rotationSnaps', []);\nFactory.addGetterSetter(Transformer, 'rotateAnchorOffset', 50, getNumberValidator());\nFactory.addGetterSetter(Transformer, 'rotationSnapTolerance', 5, getNumberValidator());\nFactory.addGetterSetter(Transformer, 'borderEnabled', true);\nFactory.addGetterSetter(Transformer, 'anchorStroke', 'rgb(0, 161, 255)');\nFactory.addGetterSetter(Transformer, 'anchorStrokeWidth', 1, getNumberValidator());\nFactory.addGetterSetter(Transformer, 'anchorFill', 'white');\nFactory.addGetterSetter(Transformer, 'anchorCornerRadius', 0, getNumberValidator());\nFactory.addGetterSetter(Transformer, 'borderStroke', 'rgb(0, 161, 255)');\nFactory.addGetterSetter(Transformer, 'borderStrokeWidth', 1, getNumberValidator());\nFactory.addGetterSetter(Transformer, 'borderDash');\nFactory.addGetterSetter(Transformer, 'keepRatio', true);\nFactory.addGetterSetter(Transformer, 'centeredScaling', false);\nFactory.addGetterSetter(Transformer, 'ignoreStroke', false);\nFactory.addGetterSetter(Transformer, 'padding', 0, getNumberValidator());\nFactory.addGetterSetter(Transformer, 'node');\nFactory.addGetterSetter(Transformer, 'nodes');\nFactory.addGetterSetter(Transformer, 'boundBoxFunc');\nFactory.addGetterSetter(Transformer, 'anchorDragBoundFunc');\nFactory.addGetterSetter(Transformer, 'shouldOverdrawWholeArea', false);\nFactory.addGetterSetter(Transformer, 'useSingleNodeRotation', true);\nFactory.backCompat(Transformer, {\n    lineEnabled: 'borderEnabled',\n    rotateHandlerOffset: 'rotateAnchorOffset',\n    enabledHandlers: 'enabledAnchors',\n});\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/shapes/Wedge.js\n\n\n\n\n\nclass Wedge extends Shape {\n    _sceneFunc(context) {\n        context.beginPath();\n        context.arc(0, 0, this.radius(), 0, Global_Konva.getAngle(this.angle()), this.clockwise());\n        context.lineTo(0, 0);\n        context.closePath();\n        context.fillStrokeShape(this);\n    }\n    getWidth() {\n        return this.radius() * 2;\n    }\n    getHeight() {\n        return this.radius() * 2;\n    }\n    setWidth(width) {\n        this.radius(width / 2);\n    }\n    setHeight(height) {\n        this.radius(height / 2);\n    }\n}\nWedge.prototype.className = 'Wedge';\nWedge.prototype._centroid = true;\nWedge.prototype._attrsAffectingSize = ['radius'];\n_registerNode(Wedge);\nFactory.addGetterSetter(Wedge, 'radius', 0, getNumberValidator());\nFactory.addGetterSetter(Wedge, 'angle', 0, getNumberValidator());\nFactory.addGetterSetter(Wedge, 'clockwise', false);\nFactory.backCompat(Wedge, {\n    angleDeg: 'angle',\n    getAngleDeg: 'getAngle',\n    setAngleDeg: 'setAngle',\n});\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/filters/Blur.js\n\n\n\nfunction BlurStack() {\n    this.r = 0;\n    this.g = 0;\n    this.b = 0;\n    this.a = 0;\n    this.next = null;\n}\nvar mul_table = [\n    512,\n    512,\n    456,\n    512,\n    328,\n    456,\n    335,\n    512,\n    405,\n    328,\n    271,\n    456,\n    388,\n    335,\n    292,\n    512,\n    454,\n    405,\n    364,\n    328,\n    298,\n    271,\n    496,\n    456,\n    420,\n    388,\n    360,\n    335,\n    312,\n    292,\n    273,\n    512,\n    482,\n    454,\n    428,\n    405,\n    383,\n    364,\n    345,\n    328,\n    312,\n    298,\n    284,\n    271,\n    259,\n    496,\n    475,\n    456,\n    437,\n    420,\n    404,\n    388,\n    374,\n    360,\n    347,\n    335,\n    323,\n    312,\n    302,\n    292,\n    282,\n    273,\n    265,\n    512,\n    497,\n    482,\n    468,\n    454,\n    441,\n    428,\n    417,\n    405,\n    394,\n    383,\n    373,\n    364,\n    354,\n    345,\n    337,\n    328,\n    320,\n    312,\n    305,\n    298,\n    291,\n    284,\n    278,\n    271,\n    265,\n    259,\n    507,\n    496,\n    485,\n    475,\n    465,\n    456,\n    446,\n    437,\n    428,\n    420,\n    412,\n    404,\n    396,\n    388,\n    381,\n    374,\n    367,\n    360,\n    354,\n    347,\n    341,\n    335,\n    329,\n    323,\n    318,\n    312,\n    307,\n    302,\n    297,\n    292,\n    287,\n    282,\n    278,\n    273,\n    269,\n    265,\n    261,\n    512,\n    505,\n    497,\n    489,\n    482,\n    475,\n    468,\n    461,\n    454,\n    447,\n    441,\n    435,\n    428,\n    422,\n    417,\n    411,\n    405,\n    399,\n    394,\n    389,\n    383,\n    378,\n    373,\n    368,\n    364,\n    359,\n    354,\n    350,\n    345,\n    341,\n    337,\n    332,\n    328,\n    324,\n    320,\n    316,\n    312,\n    309,\n    305,\n    301,\n    298,\n    294,\n    291,\n    287,\n    284,\n    281,\n    278,\n    274,\n    271,\n    268,\n    265,\n    262,\n    259,\n    257,\n    507,\n    501,\n    496,\n    491,\n    485,\n    480,\n    475,\n    470,\n    465,\n    460,\n    456,\n    451,\n    446,\n    442,\n    437,\n    433,\n    428,\n    424,\n    420,\n    416,\n    412,\n    408,\n    404,\n    400,\n    396,\n    392,\n    388,\n    385,\n    381,\n    377,\n    374,\n    370,\n    367,\n    363,\n    360,\n    357,\n    354,\n    350,\n    347,\n    344,\n    341,\n    338,\n    335,\n    332,\n    329,\n    326,\n    323,\n    320,\n    318,\n    315,\n    312,\n    310,\n    307,\n    304,\n    302,\n    299,\n    297,\n    294,\n    292,\n    289,\n    287,\n    285,\n    282,\n    280,\n    278,\n    275,\n    273,\n    271,\n    269,\n    267,\n    265,\n    263,\n    261,\n    259,\n];\nvar shg_table = [\n    9,\n    11,\n    12,\n    13,\n    13,\n    14,\n    14,\n    15,\n    15,\n    15,\n    15,\n    16,\n    16,\n    16,\n    16,\n    17,\n    17,\n    17,\n    17,\n    17,\n    17,\n    17,\n    18,\n    18,\n    18,\n    18,\n    18,\n    18,\n    18,\n    18,\n    18,\n    19,\n    19,\n    19,\n    19,\n    19,\n    19,\n    19,\n    19,\n    19,\n    19,\n    19,\n    19,\n    19,\n    19,\n    20,\n    20,\n    20,\n    20,\n    20,\n    20,\n    20,\n    20,\n    20,\n    20,\n    20,\n    20,\n    20,\n    20,\n    20,\n    20,\n    20,\n    20,\n    21,\n    21,\n    21,\n    21,\n    21,\n    21,\n    21,\n    21,\n    21,\n    21,\n    21,\n    21,\n    21,\n    21,\n    21,\n    21,\n    21,\n    21,\n    21,\n    21,\n    21,\n    21,\n    21,\n    21,\n    21,\n    21,\n    21,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    22,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    23,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n];\nfunction filterGaussBlurRGBA(imageData, radius) {\n    var pixels = imageData.data, width = imageData.width, height = imageData.height;\n    var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, r_out_sum, g_out_sum, b_out_sum, a_out_sum, r_in_sum, g_in_sum, b_in_sum, a_in_sum, pr, pg, pb, pa, rbs;\n    var div = radius + radius + 1, widthMinus1 = width - 1, heightMinus1 = height - 1, radiusPlus1 = radius + 1, sumFactor = (radiusPlus1 * (radiusPlus1 + 1)) / 2, stackStart = new BlurStack(), stackEnd = null, stack = stackStart, stackIn = null, stackOut = null, mul_sum = mul_table[radius], shg_sum = shg_table[radius];\n    for (i = 1; i < div; i++) {\n        stack = stack.next = new BlurStack();\n        if (i === radiusPlus1) {\n            stackEnd = stack;\n        }\n    }\n    stack.next = stackStart;\n    yw = yi = 0;\n    for (y = 0; y < height; y++) {\n        r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;\n        r_out_sum = radiusPlus1 * (pr = pixels[yi]);\n        g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);\n        b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);\n        a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);\n        r_sum += sumFactor * pr;\n        g_sum += sumFactor * pg;\n        b_sum += sumFactor * pb;\n        a_sum += sumFactor * pa;\n        stack = stackStart;\n        for (i = 0; i < radiusPlus1; i++) {\n            stack.r = pr;\n            stack.g = pg;\n            stack.b = pb;\n            stack.a = pa;\n            stack = stack.next;\n        }\n        for (i = 1; i < radiusPlus1; i++) {\n            p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);\n            r_sum += (stack.r = pr = pixels[p]) * (rbs = radiusPlus1 - i);\n            g_sum += (stack.g = pg = pixels[p + 1]) * rbs;\n            b_sum += (stack.b = pb = pixels[p + 2]) * rbs;\n            a_sum += (stack.a = pa = pixels[p + 3]) * rbs;\n            r_in_sum += pr;\n            g_in_sum += pg;\n            b_in_sum += pb;\n            a_in_sum += pa;\n            stack = stack.next;\n        }\n        stackIn = stackStart;\n        stackOut = stackEnd;\n        for (x = 0; x < width; x++) {\n            pixels[yi + 3] = pa = (a_sum * mul_sum) >> shg_sum;\n            if (pa !== 0) {\n                pa = 255 / pa;\n                pixels[yi] = ((r_sum * mul_sum) >> shg_sum) * pa;\n                pixels[yi + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;\n                pixels[yi + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;\n            }\n            else {\n                pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;\n            }\n            r_sum -= r_out_sum;\n            g_sum -= g_out_sum;\n            b_sum -= b_out_sum;\n            a_sum -= a_out_sum;\n            r_out_sum -= stackIn.r;\n            g_out_sum -= stackIn.g;\n            b_out_sum -= stackIn.b;\n            a_out_sum -= stackIn.a;\n            p = (yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1)) << 2;\n            r_in_sum += stackIn.r = pixels[p];\n            g_in_sum += stackIn.g = pixels[p + 1];\n            b_in_sum += stackIn.b = pixels[p + 2];\n            a_in_sum += stackIn.a = pixels[p + 3];\n            r_sum += r_in_sum;\n            g_sum += g_in_sum;\n            b_sum += b_in_sum;\n            a_sum += a_in_sum;\n            stackIn = stackIn.next;\n            r_out_sum += pr = stackOut.r;\n            g_out_sum += pg = stackOut.g;\n            b_out_sum += pb = stackOut.b;\n            a_out_sum += pa = stackOut.a;\n            r_in_sum -= pr;\n            g_in_sum -= pg;\n            b_in_sum -= pb;\n            a_in_sum -= pa;\n            stackOut = stackOut.next;\n            yi += 4;\n        }\n        yw += width;\n    }\n    for (x = 0; x < width; x++) {\n        g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;\n        yi = x << 2;\n        r_out_sum = radiusPlus1 * (pr = pixels[yi]);\n        g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);\n        b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);\n        a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);\n        r_sum += sumFactor * pr;\n        g_sum += sumFactor * pg;\n        b_sum += sumFactor * pb;\n        a_sum += sumFactor * pa;\n        stack = stackStart;\n        for (i = 0; i < radiusPlus1; i++) {\n            stack.r = pr;\n            stack.g = pg;\n            stack.b = pb;\n            stack.a = pa;\n            stack = stack.next;\n        }\n        yp = width;\n        for (i = 1; i <= radius; i++) {\n            yi = (yp + x) << 2;\n            r_sum += (stack.r = pr = pixels[yi]) * (rbs = radiusPlus1 - i);\n            g_sum += (stack.g = pg = pixels[yi + 1]) * rbs;\n            b_sum += (stack.b = pb = pixels[yi + 2]) * rbs;\n            a_sum += (stack.a = pa = pixels[yi + 3]) * rbs;\n            r_in_sum += pr;\n            g_in_sum += pg;\n            b_in_sum += pb;\n            a_in_sum += pa;\n            stack = stack.next;\n            if (i < heightMinus1) {\n                yp += width;\n            }\n        }\n        yi = x;\n        stackIn = stackStart;\n        stackOut = stackEnd;\n        for (y = 0; y < height; y++) {\n            p = yi << 2;\n            pixels[p + 3] = pa = (a_sum * mul_sum) >> shg_sum;\n            if (pa > 0) {\n                pa = 255 / pa;\n                pixels[p] = ((r_sum * mul_sum) >> shg_sum) * pa;\n                pixels[p + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;\n                pixels[p + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;\n            }\n            else {\n                pixels[p] = pixels[p + 1] = pixels[p + 2] = 0;\n            }\n            r_sum -= r_out_sum;\n            g_sum -= g_out_sum;\n            b_sum -= b_out_sum;\n            a_sum -= a_out_sum;\n            r_out_sum -= stackIn.r;\n            g_out_sum -= stackIn.g;\n            b_out_sum -= stackIn.b;\n            a_out_sum -= stackIn.a;\n            p =\n                (x +\n                    ((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width) <<\n                    2;\n            r_sum += r_in_sum += stackIn.r = pixels[p];\n            g_sum += g_in_sum += stackIn.g = pixels[p + 1];\n            b_sum += b_in_sum += stackIn.b = pixels[p + 2];\n            a_sum += a_in_sum += stackIn.a = pixels[p + 3];\n            stackIn = stackIn.next;\n            r_out_sum += pr = stackOut.r;\n            g_out_sum += pg = stackOut.g;\n            b_out_sum += pb = stackOut.b;\n            a_out_sum += pa = stackOut.a;\n            r_in_sum -= pr;\n            g_in_sum -= pg;\n            b_in_sum -= pb;\n            a_in_sum -= pa;\n            stackOut = stackOut.next;\n            yi += width;\n        }\n    }\n}\nconst Blur = function Blur(imageData) {\n    var radius = Math.round(this.blurRadius());\n    if (radius > 0) {\n        filterGaussBlurRGBA(imageData, radius);\n    }\n};\nFactory.addGetterSetter(Node, 'blurRadius', 0, getNumberValidator(), Factory.afterSetFilter);\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/filters/Brighten.js\n\n\n\nconst Brighten = function (imageData) {\n    var brightness = this.brightness() * 255, data = imageData.data, len = data.length, i;\n    for (i = 0; i < len; i += 4) {\n        data[i] += brightness;\n        data[i + 1] += brightness;\n        data[i + 2] += brightness;\n    }\n};\nFactory.addGetterSetter(Node, 'brightness', 0, getNumberValidator(), Factory.afterSetFilter);\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/filters/Contrast.js\n\n\n\nconst Contrast = function (imageData) {\n    var adjust = Math.pow((this.contrast() + 100) / 100, 2);\n    var data = imageData.data, nPixels = data.length, red = 150, green = 150, blue = 150, i;\n    for (i = 0; i < nPixels; i += 4) {\n        red = data[i];\n        green = data[i + 1];\n        blue = data[i + 2];\n        red /= 255;\n        red -= 0.5;\n        red *= adjust;\n        red += 0.5;\n        red *= 255;\n        green /= 255;\n        green -= 0.5;\n        green *= adjust;\n        green += 0.5;\n        green *= 255;\n        blue /= 255;\n        blue -= 0.5;\n        blue *= adjust;\n        blue += 0.5;\n        blue *= 255;\n        red = red < 0 ? 0 : red > 255 ? 255 : red;\n        green = green < 0 ? 0 : green > 255 ? 255 : green;\n        blue = blue < 0 ? 0 : blue > 255 ? 255 : blue;\n        data[i] = red;\n        data[i + 1] = green;\n        data[i + 2] = blue;\n    }\n};\nFactory.addGetterSetter(Node, 'contrast', 0, getNumberValidator(), Factory.afterSetFilter);\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/filters/Emboss.js\n\n\n\n\nconst Emboss = function (imageData) {\n    var strength = this.embossStrength() * 10, greyLevel = this.embossWhiteLevel() * 255, direction = this.embossDirection(), blend = this.embossBlend(), dirY = 0, dirX = 0, data = imageData.data, w = imageData.width, h = imageData.height, w4 = w * 4, y = h;\n    switch (direction) {\n        case 'top-left':\n            dirY = -1;\n            dirX = -1;\n            break;\n        case 'top':\n            dirY = -1;\n            dirX = 0;\n            break;\n        case 'top-right':\n            dirY = -1;\n            dirX = 1;\n            break;\n        case 'right':\n            dirY = 0;\n            dirX = 1;\n            break;\n        case 'bottom-right':\n            dirY = 1;\n            dirX = 1;\n            break;\n        case 'bottom':\n            dirY = 1;\n            dirX = 0;\n            break;\n        case 'bottom-left':\n            dirY = 1;\n            dirX = -1;\n            break;\n        case 'left':\n            dirY = 0;\n            dirX = -1;\n            break;\n        default:\n            Util_Util.error('Unknown emboss direction: ' + direction);\n    }\n    do {\n        var offsetY = (y - 1) * w4;\n        var otherY = dirY;\n        if (y + otherY < 1) {\n            otherY = 0;\n        }\n        if (y + otherY > h) {\n            otherY = 0;\n        }\n        var offsetYOther = (y - 1 + otherY) * w * 4;\n        var x = w;\n        do {\n            var offset = offsetY + (x - 1) * 4;\n            var otherX = dirX;\n            if (x + otherX < 1) {\n                otherX = 0;\n            }\n            if (x + otherX > w) {\n                otherX = 0;\n            }\n            var offsetOther = offsetYOther + (x - 1 + otherX) * 4;\n            var dR = data[offset] - data[offsetOther];\n            var dG = data[offset + 1] - data[offsetOther + 1];\n            var dB = data[offset + 2] - data[offsetOther + 2];\n            var dif = dR;\n            var absDif = dif > 0 ? dif : -dif;\n            var absG = dG > 0 ? dG : -dG;\n            var absB = dB > 0 ? dB : -dB;\n            if (absG > absDif) {\n                dif = dG;\n            }\n            if (absB > absDif) {\n                dif = dB;\n            }\n            dif *= strength;\n            if (blend) {\n                var r = data[offset] + dif;\n                var g = data[offset + 1] + dif;\n                var b = data[offset + 2] + dif;\n                data[offset] = r > 255 ? 255 : r < 0 ? 0 : r;\n                data[offset + 1] = g > 255 ? 255 : g < 0 ? 0 : g;\n                data[offset + 2] = b > 255 ? 255 : b < 0 ? 0 : b;\n            }\n            else {\n                var grey = greyLevel - dif;\n                if (grey < 0) {\n                    grey = 0;\n                }\n                else if (grey > 255) {\n                    grey = 255;\n                }\n                data[offset] = data[offset + 1] = data[offset + 2] = grey;\n            }\n        } while (--x);\n    } while (--y);\n};\nFactory.addGetterSetter(Node, 'embossStrength', 0.5, getNumberValidator(), Factory.afterSetFilter);\nFactory.addGetterSetter(Node, 'embossWhiteLevel', 0.5, getNumberValidator(), Factory.afterSetFilter);\nFactory.addGetterSetter(Node, 'embossDirection', 'top-left', null, Factory.afterSetFilter);\nFactory.addGetterSetter(Node, 'embossBlend', false, null, Factory.afterSetFilter);\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/filters/Enhance.js\n\n\n\nfunction remap(fromValue, fromMin, fromMax, toMin, toMax) {\n    var fromRange = fromMax - fromMin, toRange = toMax - toMin, toValue;\n    if (fromRange === 0) {\n        return toMin + toRange / 2;\n    }\n    if (toRange === 0) {\n        return toMin;\n    }\n    toValue = (fromValue - fromMin) / fromRange;\n    toValue = toRange * toValue + toMin;\n    return toValue;\n}\nconst Enhance = function (imageData) {\n    var data = imageData.data, nSubPixels = data.length, rMin = data[0], rMax = rMin, r, gMin = data[1], gMax = gMin, g, bMin = data[2], bMax = bMin, b, i;\n    var enhanceAmount = this.enhance();\n    if (enhanceAmount === 0) {\n        return;\n    }\n    for (i = 0; i < nSubPixels; i += 4) {\n        r = data[i + 0];\n        if (r < rMin) {\n            rMin = r;\n        }\n        else if (r > rMax) {\n            rMax = r;\n        }\n        g = data[i + 1];\n        if (g < gMin) {\n            gMin = g;\n        }\n        else if (g > gMax) {\n            gMax = g;\n        }\n        b = data[i + 2];\n        if (b < bMin) {\n            bMin = b;\n        }\n        else if (b > bMax) {\n            bMax = b;\n        }\n    }\n    if (rMax === rMin) {\n        rMax = 255;\n        rMin = 0;\n    }\n    if (gMax === gMin) {\n        gMax = 255;\n        gMin = 0;\n    }\n    if (bMax === bMin) {\n        bMax = 255;\n        bMin = 0;\n    }\n    var rMid, rGoalMax, rGoalMin, gMid, gGoalMax, gGoalMin, bMid, bGoalMax, bGoalMin;\n    if (enhanceAmount > 0) {\n        rGoalMax = rMax + enhanceAmount * (255 - rMax);\n        rGoalMin = rMin - enhanceAmount * (rMin - 0);\n        gGoalMax = gMax + enhanceAmount * (255 - gMax);\n        gGoalMin = gMin - enhanceAmount * (gMin - 0);\n        bGoalMax = bMax + enhanceAmount * (255 - bMax);\n        bGoalMin = bMin - enhanceAmount * (bMin - 0);\n    }\n    else {\n        rMid = (rMax + rMin) * 0.5;\n        rGoalMax = rMax + enhanceAmount * (rMax - rMid);\n        rGoalMin = rMin + enhanceAmount * (rMin - rMid);\n        gMid = (gMax + gMin) * 0.5;\n        gGoalMax = gMax + enhanceAmount * (gMax - gMid);\n        gGoalMin = gMin + enhanceAmount * (gMin - gMid);\n        bMid = (bMax + bMin) * 0.5;\n        bGoalMax = bMax + enhanceAmount * (bMax - bMid);\n        bGoalMin = bMin + enhanceAmount * (bMin - bMid);\n    }\n    for (i = 0; i < nSubPixels; i += 4) {\n        data[i + 0] = remap(data[i + 0], rMin, rMax, rGoalMin, rGoalMax);\n        data[i + 1] = remap(data[i + 1], gMin, gMax, gGoalMin, gGoalMax);\n        data[i + 2] = remap(data[i + 2], bMin, bMax, bGoalMin, bGoalMax);\n    }\n};\nFactory.addGetterSetter(Node, 'enhance', 0, getNumberValidator(), Factory.afterSetFilter);\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/filters/Grayscale.js\nconst Grayscale = function (imageData) {\n    var data = imageData.data, len = data.length, i, brightness;\n    for (i = 0; i < len; i += 4) {\n        brightness = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2];\n        data[i] = brightness;\n        data[i + 1] = brightness;\n        data[i + 2] = brightness;\n    }\n};\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/filters/HSL.js\n\n\n\nFactory.addGetterSetter(Node, 'hue', 0, getNumberValidator(), Factory.afterSetFilter);\nFactory.addGetterSetter(Node, 'saturation', 0, getNumberValidator(), Factory.afterSetFilter);\nFactory.addGetterSetter(Node, 'luminance', 0, getNumberValidator(), Factory.afterSetFilter);\nconst HSL = function (imageData) {\n    var data = imageData.data, nPixels = data.length, v = 1, s = Math.pow(2, this.saturation()), h = Math.abs(this.hue() + 360) % 360, l = this.luminance() * 127, i;\n    var vsu = v * s * Math.cos((h * Math.PI) / 180), vsw = v * s * Math.sin((h * Math.PI) / 180);\n    var rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw, rg = 0.587 * v - 0.587 * vsu + 0.33 * vsw, rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;\n    var gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw, gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw, gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;\n    var br = 0.299 * v - 0.3 * vsu + 1.25 * vsw, bg = 0.587 * v - 0.586 * vsu - 1.05 * vsw, bb = 0.114 * v + 0.886 * vsu - 0.2 * vsw;\n    var r, g, b, a;\n    for (i = 0; i < nPixels; i += 4) {\n        r = data[i + 0];\n        g = data[i + 1];\n        b = data[i + 2];\n        a = data[i + 3];\n        data[i + 0] = rr * r + rg * g + rb * b + l;\n        data[i + 1] = gr * r + gg * g + gb * b + l;\n        data[i + 2] = br * r + bg * g + bb * b + l;\n        data[i + 3] = a;\n    }\n};\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/filters/HSV.js\n\n\n\nconst HSV = function (imageData) {\n    var data = imageData.data, nPixels = data.length, v = Math.pow(2, this.value()), s = Math.pow(2, this.saturation()), h = Math.abs(this.hue() + 360) % 360, i;\n    var vsu = v * s * Math.cos((h * Math.PI) / 180), vsw = v * s * Math.sin((h * Math.PI) / 180);\n    var rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw, rg = 0.587 * v - 0.587 * vsu + 0.33 * vsw, rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;\n    var gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw, gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw, gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;\n    var br = 0.299 * v - 0.3 * vsu + 1.25 * vsw, bg = 0.587 * v - 0.586 * vsu - 1.05 * vsw, bb = 0.114 * v + 0.886 * vsu - 0.2 * vsw;\n    var r, g, b, a;\n    for (i = 0; i < nPixels; i += 4) {\n        r = data[i + 0];\n        g = data[i + 1];\n        b = data[i + 2];\n        a = data[i + 3];\n        data[i + 0] = rr * r + rg * g + rb * b;\n        data[i + 1] = gr * r + gg * g + gb * b;\n        data[i + 2] = br * r + bg * g + bb * b;\n        data[i + 3] = a;\n    }\n};\nFactory.addGetterSetter(Node, 'hue', 0, getNumberValidator(), Factory.afterSetFilter);\nFactory.addGetterSetter(Node, 'saturation', 0, getNumberValidator(), Factory.afterSetFilter);\nFactory.addGetterSetter(Node, 'value', 0, getNumberValidator(), Factory.afterSetFilter);\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/filters/Invert.js\nconst Invert = function (imageData) {\n    var data = imageData.data, len = data.length, i;\n    for (i = 0; i < len; i += 4) {\n        data[i] = 255 - data[i];\n        data[i + 1] = 255 - data[i + 1];\n        data[i + 2] = 255 - data[i + 2];\n    }\n};\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/filters/Kaleidoscope.js\n\n\n\n\nvar ToPolar = function (src, dst, opt) {\n    var srcPixels = src.data, dstPixels = dst.data, xSize = src.width, ySize = src.height, xMid = opt.polarCenterX || xSize / 2, yMid = opt.polarCenterY || ySize / 2, i, x, y, r = 0, g = 0, b = 0, a = 0;\n    var rad, rMax = Math.sqrt(xMid * xMid + yMid * yMid);\n    x = xSize - xMid;\n    y = ySize - yMid;\n    rad = Math.sqrt(x * x + y * y);\n    rMax = rad > rMax ? rad : rMax;\n    var rSize = ySize, tSize = xSize, radius, theta;\n    var conversion = ((360 / tSize) * Math.PI) / 180, sin, cos;\n    for (theta = 0; theta < tSize; theta += 1) {\n        sin = Math.sin(theta * conversion);\n        cos = Math.cos(theta * conversion);\n        for (radius = 0; radius < rSize; radius += 1) {\n            x = Math.floor(xMid + ((rMax * radius) / rSize) * cos);\n            y = Math.floor(yMid + ((rMax * radius) / rSize) * sin);\n            i = (y * xSize + x) * 4;\n            r = srcPixels[i + 0];\n            g = srcPixels[i + 1];\n            b = srcPixels[i + 2];\n            a = srcPixels[i + 3];\n            i = (theta + radius * xSize) * 4;\n            dstPixels[i + 0] = r;\n            dstPixels[i + 1] = g;\n            dstPixels[i + 2] = b;\n            dstPixels[i + 3] = a;\n        }\n    }\n};\nvar FromPolar = function (src, dst, opt) {\n    var srcPixels = src.data, dstPixels = dst.data, xSize = src.width, ySize = src.height, xMid = opt.polarCenterX || xSize / 2, yMid = opt.polarCenterY || ySize / 2, i, x, y, dx, dy, r = 0, g = 0, b = 0, a = 0;\n    var rad, rMax = Math.sqrt(xMid * xMid + yMid * yMid);\n    x = xSize - xMid;\n    y = ySize - yMid;\n    rad = Math.sqrt(x * x + y * y);\n    rMax = rad > rMax ? rad : rMax;\n    var rSize = ySize, tSize = xSize, radius, theta, phaseShift = opt.polarRotation || 0;\n    var x1, y1;\n    for (x = 0; x < xSize; x += 1) {\n        for (y = 0; y < ySize; y += 1) {\n            dx = x - xMid;\n            dy = y - yMid;\n            radius = (Math.sqrt(dx * dx + dy * dy) * rSize) / rMax;\n            theta = ((Math.atan2(dy, dx) * 180) / Math.PI + 360 + phaseShift) % 360;\n            theta = (theta * tSize) / 360;\n            x1 = Math.floor(theta);\n            y1 = Math.floor(radius);\n            i = (y1 * xSize + x1) * 4;\n            r = srcPixels[i + 0];\n            g = srcPixels[i + 1];\n            b = srcPixels[i + 2];\n            a = srcPixels[i + 3];\n            i = (y * xSize + x) * 4;\n            dstPixels[i + 0] = r;\n            dstPixels[i + 1] = g;\n            dstPixels[i + 2] = b;\n            dstPixels[i + 3] = a;\n        }\n    }\n};\nconst Kaleidoscope = function (imageData) {\n    var xSize = imageData.width, ySize = imageData.height;\n    var x, y, xoff, i, r, g, b, a, srcPos, dstPos;\n    var power = Math.round(this.kaleidoscopePower());\n    var angle = Math.round(this.kaleidoscopeAngle());\n    var offset = Math.floor((xSize * (angle % 360)) / 360);\n    if (power < 1) {\n        return;\n    }\n    var tempCanvas = Util_Util.createCanvasElement();\n    tempCanvas.width = xSize;\n    tempCanvas.height = ySize;\n    var scratchData = tempCanvas\n        .getContext('2d')\n        .getImageData(0, 0, xSize, ySize);\n    ToPolar(imageData, scratchData, {\n        polarCenterX: xSize / 2,\n        polarCenterY: ySize / 2,\n    });\n    var minSectionSize = xSize / Math.pow(2, power);\n    while (minSectionSize <= 8) {\n        minSectionSize = minSectionSize * 2;\n        power -= 1;\n    }\n    minSectionSize = Math.ceil(minSectionSize);\n    var sectionSize = minSectionSize;\n    var xStart = 0, xEnd = sectionSize, xDelta = 1;\n    if (offset + minSectionSize > xSize) {\n        xStart = sectionSize;\n        xEnd = 0;\n        xDelta = -1;\n    }\n    for (y = 0; y < ySize; y += 1) {\n        for (x = xStart; x !== xEnd; x += xDelta) {\n            xoff = Math.round(x + offset) % xSize;\n            srcPos = (xSize * y + xoff) * 4;\n            r = scratchData.data[srcPos + 0];\n            g = scratchData.data[srcPos + 1];\n            b = scratchData.data[srcPos + 2];\n            a = scratchData.data[srcPos + 3];\n            dstPos = (xSize * y + x) * 4;\n            scratchData.data[dstPos + 0] = r;\n            scratchData.data[dstPos + 1] = g;\n            scratchData.data[dstPos + 2] = b;\n            scratchData.data[dstPos + 3] = a;\n        }\n    }\n    for (y = 0; y < ySize; y += 1) {\n        sectionSize = Math.floor(minSectionSize);\n        for (i = 0; i < power; i += 1) {\n            for (x = 0; x < sectionSize + 1; x += 1) {\n                srcPos = (xSize * y + x) * 4;\n                r = scratchData.data[srcPos + 0];\n                g = scratchData.data[srcPos + 1];\n                b = scratchData.data[srcPos + 2];\n                a = scratchData.data[srcPos + 3];\n                dstPos = (xSize * y + sectionSize * 2 - x - 1) * 4;\n                scratchData.data[dstPos + 0] = r;\n                scratchData.data[dstPos + 1] = g;\n                scratchData.data[dstPos + 2] = b;\n                scratchData.data[dstPos + 3] = a;\n            }\n            sectionSize *= 2;\n        }\n    }\n    FromPolar(scratchData, imageData, { polarRotation: 0 });\n};\nFactory.addGetterSetter(Node, 'kaleidoscopePower', 2, getNumberValidator(), Factory.afterSetFilter);\nFactory.addGetterSetter(Node, 'kaleidoscopeAngle', 0, getNumberValidator(), Factory.afterSetFilter);\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/filters/Mask.js\n\n\n\nfunction pixelAt(idata, x, y) {\n    var idx = (y * idata.width + x) * 4;\n    var d = [];\n    d.push(idata.data[idx++], idata.data[idx++], idata.data[idx++], idata.data[idx++]);\n    return d;\n}\nfunction rgbDistance(p1, p2) {\n    return Math.sqrt(Math.pow(p1[0] - p2[0], 2) +\n        Math.pow(p1[1] - p2[1], 2) +\n        Math.pow(p1[2] - p2[2], 2));\n}\nfunction rgbMean(pTab) {\n    var m = [0, 0, 0];\n    for (var i = 0; i < pTab.length; i++) {\n        m[0] += pTab[i][0];\n        m[1] += pTab[i][1];\n        m[2] += pTab[i][2];\n    }\n    m[0] /= pTab.length;\n    m[1] /= pTab.length;\n    m[2] /= pTab.length;\n    return m;\n}\nfunction backgroundMask(idata, threshold) {\n    var rgbv_no = pixelAt(idata, 0, 0);\n    var rgbv_ne = pixelAt(idata, idata.width - 1, 0);\n    var rgbv_so = pixelAt(idata, 0, idata.height - 1);\n    var rgbv_se = pixelAt(idata, idata.width - 1, idata.height - 1);\n    var thres = threshold || 10;\n    if (rgbDistance(rgbv_no, rgbv_ne) < thres &&\n        rgbDistance(rgbv_ne, rgbv_se) < thres &&\n        rgbDistance(rgbv_se, rgbv_so) < thres &&\n        rgbDistance(rgbv_so, rgbv_no) < thres) {\n        var mean = rgbMean([rgbv_ne, rgbv_no, rgbv_se, rgbv_so]);\n        var mask = [];\n        for (var i = 0; i < idata.width * idata.height; i++) {\n            var d = rgbDistance(mean, [\n                idata.data[i * 4],\n                idata.data[i * 4 + 1],\n                idata.data[i * 4 + 2],\n            ]);\n            mask[i] = d < thres ? 0 : 255;\n        }\n        return mask;\n    }\n}\nfunction applyMask(idata, mask) {\n    for (var i = 0; i < idata.width * idata.height; i++) {\n        idata.data[4 * i + 3] = mask[i];\n    }\n}\nfunction erodeMask(mask, sw, sh) {\n    var weights = [1, 1, 1, 1, 0, 1, 1, 1, 1];\n    var side = Math.round(Math.sqrt(weights.length));\n    var halfSide = Math.floor(side / 2);\n    var maskResult = [];\n    for (var y = 0; y < sh; y++) {\n        for (var x = 0; x < sw; x++) {\n            var so = y * sw + x;\n            var a = 0;\n            for (var cy = 0; cy < side; cy++) {\n                for (var cx = 0; cx < side; cx++) {\n                    var scy = y + cy - halfSide;\n                    var scx = x + cx - halfSide;\n                    if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {\n                        var srcOff = scy * sw + scx;\n                        var wt = weights[cy * side + cx];\n                        a += mask[srcOff] * wt;\n                    }\n                }\n            }\n            maskResult[so] = a === 255 * 8 ? 255 : 0;\n        }\n    }\n    return maskResult;\n}\nfunction dilateMask(mask, sw, sh) {\n    var weights = [1, 1, 1, 1, 1, 1, 1, 1, 1];\n    var side = Math.round(Math.sqrt(weights.length));\n    var halfSide = Math.floor(side / 2);\n    var maskResult = [];\n    for (var y = 0; y < sh; y++) {\n        for (var x = 0; x < sw; x++) {\n            var so = y * sw + x;\n            var a = 0;\n            for (var cy = 0; cy < side; cy++) {\n                for (var cx = 0; cx < side; cx++) {\n                    var scy = y + cy - halfSide;\n                    var scx = x + cx - halfSide;\n                    if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {\n                        var srcOff = scy * sw + scx;\n                        var wt = weights[cy * side + cx];\n                        a += mask[srcOff] * wt;\n                    }\n                }\n            }\n            maskResult[so] = a >= 255 * 4 ? 255 : 0;\n        }\n    }\n    return maskResult;\n}\nfunction smoothEdgeMask(mask, sw, sh) {\n    var weights = [1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9];\n    var side = Math.round(Math.sqrt(weights.length));\n    var halfSide = Math.floor(side / 2);\n    var maskResult = [];\n    for (var y = 0; y < sh; y++) {\n        for (var x = 0; x < sw; x++) {\n            var so = y * sw + x;\n            var a = 0;\n            for (var cy = 0; cy < side; cy++) {\n                for (var cx = 0; cx < side; cx++) {\n                    var scy = y + cy - halfSide;\n                    var scx = x + cx - halfSide;\n                    if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {\n                        var srcOff = scy * sw + scx;\n                        var wt = weights[cy * side + cx];\n                        a += mask[srcOff] * wt;\n                    }\n                }\n            }\n            maskResult[so] = a;\n        }\n    }\n    return maskResult;\n}\nconst Mask = function (imageData) {\n    var threshold = this.threshold(), mask = backgroundMask(imageData, threshold);\n    if (mask) {\n        mask = erodeMask(mask, imageData.width, imageData.height);\n        mask = dilateMask(mask, imageData.width, imageData.height);\n        mask = smoothEdgeMask(mask, imageData.width, imageData.height);\n        applyMask(imageData, mask);\n    }\n    return imageData;\n};\nFactory.addGetterSetter(Node, 'threshold', 0, getNumberValidator(), Factory.afterSetFilter);\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/filters/Noise.js\n\n\n\nconst Noise = function (imageData) {\n    var amount = this.noise() * 255, data = imageData.data, nPixels = data.length, half = amount / 2, i;\n    for (i = 0; i < nPixels; i += 4) {\n        data[i + 0] += half - 2 * half * Math.random();\n        data[i + 1] += half - 2 * half * Math.random();\n        data[i + 2] += half - 2 * half * Math.random();\n    }\n};\nFactory.addGetterSetter(Node, 'noise', 0.2, getNumberValidator(), Factory.afterSetFilter);\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/filters/Pixelate.js\n\n\n\n\nconst Pixelate = function (imageData) {\n    var pixelSize = Math.ceil(this.pixelSize()), width = imageData.width, height = imageData.height, x, y, i, red, green, blue, alpha, nBinsX = Math.ceil(width / pixelSize), nBinsY = Math.ceil(height / pixelSize), xBinStart, xBinEnd, yBinStart, yBinEnd, xBin, yBin, pixelsInBin, data = imageData.data;\n    if (pixelSize <= 0) {\n        Util_Util.error('pixelSize value can not be <= 0');\n        return;\n    }\n    for (xBin = 0; xBin < nBinsX; xBin += 1) {\n        for (yBin = 0; yBin < nBinsY; yBin += 1) {\n            red = 0;\n            green = 0;\n            blue = 0;\n            alpha = 0;\n            xBinStart = xBin * pixelSize;\n            xBinEnd = xBinStart + pixelSize;\n            yBinStart = yBin * pixelSize;\n            yBinEnd = yBinStart + pixelSize;\n            pixelsInBin = 0;\n            for (x = xBinStart; x < xBinEnd; x += 1) {\n                if (x >= width) {\n                    continue;\n                }\n                for (y = yBinStart; y < yBinEnd; y += 1) {\n                    if (y >= height) {\n                        continue;\n                    }\n                    i = (width * y + x) * 4;\n                    red += data[i + 0];\n                    green += data[i + 1];\n                    blue += data[i + 2];\n                    alpha += data[i + 3];\n                    pixelsInBin += 1;\n                }\n            }\n            red = red / pixelsInBin;\n            green = green / pixelsInBin;\n            blue = blue / pixelsInBin;\n            alpha = alpha / pixelsInBin;\n            for (x = xBinStart; x < xBinEnd; x += 1) {\n                if (x >= width) {\n                    continue;\n                }\n                for (y = yBinStart; y < yBinEnd; y += 1) {\n                    if (y >= height) {\n                        continue;\n                    }\n                    i = (width * y + x) * 4;\n                    data[i + 0] = red;\n                    data[i + 1] = green;\n                    data[i + 2] = blue;\n                    data[i + 3] = alpha;\n                }\n            }\n        }\n    }\n};\nFactory.addGetterSetter(Node, 'pixelSize', 8, getNumberValidator(), Factory.afterSetFilter);\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/filters/Posterize.js\n\n\n\nconst Posterize = function (imageData) {\n    var levels = Math.round(this.levels() * 254) + 1, data = imageData.data, len = data.length, scale = 255 / levels, i;\n    for (i = 0; i < len; i += 1) {\n        data[i] = Math.floor(data[i] / scale) * scale;\n    }\n};\nFactory.addGetterSetter(Node, 'levels', 0.5, getNumberValidator(), Factory.afterSetFilter);\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/filters/RGB.js\n\n\n\nconst RGB = function (imageData) {\n    var data = imageData.data, nPixels = data.length, red = this.red(), green = this.green(), blue = this.blue(), i, brightness;\n    for (i = 0; i < nPixels; i += 4) {\n        brightness =\n            (0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2]) / 255;\n        data[i] = brightness * red;\n        data[i + 1] = brightness * green;\n        data[i + 2] = brightness * blue;\n        data[i + 3] = data[i + 3];\n    }\n};\nFactory.addGetterSetter(Node, 'red', 0, function (val) {\n    this._filterUpToDate = false;\n    if (val > 255) {\n        return 255;\n    }\n    else if (val < 0) {\n        return 0;\n    }\n    else {\n        return Math.round(val);\n    }\n});\nFactory.addGetterSetter(Node, 'green', 0, function (val) {\n    this._filterUpToDate = false;\n    if (val > 255) {\n        return 255;\n    }\n    else if (val < 0) {\n        return 0;\n    }\n    else {\n        return Math.round(val);\n    }\n});\nFactory.addGetterSetter(Node, 'blue', 0, RGBComponent, Factory.afterSetFilter);\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/filters/RGBA.js\n\n\n\nconst RGBA = function (imageData) {\n    var data = imageData.data, nPixels = data.length, red = this.red(), green = this.green(), blue = this.blue(), alpha = this.alpha(), i, ia;\n    for (i = 0; i < nPixels; i += 4) {\n        ia = 1 - alpha;\n        data[i] = red * alpha + data[i] * ia;\n        data[i + 1] = green * alpha + data[i + 1] * ia;\n        data[i + 2] = blue * alpha + data[i + 2] * ia;\n    }\n};\nFactory.addGetterSetter(Node, 'red', 0, function (val) {\n    this._filterUpToDate = false;\n    if (val > 255) {\n        return 255;\n    }\n    else if (val < 0) {\n        return 0;\n    }\n    else {\n        return Math.round(val);\n    }\n});\nFactory.addGetterSetter(Node, 'green', 0, function (val) {\n    this._filterUpToDate = false;\n    if (val > 255) {\n        return 255;\n    }\n    else if (val < 0) {\n        return 0;\n    }\n    else {\n        return Math.round(val);\n    }\n});\nFactory.addGetterSetter(Node, 'blue', 0, RGBComponent, Factory.afterSetFilter);\nFactory.addGetterSetter(Node, 'alpha', 1, function (val) {\n    this._filterUpToDate = false;\n    if (val > 1) {\n        return 1;\n    }\n    else if (val < 0) {\n        return 0;\n    }\n    else {\n        return val;\n    }\n});\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/filters/Sepia.js\nconst Sepia = function (imageData) {\n    var data = imageData.data, nPixels = data.length, i, r, g, b;\n    for (i = 0; i < nPixels; i += 4) {\n        r = data[i + 0];\n        g = data[i + 1];\n        b = data[i + 2];\n        data[i + 0] = Math.min(255, r * 0.393 + g * 0.769 + b * 0.189);\n        data[i + 1] = Math.min(255, r * 0.349 + g * 0.686 + b * 0.168);\n        data[i + 2] = Math.min(255, r * 0.272 + g * 0.534 + b * 0.131);\n    }\n};\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/filters/Solarize.js\nconst Solarize = function (imageData) {\n    var data = imageData.data, w = imageData.width, h = imageData.height, w4 = w * 4, y = h;\n    do {\n        var offsetY = (y - 1) * w4;\n        var x = w;\n        do {\n            var offset = offsetY + (x - 1) * 4;\n            var r = data[offset];\n            var g = data[offset + 1];\n            var b = data[offset + 2];\n            if (r > 127) {\n                r = 255 - r;\n            }\n            if (g > 127) {\n                g = 255 - g;\n            }\n            if (b > 127) {\n                b = 255 - b;\n            }\n            data[offset] = r;\n            data[offset + 1] = g;\n            data[offset + 2] = b;\n        } while (--x);\n    } while (--y);\n};\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/filters/Threshold.js\n\n\n\nconst Threshold = function (imageData) {\n    var level = this.threshold() * 255, data = imageData.data, len = data.length, i;\n    for (i = 0; i < len; i += 1) {\n        data[i] = data[i] < level ? 0 : 255;\n    }\n};\nFactory.addGetterSetter(Node, 'threshold', 0.5, getNumberValidator(), Factory.afterSetFilter);\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/_FullInternals.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst _FullInternals_Konva = _CoreInternals_Konva.Util._assign(_CoreInternals_Konva, {\n    Arc: Arc,\n    Arrow: Arrow,\n    Circle: Circle,\n    Ellipse: Ellipse,\n    Image: Image,\n    Label: Label,\n    Tag: Tag,\n    Line: Line,\n    Path: Path,\n    Rect: Rect,\n    RegularPolygon: RegularPolygon,\n    Ring: Ring,\n    Sprite: Sprite,\n    Star: Star,\n    Text: Text,\n    TextPath: TextPath,\n    Transformer: Transformer,\n    Wedge: Wedge,\n    Filters: {\n        Blur: Blur,\n        Brighten: Brighten,\n        Contrast: Contrast,\n        Emboss: Emboss,\n        Enhance: Enhance,\n        Grayscale: Grayscale,\n        HSL: HSL,\n        HSV: HSV,\n        Invert: Invert,\n        Kaleidoscope: Kaleidoscope,\n        Mask: Mask,\n        Noise: Noise,\n        Pixelate: Pixelate,\n        Posterize: Posterize,\n        RGB: RGB,\n        RGBA: RGBA,\n        Sepia: Sepia,\n        Solarize: Solarize,\n        Threshold: Threshold,\n    },\n});\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/index.js\n\n/* harmony default export */ const lib = ((/* unused pure expression or super */ null && (Konva)));\n\n;// CONCATENATED MODULE: ./node_modules/konva/lib/Core.js\n\n\n/* harmony default export */ const Core = (_CoreInternals_Konva);\n\n// EXTERNAL MODULE: ./node_modules/react-reconciler/index.js\nvar react_reconciler = __webpack_require__(525);\nvar react_reconciler_default = /*#__PURE__*/__webpack_require__.n(react_reconciler);\n// EXTERNAL MODULE: ./node_modules/react-reconciler/constants.js\nvar constants = __webpack_require__(576);\n;// CONCATENATED MODULE: ./node_modules/react-konva/es/makeUpdates.js\n\nconst propsToSkip = {\n    children: true,\n    ref: true,\n    key: true,\n    style: true,\n    forwardedRef: true,\n    unstable_applyCache: true,\n    unstable_applyDrawHitFromCache: true,\n};\nlet zIndexWarningShowed = false;\nlet dragWarningShowed = false;\nconst EVENTS_NAMESPACE = '.react-konva-event';\nlet useStrictMode = false;\nfunction makeUpdates_toggleStrictMode(value) {\n    useStrictMode = value;\n}\nconst DRAGGABLE_WARNING = `ReactKonva: You have a Konva node with draggable = true and position defined but no onDragMove or onDragEnd events are handled.\nPosition of a node will be changed during drag&drop, so you should update state of the react app as well.\nConsider to add onDragMove or onDragEnd events.\nFor more info see: https://github.com/konvajs/react-konva/issues/256\n`;\nconst Z_INDEX_WARNING = `ReactKonva: You are using \"zIndex\" attribute for a Konva node.\nreact-konva may get confused with ordering. Just define correct order of elements in your render function of a component.\nFor more info see: https://github.com/konvajs/react-konva/issues/194\n`;\nconst EMPTY_PROPS = {};\nfunction applyNodeProps(instance, props, oldProps = EMPTY_PROPS) {\n    if (props === oldProps) {\n        console.error('same props');\n    }\n    // don't use zIndex in react-konva\n    if (!zIndexWarningShowed && 'zIndex' in props) {\n        console.warn(Z_INDEX_WARNING);\n        zIndexWarningShowed = true;\n    }\n    // check correct draggable usage\n    if (!dragWarningShowed && props.draggable) {\n        var hasPosition = props.x !== undefined || props.y !== undefined;\n        var hasEvents = props.onDragEnd || props.onDragMove;\n        if (hasPosition && !hasEvents) {\n            console.warn(DRAGGABLE_WARNING);\n            dragWarningShowed = true;\n        }\n    }\n    // check old props\n    // we need to unset properties that are not in new props\n    // and remove all events\n    for (var key in oldProps) {\n        if (propsToSkip[key]) {\n            continue;\n        }\n        var isEvent = key.slice(0, 2) === 'on';\n        var propChanged = oldProps[key] !== props[key];\n        // if that is a changed event, we need to remvoe it\n        if (isEvent && propChanged) {\n            var eventName = key.substr(2).toLowerCase();\n            if (eventName.substr(0, 7) === 'content') {\n                eventName =\n                    'content' +\n                        eventName.substr(7, 1).toUpperCase() +\n                        eventName.substr(8);\n            }\n            instance.off(eventName, oldProps[key]);\n        }\n        var toRemove = !props.hasOwnProperty(key);\n        if (toRemove) {\n            instance.setAttr(key, undefined);\n        }\n    }\n    var strictUpdate = useStrictMode || props._useStrictMode;\n    var updatedProps = {};\n    var hasUpdates = false;\n    const newEvents = {};\n    for (var key in props) {\n        if (propsToSkip[key]) {\n            continue;\n        }\n        var isEvent = key.slice(0, 2) === 'on';\n        var toAdd = oldProps[key] !== props[key];\n        if (isEvent && toAdd) {\n            var eventName = key.substr(2).toLowerCase();\n            if (eventName.substr(0, 7) === 'content') {\n                eventName =\n                    'content' +\n                        eventName.substr(7, 1).toUpperCase() +\n                        eventName.substr(8);\n            }\n            // check that event is not undefined\n            if (props[key]) {\n                newEvents[eventName] = props[key];\n            }\n        }\n        if (!isEvent &&\n            (props[key] !== oldProps[key] ||\n                (strictUpdate && props[key] !== instance.getAttr(key)))) {\n            hasUpdates = true;\n            updatedProps[key] = props[key];\n        }\n    }\n    if (hasUpdates) {\n        instance.setAttrs(updatedProps);\n        updatePicture(instance);\n    }\n    // subscribe to events AFTER we set attrs\n    // we need it to fix https://github.com/konvajs/react-konva/issues/471\n    // settings attrs may add events. Like \"draggable: true\" will add \"mousedown\" listener\n    for (var eventName in newEvents) {\n        instance.on(eventName + EVENTS_NAMESPACE, newEvents[eventName]);\n    }\n}\nfunction updatePicture(node) {\n    if (!Global_Konva.autoDrawEnabled) {\n        var drawingNode = node.getLayer() || node.getStage();\n        drawingNode && drawingNode.batchDraw();\n    }\n}\n\n// EXTERNAL MODULE: ./node_modules/scheduler/index.js\nvar scheduler = __webpack_require__(840);\n;// CONCATENATED MODULE: ./node_modules/react-konva/es/ReactKonvaHostConfig.js\n\n\n\n\nconst NO_CONTEXT = {};\nconst UPDATE_SIGNAL = {};\n// for react-spring capability\nCore.Node.prototype._applyProps = applyNodeProps;\nfunction appendInitialChild(parentInstance, child) {\n    if (typeof child === 'string') {\n        // Noop for string children of Text (eg <Text>foo</Text>)\n        console.error(`Do not use plain text as child of Konva.Node. You are using text: ${child}`);\n        return;\n    }\n    parentInstance.add(child);\n    updatePicture(parentInstance);\n}\nfunction createInstance(type, props, internalInstanceHandle) {\n    let NodeClass = Core[type];\n    if (!NodeClass) {\n        console.error(`Konva has no node with the type ${type}. Group will be used instead. If you use minimal version of react-konva, just import required nodes into Konva: \"import \"konva/lib/shapes/${type}\"  If you want to render DOM elements as part of canvas tree take a look into this demo: https://konvajs.github.io/docs/react/DOM_Portal.html`);\n        NodeClass = Core.Group;\n    }\n    // we need to split props into events and non events\n    // we we can pass non events into constructor directly\n    // that way the performance should be better\n    // we we apply change \"applyNodeProps\"\n    // then it will trigger change events on first run\n    // but we don't need them!\n    const propsWithoutEvents = {};\n    const propsWithOnlyEvents = {};\n    for (var key in props) {\n        var isEvent = key.slice(0, 2) === 'on';\n        if (isEvent) {\n            propsWithOnlyEvents[key] = props[key];\n        }\n        else {\n            propsWithoutEvents[key] = props[key];\n        }\n    }\n    const instance = new NodeClass(propsWithoutEvents);\n    applyNodeProps(instance, propsWithOnlyEvents);\n    return instance;\n}\nfunction createTextInstance(text, rootContainerInstance, internalInstanceHandle) {\n    console.error(`Text components are not supported for now in ReactKonva. Your text is: \"${text}\"`);\n}\nfunction finalizeInitialChildren(domElement, type, props) {\n    return false;\n}\nfunction getPublicInstance(instance) {\n    return instance;\n}\nfunction prepareForCommit() {\n    return null;\n}\nfunction preparePortalMount() {\n    return null;\n}\nfunction prepareUpdate(domElement, type, oldProps, newProps) {\n    return UPDATE_SIGNAL;\n}\nfunction resetAfterCommit() {\n    // Noop\n}\nfunction resetTextContent(domElement) {\n    // Noop\n}\nfunction shouldDeprioritizeSubtree(type, props) {\n    return false;\n}\nfunction getRootHostContext() {\n    return NO_CONTEXT;\n}\nfunction getChildHostContext() {\n    return NO_CONTEXT;\n}\nconst scheduleTimeout = setTimeout;\nconst cancelTimeout = clearTimeout;\nconst noTimeout = -1;\n// export const schedulePassiveEffects = scheduleDeferredCallback;\n// export const cancelPassiveEffects = cancelDeferredCallback;\nfunction shouldSetTextContent(type, props) {\n    return false;\n}\n// The Konva renderer is secondary to the React DOM renderer.\nconst isPrimaryRenderer = false;\nconst warnsIfNotActing = true;\nconst supportsMutation = true;\nfunction appendChild(parentInstance, child) {\n    if (child.parent === parentInstance) {\n        child.moveToTop();\n    }\n    else {\n        parentInstance.add(child);\n    }\n    updatePicture(parentInstance);\n}\nfunction appendChildToContainer(parentInstance, child) {\n    if (child.parent === parentInstance) {\n        child.moveToTop();\n    }\n    else {\n        parentInstance.add(child);\n    }\n    updatePicture(parentInstance);\n}\nfunction insertBefore(parentInstance, child, beforeChild) {\n    // child._remove() will not stop dragging\n    // but child.remove() will stop it, but we don't need it\n    // removing will reset zIndexes\n    child._remove();\n    parentInstance.add(child);\n    child.setZIndex(beforeChild.getZIndex());\n    updatePicture(parentInstance);\n}\nfunction insertInContainerBefore(parentInstance, child, beforeChild) {\n    insertBefore(parentInstance, child, beforeChild);\n}\nfunction removeChild(parentInstance, child) {\n    child.destroy();\n    child.off(EVENTS_NAMESPACE);\n    updatePicture(parentInstance);\n}\nfunction removeChildFromContainer(parentInstance, child) {\n    child.destroy();\n    child.off(EVENTS_NAMESPACE);\n    updatePicture(parentInstance);\n}\nfunction commitTextUpdate(textInstance, oldText, newText) {\n    console.error(`Text components are not yet supported in ReactKonva. You text is: \"${newText}\"`);\n}\nfunction commitMount(instance, type, newProps) {\n    // Noop\n}\nfunction commitUpdate(instance, updatePayload, type, oldProps, newProps) {\n    applyNodeProps(instance, newProps, oldProps);\n}\nfunction hideInstance(instance) {\n    instance.hide();\n    updatePicture(instance);\n}\nfunction hideTextInstance(textInstance) {\n    // Noop\n}\nfunction unhideInstance(instance, props) {\n    if (props.visible == null || props.visible) {\n        instance.show();\n    }\n}\nfunction unhideTextInstance(textInstance, text) {\n    // Noop\n}\nfunction clearContainer(container) {\n    // Noop\n}\nfunction detachDeletedInstance() { }\nconst getCurrentEventPriority = () => constants.DefaultEventPriority;\n\n;// CONCATENATED MODULE: ./node_modules/react-konva/es/ReactKonvaCore.js\n/**\n * Based on ReactArt.js\n * Copyright (c) 2017-present Lavrenov Anton.\n * All rights reserved.\n *\n * MIT\n */\n\n\n\n\n\n\n\nfunction usePrevious(value) {\n    const ref = react.useRef();\n    react.useLayoutEffect(() => {\n        ref.current = value;\n    });\n    return ref.current;\n}\nconst StageWrap = (props) => {\n    const container = react.useRef();\n    const stage = react.useRef();\n    const fiberRef = react.useRef();\n    const oldProps = usePrevious(props);\n    const _setRef = (stage) => {\n        const { forwardedRef } = props;\n        if (!forwardedRef) {\n            return;\n        }\n        if (typeof forwardedRef === 'function') {\n            forwardedRef(stage);\n        }\n        else {\n            forwardedRef.current = stage;\n        }\n    };\n    react.useLayoutEffect(() => {\n        stage.current = new Core.Stage({\n            width: props.width,\n            height: props.height,\n            container: container.current,\n        });\n        _setRef(stage.current);\n        fiberRef.current = KonvaRenderer.createContainer(stage.current, constants.ConcurrentRoot, false, null);\n        KonvaRenderer.updateContainer(props.children, fiberRef.current);\n        return () => {\n            if (!Core.isBrowser) {\n                return;\n            }\n            _setRef(null);\n            KonvaRenderer.updateContainer(null, fiberRef.current, null);\n            stage.current.destroy();\n        };\n    }, []);\n    react.useLayoutEffect(() => {\n        _setRef(stage.current);\n        applyNodeProps(stage.current, props, oldProps);\n        KonvaRenderer.updateContainer(props.children, fiberRef.current, null);\n    });\n    return react.createElement('div', {\n        ref: container,\n        accessKey: props.accessKey,\n        className: props.className,\n        role: props.role,\n        style: props.style,\n        tabIndex: props.tabIndex,\n        title: props.title,\n    });\n};\nconst ReactKonvaCore_Layer = 'Layer';\nconst ReactKonvaCore_FastLayer = 'FastLayer';\nconst ReactKonvaCore_Group = 'Group';\nconst ReactKonvaCore_Label = 'Label';\nconst ReactKonvaCore_Rect = 'Rect';\nconst ReactKonvaCore_Circle = 'Circle';\nconst ReactKonvaCore_Ellipse = 'Ellipse';\nconst ReactKonvaCore_Wedge = 'Wedge';\nconst ReactKonvaCore_Line = 'Line';\nconst ReactKonvaCore_Sprite = 'Sprite';\nconst ReactKonvaCore_Image = 'Image';\nconst ReactKonvaCore_Text = 'Text';\nconst ReactKonvaCore_TextPath = 'TextPath';\nconst ReactKonvaCore_Star = 'Star';\nconst ReactKonvaCore_Ring = 'Ring';\nconst ReactKonvaCore_Arc = 'Arc';\nconst ReactKonvaCore_Tag = 'Tag';\nconst ReactKonvaCore_Path = 'Path';\nconst ReactKonvaCore_RegularPolygon = 'RegularPolygon';\nconst ReactKonvaCore_Arrow = 'Arrow';\nconst ReactKonvaCore_Shape = 'Shape';\nconst ReactKonvaCore_Transformer = 'Transformer';\nconst KonvaRenderer = react_reconciler_default()(ReactKonvaHostConfig_namespaceObject);\nKonvaRenderer.injectIntoDevTools({\n    findHostInstanceByFiber: () => null,\n    bundleType:  false ? 0 : 0,\n    version: react.version,\n    rendererPackageName: 'react-konva',\n});\nconst ReactKonvaCore_Stage = react.forwardRef((props, ref) => {\n    return react.createElement(StageWrap, { ...props, forwardedRef: ref });\n});\nconst ReactKonvaCore_useStrictMode = (/* unused pure expression or super */ null && (toggleStrictMode));\n\n;// CONCATENATED MODULE: ./node_modules/react-konva/es/ReactKonva.js\n/**\n * Based on ReactArt.js\n * Copyright (c) 2017-present Lavrenov Anton.\n * All rights reserved.\n *\n * MIT\n */\n\n\n\n\n;// CONCATENATED MODULE: ./node_modules/immutable/dist/immutable.es.js\n/**\n * MIT License\n * \n * Copyright (c) 2014-present, Lee Byron and other contributors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nvar DELETE = 'delete';\n\n// Constants describing the size of trie nodes.\nvar SHIFT = 5; // Resulted in best performance after ______?\nvar SIZE = 1 << SHIFT;\nvar MASK = SIZE - 1;\n\n// A consistent shared value representing \"not set\" which equals nothing other\n// than itself, and nothing that could be provided externally.\nvar NOT_SET = {};\n\n// Boolean references, Rough equivalent of `bool &`.\nfunction MakeRef() {\n  return { value: false };\n}\n\nfunction SetRef(ref) {\n  if (ref) {\n    ref.value = true;\n  }\n}\n\n// A function which returns a value representing an \"owner\" for transient writes\n// to tries. The return value will only ever equal itself, and will not equal\n// the return of any subsequent call of this function.\nfunction OwnerID() {}\n\nfunction ensureSize(iter) {\n  if (iter.size === undefined) {\n    iter.size = iter.__iterate(returnTrue);\n  }\n  return iter.size;\n}\n\nfunction wrapIndex(iter, index) {\n  // This implements \"is array index\" which the ECMAString spec defines as:\n  //\n  //     A String property name P is an array index if and only if\n  //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n  //     to 2^32−1.\n  //\n  // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n  if (typeof index !== 'number') {\n    var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n    if ('' + uint32Index !== index || uint32Index === 4294967295) {\n      return NaN;\n    }\n    index = uint32Index;\n  }\n  return index < 0 ? ensureSize(iter) + index : index;\n}\n\nfunction returnTrue() {\n  return true;\n}\n\nfunction wholeSlice(begin, end, size) {\n  return (\n    ((begin === 0 && !isNeg(begin)) ||\n      (size !== undefined && begin <= -size)) &&\n    (end === undefined || (size !== undefined && end >= size))\n  );\n}\n\nfunction resolveBegin(begin, size) {\n  return resolveIndex(begin, size, 0);\n}\n\nfunction resolveEnd(end, size) {\n  return resolveIndex(end, size, size);\n}\n\nfunction resolveIndex(index, size, defaultIndex) {\n  // Sanitize indices using this shorthand for ToInt32(argument)\n  // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n  return index === undefined\n    ? defaultIndex\n    : isNeg(index)\n    ? size === Infinity\n      ? size\n      : Math.max(0, size + index) | 0\n    : size === undefined || size === index\n    ? index\n    : Math.min(size, index) | 0;\n}\n\nfunction isNeg(value) {\n  // Account for -0 which is negative, but not less than 0.\n  return value < 0 || (value === 0 && 1 / value === -Infinity);\n}\n\nvar IS_COLLECTION_SYMBOL = '@@__IMMUTABLE_ITERABLE__@@';\n\nfunction isCollection(maybeCollection) {\n  return Boolean(maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]);\n}\n\nvar IS_KEYED_SYMBOL = '@@__IMMUTABLE_KEYED__@@';\n\nfunction isKeyed(maybeKeyed) {\n  return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);\n}\n\nvar IS_INDEXED_SYMBOL = '@@__IMMUTABLE_INDEXED__@@';\n\nfunction isIndexed(maybeIndexed) {\n  return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);\n}\n\nfunction isAssociative(maybeAssociative) {\n  return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n}\n\nvar Collection = function Collection(value) {\n  return isCollection(value) ? value : Seq(value);\n};\n\nvar KeyedCollection = /*@__PURE__*/(function (Collection) {\n  function KeyedCollection(value) {\n    return isKeyed(value) ? value : KeyedSeq(value);\n  }\n\n  if ( Collection ) KeyedCollection.__proto__ = Collection;\n  KeyedCollection.prototype = Object.create( Collection && Collection.prototype );\n  KeyedCollection.prototype.constructor = KeyedCollection;\n\n  return KeyedCollection;\n}(Collection));\n\nvar IndexedCollection = /*@__PURE__*/(function (Collection) {\n  function IndexedCollection(value) {\n    return isIndexed(value) ? value : IndexedSeq(value);\n  }\n\n  if ( Collection ) IndexedCollection.__proto__ = Collection;\n  IndexedCollection.prototype = Object.create( Collection && Collection.prototype );\n  IndexedCollection.prototype.constructor = IndexedCollection;\n\n  return IndexedCollection;\n}(Collection));\n\nvar SetCollection = /*@__PURE__*/(function (Collection) {\n  function SetCollection(value) {\n    return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);\n  }\n\n  if ( Collection ) SetCollection.__proto__ = Collection;\n  SetCollection.prototype = Object.create( Collection && Collection.prototype );\n  SetCollection.prototype.constructor = SetCollection;\n\n  return SetCollection;\n}(Collection));\n\nCollection.Keyed = KeyedCollection;\nCollection.Indexed = IndexedCollection;\nCollection.Set = SetCollection;\n\nvar IS_SEQ_SYMBOL = '@@__IMMUTABLE_SEQ__@@';\n\nfunction isSeq(maybeSeq) {\n  return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);\n}\n\nvar IS_RECORD_SYMBOL = '@@__IMMUTABLE_RECORD__@@';\n\nfunction isRecord(maybeRecord) {\n  return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);\n}\n\nfunction isImmutable(maybeImmutable) {\n  return isCollection(maybeImmutable) || isRecord(maybeImmutable);\n}\n\nvar IS_ORDERED_SYMBOL = '@@__IMMUTABLE_ORDERED__@@';\n\nfunction isOrdered(maybeOrdered) {\n  return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);\n}\n\nvar ITERATE_KEYS = 0;\nvar ITERATE_VALUES = 1;\nvar ITERATE_ENTRIES = 2;\n\nvar REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nvar ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\nvar Iterator = function Iterator(next) {\n  this.next = next;\n};\n\nIterator.prototype.toString = function toString () {\n  return '[Iterator]';\n};\n\nIterator.KEYS = ITERATE_KEYS;\nIterator.VALUES = ITERATE_VALUES;\nIterator.ENTRIES = ITERATE_ENTRIES;\n\nIterator.prototype.inspect = Iterator.prototype.toSource = function () {\n  return this.toString();\n};\nIterator.prototype[ITERATOR_SYMBOL] = function () {\n  return this;\n};\n\nfunction iteratorValue(type, k, v, iteratorResult) {\n  var value = type === 0 ? k : type === 1 ? v : [k, v];\n  iteratorResult\n    ? (iteratorResult.value = value)\n    : (iteratorResult = {\n        value: value,\n        done: false,\n      });\n  return iteratorResult;\n}\n\nfunction iteratorDone() {\n  return { value: undefined, done: true };\n}\n\nfunction hasIterator(maybeIterable) {\n  if (Array.isArray(maybeIterable)) {\n    // IE11 trick as it does not support `Symbol.iterator`\n    return true;\n  }\n\n  return !!getIteratorFn(maybeIterable);\n}\n\nfunction isIterator(maybeIterator) {\n  return maybeIterator && typeof maybeIterator.next === 'function';\n}\n\nfunction getIterator(iterable) {\n  var iteratorFn = getIteratorFn(iterable);\n  return iteratorFn && iteratorFn.call(iterable);\n}\n\nfunction getIteratorFn(iterable) {\n  var iteratorFn =\n    iterable &&\n    ((REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n      iterable[FAUX_ITERATOR_SYMBOL]);\n  if (typeof iteratorFn === 'function') {\n    return iteratorFn;\n  }\n}\n\nfunction isEntriesIterable(maybeIterable) {\n  var iteratorFn = getIteratorFn(maybeIterable);\n  return iteratorFn && iteratorFn === maybeIterable.entries;\n}\n\nfunction isKeysIterable(maybeIterable) {\n  var iteratorFn = getIteratorFn(maybeIterable);\n  return iteratorFn && iteratorFn === maybeIterable.keys;\n}\n\nvar immutable_es_hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction isArrayLike(value) {\n  if (Array.isArray(value) || typeof value === 'string') {\n    return true;\n  }\n\n  return (\n    value &&\n    typeof value === 'object' &&\n    Number.isInteger(value.length) &&\n    value.length >= 0 &&\n    (value.length === 0\n      ? // Only {length: 0} is considered Array-like.\n        Object.keys(value).length === 1\n      : // An object is only Array-like if it has a property where the last value\n        // in the array-like may be found (which could be undefined).\n        value.hasOwnProperty(value.length - 1))\n  );\n}\n\nvar Seq = /*@__PURE__*/(function (Collection) {\n  function Seq(value) {\n    return value === undefined || value === null\n      ? emptySequence()\n      : isImmutable(value)\n      ? value.toSeq()\n      : seqFromValue(value);\n  }\n\n  if ( Collection ) Seq.__proto__ = Collection;\n  Seq.prototype = Object.create( Collection && Collection.prototype );\n  Seq.prototype.constructor = Seq;\n\n  Seq.prototype.toSeq = function toSeq () {\n    return this;\n  };\n\n  Seq.prototype.toString = function toString () {\n    return this.__toString('Seq {', '}');\n  };\n\n  Seq.prototype.cacheResult = function cacheResult () {\n    if (!this._cache && this.__iterateUncached) {\n      this._cache = this.entrySeq().toArray();\n      this.size = this._cache.length;\n    }\n    return this;\n  };\n\n  // abstract __iterateUncached(fn, reverse)\n\n  Seq.prototype.__iterate = function __iterate (fn, reverse) {\n    var cache = this._cache;\n    if (cache) {\n      var size = cache.length;\n      var i = 0;\n      while (i !== size) {\n        var entry = cache[reverse ? size - ++i : i++];\n        if (fn(entry[1], entry[0], this) === false) {\n          break;\n        }\n      }\n      return i;\n    }\n    return this.__iterateUncached(fn, reverse);\n  };\n\n  // abstract __iteratorUncached(type, reverse)\n\n  Seq.prototype.__iterator = function __iterator (type, reverse) {\n    var cache = this._cache;\n    if (cache) {\n      var size = cache.length;\n      var i = 0;\n      return new Iterator(function () {\n        if (i === size) {\n          return iteratorDone();\n        }\n        var entry = cache[reverse ? size - ++i : i++];\n        return iteratorValue(type, entry[0], entry[1]);\n      });\n    }\n    return this.__iteratorUncached(type, reverse);\n  };\n\n  return Seq;\n}(Collection));\n\nvar KeyedSeq = /*@__PURE__*/(function (Seq) {\n  function KeyedSeq(value) {\n    return value === undefined || value === null\n      ? emptySequence().toKeyedSeq()\n      : isCollection(value)\n      ? isKeyed(value)\n        ? value.toSeq()\n        : value.fromEntrySeq()\n      : isRecord(value)\n      ? value.toSeq()\n      : keyedSeqFromValue(value);\n  }\n\n  if ( Seq ) KeyedSeq.__proto__ = Seq;\n  KeyedSeq.prototype = Object.create( Seq && Seq.prototype );\n  KeyedSeq.prototype.constructor = KeyedSeq;\n\n  KeyedSeq.prototype.toKeyedSeq = function toKeyedSeq () {\n    return this;\n  };\n\n  return KeyedSeq;\n}(Seq));\n\nvar IndexedSeq = /*@__PURE__*/(function (Seq) {\n  function IndexedSeq(value) {\n    return value === undefined || value === null\n      ? emptySequence()\n      : isCollection(value)\n      ? isKeyed(value)\n        ? value.entrySeq()\n        : value.toIndexedSeq()\n      : isRecord(value)\n      ? value.toSeq().entrySeq()\n      : indexedSeqFromValue(value);\n  }\n\n  if ( Seq ) IndexedSeq.__proto__ = Seq;\n  IndexedSeq.prototype = Object.create( Seq && Seq.prototype );\n  IndexedSeq.prototype.constructor = IndexedSeq;\n\n  IndexedSeq.of = function of (/*...values*/) {\n    return IndexedSeq(arguments);\n  };\n\n  IndexedSeq.prototype.toIndexedSeq = function toIndexedSeq () {\n    return this;\n  };\n\n  IndexedSeq.prototype.toString = function toString () {\n    return this.__toString('Seq [', ']');\n  };\n\n  return IndexedSeq;\n}(Seq));\n\nvar SetSeq = /*@__PURE__*/(function (Seq) {\n  function SetSeq(value) {\n    return (\n      isCollection(value) && !isAssociative(value) ? value : IndexedSeq(value)\n    ).toSetSeq();\n  }\n\n  if ( Seq ) SetSeq.__proto__ = Seq;\n  SetSeq.prototype = Object.create( Seq && Seq.prototype );\n  SetSeq.prototype.constructor = SetSeq;\n\n  SetSeq.of = function of (/*...values*/) {\n    return SetSeq(arguments);\n  };\n\n  SetSeq.prototype.toSetSeq = function toSetSeq () {\n    return this;\n  };\n\n  return SetSeq;\n}(Seq));\n\nSeq.isSeq = isSeq;\nSeq.Keyed = KeyedSeq;\nSeq.Set = SetSeq;\nSeq.Indexed = IndexedSeq;\n\nSeq.prototype[IS_SEQ_SYMBOL] = true;\n\n// #pragma Root Sequences\n\nvar ArraySeq = /*@__PURE__*/(function (IndexedSeq) {\n  function ArraySeq(array) {\n    this._array = array;\n    this.size = array.length;\n  }\n\n  if ( IndexedSeq ) ArraySeq.__proto__ = IndexedSeq;\n  ArraySeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n  ArraySeq.prototype.constructor = ArraySeq;\n\n  ArraySeq.prototype.get = function get (index, notSetValue) {\n    return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n  };\n\n  ArraySeq.prototype.__iterate = function __iterate (fn, reverse) {\n    var array = this._array;\n    var size = array.length;\n    var i = 0;\n    while (i !== size) {\n      var ii = reverse ? size - ++i : i++;\n      if (fn(array[ii], ii, this) === false) {\n        break;\n      }\n    }\n    return i;\n  };\n\n  ArraySeq.prototype.__iterator = function __iterator (type, reverse) {\n    var array = this._array;\n    var size = array.length;\n    var i = 0;\n    return new Iterator(function () {\n      if (i === size) {\n        return iteratorDone();\n      }\n      var ii = reverse ? size - ++i : i++;\n      return iteratorValue(type, ii, array[ii]);\n    });\n  };\n\n  return ArraySeq;\n}(IndexedSeq));\n\nvar ObjectSeq = /*@__PURE__*/(function (KeyedSeq) {\n  function ObjectSeq(object) {\n    var keys = Object.keys(object).concat(\n      Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : []\n    );\n    this._object = object;\n    this._keys = keys;\n    this.size = keys.length;\n  }\n\n  if ( KeyedSeq ) ObjectSeq.__proto__ = KeyedSeq;\n  ObjectSeq.prototype = Object.create( KeyedSeq && KeyedSeq.prototype );\n  ObjectSeq.prototype.constructor = ObjectSeq;\n\n  ObjectSeq.prototype.get = function get (key, notSetValue) {\n    if (notSetValue !== undefined && !this.has(key)) {\n      return notSetValue;\n    }\n    return this._object[key];\n  };\n\n  ObjectSeq.prototype.has = function has (key) {\n    return immutable_es_hasOwnProperty.call(this._object, key);\n  };\n\n  ObjectSeq.prototype.__iterate = function __iterate (fn, reverse) {\n    var object = this._object;\n    var keys = this._keys;\n    var size = keys.length;\n    var i = 0;\n    while (i !== size) {\n      var key = keys[reverse ? size - ++i : i++];\n      if (fn(object[key], key, this) === false) {\n        break;\n      }\n    }\n    return i;\n  };\n\n  ObjectSeq.prototype.__iterator = function __iterator (type, reverse) {\n    var object = this._object;\n    var keys = this._keys;\n    var size = keys.length;\n    var i = 0;\n    return new Iterator(function () {\n      if (i === size) {\n        return iteratorDone();\n      }\n      var key = keys[reverse ? size - ++i : i++];\n      return iteratorValue(type, key, object[key]);\n    });\n  };\n\n  return ObjectSeq;\n}(KeyedSeq));\nObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;\n\nvar CollectionSeq = /*@__PURE__*/(function (IndexedSeq) {\n  function CollectionSeq(collection) {\n    this._collection = collection;\n    this.size = collection.length || collection.size;\n  }\n\n  if ( IndexedSeq ) CollectionSeq.__proto__ = IndexedSeq;\n  CollectionSeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n  CollectionSeq.prototype.constructor = CollectionSeq;\n\n  CollectionSeq.prototype.__iterateUncached = function __iterateUncached (fn, reverse) {\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var collection = this._collection;\n    var iterator = getIterator(collection);\n    var iterations = 0;\n    if (isIterator(iterator)) {\n      var step;\n      while (!(step = iterator.next()).done) {\n        if (fn(step.value, iterations++, this) === false) {\n          break;\n        }\n      }\n    }\n    return iterations;\n  };\n\n  CollectionSeq.prototype.__iteratorUncached = function __iteratorUncached (type, reverse) {\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var collection = this._collection;\n    var iterator = getIterator(collection);\n    if (!isIterator(iterator)) {\n      return new Iterator(iteratorDone);\n    }\n    var iterations = 0;\n    return new Iterator(function () {\n      var step = iterator.next();\n      return step.done ? step : iteratorValue(type, iterations++, step.value);\n    });\n  };\n\n  return CollectionSeq;\n}(IndexedSeq));\n\n// # pragma Helper functions\n\nvar EMPTY_SEQ;\n\nfunction emptySequence() {\n  return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n}\n\nfunction keyedSeqFromValue(value) {\n  var seq = maybeIndexedSeqFromValue(value);\n  if (seq) {\n    return seq.fromEntrySeq();\n  }\n  if (typeof value === 'object') {\n    return new ObjectSeq(value);\n  }\n  throw new TypeError(\n    'Expected Array or collection object of [k, v] entries, or keyed object: ' +\n      value\n  );\n}\n\nfunction indexedSeqFromValue(value) {\n  var seq = maybeIndexedSeqFromValue(value);\n  if (seq) {\n    return seq;\n  }\n  throw new TypeError(\n    'Expected Array or collection object of values: ' + value\n  );\n}\n\nfunction seqFromValue(value) {\n  var seq = maybeIndexedSeqFromValue(value);\n  if (seq) {\n    return isEntriesIterable(value)\n      ? seq.fromEntrySeq()\n      : isKeysIterable(value)\n      ? seq.toSetSeq()\n      : seq;\n  }\n  if (typeof value === 'object') {\n    return new ObjectSeq(value);\n  }\n  throw new TypeError(\n    'Expected Array or collection object of values, or keyed object: ' + value\n  );\n}\n\nfunction maybeIndexedSeqFromValue(value) {\n  return isArrayLike(value)\n    ? new ArraySeq(value)\n    : hasIterator(value)\n    ? new CollectionSeq(value)\n    : undefined;\n}\n\nvar IS_MAP_SYMBOL = '@@__IMMUTABLE_MAP__@@';\n\nfunction isMap(maybeMap) {\n  return Boolean(maybeMap && maybeMap[IS_MAP_SYMBOL]);\n}\n\nfunction isOrderedMap(maybeOrderedMap) {\n  return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n}\n\nfunction isValueObject(maybeValue) {\n  return Boolean(\n    maybeValue &&\n      typeof maybeValue.equals === 'function' &&\n      typeof maybeValue.hashCode === 'function'\n  );\n}\n\n/**\n * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n *\n * NaN is considered the same as NaN, however -0 and 0 are considered the same\n * value, which is different from the algorithm described by\n * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n *\n * This is extended further to allow Objects to describe the values they\n * represent, by way of `valueOf` or `equals` (and `hashCode`).\n *\n * Note: because of this extension, the key equality of Immutable.Map and the\n * value equality of Immutable.Set will differ from ES6 Map and Set.\n *\n * ### Defining custom values\n *\n * The easiest way to describe the value an object represents is by implementing\n * `valueOf`. For example, `Date` represents a value by returning a unix\n * timestamp for `valueOf`:\n *\n *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n *     var date2 = new Date(1234567890000);\n *     date1.valueOf(); // 1234567890000\n *     assert( date1 !== date2 );\n *     assert( Immutable.is( date1, date2 ) );\n *\n * Note: overriding `valueOf` may have other implications if you use this object\n * where JavaScript expects a primitive, such as implicit string coercion.\n *\n * For more complex types, especially collections, implementing `valueOf` may\n * not be performant. An alternative is to implement `equals` and `hashCode`.\n *\n * `equals` takes another object, presumably of similar type, and returns true\n * if it is equal. Equality is symmetrical, so the same result should be\n * returned if this and the argument are flipped.\n *\n *     assert( a.equals(b) === b.equals(a) );\n *\n * `hashCode` returns a 32bit integer number representing the object which will\n * be used to determine how to store the value object in a Map or Set. You must\n * provide both or neither methods, one must not exist without the other.\n *\n * Also, an important relationship between these methods must be upheld: if two\n * values are equal, they *must* return the same hashCode. If the values are not\n * equal, they might have the same hashCode; this is called a hash collision,\n * and while undesirable for performance reasons, it is acceptable.\n *\n *     if (a.equals(b)) {\n *       assert( a.hashCode() === b.hashCode() );\n *     }\n *\n * All Immutable collections are Value Objects: they implement `equals()`\n * and `hashCode()`.\n */\nfunction immutable_es_is(valueA, valueB) {\n  if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n    return true;\n  }\n  if (!valueA || !valueB) {\n    return false;\n  }\n  if (\n    typeof valueA.valueOf === 'function' &&\n    typeof valueB.valueOf === 'function'\n  ) {\n    valueA = valueA.valueOf();\n    valueB = valueB.valueOf();\n    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n      return true;\n    }\n    if (!valueA || !valueB) {\n      return false;\n    }\n  }\n  return !!(\n    isValueObject(valueA) &&\n    isValueObject(valueB) &&\n    valueA.equals(valueB)\n  );\n}\n\nvar imul =\n  typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2\n    ? Math.imul\n    : function imul(a, b) {\n        a |= 0; // int\n        b |= 0; // int\n        var c = a & 0xffff;\n        var d = b & 0xffff;\n        // Shift by 0 fixes the sign on the high part.\n        return (c * d + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0)) | 0; // int\n      };\n\n// v8 has an optimization for storing 31-bit signed numbers.\n// Values which have either 00 or 11 as the high order bits qualify.\n// This function drops the highest order bit in a signed number, maintaining\n// the sign bit.\nfunction smi(i32) {\n  return ((i32 >>> 1) & 0x40000000) | (i32 & 0xbfffffff);\n}\n\nvar defaultValueOf = Object.prototype.valueOf;\n\nfunction hash(o) {\n  if (o == null) {\n    return hashNullish(o);\n  }\n\n  if (typeof o.hashCode === 'function') {\n    // Drop any high bits from accidentally long hash codes.\n    return smi(o.hashCode(o));\n  }\n\n  var v = immutable_es_valueOf(o);\n\n  if (v == null) {\n    return hashNullish(v);\n  }\n\n  switch (typeof v) {\n    case 'boolean':\n      // The hash values for built-in constants are a 1 value for each 5-byte\n      // shift region expect for the first, which encodes the value. This\n      // reduces the odds of a hash collision for these common values.\n      return v ? 0x42108421 : 0x42108420;\n    case 'number':\n      return hashNumber(v);\n    case 'string':\n      return v.length > STRING_HASH_CACHE_MIN_STRLEN\n        ? cachedHashString(v)\n        : hashString(v);\n    case 'object':\n    case 'function':\n      return hashJSObj(v);\n    case 'symbol':\n      return hashSymbol(v);\n    default:\n      if (typeof v.toString === 'function') {\n        return hashString(v.toString());\n      }\n      throw new Error('Value type ' + typeof v + ' cannot be hashed.');\n  }\n}\n\nfunction hashNullish(nullish) {\n  return nullish === null ? 0x42108422 : /* undefined */ 0x42108423;\n}\n\n// Compress arbitrarily large numbers into smi hashes.\nfunction hashNumber(n) {\n  if (n !== n || n === Infinity) {\n    return 0;\n  }\n  var hash = n | 0;\n  if (hash !== n) {\n    hash ^= n * 0xffffffff;\n  }\n  while (n > 0xffffffff) {\n    n /= 0xffffffff;\n    hash ^= n;\n  }\n  return smi(hash);\n}\n\nfunction cachedHashString(string) {\n  var hashed = stringHashCache[string];\n  if (hashed === undefined) {\n    hashed = hashString(string);\n    if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n      STRING_HASH_CACHE_SIZE = 0;\n      stringHashCache = {};\n    }\n    STRING_HASH_CACHE_SIZE++;\n    stringHashCache[string] = hashed;\n  }\n  return hashed;\n}\n\n// http://jsperf.com/hashing-strings\nfunction hashString(string) {\n  // This is the hash from JVM\n  // The hash code for a string is computed as\n  // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n  // where s[i] is the ith character of the string and n is the length of\n  // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n  // (exclusive) by dropping high bits.\n  var hashed = 0;\n  for (var ii = 0; ii < string.length; ii++) {\n    hashed = (31 * hashed + string.charCodeAt(ii)) | 0;\n  }\n  return smi(hashed);\n}\n\nfunction hashSymbol(sym) {\n  var hashed = symbolMap[sym];\n  if (hashed !== undefined) {\n    return hashed;\n  }\n\n  hashed = nextHash();\n\n  symbolMap[sym] = hashed;\n\n  return hashed;\n}\n\nfunction hashJSObj(obj) {\n  var hashed;\n  if (usingWeakMap) {\n    hashed = weakMap.get(obj);\n    if (hashed !== undefined) {\n      return hashed;\n    }\n  }\n\n  hashed = obj[UID_HASH_KEY];\n  if (hashed !== undefined) {\n    return hashed;\n  }\n\n  if (!canDefineProperty) {\n    hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n    if (hashed !== undefined) {\n      return hashed;\n    }\n\n    hashed = getIENodeHash(obj);\n    if (hashed !== undefined) {\n      return hashed;\n    }\n  }\n\n  hashed = nextHash();\n\n  if (usingWeakMap) {\n    weakMap.set(obj, hashed);\n  } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n    throw new Error('Non-extensible objects are not allowed as keys.');\n  } else if (canDefineProperty) {\n    Object.defineProperty(obj, UID_HASH_KEY, {\n      enumerable: false,\n      configurable: false,\n      writable: false,\n      value: hashed,\n    });\n  } else if (\n    obj.propertyIsEnumerable !== undefined &&\n    obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable\n  ) {\n    // Since we can't define a non-enumerable property on the object\n    // we'll hijack one of the less-used non-enumerable properties to\n    // save our hash on it. Since this is a function it will not show up in\n    // `JSON.stringify` which is what we want.\n    obj.propertyIsEnumerable = function () {\n      return this.constructor.prototype.propertyIsEnumerable.apply(\n        this,\n        arguments\n      );\n    };\n    obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;\n  } else if (obj.nodeType !== undefined) {\n    // At this point we couldn't get the IE `uniqueID` to use as a hash\n    // and we couldn't use a non-enumerable property to exploit the\n    // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n    // itself.\n    obj[UID_HASH_KEY] = hashed;\n  } else {\n    throw new Error('Unable to set a non-enumerable property on object.');\n  }\n\n  return hashed;\n}\n\n// Get references to ES5 object methods.\nvar isExtensible = Object.isExtensible;\n\n// True if Object.defineProperty works as expected. IE8 fails this test.\nvar canDefineProperty = (function () {\n  try {\n    Object.defineProperty({}, '@', {});\n    return true;\n  } catch (e) {\n    return false;\n  }\n})();\n\n// IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n// and avoid memory leaks from the IE cloneNode bug.\nfunction getIENodeHash(node) {\n  if (node && node.nodeType > 0) {\n    switch (node.nodeType) {\n      case 1: // Element\n        return node.uniqueID;\n      case 9: // Document\n        return node.documentElement && node.documentElement.uniqueID;\n    }\n  }\n}\n\nfunction immutable_es_valueOf(obj) {\n  return obj.valueOf !== defaultValueOf && typeof obj.valueOf === 'function'\n    ? obj.valueOf(obj)\n    : obj;\n}\n\nfunction nextHash() {\n  var nextHash = ++_objHashUID;\n  if (_objHashUID & 0x40000000) {\n    _objHashUID = 0;\n  }\n  return nextHash;\n}\n\n// If possible, use a WeakMap.\nvar usingWeakMap = typeof WeakMap === 'function';\nvar weakMap;\nif (usingWeakMap) {\n  weakMap = new WeakMap();\n}\n\nvar symbolMap = Object.create(null);\n\nvar _objHashUID = 0;\n\nvar UID_HASH_KEY = '__immutablehash__';\nif (typeof Symbol === 'function') {\n  UID_HASH_KEY = Symbol(UID_HASH_KEY);\n}\n\nvar STRING_HASH_CACHE_MIN_STRLEN = 16;\nvar STRING_HASH_CACHE_MAX_SIZE = 255;\nvar STRING_HASH_CACHE_SIZE = 0;\nvar stringHashCache = {};\n\nvar ToKeyedSequence = /*@__PURE__*/(function (KeyedSeq) {\n  function ToKeyedSequence(indexed, useKeys) {\n    this._iter = indexed;\n    this._useKeys = useKeys;\n    this.size = indexed.size;\n  }\n\n  if ( KeyedSeq ) ToKeyedSequence.__proto__ = KeyedSeq;\n  ToKeyedSequence.prototype = Object.create( KeyedSeq && KeyedSeq.prototype );\n  ToKeyedSequence.prototype.constructor = ToKeyedSequence;\n\n  ToKeyedSequence.prototype.get = function get (key, notSetValue) {\n    return this._iter.get(key, notSetValue);\n  };\n\n  ToKeyedSequence.prototype.has = function has (key) {\n    return this._iter.has(key);\n  };\n\n  ToKeyedSequence.prototype.valueSeq = function valueSeq () {\n    return this._iter.valueSeq();\n  };\n\n  ToKeyedSequence.prototype.reverse = function reverse () {\n    var this$1$1 = this;\n\n    var reversedSequence = reverseFactory(this, true);\n    if (!this._useKeys) {\n      reversedSequence.valueSeq = function () { return this$1$1._iter.toSeq().reverse(); };\n    }\n    return reversedSequence;\n  };\n\n  ToKeyedSequence.prototype.map = function map (mapper, context) {\n    var this$1$1 = this;\n\n    var mappedSequence = mapFactory(this, mapper, context);\n    if (!this._useKeys) {\n      mappedSequence.valueSeq = function () { return this$1$1._iter.toSeq().map(mapper, context); };\n    }\n    return mappedSequence;\n  };\n\n  ToKeyedSequence.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1$1 = this;\n\n    return this._iter.__iterate(function (v, k) { return fn(v, k, this$1$1); }, reverse);\n  };\n\n  ToKeyedSequence.prototype.__iterator = function __iterator (type, reverse) {\n    return this._iter.__iterator(type, reverse);\n  };\n\n  return ToKeyedSequence;\n}(KeyedSeq));\nToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;\n\nvar ToIndexedSequence = /*@__PURE__*/(function (IndexedSeq) {\n  function ToIndexedSequence(iter) {\n    this._iter = iter;\n    this.size = iter.size;\n  }\n\n  if ( IndexedSeq ) ToIndexedSequence.__proto__ = IndexedSeq;\n  ToIndexedSequence.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n  ToIndexedSequence.prototype.constructor = ToIndexedSequence;\n\n  ToIndexedSequence.prototype.includes = function includes (value) {\n    return this._iter.includes(value);\n  };\n\n  ToIndexedSequence.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1$1 = this;\n\n    var i = 0;\n    reverse && ensureSize(this);\n    return this._iter.__iterate(\n      function (v) { return fn(v, reverse ? this$1$1.size - ++i : i++, this$1$1); },\n      reverse\n    );\n  };\n\n  ToIndexedSequence.prototype.__iterator = function __iterator (type, reverse) {\n    var this$1$1 = this;\n\n    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n    var i = 0;\n    reverse && ensureSize(this);\n    return new Iterator(function () {\n      var step = iterator.next();\n      return step.done\n        ? step\n        : iteratorValue(\n            type,\n            reverse ? this$1$1.size - ++i : i++,\n            step.value,\n            step\n          );\n    });\n  };\n\n  return ToIndexedSequence;\n}(IndexedSeq));\n\nvar ToSetSequence = /*@__PURE__*/(function (SetSeq) {\n  function ToSetSequence(iter) {\n    this._iter = iter;\n    this.size = iter.size;\n  }\n\n  if ( SetSeq ) ToSetSequence.__proto__ = SetSeq;\n  ToSetSequence.prototype = Object.create( SetSeq && SetSeq.prototype );\n  ToSetSequence.prototype.constructor = ToSetSequence;\n\n  ToSetSequence.prototype.has = function has (key) {\n    return this._iter.includes(key);\n  };\n\n  ToSetSequence.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1$1 = this;\n\n    return this._iter.__iterate(function (v) { return fn(v, v, this$1$1); }, reverse);\n  };\n\n  ToSetSequence.prototype.__iterator = function __iterator (type, reverse) {\n    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n    return new Iterator(function () {\n      var step = iterator.next();\n      return step.done\n        ? step\n        : iteratorValue(type, step.value, step.value, step);\n    });\n  };\n\n  return ToSetSequence;\n}(SetSeq));\n\nvar FromEntriesSequence = /*@__PURE__*/(function (KeyedSeq) {\n  function FromEntriesSequence(entries) {\n    this._iter = entries;\n    this.size = entries.size;\n  }\n\n  if ( KeyedSeq ) FromEntriesSequence.__proto__ = KeyedSeq;\n  FromEntriesSequence.prototype = Object.create( KeyedSeq && KeyedSeq.prototype );\n  FromEntriesSequence.prototype.constructor = FromEntriesSequence;\n\n  FromEntriesSequence.prototype.entrySeq = function entrySeq () {\n    return this._iter.toSeq();\n  };\n\n  FromEntriesSequence.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1$1 = this;\n\n    return this._iter.__iterate(function (entry) {\n      // Check if entry exists first so array access doesn't throw for holes\n      // in the parent iteration.\n      if (entry) {\n        validateEntry(entry);\n        var indexedCollection = isCollection(entry);\n        return fn(\n          indexedCollection ? entry.get(1) : entry[1],\n          indexedCollection ? entry.get(0) : entry[0],\n          this$1$1\n        );\n      }\n    }, reverse);\n  };\n\n  FromEntriesSequence.prototype.__iterator = function __iterator (type, reverse) {\n    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n    return new Iterator(function () {\n      while (true) {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          var indexedCollection = isCollection(entry);\n          return iteratorValue(\n            type,\n            indexedCollection ? entry.get(0) : entry[0],\n            indexedCollection ? entry.get(1) : entry[1],\n            step\n          );\n        }\n      }\n    });\n  };\n\n  return FromEntriesSequence;\n}(KeyedSeq));\n\nToIndexedSequence.prototype.cacheResult =\n  ToKeyedSequence.prototype.cacheResult =\n  ToSetSequence.prototype.cacheResult =\n  FromEntriesSequence.prototype.cacheResult =\n    cacheResultThrough;\n\nfunction flipFactory(collection) {\n  var flipSequence = makeSequence(collection);\n  flipSequence._iter = collection;\n  flipSequence.size = collection.size;\n  flipSequence.flip = function () { return collection; };\n  flipSequence.reverse = function () {\n    var reversedSequence = collection.reverse.apply(this); // super.reverse()\n    reversedSequence.flip = function () { return collection.reverse(); };\n    return reversedSequence;\n  };\n  flipSequence.has = function (key) { return collection.includes(key); };\n  flipSequence.includes = function (key) { return collection.has(key); };\n  flipSequence.cacheResult = cacheResultThrough;\n  flipSequence.__iterateUncached = function (fn, reverse) {\n    var this$1$1 = this;\n\n    return collection.__iterate(function (v, k) { return fn(k, v, this$1$1) !== false; }, reverse);\n  };\n  flipSequence.__iteratorUncached = function (type, reverse) {\n    if (type === ITERATE_ENTRIES) {\n      var iterator = collection.__iterator(type, reverse);\n      return new Iterator(function () {\n        var step = iterator.next();\n        if (!step.done) {\n          var k = step.value[0];\n          step.value[0] = step.value[1];\n          step.value[1] = k;\n        }\n        return step;\n      });\n    }\n    return collection.__iterator(\n      type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n      reverse\n    );\n  };\n  return flipSequence;\n}\n\nfunction mapFactory(collection, mapper, context) {\n  var mappedSequence = makeSequence(collection);\n  mappedSequence.size = collection.size;\n  mappedSequence.has = function (key) { return collection.has(key); };\n  mappedSequence.get = function (key, notSetValue) {\n    var v = collection.get(key, NOT_SET);\n    return v === NOT_SET\n      ? notSetValue\n      : mapper.call(context, v, key, collection);\n  };\n  mappedSequence.__iterateUncached = function (fn, reverse) {\n    var this$1$1 = this;\n\n    return collection.__iterate(\n      function (v, k, c) { return fn(mapper.call(context, v, k, c), k, this$1$1) !== false; },\n      reverse\n    );\n  };\n  mappedSequence.__iteratorUncached = function (type, reverse) {\n    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n    return new Iterator(function () {\n      var step = iterator.next();\n      if (step.done) {\n        return step;\n      }\n      var entry = step.value;\n      var key = entry[0];\n      return iteratorValue(\n        type,\n        key,\n        mapper.call(context, entry[1], key, collection),\n        step\n      );\n    });\n  };\n  return mappedSequence;\n}\n\nfunction reverseFactory(collection, useKeys) {\n  var this$1$1 = this;\n\n  var reversedSequence = makeSequence(collection);\n  reversedSequence._iter = collection;\n  reversedSequence.size = collection.size;\n  reversedSequence.reverse = function () { return collection; };\n  if (collection.flip) {\n    reversedSequence.flip = function () {\n      var flipSequence = flipFactory(collection);\n      flipSequence.reverse = function () { return collection.flip(); };\n      return flipSequence;\n    };\n  }\n  reversedSequence.get = function (key, notSetValue) { return collection.get(useKeys ? key : -1 - key, notSetValue); };\n  reversedSequence.has = function (key) { return collection.has(useKeys ? key : -1 - key); };\n  reversedSequence.includes = function (value) { return collection.includes(value); };\n  reversedSequence.cacheResult = cacheResultThrough;\n  reversedSequence.__iterate = function (fn, reverse) {\n    var this$1$1 = this;\n\n    var i = 0;\n    reverse && ensureSize(collection);\n    return collection.__iterate(\n      function (v, k) { return fn(v, useKeys ? k : reverse ? this$1$1.size - ++i : i++, this$1$1); },\n      !reverse\n    );\n  };\n  reversedSequence.__iterator = function (type, reverse) {\n    var i = 0;\n    reverse && ensureSize(collection);\n    var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);\n    return new Iterator(function () {\n      var step = iterator.next();\n      if (step.done) {\n        return step;\n      }\n      var entry = step.value;\n      return iteratorValue(\n        type,\n        useKeys ? entry[0] : reverse ? this$1$1.size - ++i : i++,\n        entry[1],\n        step\n      );\n    });\n  };\n  return reversedSequence;\n}\n\nfunction filterFactory(collection, predicate, context, useKeys) {\n  var filterSequence = makeSequence(collection);\n  if (useKeys) {\n    filterSequence.has = function (key) {\n      var v = collection.get(key, NOT_SET);\n      return v !== NOT_SET && !!predicate.call(context, v, key, collection);\n    };\n    filterSequence.get = function (key, notSetValue) {\n      var v = collection.get(key, NOT_SET);\n      return v !== NOT_SET && predicate.call(context, v, key, collection)\n        ? v\n        : notSetValue;\n    };\n  }\n  filterSequence.__iterateUncached = function (fn, reverse) {\n    var this$1$1 = this;\n\n    var iterations = 0;\n    collection.__iterate(function (v, k, c) {\n      if (predicate.call(context, v, k, c)) {\n        iterations++;\n        return fn(v, useKeys ? k : iterations - 1, this$1$1);\n      }\n    }, reverse);\n    return iterations;\n  };\n  filterSequence.__iteratorUncached = function (type, reverse) {\n    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n    var iterations = 0;\n    return new Iterator(function () {\n      while (true) {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var key = entry[0];\n        var value = entry[1];\n        if (predicate.call(context, value, key, collection)) {\n          return iteratorValue(type, useKeys ? key : iterations++, value, step);\n        }\n      }\n    });\n  };\n  return filterSequence;\n}\n\nfunction countByFactory(collection, grouper, context) {\n  var groups = immutable_es_Map().asMutable();\n  collection.__iterate(function (v, k) {\n    groups.update(grouper.call(context, v, k, collection), 0, function (a) { return a + 1; });\n  });\n  return groups.asImmutable();\n}\n\nfunction groupByFactory(collection, grouper, context) {\n  var isKeyedIter = isKeyed(collection);\n  var groups = (isOrdered(collection) ? OrderedMap() : immutable_es_Map()).asMutable();\n  collection.__iterate(function (v, k) {\n    groups.update(\n      grouper.call(context, v, k, collection),\n      function (a) { return ((a = a || []), a.push(isKeyedIter ? [k, v] : v), a); }\n    );\n  });\n  var coerce = collectionClass(collection);\n  return groups.map(function (arr) { return reify(collection, coerce(arr)); }).asImmutable();\n}\n\nfunction sliceFactory(collection, begin, end, useKeys) {\n  var originalSize = collection.size;\n\n  if (wholeSlice(begin, end, originalSize)) {\n    return collection;\n  }\n\n  var resolvedBegin = resolveBegin(begin, originalSize);\n  var resolvedEnd = resolveEnd(end, originalSize);\n\n  // begin or end will be NaN if they were provided as negative numbers and\n  // this collection's size is unknown. In that case, cache first so there is\n  // a known size and these do not resolve to NaN.\n  if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n    return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);\n  }\n\n  // Note: resolvedEnd is undefined when the original sequence's length is\n  // unknown and this slice did not supply an end and should contain all\n  // elements after resolvedBegin.\n  // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n  var resolvedSize = resolvedEnd - resolvedBegin;\n  var sliceSize;\n  if (resolvedSize === resolvedSize) {\n    sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n  }\n\n  var sliceSeq = makeSequence(collection);\n\n  // If collection.size is undefined, the size of the realized sliceSeq is\n  // unknown at this point unless the number of items to slice is 0\n  sliceSeq.size =\n    sliceSize === 0 ? sliceSize : (collection.size && sliceSize) || undefined;\n\n  if (!useKeys && isSeq(collection) && sliceSize >= 0) {\n    sliceSeq.get = function (index, notSetValue) {\n      index = wrapIndex(this, index);\n      return index >= 0 && index < sliceSize\n        ? collection.get(index + resolvedBegin, notSetValue)\n        : notSetValue;\n    };\n  }\n\n  sliceSeq.__iterateUncached = function (fn, reverse) {\n    var this$1$1 = this;\n\n    if (sliceSize === 0) {\n      return 0;\n    }\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var skipped = 0;\n    var isSkipping = true;\n    var iterations = 0;\n    collection.__iterate(function (v, k) {\n      if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n        iterations++;\n        return (\n          fn(v, useKeys ? k : iterations - 1, this$1$1) !== false &&\n          iterations !== sliceSize\n        );\n      }\n    });\n    return iterations;\n  };\n\n  sliceSeq.__iteratorUncached = function (type, reverse) {\n    if (sliceSize !== 0 && reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    // Don't bother instantiating parent iterator if taking 0.\n    if (sliceSize === 0) {\n      return new Iterator(iteratorDone);\n    }\n    var iterator = collection.__iterator(type, reverse);\n    var skipped = 0;\n    var iterations = 0;\n    return new Iterator(function () {\n      while (skipped++ < resolvedBegin) {\n        iterator.next();\n      }\n      if (++iterations > sliceSize) {\n        return iteratorDone();\n      }\n      var step = iterator.next();\n      if (useKeys || type === ITERATE_VALUES || step.done) {\n        return step;\n      }\n      if (type === ITERATE_KEYS) {\n        return iteratorValue(type, iterations - 1, undefined, step);\n      }\n      return iteratorValue(type, iterations - 1, step.value[1], step);\n    });\n  };\n\n  return sliceSeq;\n}\n\nfunction takeWhileFactory(collection, predicate, context) {\n  var takeSequence = makeSequence(collection);\n  takeSequence.__iterateUncached = function (fn, reverse) {\n    var this$1$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var iterations = 0;\n    collection.__iterate(\n      function (v, k, c) { return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1$1); }\n    );\n    return iterations;\n  };\n  takeSequence.__iteratorUncached = function (type, reverse) {\n    var this$1$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n    var iterating = true;\n    return new Iterator(function () {\n      if (!iterating) {\n        return iteratorDone();\n      }\n      var step = iterator.next();\n      if (step.done) {\n        return step;\n      }\n      var entry = step.value;\n      var k = entry[0];\n      var v = entry[1];\n      if (!predicate.call(context, v, k, this$1$1)) {\n        iterating = false;\n        return iteratorDone();\n      }\n      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n    });\n  };\n  return takeSequence;\n}\n\nfunction skipWhileFactory(collection, predicate, context, useKeys) {\n  var skipSequence = makeSequence(collection);\n  skipSequence.__iterateUncached = function (fn, reverse) {\n    var this$1$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var isSkipping = true;\n    var iterations = 0;\n    collection.__iterate(function (v, k, c) {\n      if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n        iterations++;\n        return fn(v, useKeys ? k : iterations - 1, this$1$1);\n      }\n    });\n    return iterations;\n  };\n  skipSequence.__iteratorUncached = function (type, reverse) {\n    var this$1$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n    var skipping = true;\n    var iterations = 0;\n    return new Iterator(function () {\n      var step;\n      var k;\n      var v;\n      do {\n        step = iterator.next();\n        if (step.done) {\n          if (useKeys || type === ITERATE_VALUES) {\n            return step;\n          }\n          if (type === ITERATE_KEYS) {\n            return iteratorValue(type, iterations++, undefined, step);\n          }\n          return iteratorValue(type, iterations++, step.value[1], step);\n        }\n        var entry = step.value;\n        k = entry[0];\n        v = entry[1];\n        skipping && (skipping = predicate.call(context, v, k, this$1$1));\n      } while (skipping);\n      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n    });\n  };\n  return skipSequence;\n}\n\nfunction concatFactory(collection, values) {\n  var isKeyedCollection = isKeyed(collection);\n  var iters = [collection]\n    .concat(values)\n    .map(function (v) {\n      if (!isCollection(v)) {\n        v = isKeyedCollection\n          ? keyedSeqFromValue(v)\n          : indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n      } else if (isKeyedCollection) {\n        v = KeyedCollection(v);\n      }\n      return v;\n    })\n    .filter(function (v) { return v.size !== 0; });\n\n  if (iters.length === 0) {\n    return collection;\n  }\n\n  if (iters.length === 1) {\n    var singleton = iters[0];\n    if (\n      singleton === collection ||\n      (isKeyedCollection && isKeyed(singleton)) ||\n      (isIndexed(collection) && isIndexed(singleton))\n    ) {\n      return singleton;\n    }\n  }\n\n  var concatSeq = new ArraySeq(iters);\n  if (isKeyedCollection) {\n    concatSeq = concatSeq.toKeyedSeq();\n  } else if (!isIndexed(collection)) {\n    concatSeq = concatSeq.toSetSeq();\n  }\n  concatSeq = concatSeq.flatten(true);\n  concatSeq.size = iters.reduce(function (sum, seq) {\n    if (sum !== undefined) {\n      var size = seq.size;\n      if (size !== undefined) {\n        return sum + size;\n      }\n    }\n  }, 0);\n  return concatSeq;\n}\n\nfunction flattenFactory(collection, depth, useKeys) {\n  var flatSequence = makeSequence(collection);\n  flatSequence.__iterateUncached = function (fn, reverse) {\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var iterations = 0;\n    var stopped = false;\n    function flatDeep(iter, currentDepth) {\n      iter.__iterate(function (v, k) {\n        if ((!depth || currentDepth < depth) && isCollection(v)) {\n          flatDeep(v, currentDepth + 1);\n        } else {\n          iterations++;\n          if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {\n            stopped = true;\n          }\n        }\n        return !stopped;\n      }, reverse);\n    }\n    flatDeep(collection, 0);\n    return iterations;\n  };\n  flatSequence.__iteratorUncached = function (type, reverse) {\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var iterator = collection.__iterator(type, reverse);\n    var stack = [];\n    var iterations = 0;\n    return new Iterator(function () {\n      while (iterator) {\n        var step = iterator.next();\n        if (step.done !== false) {\n          iterator = stack.pop();\n          continue;\n        }\n        var v = step.value;\n        if (type === ITERATE_ENTRIES) {\n          v = v[1];\n        }\n        if ((!depth || stack.length < depth) && isCollection(v)) {\n          stack.push(iterator);\n          iterator = v.__iterator(type, reverse);\n        } else {\n          return useKeys ? step : iteratorValue(type, iterations++, v, step);\n        }\n      }\n      return iteratorDone();\n    });\n  };\n  return flatSequence;\n}\n\nfunction flatMapFactory(collection, mapper, context) {\n  var coerce = collectionClass(collection);\n  return collection\n    .toSeq()\n    .map(function (v, k) { return coerce(mapper.call(context, v, k, collection)); })\n    .flatten(true);\n}\n\nfunction interposeFactory(collection, separator) {\n  var interposedSequence = makeSequence(collection);\n  interposedSequence.size = collection.size && collection.size * 2 - 1;\n  interposedSequence.__iterateUncached = function (fn, reverse) {\n    var this$1$1 = this;\n\n    var iterations = 0;\n    collection.__iterate(\n      function (v) { return (!iterations || fn(separator, iterations++, this$1$1) !== false) &&\n        fn(v, iterations++, this$1$1) !== false; },\n      reverse\n    );\n    return iterations;\n  };\n  interposedSequence.__iteratorUncached = function (type, reverse) {\n    var iterator = collection.__iterator(ITERATE_VALUES, reverse);\n    var iterations = 0;\n    var step;\n    return new Iterator(function () {\n      if (!step || iterations % 2) {\n        step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n      }\n      return iterations % 2\n        ? iteratorValue(type, iterations++, separator)\n        : iteratorValue(type, iterations++, step.value, step);\n    });\n  };\n  return interposedSequence;\n}\n\nfunction sortFactory(collection, comparator, mapper) {\n  if (!comparator) {\n    comparator = defaultComparator;\n  }\n  var isKeyedCollection = isKeyed(collection);\n  var index = 0;\n  var entries = collection\n    .toSeq()\n    .map(function (v, k) { return [k, v, index++, mapper ? mapper(v, k, collection) : v]; })\n    .valueSeq()\n    .toArray();\n  entries\n    .sort(function (a, b) { return comparator(a[3], b[3]) || a[2] - b[2]; })\n    .forEach(\n      isKeyedCollection\n        ? function (v, i) {\n            entries[i].length = 2;\n          }\n        : function (v, i) {\n            entries[i] = v[1];\n          }\n    );\n  return isKeyedCollection\n    ? KeyedSeq(entries)\n    : isIndexed(collection)\n    ? IndexedSeq(entries)\n    : SetSeq(entries);\n}\n\nfunction maxFactory(collection, comparator, mapper) {\n  if (!comparator) {\n    comparator = defaultComparator;\n  }\n  if (mapper) {\n    var entry = collection\n      .toSeq()\n      .map(function (v, k) { return [v, mapper(v, k, collection)]; })\n      .reduce(function (a, b) { return (maxCompare(comparator, a[1], b[1]) ? b : a); });\n    return entry && entry[0];\n  }\n  return collection.reduce(function (a, b) { return (maxCompare(comparator, a, b) ? b : a); });\n}\n\nfunction maxCompare(comparator, a, b) {\n  var comp = comparator(b, a);\n  // b is considered the new max if the comparator declares them equal, but\n  // they are not equal and b is in fact a nullish value.\n  return (\n    (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) ||\n    comp > 0\n  );\n}\n\nfunction zipWithFactory(keyIter, zipper, iters, zipAll) {\n  var zipSequence = makeSequence(keyIter);\n  var sizes = new ArraySeq(iters).map(function (i) { return i.size; });\n  zipSequence.size = zipAll ? sizes.max() : sizes.min();\n  // Note: this a generic base implementation of __iterate in terms of\n  // __iterator which may be more generically useful in the future.\n  zipSequence.__iterate = function (fn, reverse) {\n    /* generic:\n    var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n    var step;\n    var iterations = 0;\n    while (!(step = iterator.next()).done) {\n      iterations++;\n      if (fn(step.value[1], step.value[0], this) === false) {\n        break;\n      }\n    }\n    return iterations;\n    */\n    // indexed:\n    var iterator = this.__iterator(ITERATE_VALUES, reverse);\n    var step;\n    var iterations = 0;\n    while (!(step = iterator.next()).done) {\n      if (fn(step.value, iterations++, this) === false) {\n        break;\n      }\n    }\n    return iterations;\n  };\n  zipSequence.__iteratorUncached = function (type, reverse) {\n    var iterators = iters.map(\n      function (i) { return ((i = Collection(i)), getIterator(reverse ? i.reverse() : i)); }\n    );\n    var iterations = 0;\n    var isDone = false;\n    return new Iterator(function () {\n      var steps;\n      if (!isDone) {\n        steps = iterators.map(function (i) { return i.next(); });\n        isDone = zipAll ? steps.every(function (s) { return s.done; }) : steps.some(function (s) { return s.done; });\n      }\n      if (isDone) {\n        return iteratorDone();\n      }\n      return iteratorValue(\n        type,\n        iterations++,\n        zipper.apply(\n          null,\n          steps.map(function (s) { return s.value; })\n        )\n      );\n    });\n  };\n  return zipSequence;\n}\n\n// #pragma Helper Functions\n\nfunction reify(iter, seq) {\n  return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);\n}\n\nfunction validateEntry(entry) {\n  if (entry !== Object(entry)) {\n    throw new TypeError('Expected [K, V] tuple: ' + entry);\n  }\n}\n\nfunction collectionClass(collection) {\n  return isKeyed(collection)\n    ? KeyedCollection\n    : isIndexed(collection)\n    ? IndexedCollection\n    : SetCollection;\n}\n\nfunction makeSequence(collection) {\n  return Object.create(\n    (isKeyed(collection)\n      ? KeyedSeq\n      : isIndexed(collection)\n      ? IndexedSeq\n      : SetSeq\n    ).prototype\n  );\n}\n\nfunction cacheResultThrough() {\n  if (this._iter.cacheResult) {\n    this._iter.cacheResult();\n    this.size = this._iter.size;\n    return this;\n  }\n  return Seq.prototype.cacheResult.call(this);\n}\n\nfunction defaultComparator(a, b) {\n  if (a === undefined && b === undefined) {\n    return 0;\n  }\n\n  if (a === undefined) {\n    return 1;\n  }\n\n  if (b === undefined) {\n    return -1;\n  }\n\n  return a > b ? 1 : a < b ? -1 : 0;\n}\n\nfunction arrCopy(arr, offset) {\n  offset = offset || 0;\n  var len = Math.max(0, arr.length - offset);\n  var newArr = new Array(len);\n  for (var ii = 0; ii < len; ii++) {\n    newArr[ii] = arr[ii + offset];\n  }\n  return newArr;\n}\n\nfunction invariant(condition, error) {\n  if (!condition) { throw new Error(error); }\n}\n\nfunction assertNotInfinite(size) {\n  invariant(\n    size !== Infinity,\n    'Cannot perform this action with an infinite size.'\n  );\n}\n\nfunction coerceKeyPath(keyPath) {\n  if (isArrayLike(keyPath) && typeof keyPath !== 'string') {\n    return keyPath;\n  }\n  if (isOrdered(keyPath)) {\n    return keyPath.toArray();\n  }\n  throw new TypeError(\n    'Invalid keyPath: expected Ordered Collection or Array: ' + keyPath\n  );\n}\n\nvar immutable_es_toString = Object.prototype.toString;\n\nfunction isPlainObject(value) {\n  // The base prototype's toString deals with Argument objects and native namespaces like Math\n  if (\n    !value ||\n    typeof value !== 'object' ||\n    immutable_es_toString.call(value) !== '[object Object]'\n  ) {\n    return false;\n  }\n\n  var proto = Object.getPrototypeOf(value);\n  if (proto === null) {\n    return true;\n  }\n\n  // Iteratively going up the prototype chain is needed for cross-realm environments (differing contexts, iframes, etc)\n  var parentProto = proto;\n  var nextProto = Object.getPrototypeOf(proto);\n  while (nextProto !== null) {\n    parentProto = nextProto;\n    nextProto = Object.getPrototypeOf(parentProto);\n  }\n  return parentProto === proto;\n}\n\n/**\n * Returns true if the value is a potentially-persistent data structure, either\n * provided by Immutable.js or a plain Array or Object.\n */\nfunction isDataStructure(value) {\n  return (\n    typeof value === 'object' &&\n    (isImmutable(value) || Array.isArray(value) || isPlainObject(value))\n  );\n}\n\nfunction quoteString(value) {\n  try {\n    return typeof value === 'string' ? JSON.stringify(value) : String(value);\n  } catch (_ignoreError) {\n    return JSON.stringify(value);\n  }\n}\n\nfunction has(collection, key) {\n  return isImmutable(collection)\n    ? collection.has(key)\n    : isDataStructure(collection) && immutable_es_hasOwnProperty.call(collection, key);\n}\n\nfunction get(collection, key, notSetValue) {\n  return isImmutable(collection)\n    ? collection.get(key, notSetValue)\n    : !has(collection, key)\n    ? notSetValue\n    : typeof collection.get === 'function'\n    ? collection.get(key)\n    : collection[key];\n}\n\nfunction shallowCopy(from) {\n  if (Array.isArray(from)) {\n    return arrCopy(from);\n  }\n  var to = {};\n  for (var key in from) {\n    if (immutable_es_hasOwnProperty.call(from, key)) {\n      to[key] = from[key];\n    }\n  }\n  return to;\n}\n\nfunction remove(collection, key) {\n  if (!isDataStructure(collection)) {\n    throw new TypeError(\n      'Cannot update non-data-structure value: ' + collection\n    );\n  }\n  if (isImmutable(collection)) {\n    if (!collection.remove) {\n      throw new TypeError(\n        'Cannot update immutable value without .remove() method: ' + collection\n      );\n    }\n    return collection.remove(key);\n  }\n  if (!immutable_es_hasOwnProperty.call(collection, key)) {\n    return collection;\n  }\n  var collectionCopy = shallowCopy(collection);\n  if (Array.isArray(collectionCopy)) {\n    collectionCopy.splice(key, 1);\n  } else {\n    delete collectionCopy[key];\n  }\n  return collectionCopy;\n}\n\nfunction set(collection, key, value) {\n  if (!isDataStructure(collection)) {\n    throw new TypeError(\n      'Cannot update non-data-structure value: ' + collection\n    );\n  }\n  if (isImmutable(collection)) {\n    if (!collection.set) {\n      throw new TypeError(\n        'Cannot update immutable value without .set() method: ' + collection\n      );\n    }\n    return collection.set(key, value);\n  }\n  if (immutable_es_hasOwnProperty.call(collection, key) && value === collection[key]) {\n    return collection;\n  }\n  var collectionCopy = shallowCopy(collection);\n  collectionCopy[key] = value;\n  return collectionCopy;\n}\n\nfunction updateIn$1(collection, keyPath, notSetValue, updater) {\n  if (!updater) {\n    updater = notSetValue;\n    notSetValue = undefined;\n  }\n  var updatedValue = updateInDeeply(\n    isImmutable(collection),\n    collection,\n    coerceKeyPath(keyPath),\n    0,\n    notSetValue,\n    updater\n  );\n  return updatedValue === NOT_SET ? notSetValue : updatedValue;\n}\n\nfunction updateInDeeply(\n  inImmutable,\n  existing,\n  keyPath,\n  i,\n  notSetValue,\n  updater\n) {\n  var wasNotSet = existing === NOT_SET;\n  if (i === keyPath.length) {\n    var existingValue = wasNotSet ? notSetValue : existing;\n    var newValue = updater(existingValue);\n    return newValue === existingValue ? existing : newValue;\n  }\n  if (!wasNotSet && !isDataStructure(existing)) {\n    throw new TypeError(\n      'Cannot update within non-data-structure value in path [' +\n        keyPath.slice(0, i).map(quoteString) +\n        ']: ' +\n        existing\n    );\n  }\n  var key = keyPath[i];\n  var nextExisting = wasNotSet ? NOT_SET : get(existing, key, NOT_SET);\n  var nextUpdated = updateInDeeply(\n    nextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting),\n    nextExisting,\n    keyPath,\n    i + 1,\n    notSetValue,\n    updater\n  );\n  return nextUpdated === nextExisting\n    ? existing\n    : nextUpdated === NOT_SET\n    ? remove(existing, key)\n    : set(\n        wasNotSet ? (inImmutable ? emptyMap() : {}) : existing,\n        key,\n        nextUpdated\n      );\n}\n\nfunction setIn$1(collection, keyPath, value) {\n  return updateIn$1(collection, keyPath, NOT_SET, function () { return value; });\n}\n\nfunction setIn(keyPath, v) {\n  return setIn$1(this, keyPath, v);\n}\n\nfunction removeIn(collection, keyPath) {\n  return updateIn$1(collection, keyPath, function () { return NOT_SET; });\n}\n\nfunction deleteIn(keyPath) {\n  return removeIn(this, keyPath);\n}\n\nfunction update$1(collection, key, notSetValue, updater) {\n  return updateIn$1(collection, [key], notSetValue, updater);\n}\n\nfunction update(key, notSetValue, updater) {\n  return arguments.length === 1\n    ? key(this)\n    : update$1(this, key, notSetValue, updater);\n}\n\nfunction updateIn(keyPath, notSetValue, updater) {\n  return updateIn$1(this, keyPath, notSetValue, updater);\n}\n\nfunction merge$1() {\n  var iters = [], len = arguments.length;\n  while ( len-- ) iters[ len ] = arguments[ len ];\n\n  return mergeIntoKeyedWith(this, iters);\n}\n\nfunction mergeWith$1(merger) {\n  var iters = [], len = arguments.length - 1;\n  while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n  if (typeof merger !== 'function') {\n    throw new TypeError('Invalid merger function: ' + merger);\n  }\n  return mergeIntoKeyedWith(this, iters, merger);\n}\n\nfunction mergeIntoKeyedWith(collection, collections, merger) {\n  var iters = [];\n  for (var ii = 0; ii < collections.length; ii++) {\n    var collection$1 = KeyedCollection(collections[ii]);\n    if (collection$1.size !== 0) {\n      iters.push(collection$1);\n    }\n  }\n  if (iters.length === 0) {\n    return collection;\n  }\n  if (\n    collection.toSeq().size === 0 &&\n    !collection.__ownerID &&\n    iters.length === 1\n  ) {\n    return collection.constructor(iters[0]);\n  }\n  return collection.withMutations(function (collection) {\n    var mergeIntoCollection = merger\n      ? function (value, key) {\n          update$1(collection, key, NOT_SET, function (oldVal) { return oldVal === NOT_SET ? value : merger(oldVal, value, key); }\n          );\n        }\n      : function (value, key) {\n          collection.set(key, value);\n        };\n    for (var ii = 0; ii < iters.length; ii++) {\n      iters[ii].forEach(mergeIntoCollection);\n    }\n  });\n}\n\nfunction merge(collection) {\n  var sources = [], len = arguments.length - 1;\n  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n  return mergeWithSources(collection, sources);\n}\n\nfunction mergeWith(merger, collection) {\n  var sources = [], len = arguments.length - 2;\n  while ( len-- > 0 ) sources[ len ] = arguments[ len + 2 ];\n\n  return mergeWithSources(collection, sources, merger);\n}\n\nfunction mergeDeep$1(collection) {\n  var sources = [], len = arguments.length - 1;\n  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n  return mergeDeepWithSources(collection, sources);\n}\n\nfunction mergeDeepWith$1(merger, collection) {\n  var sources = [], len = arguments.length - 2;\n  while ( len-- > 0 ) sources[ len ] = arguments[ len + 2 ];\n\n  return mergeDeepWithSources(collection, sources, merger);\n}\n\nfunction mergeDeepWithSources(collection, sources, merger) {\n  return mergeWithSources(collection, sources, deepMergerWith(merger));\n}\n\nfunction mergeWithSources(collection, sources, merger) {\n  if (!isDataStructure(collection)) {\n    throw new TypeError(\n      'Cannot merge into non-data-structure value: ' + collection\n    );\n  }\n  if (isImmutable(collection)) {\n    return typeof merger === 'function' && collection.mergeWith\n      ? collection.mergeWith.apply(collection, [ merger ].concat( sources ))\n      : collection.merge\n      ? collection.merge.apply(collection, sources)\n      : collection.concat.apply(collection, sources);\n  }\n  var isArray = Array.isArray(collection);\n  var merged = collection;\n  var Collection = isArray ? IndexedCollection : KeyedCollection;\n  var mergeItem = isArray\n    ? function (value) {\n        // Copy on write\n        if (merged === collection) {\n          merged = shallowCopy(merged);\n        }\n        merged.push(value);\n      }\n    : function (value, key) {\n        var hasVal = immutable_es_hasOwnProperty.call(merged, key);\n        var nextVal =\n          hasVal && merger ? merger(merged[key], value, key) : value;\n        if (!hasVal || nextVal !== merged[key]) {\n          // Copy on write\n          if (merged === collection) {\n            merged = shallowCopy(merged);\n          }\n          merged[key] = nextVal;\n        }\n      };\n  for (var i = 0; i < sources.length; i++) {\n    Collection(sources[i]).forEach(mergeItem);\n  }\n  return merged;\n}\n\nfunction deepMergerWith(merger) {\n  function deepMerger(oldValue, newValue, key) {\n    return isDataStructure(oldValue) &&\n      isDataStructure(newValue) &&\n      areMergeable(oldValue, newValue)\n      ? mergeWithSources(oldValue, [newValue], deepMerger)\n      : merger\n      ? merger(oldValue, newValue, key)\n      : newValue;\n  }\n  return deepMerger;\n}\n\n/**\n * It's unclear what the desired behavior is for merging two collections that\n * fall into separate categories between keyed, indexed, or set-like, so we only\n * consider them mergeable if they fall into the same category.\n */\nfunction areMergeable(oldDataStructure, newDataStructure) {\n  var oldSeq = Seq(oldDataStructure);\n  var newSeq = Seq(newDataStructure);\n  // This logic assumes that a sequence can only fall into one of the three\n  // categories mentioned above (since there's no `isSetLike()` method).\n  return (\n    isIndexed(oldSeq) === isIndexed(newSeq) &&\n    isKeyed(oldSeq) === isKeyed(newSeq)\n  );\n}\n\nfunction mergeDeep() {\n  var iters = [], len = arguments.length;\n  while ( len-- ) iters[ len ] = arguments[ len ];\n\n  return mergeDeepWithSources(this, iters);\n}\n\nfunction mergeDeepWith(merger) {\n  var iters = [], len = arguments.length - 1;\n  while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n  return mergeDeepWithSources(this, iters, merger);\n}\n\nfunction mergeIn(keyPath) {\n  var iters = [], len = arguments.length - 1;\n  while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n  return updateIn$1(this, keyPath, emptyMap(), function (m) { return mergeWithSources(m, iters); });\n}\n\nfunction mergeDeepIn(keyPath) {\n  var iters = [], len = arguments.length - 1;\n  while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n  return updateIn$1(this, keyPath, emptyMap(), function (m) { return mergeDeepWithSources(m, iters); }\n  );\n}\n\nfunction withMutations(fn) {\n  var mutable = this.asMutable();\n  fn(mutable);\n  return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n}\n\nfunction asMutable() {\n  return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n}\n\nfunction asImmutable() {\n  return this.__ensureOwner();\n}\n\nfunction wasAltered() {\n  return this.__altered;\n}\n\nvar immutable_es_Map = /*@__PURE__*/(function (KeyedCollection) {\n  function Map(value) {\n    return value === undefined || value === null\n      ? emptyMap()\n      : isMap(value) && !isOrdered(value)\n      ? value\n      : emptyMap().withMutations(function (map) {\n          var iter = KeyedCollection(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function (v, k) { return map.set(k, v); });\n        });\n  }\n\n  if ( KeyedCollection ) Map.__proto__ = KeyedCollection;\n  Map.prototype = Object.create( KeyedCollection && KeyedCollection.prototype );\n  Map.prototype.constructor = Map;\n\n  Map.of = function of () {\n    var keyValues = [], len = arguments.length;\n    while ( len-- ) keyValues[ len ] = arguments[ len ];\n\n    return emptyMap().withMutations(function (map) {\n      for (var i = 0; i < keyValues.length; i += 2) {\n        if (i + 1 >= keyValues.length) {\n          throw new Error('Missing value for key: ' + keyValues[i]);\n        }\n        map.set(keyValues[i], keyValues[i + 1]);\n      }\n    });\n  };\n\n  Map.prototype.toString = function toString () {\n    return this.__toString('Map {', '}');\n  };\n\n  // @pragma Access\n\n  Map.prototype.get = function get (k, notSetValue) {\n    return this._root\n      ? this._root.get(0, undefined, k, notSetValue)\n      : notSetValue;\n  };\n\n  // @pragma Modification\n\n  Map.prototype.set = function set (k, v) {\n    return updateMap(this, k, v);\n  };\n\n  Map.prototype.remove = function remove (k) {\n    return updateMap(this, k, NOT_SET);\n  };\n\n  Map.prototype.deleteAll = function deleteAll (keys) {\n    var collection = Collection(keys);\n\n    if (collection.size === 0) {\n      return this;\n    }\n\n    return this.withMutations(function (map) {\n      collection.forEach(function (key) { return map.remove(key); });\n    });\n  };\n\n  Map.prototype.clear = function clear () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = 0;\n      this._root = null;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return emptyMap();\n  };\n\n  // @pragma Composition\n\n  Map.prototype.sort = function sort (comparator) {\n    // Late binding\n    return OrderedMap(sortFactory(this, comparator));\n  };\n\n  Map.prototype.sortBy = function sortBy (mapper, comparator) {\n    // Late binding\n    return OrderedMap(sortFactory(this, comparator, mapper));\n  };\n\n  Map.prototype.map = function map (mapper, context) {\n    var this$1$1 = this;\n\n    return this.withMutations(function (map) {\n      map.forEach(function (value, key) {\n        map.set(key, mapper.call(context, value, key, this$1$1));\n      });\n    });\n  };\n\n  // @pragma Mutability\n\n  Map.prototype.__iterator = function __iterator (type, reverse) {\n    return new MapIterator(this, type, reverse);\n  };\n\n  Map.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1$1 = this;\n\n    var iterations = 0;\n    this._root &&\n      this._root.iterate(function (entry) {\n        iterations++;\n        return fn(entry[1], entry[0], this$1$1);\n      }, reverse);\n    return iterations;\n  };\n\n  Map.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptyMap();\n      }\n      this.__ownerID = ownerID;\n      this.__altered = false;\n      return this;\n    }\n    return makeMap(this.size, this._root, ownerID, this.__hash);\n  };\n\n  return Map;\n}(KeyedCollection));\n\nimmutable_es_Map.isMap = isMap;\n\nvar MapPrototype = immutable_es_Map.prototype;\nMapPrototype[IS_MAP_SYMBOL] = true;\nMapPrototype[DELETE] = MapPrototype.remove;\nMapPrototype.removeAll = MapPrototype.deleteAll;\nMapPrototype.setIn = setIn;\nMapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;\nMapPrototype.update = update;\nMapPrototype.updateIn = updateIn;\nMapPrototype.merge = MapPrototype.concat = merge$1;\nMapPrototype.mergeWith = mergeWith$1;\nMapPrototype.mergeDeep = mergeDeep;\nMapPrototype.mergeDeepWith = mergeDeepWith;\nMapPrototype.mergeIn = mergeIn;\nMapPrototype.mergeDeepIn = mergeDeepIn;\nMapPrototype.withMutations = withMutations;\nMapPrototype.wasAltered = wasAltered;\nMapPrototype.asImmutable = asImmutable;\nMapPrototype['@@transducer/init'] = MapPrototype.asMutable = asMutable;\nMapPrototype['@@transducer/step'] = function (result, arr) {\n  return result.set(arr[0], arr[1]);\n};\nMapPrototype['@@transducer/result'] = function (obj) {\n  return obj.asImmutable();\n};\n\n// #pragma Trie Nodes\n\nvar ArrayMapNode = function ArrayMapNode(ownerID, entries) {\n  this.ownerID = ownerID;\n  this.entries = entries;\n};\n\nArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  var entries = this.entries;\n  for (var ii = 0, len = entries.length; ii < len; ii++) {\n    if (immutable_es_is(key, entries[ii][0])) {\n      return entries[ii][1];\n    }\n  }\n  return notSetValue;\n};\n\nArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  var removed = value === NOT_SET;\n\n  var entries = this.entries;\n  var idx = 0;\n  var len = entries.length;\n  for (; idx < len; idx++) {\n    if (immutable_es_is(key, entries[idx][0])) {\n      break;\n    }\n  }\n  var exists = idx < len;\n\n  if (exists ? entries[idx][1] === value : removed) {\n    return this;\n  }\n\n  SetRef(didAlter);\n  (removed || !exists) && SetRef(didChangeSize);\n\n  if (removed && entries.length === 1) {\n    return; // undefined\n  }\n\n  if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n    return createNodes(ownerID, entries, key, value);\n  }\n\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newEntries = isEditable ? entries : arrCopy(entries);\n\n  if (exists) {\n    if (removed) {\n      idx === len - 1\n        ? newEntries.pop()\n        : (newEntries[idx] = newEntries.pop());\n    } else {\n      newEntries[idx] = [key, value];\n    }\n  } else {\n    newEntries.push([key, value]);\n  }\n\n  if (isEditable) {\n    this.entries = newEntries;\n    return this;\n  }\n\n  return new ArrayMapNode(ownerID, newEntries);\n};\n\nvar BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {\n  this.ownerID = ownerID;\n  this.bitmap = bitmap;\n  this.nodes = nodes;\n};\n\nBitmapIndexedNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);\n  var bitmap = this.bitmap;\n  return (bitmap & bit) === 0\n    ? notSetValue\n    : this.nodes[popCount(bitmap & (bit - 1))].get(\n        shift + SHIFT,\n        keyHash,\n        key,\n        notSetValue\n      );\n};\n\nBitmapIndexedNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n  var bit = 1 << keyHashFrag;\n  var bitmap = this.bitmap;\n  var exists = (bitmap & bit) !== 0;\n\n  if (!exists && value === NOT_SET) {\n    return this;\n  }\n\n  var idx = popCount(bitmap & (bit - 1));\n  var nodes = this.nodes;\n  var node = exists ? nodes[idx] : undefined;\n  var newNode = updateNode(\n    node,\n    ownerID,\n    shift + SHIFT,\n    keyHash,\n    key,\n    value,\n    didChangeSize,\n    didAlter\n  );\n\n  if (newNode === node) {\n    return this;\n  }\n\n  if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n    return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n  }\n\n  if (\n    exists &&\n    !newNode &&\n    nodes.length === 2 &&\n    isLeafNode(nodes[idx ^ 1])\n  ) {\n    return nodes[idx ^ 1];\n  }\n\n  if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n    return newNode;\n  }\n\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newBitmap = exists ? (newNode ? bitmap : bitmap ^ bit) : bitmap | bit;\n  var newNodes = exists\n    ? newNode\n      ? setAt(nodes, idx, newNode, isEditable)\n      : spliceOut(nodes, idx, isEditable)\n    : spliceIn(nodes, idx, newNode, isEditable);\n\n  if (isEditable) {\n    this.bitmap = newBitmap;\n    this.nodes = newNodes;\n    return this;\n  }\n\n  return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n};\n\nvar HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {\n  this.ownerID = ownerID;\n  this.count = count;\n  this.nodes = nodes;\n};\n\nHashArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n  var node = this.nodes[idx];\n  return node\n    ? node.get(shift + SHIFT, keyHash, key, notSetValue)\n    : notSetValue;\n};\n\nHashArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n  var removed = value === NOT_SET;\n  var nodes = this.nodes;\n  var node = nodes[idx];\n\n  if (removed && !node) {\n    return this;\n  }\n\n  var newNode = updateNode(\n    node,\n    ownerID,\n    shift + SHIFT,\n    keyHash,\n    key,\n    value,\n    didChangeSize,\n    didAlter\n  );\n  if (newNode === node) {\n    return this;\n  }\n\n  var newCount = this.count;\n  if (!node) {\n    newCount++;\n  } else if (!newNode) {\n    newCount--;\n    if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n      return packNodes(ownerID, nodes, newCount, idx);\n    }\n  }\n\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newNodes = setAt(nodes, idx, newNode, isEditable);\n\n  if (isEditable) {\n    this.count = newCount;\n    this.nodes = newNodes;\n    return this;\n  }\n\n  return new HashArrayMapNode(ownerID, newCount, newNodes);\n};\n\nvar HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {\n  this.ownerID = ownerID;\n  this.keyHash = keyHash;\n  this.entries = entries;\n};\n\nHashCollisionNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  var entries = this.entries;\n  for (var ii = 0, len = entries.length; ii < len; ii++) {\n    if (immutable_es_is(key, entries[ii][0])) {\n      return entries[ii][1];\n    }\n  }\n  return notSetValue;\n};\n\nHashCollisionNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n\n  var removed = value === NOT_SET;\n\n  if (keyHash !== this.keyHash) {\n    if (removed) {\n      return this;\n    }\n    SetRef(didAlter);\n    SetRef(didChangeSize);\n    return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n  }\n\n  var entries = this.entries;\n  var idx = 0;\n  var len = entries.length;\n  for (; idx < len; idx++) {\n    if (immutable_es_is(key, entries[idx][0])) {\n      break;\n    }\n  }\n  var exists = idx < len;\n\n  if (exists ? entries[idx][1] === value : removed) {\n    return this;\n  }\n\n  SetRef(didAlter);\n  (removed || !exists) && SetRef(didChangeSize);\n\n  if (removed && len === 2) {\n    return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n  }\n\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newEntries = isEditable ? entries : arrCopy(entries);\n\n  if (exists) {\n    if (removed) {\n      idx === len - 1\n        ? newEntries.pop()\n        : (newEntries[idx] = newEntries.pop());\n    } else {\n      newEntries[idx] = [key, value];\n    }\n  } else {\n    newEntries.push([key, value]);\n  }\n\n  if (isEditable) {\n    this.entries = newEntries;\n    return this;\n  }\n\n  return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n};\n\nvar ValueNode = function ValueNode(ownerID, keyHash, entry) {\n  this.ownerID = ownerID;\n  this.keyHash = keyHash;\n  this.entry = entry;\n};\n\nValueNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  return immutable_es_is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n};\n\nValueNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  var removed = value === NOT_SET;\n  var keyMatch = immutable_es_is(key, this.entry[0]);\n  if (keyMatch ? value === this.entry[1] : removed) {\n    return this;\n  }\n\n  SetRef(didAlter);\n\n  if (removed) {\n    SetRef(didChangeSize);\n    return; // undefined\n  }\n\n  if (keyMatch) {\n    if (ownerID && ownerID === this.ownerID) {\n      this.entry[1] = value;\n      return this;\n    }\n    return new ValueNode(ownerID, this.keyHash, [key, value]);\n  }\n\n  SetRef(didChangeSize);\n  return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n};\n\n// #pragma Iterators\n\nArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate =\n  function (fn, reverse) {\n    var entries = this.entries;\n    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n        return false;\n      }\n    }\n  };\n\nBitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate =\n  function (fn, reverse) {\n    var nodes = this.nodes;\n    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n      var node = nodes[reverse ? maxIndex - ii : ii];\n      if (node && node.iterate(fn, reverse) === false) {\n        return false;\n      }\n    }\n  };\n\n// eslint-disable-next-line no-unused-vars\nValueNode.prototype.iterate = function (fn, reverse) {\n  return fn(this.entry);\n};\n\nvar MapIterator = /*@__PURE__*/(function (Iterator) {\n  function MapIterator(map, type, reverse) {\n    this._type = type;\n    this._reverse = reverse;\n    this._stack = map._root && mapIteratorFrame(map._root);\n  }\n\n  if ( Iterator ) MapIterator.__proto__ = Iterator;\n  MapIterator.prototype = Object.create( Iterator && Iterator.prototype );\n  MapIterator.prototype.constructor = MapIterator;\n\n  MapIterator.prototype.next = function next () {\n    var type = this._type;\n    var stack = this._stack;\n    while (stack) {\n      var node = stack.node;\n      var index = stack.index++;\n      var maxIndex = (void 0);\n      if (node.entry) {\n        if (index === 0) {\n          return mapIteratorValue(type, node.entry);\n        }\n      } else if (node.entries) {\n        maxIndex = node.entries.length - 1;\n        if (index <= maxIndex) {\n          return mapIteratorValue(\n            type,\n            node.entries[this._reverse ? maxIndex - index : index]\n          );\n        }\n      } else {\n        maxIndex = node.nodes.length - 1;\n        if (index <= maxIndex) {\n          var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n          if (subNode) {\n            if (subNode.entry) {\n              return mapIteratorValue(type, subNode.entry);\n            }\n            stack = this._stack = mapIteratorFrame(subNode, stack);\n          }\n          continue;\n        }\n      }\n      stack = this._stack = this._stack.__prev;\n    }\n    return iteratorDone();\n  };\n\n  return MapIterator;\n}(Iterator));\n\nfunction mapIteratorValue(type, entry) {\n  return iteratorValue(type, entry[0], entry[1]);\n}\n\nfunction mapIteratorFrame(node, prev) {\n  return {\n    node: node,\n    index: 0,\n    __prev: prev,\n  };\n}\n\nfunction makeMap(size, root, ownerID, hash) {\n  var map = Object.create(MapPrototype);\n  map.size = size;\n  map._root = root;\n  map.__ownerID = ownerID;\n  map.__hash = hash;\n  map.__altered = false;\n  return map;\n}\n\nvar EMPTY_MAP;\nfunction emptyMap() {\n  return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n}\n\nfunction updateMap(map, k, v) {\n  var newRoot;\n  var newSize;\n  if (!map._root) {\n    if (v === NOT_SET) {\n      return map;\n    }\n    newSize = 1;\n    newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n  } else {\n    var didChangeSize = MakeRef();\n    var didAlter = MakeRef();\n    newRoot = updateNode(\n      map._root,\n      map.__ownerID,\n      0,\n      undefined,\n      k,\n      v,\n      didChangeSize,\n      didAlter\n    );\n    if (!didAlter.value) {\n      return map;\n    }\n    newSize = map.size + (didChangeSize.value ? (v === NOT_SET ? -1 : 1) : 0);\n  }\n  if (map.__ownerID) {\n    map.size = newSize;\n    map._root = newRoot;\n    map.__hash = undefined;\n    map.__altered = true;\n    return map;\n  }\n  return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n}\n\nfunction updateNode(\n  node,\n  ownerID,\n  shift,\n  keyHash,\n  key,\n  value,\n  didChangeSize,\n  didAlter\n) {\n  if (!node) {\n    if (value === NOT_SET) {\n      return node;\n    }\n    SetRef(didAlter);\n    SetRef(didChangeSize);\n    return new ValueNode(ownerID, keyHash, [key, value]);\n  }\n  return node.update(\n    ownerID,\n    shift,\n    keyHash,\n    key,\n    value,\n    didChangeSize,\n    didAlter\n  );\n}\n\nfunction isLeafNode(node) {\n  return (\n    node.constructor === ValueNode || node.constructor === HashCollisionNode\n  );\n}\n\nfunction mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n  if (node.keyHash === keyHash) {\n    return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n  }\n\n  var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n  var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\n  var newNode;\n  var nodes =\n    idx1 === idx2\n      ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)]\n      : ((newNode = new ValueNode(ownerID, keyHash, entry)),\n        idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\n  return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);\n}\n\nfunction createNodes(ownerID, entries, key, value) {\n  if (!ownerID) {\n    ownerID = new OwnerID();\n  }\n  var node = new ValueNode(ownerID, hash(key), [key, value]);\n  for (var ii = 0; ii < entries.length; ii++) {\n    var entry = entries[ii];\n    node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n  }\n  return node;\n}\n\nfunction packNodes(ownerID, nodes, count, excluding) {\n  var bitmap = 0;\n  var packedII = 0;\n  var packedNodes = new Array(count);\n  for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n    var node = nodes[ii];\n    if (node !== undefined && ii !== excluding) {\n      bitmap |= bit;\n      packedNodes[packedII++] = node;\n    }\n  }\n  return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n}\n\nfunction expandNodes(ownerID, nodes, bitmap, including, node) {\n  var count = 0;\n  var expandedNodes = new Array(SIZE);\n  for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n    expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n  }\n  expandedNodes[including] = node;\n  return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n}\n\nfunction popCount(x) {\n  x -= (x >> 1) & 0x55555555;\n  x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n  x = (x + (x >> 4)) & 0x0f0f0f0f;\n  x += x >> 8;\n  x += x >> 16;\n  return x & 0x7f;\n}\n\nfunction setAt(array, idx, val, canEdit) {\n  var newArray = canEdit ? array : arrCopy(array);\n  newArray[idx] = val;\n  return newArray;\n}\n\nfunction spliceIn(array, idx, val, canEdit) {\n  var newLen = array.length + 1;\n  if (canEdit && idx + 1 === newLen) {\n    array[idx] = val;\n    return array;\n  }\n  var newArray = new Array(newLen);\n  var after = 0;\n  for (var ii = 0; ii < newLen; ii++) {\n    if (ii === idx) {\n      newArray[ii] = val;\n      after = -1;\n    } else {\n      newArray[ii] = array[ii + after];\n    }\n  }\n  return newArray;\n}\n\nfunction spliceOut(array, idx, canEdit) {\n  var newLen = array.length - 1;\n  if (canEdit && idx === newLen) {\n    array.pop();\n    return array;\n  }\n  var newArray = new Array(newLen);\n  var after = 0;\n  for (var ii = 0; ii < newLen; ii++) {\n    if (ii === idx) {\n      after = 1;\n    }\n    newArray[ii] = array[ii + after];\n  }\n  return newArray;\n}\n\nvar MAX_ARRAY_MAP_SIZE = SIZE / 4;\nvar MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\nvar MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\nvar IS_LIST_SYMBOL = '@@__IMMUTABLE_LIST__@@';\n\nfunction isList(maybeList) {\n  return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);\n}\n\nvar List = /*@__PURE__*/(function (IndexedCollection) {\n  function List(value) {\n    var empty = emptyList();\n    if (value === undefined || value === null) {\n      return empty;\n    }\n    if (isList(value)) {\n      return value;\n    }\n    var iter = IndexedCollection(value);\n    var size = iter.size;\n    if (size === 0) {\n      return empty;\n    }\n    assertNotInfinite(size);\n    if (size > 0 && size < SIZE) {\n      return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n    }\n    return empty.withMutations(function (list) {\n      list.setSize(size);\n      iter.forEach(function (v, i) { return list.set(i, v); });\n    });\n  }\n\n  if ( IndexedCollection ) List.__proto__ = IndexedCollection;\n  List.prototype = Object.create( IndexedCollection && IndexedCollection.prototype );\n  List.prototype.constructor = List;\n\n  List.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  List.prototype.toString = function toString () {\n    return this.__toString('List [', ']');\n  };\n\n  // @pragma Access\n\n  List.prototype.get = function get (index, notSetValue) {\n    index = wrapIndex(this, index);\n    if (index >= 0 && index < this.size) {\n      index += this._origin;\n      var node = listNodeFor(this, index);\n      return node && node.array[index & MASK];\n    }\n    return notSetValue;\n  };\n\n  // @pragma Modification\n\n  List.prototype.set = function set (index, value) {\n    return updateList(this, index, value);\n  };\n\n  List.prototype.remove = function remove (index) {\n    return !this.has(index)\n      ? this\n      : index === 0\n      ? this.shift()\n      : index === this.size - 1\n      ? this.pop()\n      : this.splice(index, 1);\n  };\n\n  List.prototype.insert = function insert (index, value) {\n    return this.splice(index, 0, value);\n  };\n\n  List.prototype.clear = function clear () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = this._origin = this._capacity = 0;\n      this._level = SHIFT;\n      this._root = this._tail = this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return emptyList();\n  };\n\n  List.prototype.push = function push (/*...values*/) {\n    var values = arguments;\n    var oldSize = this.size;\n    return this.withMutations(function (list) {\n      setListBounds(list, 0, oldSize + values.length);\n      for (var ii = 0; ii < values.length; ii++) {\n        list.set(oldSize + ii, values[ii]);\n      }\n    });\n  };\n\n  List.prototype.pop = function pop () {\n    return setListBounds(this, 0, -1);\n  };\n\n  List.prototype.unshift = function unshift (/*...values*/) {\n    var values = arguments;\n    return this.withMutations(function (list) {\n      setListBounds(list, -values.length);\n      for (var ii = 0; ii < values.length; ii++) {\n        list.set(ii, values[ii]);\n      }\n    });\n  };\n\n  List.prototype.shift = function shift () {\n    return setListBounds(this, 1);\n  };\n\n  // @pragma Composition\n\n  List.prototype.concat = function concat (/*...collections*/) {\n    var arguments$1 = arguments;\n\n    var seqs = [];\n    for (var i = 0; i < arguments.length; i++) {\n      var argument = arguments$1[i];\n      var seq = IndexedCollection(\n        typeof argument !== 'string' && hasIterator(argument)\n          ? argument\n          : [argument]\n      );\n      if (seq.size !== 0) {\n        seqs.push(seq);\n      }\n    }\n    if (seqs.length === 0) {\n      return this;\n    }\n    if (this.size === 0 && !this.__ownerID && seqs.length === 1) {\n      return this.constructor(seqs[0]);\n    }\n    return this.withMutations(function (list) {\n      seqs.forEach(function (seq) { return seq.forEach(function (value) { return list.push(value); }); });\n    });\n  };\n\n  List.prototype.setSize = function setSize (size) {\n    return setListBounds(this, 0, size);\n  };\n\n  List.prototype.map = function map (mapper, context) {\n    var this$1$1 = this;\n\n    return this.withMutations(function (list) {\n      for (var i = 0; i < this$1$1.size; i++) {\n        list.set(i, mapper.call(context, list.get(i), i, this$1$1));\n      }\n    });\n  };\n\n  // @pragma Iteration\n\n  List.prototype.slice = function slice (begin, end) {\n    var size = this.size;\n    if (wholeSlice(begin, end, size)) {\n      return this;\n    }\n    return setListBounds(\n      this,\n      resolveBegin(begin, size),\n      resolveEnd(end, size)\n    );\n  };\n\n  List.prototype.__iterator = function __iterator (type, reverse) {\n    var index = reverse ? this.size : 0;\n    var values = iterateList(this, reverse);\n    return new Iterator(function () {\n      var value = values();\n      return value === DONE\n        ? iteratorDone()\n        : iteratorValue(type, reverse ? --index : index++, value);\n    });\n  };\n\n  List.prototype.__iterate = function __iterate (fn, reverse) {\n    var index = reverse ? this.size : 0;\n    var values = iterateList(this, reverse);\n    var value;\n    while ((value = values()) !== DONE) {\n      if (fn(value, reverse ? --index : index++, this) === false) {\n        break;\n      }\n    }\n    return index;\n  };\n\n  List.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptyList();\n      }\n      this.__ownerID = ownerID;\n      this.__altered = false;\n      return this;\n    }\n    return makeList(\n      this._origin,\n      this._capacity,\n      this._level,\n      this._root,\n      this._tail,\n      ownerID,\n      this.__hash\n    );\n  };\n\n  return List;\n}(IndexedCollection));\n\nList.isList = isList;\n\nvar ListPrototype = List.prototype;\nListPrototype[IS_LIST_SYMBOL] = true;\nListPrototype[DELETE] = ListPrototype.remove;\nListPrototype.merge = ListPrototype.concat;\nListPrototype.setIn = setIn;\nListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;\nListPrototype.update = update;\nListPrototype.updateIn = updateIn;\nListPrototype.mergeIn = mergeIn;\nListPrototype.mergeDeepIn = mergeDeepIn;\nListPrototype.withMutations = withMutations;\nListPrototype.wasAltered = wasAltered;\nListPrototype.asImmutable = asImmutable;\nListPrototype['@@transducer/init'] = ListPrototype.asMutable = asMutable;\nListPrototype['@@transducer/step'] = function (result, arr) {\n  return result.push(arr);\n};\nListPrototype['@@transducer/result'] = function (obj) {\n  return obj.asImmutable();\n};\n\nvar VNode = function VNode(array, ownerID) {\n  this.array = array;\n  this.ownerID = ownerID;\n};\n\n// TODO: seems like these methods are very similar\n\nVNode.prototype.removeBefore = function removeBefore (ownerID, level, index) {\n  if (index === level ? 1 << level : this.array.length === 0) {\n    return this;\n  }\n  var originIndex = (index >>> level) & MASK;\n  if (originIndex >= this.array.length) {\n    return new VNode([], ownerID);\n  }\n  var removingFirst = originIndex === 0;\n  var newChild;\n  if (level > 0) {\n    var oldChild = this.array[originIndex];\n    newChild =\n      oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n    if (newChild === oldChild && removingFirst) {\n      return this;\n    }\n  }\n  if (removingFirst && !newChild) {\n    return this;\n  }\n  var editable = editableVNode(this, ownerID);\n  if (!removingFirst) {\n    for (var ii = 0; ii < originIndex; ii++) {\n      editable.array[ii] = undefined;\n    }\n  }\n  if (newChild) {\n    editable.array[originIndex] = newChild;\n  }\n  return editable;\n};\n\nVNode.prototype.removeAfter = function removeAfter (ownerID, level, index) {\n  if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n    return this;\n  }\n  var sizeIndex = ((index - 1) >>> level) & MASK;\n  if (sizeIndex >= this.array.length) {\n    return this;\n  }\n\n  var newChild;\n  if (level > 0) {\n    var oldChild = this.array[sizeIndex];\n    newChild =\n      oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n    if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n      return this;\n    }\n  }\n\n  var editable = editableVNode(this, ownerID);\n  editable.array.splice(sizeIndex + 1);\n  if (newChild) {\n    editable.array[sizeIndex] = newChild;\n  }\n  return editable;\n};\n\nvar DONE = {};\n\nfunction iterateList(list, reverse) {\n  var left = list._origin;\n  var right = list._capacity;\n  var tailPos = getTailOffset(right);\n  var tail = list._tail;\n\n  return iterateNodeOrLeaf(list._root, list._level, 0);\n\n  function iterateNodeOrLeaf(node, level, offset) {\n    return level === 0\n      ? iterateLeaf(node, offset)\n      : iterateNode(node, level, offset);\n  }\n\n  function iterateLeaf(node, offset) {\n    var array = offset === tailPos ? tail && tail.array : node && node.array;\n    var from = offset > left ? 0 : left - offset;\n    var to = right - offset;\n    if (to > SIZE) {\n      to = SIZE;\n    }\n    return function () {\n      if (from === to) {\n        return DONE;\n      }\n      var idx = reverse ? --to : from++;\n      return array && array[idx];\n    };\n  }\n\n  function iterateNode(node, level, offset) {\n    var values;\n    var array = node && node.array;\n    var from = offset > left ? 0 : (left - offset) >> level;\n    var to = ((right - offset) >> level) + 1;\n    if (to > SIZE) {\n      to = SIZE;\n    }\n    return function () {\n      while (true) {\n        if (values) {\n          var value = values();\n          if (value !== DONE) {\n            return value;\n          }\n          values = null;\n        }\n        if (from === to) {\n          return DONE;\n        }\n        var idx = reverse ? --to : from++;\n        values = iterateNodeOrLeaf(\n          array && array[idx],\n          level - SHIFT,\n          offset + (idx << level)\n        );\n      }\n    };\n  }\n}\n\nfunction makeList(origin, capacity, level, root, tail, ownerID, hash) {\n  var list = Object.create(ListPrototype);\n  list.size = capacity - origin;\n  list._origin = origin;\n  list._capacity = capacity;\n  list._level = level;\n  list._root = root;\n  list._tail = tail;\n  list.__ownerID = ownerID;\n  list.__hash = hash;\n  list.__altered = false;\n  return list;\n}\n\nvar EMPTY_LIST;\nfunction emptyList() {\n  return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n}\n\nfunction updateList(list, index, value) {\n  index = wrapIndex(list, index);\n\n  if (index !== index) {\n    return list;\n  }\n\n  if (index >= list.size || index < 0) {\n    return list.withMutations(function (list) {\n      index < 0\n        ? setListBounds(list, index).set(0, value)\n        : setListBounds(list, 0, index + 1).set(index, value);\n    });\n  }\n\n  index += list._origin;\n\n  var newTail = list._tail;\n  var newRoot = list._root;\n  var didAlter = MakeRef();\n  if (index >= getTailOffset(list._capacity)) {\n    newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n  } else {\n    newRoot = updateVNode(\n      newRoot,\n      list.__ownerID,\n      list._level,\n      index,\n      value,\n      didAlter\n    );\n  }\n\n  if (!didAlter.value) {\n    return list;\n  }\n\n  if (list.__ownerID) {\n    list._root = newRoot;\n    list._tail = newTail;\n    list.__hash = undefined;\n    list.__altered = true;\n    return list;\n  }\n  return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n}\n\nfunction updateVNode(node, ownerID, level, index, value, didAlter) {\n  var idx = (index >>> level) & MASK;\n  var nodeHas = node && idx < node.array.length;\n  if (!nodeHas && value === undefined) {\n    return node;\n  }\n\n  var newNode;\n\n  if (level > 0) {\n    var lowerNode = node && node.array[idx];\n    var newLowerNode = updateVNode(\n      lowerNode,\n      ownerID,\n      level - SHIFT,\n      index,\n      value,\n      didAlter\n    );\n    if (newLowerNode === lowerNode) {\n      return node;\n    }\n    newNode = editableVNode(node, ownerID);\n    newNode.array[idx] = newLowerNode;\n    return newNode;\n  }\n\n  if (nodeHas && node.array[idx] === value) {\n    return node;\n  }\n\n  if (didAlter) {\n    SetRef(didAlter);\n  }\n\n  newNode = editableVNode(node, ownerID);\n  if (value === undefined && idx === newNode.array.length - 1) {\n    newNode.array.pop();\n  } else {\n    newNode.array[idx] = value;\n  }\n  return newNode;\n}\n\nfunction editableVNode(node, ownerID) {\n  if (ownerID && node && ownerID === node.ownerID) {\n    return node;\n  }\n  return new VNode(node ? node.array.slice() : [], ownerID);\n}\n\nfunction listNodeFor(list, rawIndex) {\n  if (rawIndex >= getTailOffset(list._capacity)) {\n    return list._tail;\n  }\n  if (rawIndex < 1 << (list._level + SHIFT)) {\n    var node = list._root;\n    var level = list._level;\n    while (node && level > 0) {\n      node = node.array[(rawIndex >>> level) & MASK];\n      level -= SHIFT;\n    }\n    return node;\n  }\n}\n\nfunction setListBounds(list, begin, end) {\n  // Sanitize begin & end using this shorthand for ToInt32(argument)\n  // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n  if (begin !== undefined) {\n    begin |= 0;\n  }\n  if (end !== undefined) {\n    end |= 0;\n  }\n  var owner = list.__ownerID || new OwnerID();\n  var oldOrigin = list._origin;\n  var oldCapacity = list._capacity;\n  var newOrigin = oldOrigin + begin;\n  var newCapacity =\n    end === undefined\n      ? oldCapacity\n      : end < 0\n      ? oldCapacity + end\n      : oldOrigin + end;\n  if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n    return list;\n  }\n\n  // If it's going to end after it starts, it's empty.\n  if (newOrigin >= newCapacity) {\n    return list.clear();\n  }\n\n  var newLevel = list._level;\n  var newRoot = list._root;\n\n  // New origin might need creating a higher root.\n  var offsetShift = 0;\n  while (newOrigin + offsetShift < 0) {\n    newRoot = new VNode(\n      newRoot && newRoot.array.length ? [undefined, newRoot] : [],\n      owner\n    );\n    newLevel += SHIFT;\n    offsetShift += 1 << newLevel;\n  }\n  if (offsetShift) {\n    newOrigin += offsetShift;\n    oldOrigin += offsetShift;\n    newCapacity += offsetShift;\n    oldCapacity += offsetShift;\n  }\n\n  var oldTailOffset = getTailOffset(oldCapacity);\n  var newTailOffset = getTailOffset(newCapacity);\n\n  // New size might need creating a higher root.\n  while (newTailOffset >= 1 << (newLevel + SHIFT)) {\n    newRoot = new VNode(\n      newRoot && newRoot.array.length ? [newRoot] : [],\n      owner\n    );\n    newLevel += SHIFT;\n  }\n\n  // Locate or create the new tail.\n  var oldTail = list._tail;\n  var newTail =\n    newTailOffset < oldTailOffset\n      ? listNodeFor(list, newCapacity - 1)\n      : newTailOffset > oldTailOffset\n      ? new VNode([], owner)\n      : oldTail;\n\n  // Merge Tail into tree.\n  if (\n    oldTail &&\n    newTailOffset > oldTailOffset &&\n    newOrigin < oldCapacity &&\n    oldTail.array.length\n  ) {\n    newRoot = editableVNode(newRoot, owner);\n    var node = newRoot;\n    for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n      var idx = (oldTailOffset >>> level) & MASK;\n      node = node.array[idx] = editableVNode(node.array[idx], owner);\n    }\n    node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;\n  }\n\n  // If the size has been reduced, there's a chance the tail needs to be trimmed.\n  if (newCapacity < oldCapacity) {\n    newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n  }\n\n  // If the new origin is within the tail, then we do not need a root.\n  if (newOrigin >= newTailOffset) {\n    newOrigin -= newTailOffset;\n    newCapacity -= newTailOffset;\n    newLevel = SHIFT;\n    newRoot = null;\n    newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\n    // Otherwise, if the root has been trimmed, garbage collect.\n  } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n    offsetShift = 0;\n\n    // Identify the new top root node of the subtree of the old root.\n    while (newRoot) {\n      var beginIndex = (newOrigin >>> newLevel) & MASK;\n      if ((beginIndex !== newTailOffset >>> newLevel) & MASK) {\n        break;\n      }\n      if (beginIndex) {\n        offsetShift += (1 << newLevel) * beginIndex;\n      }\n      newLevel -= SHIFT;\n      newRoot = newRoot.array[beginIndex];\n    }\n\n    // Trim the new sides of the new root.\n    if (newRoot && newOrigin > oldOrigin) {\n      newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n    }\n    if (newRoot && newTailOffset < oldTailOffset) {\n      newRoot = newRoot.removeAfter(\n        owner,\n        newLevel,\n        newTailOffset - offsetShift\n      );\n    }\n    if (offsetShift) {\n      newOrigin -= offsetShift;\n      newCapacity -= offsetShift;\n    }\n  }\n\n  if (list.__ownerID) {\n    list.size = newCapacity - newOrigin;\n    list._origin = newOrigin;\n    list._capacity = newCapacity;\n    list._level = newLevel;\n    list._root = newRoot;\n    list._tail = newTail;\n    list.__hash = undefined;\n    list.__altered = true;\n    return list;\n  }\n  return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n}\n\nfunction getTailOffset(size) {\n  return size < SIZE ? 0 : ((size - 1) >>> SHIFT) << SHIFT;\n}\n\nvar OrderedMap = /*@__PURE__*/(function (Map) {\n  function OrderedMap(value) {\n    return value === undefined || value === null\n      ? emptyOrderedMap()\n      : isOrderedMap(value)\n      ? value\n      : emptyOrderedMap().withMutations(function (map) {\n          var iter = KeyedCollection(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function (v, k) { return map.set(k, v); });\n        });\n  }\n\n  if ( Map ) OrderedMap.__proto__ = Map;\n  OrderedMap.prototype = Object.create( Map && Map.prototype );\n  OrderedMap.prototype.constructor = OrderedMap;\n\n  OrderedMap.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  OrderedMap.prototype.toString = function toString () {\n    return this.__toString('OrderedMap {', '}');\n  };\n\n  // @pragma Access\n\n  OrderedMap.prototype.get = function get (k, notSetValue) {\n    var index = this._map.get(k);\n    return index !== undefined ? this._list.get(index)[1] : notSetValue;\n  };\n\n  // @pragma Modification\n\n  OrderedMap.prototype.clear = function clear () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = 0;\n      this._map.clear();\n      this._list.clear();\n      this.__altered = true;\n      return this;\n    }\n    return emptyOrderedMap();\n  };\n\n  OrderedMap.prototype.set = function set (k, v) {\n    return updateOrderedMap(this, k, v);\n  };\n\n  OrderedMap.prototype.remove = function remove (k) {\n    return updateOrderedMap(this, k, NOT_SET);\n  };\n\n  OrderedMap.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1$1 = this;\n\n    return this._list.__iterate(\n      function (entry) { return entry && fn(entry[1], entry[0], this$1$1); },\n      reverse\n    );\n  };\n\n  OrderedMap.prototype.__iterator = function __iterator (type, reverse) {\n    return this._list.fromEntrySeq().__iterator(type, reverse);\n  };\n\n  OrderedMap.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    var newMap = this._map.__ensureOwner(ownerID);\n    var newList = this._list.__ensureOwner(ownerID);\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptyOrderedMap();\n      }\n      this.__ownerID = ownerID;\n      this.__altered = false;\n      this._map = newMap;\n      this._list = newList;\n      return this;\n    }\n    return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n  };\n\n  return OrderedMap;\n}(immutable_es_Map));\n\nOrderedMap.isOrderedMap = isOrderedMap;\n\nOrderedMap.prototype[IS_ORDERED_SYMBOL] = true;\nOrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\nfunction makeOrderedMap(map, list, ownerID, hash) {\n  var omap = Object.create(OrderedMap.prototype);\n  omap.size = map ? map.size : 0;\n  omap._map = map;\n  omap._list = list;\n  omap.__ownerID = ownerID;\n  omap.__hash = hash;\n  omap.__altered = false;\n  return omap;\n}\n\nvar EMPTY_ORDERED_MAP;\nfunction emptyOrderedMap() {\n  return (\n    EMPTY_ORDERED_MAP ||\n    (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()))\n  );\n}\n\nfunction updateOrderedMap(omap, k, v) {\n  var map = omap._map;\n  var list = omap._list;\n  var i = map.get(k);\n  var has = i !== undefined;\n  var newMap;\n  var newList;\n  if (v === NOT_SET) {\n    // removed\n    if (!has) {\n      return omap;\n    }\n    if (list.size >= SIZE && list.size >= map.size * 2) {\n      newList = list.filter(function (entry, idx) { return entry !== undefined && i !== idx; });\n      newMap = newList\n        .toKeyedSeq()\n        .map(function (entry) { return entry[0]; })\n        .flip()\n        .toMap();\n      if (omap.__ownerID) {\n        newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n      }\n    } else {\n      newMap = map.remove(k);\n      newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n    }\n  } else if (has) {\n    if (v === list.get(i)[1]) {\n      return omap;\n    }\n    newMap = map;\n    newList = list.set(i, [k, v]);\n  } else {\n    newMap = map.set(k, list.size);\n    newList = list.set(list.size, [k, v]);\n  }\n  if (omap.__ownerID) {\n    omap.size = newMap.size;\n    omap._map = newMap;\n    omap._list = newList;\n    omap.__hash = undefined;\n    omap.__altered = true;\n    return omap;\n  }\n  return makeOrderedMap(newMap, newList);\n}\n\nvar IS_STACK_SYMBOL = '@@__IMMUTABLE_STACK__@@';\n\nfunction isStack(maybeStack) {\n  return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);\n}\n\nvar Stack = /*@__PURE__*/(function (IndexedCollection) {\n  function Stack(value) {\n    return value === undefined || value === null\n      ? emptyStack()\n      : isStack(value)\n      ? value\n      : emptyStack().pushAll(value);\n  }\n\n  if ( IndexedCollection ) Stack.__proto__ = IndexedCollection;\n  Stack.prototype = Object.create( IndexedCollection && IndexedCollection.prototype );\n  Stack.prototype.constructor = Stack;\n\n  Stack.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  Stack.prototype.toString = function toString () {\n    return this.__toString('Stack [', ']');\n  };\n\n  // @pragma Access\n\n  Stack.prototype.get = function get (index, notSetValue) {\n    var head = this._head;\n    index = wrapIndex(this, index);\n    while (head && index--) {\n      head = head.next;\n    }\n    return head ? head.value : notSetValue;\n  };\n\n  Stack.prototype.peek = function peek () {\n    return this._head && this._head.value;\n  };\n\n  // @pragma Modification\n\n  Stack.prototype.push = function push (/*...values*/) {\n    var arguments$1 = arguments;\n\n    if (arguments.length === 0) {\n      return this;\n    }\n    var newSize = this.size + arguments.length;\n    var head = this._head;\n    for (var ii = arguments.length - 1; ii >= 0; ii--) {\n      head = {\n        value: arguments$1[ii],\n        next: head,\n      };\n    }\n    if (this.__ownerID) {\n      this.size = newSize;\n      this._head = head;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return makeStack(newSize, head);\n  };\n\n  Stack.prototype.pushAll = function pushAll (iter) {\n    iter = IndexedCollection(iter);\n    if (iter.size === 0) {\n      return this;\n    }\n    if (this.size === 0 && isStack(iter)) {\n      return iter;\n    }\n    assertNotInfinite(iter.size);\n    var newSize = this.size;\n    var head = this._head;\n    iter.__iterate(function (value) {\n      newSize++;\n      head = {\n        value: value,\n        next: head,\n      };\n    }, /* reverse */ true);\n    if (this.__ownerID) {\n      this.size = newSize;\n      this._head = head;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return makeStack(newSize, head);\n  };\n\n  Stack.prototype.pop = function pop () {\n    return this.slice(1);\n  };\n\n  Stack.prototype.clear = function clear () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = 0;\n      this._head = undefined;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return emptyStack();\n  };\n\n  Stack.prototype.slice = function slice (begin, end) {\n    if (wholeSlice(begin, end, this.size)) {\n      return this;\n    }\n    var resolvedBegin = resolveBegin(begin, this.size);\n    var resolvedEnd = resolveEnd(end, this.size);\n    if (resolvedEnd !== this.size) {\n      // super.slice(begin, end);\n      return IndexedCollection.prototype.slice.call(this, begin, end);\n    }\n    var newSize = this.size - resolvedBegin;\n    var head = this._head;\n    while (resolvedBegin--) {\n      head = head.next;\n    }\n    if (this.__ownerID) {\n      this.size = newSize;\n      this._head = head;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return makeStack(newSize, head);\n  };\n\n  // @pragma Mutability\n\n  Stack.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptyStack();\n      }\n      this.__ownerID = ownerID;\n      this.__altered = false;\n      return this;\n    }\n    return makeStack(this.size, this._head, ownerID, this.__hash);\n  };\n\n  // @pragma Iteration\n\n  Stack.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1$1 = this;\n\n    if (reverse) {\n      return new ArraySeq(this.toArray()).__iterate(\n        function (v, k) { return fn(v, k, this$1$1); },\n        reverse\n      );\n    }\n    var iterations = 0;\n    var node = this._head;\n    while (node) {\n      if (fn(node.value, iterations++, this) === false) {\n        break;\n      }\n      node = node.next;\n    }\n    return iterations;\n  };\n\n  Stack.prototype.__iterator = function __iterator (type, reverse) {\n    if (reverse) {\n      return new ArraySeq(this.toArray()).__iterator(type, reverse);\n    }\n    var iterations = 0;\n    var node = this._head;\n    return new Iterator(function () {\n      if (node) {\n        var value = node.value;\n        node = node.next;\n        return iteratorValue(type, iterations++, value);\n      }\n      return iteratorDone();\n    });\n  };\n\n  return Stack;\n}(IndexedCollection));\n\nStack.isStack = isStack;\n\nvar StackPrototype = Stack.prototype;\nStackPrototype[IS_STACK_SYMBOL] = true;\nStackPrototype.shift = StackPrototype.pop;\nStackPrototype.unshift = StackPrototype.push;\nStackPrototype.unshiftAll = StackPrototype.pushAll;\nStackPrototype.withMutations = withMutations;\nStackPrototype.wasAltered = wasAltered;\nStackPrototype.asImmutable = asImmutable;\nStackPrototype['@@transducer/init'] = StackPrototype.asMutable = asMutable;\nStackPrototype['@@transducer/step'] = function (result, arr) {\n  return result.unshift(arr);\n};\nStackPrototype['@@transducer/result'] = function (obj) {\n  return obj.asImmutable();\n};\n\nfunction makeStack(size, head, ownerID, hash) {\n  var map = Object.create(StackPrototype);\n  map.size = size;\n  map._head = head;\n  map.__ownerID = ownerID;\n  map.__hash = hash;\n  map.__altered = false;\n  return map;\n}\n\nvar EMPTY_STACK;\nfunction emptyStack() {\n  return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n}\n\nvar IS_SET_SYMBOL = '@@__IMMUTABLE_SET__@@';\n\nfunction isSet(maybeSet) {\n  return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);\n}\n\nfunction isOrderedSet(maybeOrderedSet) {\n  return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n}\n\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (\n    !isCollection(b) ||\n    (a.size !== undefined && b.size !== undefined && a.size !== b.size) ||\n    (a.__hash !== undefined &&\n      b.__hash !== undefined &&\n      a.__hash !== b.__hash) ||\n    isKeyed(a) !== isKeyed(b) ||\n    isIndexed(a) !== isIndexed(b) ||\n    isOrdered(a) !== isOrdered(b)\n  ) {\n    return false;\n  }\n\n  if (a.size === 0 && b.size === 0) {\n    return true;\n  }\n\n  var notAssociative = !isAssociative(a);\n\n  if (isOrdered(a)) {\n    var entries = a.entries();\n    return (\n      b.every(function (v, k) {\n        var entry = entries.next().value;\n        return entry && immutable_es_is(entry[1], v) && (notAssociative || immutable_es_is(entry[0], k));\n      }) && entries.next().done\n    );\n  }\n\n  var flipped = false;\n\n  if (a.size === undefined) {\n    if (b.size === undefined) {\n      if (typeof a.cacheResult === 'function') {\n        a.cacheResult();\n      }\n    } else {\n      flipped = true;\n      var _ = a;\n      a = b;\n      b = _;\n    }\n  }\n\n  var allEqual = true;\n  var bSize = b.__iterate(function (v, k) {\n    if (\n      notAssociative\n        ? !a.has(v)\n        : flipped\n        ? !immutable_es_is(v, a.get(k, NOT_SET))\n        : !immutable_es_is(a.get(k, NOT_SET), v)\n    ) {\n      allEqual = false;\n      return false;\n    }\n  });\n\n  return allEqual && a.size === bSize;\n}\n\nfunction mixin(ctor, methods) {\n  var keyCopier = function (key) {\n    ctor.prototype[key] = methods[key];\n  };\n  Object.keys(methods).forEach(keyCopier);\n  Object.getOwnPropertySymbols &&\n    Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n  return ctor;\n}\n\nfunction toJS(value) {\n  if (!value || typeof value !== 'object') {\n    return value;\n  }\n  if (!isCollection(value)) {\n    if (!isDataStructure(value)) {\n      return value;\n    }\n    value = Seq(value);\n  }\n  if (isKeyed(value)) {\n    var result$1 = {};\n    value.__iterate(function (v, k) {\n      result$1[k] = toJS(v);\n    });\n    return result$1;\n  }\n  var result = [];\n  value.__iterate(function (v) {\n    result.push(toJS(v));\n  });\n  return result;\n}\n\nvar immutable_es_Set = /*@__PURE__*/(function (SetCollection) {\n  function Set(value) {\n    return value === undefined || value === null\n      ? emptySet()\n      : isSet(value) && !isOrdered(value)\n      ? value\n      : emptySet().withMutations(function (set) {\n          var iter = SetCollection(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function (v) { return set.add(v); });\n        });\n  }\n\n  if ( SetCollection ) Set.__proto__ = SetCollection;\n  Set.prototype = Object.create( SetCollection && SetCollection.prototype );\n  Set.prototype.constructor = Set;\n\n  Set.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  Set.fromKeys = function fromKeys (value) {\n    return this(KeyedCollection(value).keySeq());\n  };\n\n  Set.intersect = function intersect (sets) {\n    sets = Collection(sets).toArray();\n    return sets.length\n      ? SetPrototype.intersect.apply(Set(sets.pop()), sets)\n      : emptySet();\n  };\n\n  Set.union = function union (sets) {\n    sets = Collection(sets).toArray();\n    return sets.length\n      ? SetPrototype.union.apply(Set(sets.pop()), sets)\n      : emptySet();\n  };\n\n  Set.prototype.toString = function toString () {\n    return this.__toString('Set {', '}');\n  };\n\n  // @pragma Access\n\n  Set.prototype.has = function has (value) {\n    return this._map.has(value);\n  };\n\n  // @pragma Modification\n\n  Set.prototype.add = function add (value) {\n    return updateSet(this, this._map.set(value, value));\n  };\n\n  Set.prototype.remove = function remove (value) {\n    return updateSet(this, this._map.remove(value));\n  };\n\n  Set.prototype.clear = function clear () {\n    return updateSet(this, this._map.clear());\n  };\n\n  // @pragma Composition\n\n  Set.prototype.map = function map (mapper, context) {\n    var this$1$1 = this;\n\n    // keep track if the set is altered by the map function\n    var didChanges = false;\n\n    var newMap = updateSet(\n      this,\n      this._map.mapEntries(function (ref) {\n        var v = ref[1];\n\n        var mapped = mapper.call(context, v, v, this$1$1);\n\n        if (mapped !== v) {\n          didChanges = true;\n        }\n\n        return [mapped, mapped];\n      }, context)\n    );\n\n    return didChanges ? newMap : this;\n  };\n\n  Set.prototype.union = function union () {\n    var iters = [], len = arguments.length;\n    while ( len-- ) iters[ len ] = arguments[ len ];\n\n    iters = iters.filter(function (x) { return x.size !== 0; });\n    if (iters.length === 0) {\n      return this;\n    }\n    if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n      return this.constructor(iters[0]);\n    }\n    return this.withMutations(function (set) {\n      for (var ii = 0; ii < iters.length; ii++) {\n        SetCollection(iters[ii]).forEach(function (value) { return set.add(value); });\n      }\n    });\n  };\n\n  Set.prototype.intersect = function intersect () {\n    var iters = [], len = arguments.length;\n    while ( len-- ) iters[ len ] = arguments[ len ];\n\n    if (iters.length === 0) {\n      return this;\n    }\n    iters = iters.map(function (iter) { return SetCollection(iter); });\n    var toRemove = [];\n    this.forEach(function (value) {\n      if (!iters.every(function (iter) { return iter.includes(value); })) {\n        toRemove.push(value);\n      }\n    });\n    return this.withMutations(function (set) {\n      toRemove.forEach(function (value) {\n        set.remove(value);\n      });\n    });\n  };\n\n  Set.prototype.subtract = function subtract () {\n    var iters = [], len = arguments.length;\n    while ( len-- ) iters[ len ] = arguments[ len ];\n\n    if (iters.length === 0) {\n      return this;\n    }\n    iters = iters.map(function (iter) { return SetCollection(iter); });\n    var toRemove = [];\n    this.forEach(function (value) {\n      if (iters.some(function (iter) { return iter.includes(value); })) {\n        toRemove.push(value);\n      }\n    });\n    return this.withMutations(function (set) {\n      toRemove.forEach(function (value) {\n        set.remove(value);\n      });\n    });\n  };\n\n  Set.prototype.sort = function sort (comparator) {\n    // Late binding\n    return OrderedSet(sortFactory(this, comparator));\n  };\n\n  Set.prototype.sortBy = function sortBy (mapper, comparator) {\n    // Late binding\n    return OrderedSet(sortFactory(this, comparator, mapper));\n  };\n\n  Set.prototype.wasAltered = function wasAltered () {\n    return this._map.wasAltered();\n  };\n\n  Set.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1$1 = this;\n\n    return this._map.__iterate(function (k) { return fn(k, k, this$1$1); }, reverse);\n  };\n\n  Set.prototype.__iterator = function __iterator (type, reverse) {\n    return this._map.__iterator(type, reverse);\n  };\n\n  Set.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    var newMap = this._map.__ensureOwner(ownerID);\n    if (!ownerID) {\n      if (this.size === 0) {\n        return this.__empty();\n      }\n      this.__ownerID = ownerID;\n      this._map = newMap;\n      return this;\n    }\n    return this.__make(newMap, ownerID);\n  };\n\n  return Set;\n}(SetCollection));\n\nimmutable_es_Set.isSet = isSet;\n\nvar SetPrototype = immutable_es_Set.prototype;\nSetPrototype[IS_SET_SYMBOL] = true;\nSetPrototype[DELETE] = SetPrototype.remove;\nSetPrototype.merge = SetPrototype.concat = SetPrototype.union;\nSetPrototype.withMutations = withMutations;\nSetPrototype.asImmutable = asImmutable;\nSetPrototype['@@transducer/init'] = SetPrototype.asMutable = asMutable;\nSetPrototype['@@transducer/step'] = function (result, arr) {\n  return result.add(arr);\n};\nSetPrototype['@@transducer/result'] = function (obj) {\n  return obj.asImmutable();\n};\n\nSetPrototype.__empty = emptySet;\nSetPrototype.__make = makeSet;\n\nfunction updateSet(set, newMap) {\n  if (set.__ownerID) {\n    set.size = newMap.size;\n    set._map = newMap;\n    return set;\n  }\n  return newMap === set._map\n    ? set\n    : newMap.size === 0\n    ? set.__empty()\n    : set.__make(newMap);\n}\n\nfunction makeSet(map, ownerID) {\n  var set = Object.create(SetPrototype);\n  set.size = map ? map.size : 0;\n  set._map = map;\n  set.__ownerID = ownerID;\n  return set;\n}\n\nvar EMPTY_SET;\nfunction emptySet() {\n  return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n}\n\n/**\n * Returns a lazy seq of nums from start (inclusive) to end\n * (exclusive), by step, where start defaults to 0, step to 1, and end to\n * infinity. When start is equal to end, returns empty list.\n */\nvar Range = /*@__PURE__*/(function (IndexedSeq) {\n  function Range(start, end, step) {\n    if (!(this instanceof Range)) {\n      return new Range(start, end, step);\n    }\n    invariant(step !== 0, 'Cannot step a Range by 0');\n    start = start || 0;\n    if (end === undefined) {\n      end = Infinity;\n    }\n    step = step === undefined ? 1 : Math.abs(step);\n    if (end < start) {\n      step = -step;\n    }\n    this._start = start;\n    this._end = end;\n    this._step = step;\n    this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n    if (this.size === 0) {\n      if (EMPTY_RANGE) {\n        return EMPTY_RANGE;\n      }\n      EMPTY_RANGE = this;\n    }\n  }\n\n  if ( IndexedSeq ) Range.__proto__ = IndexedSeq;\n  Range.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n  Range.prototype.constructor = Range;\n\n  Range.prototype.toString = function toString () {\n    if (this.size === 0) {\n      return 'Range []';\n    }\n    return (\n      'Range [ ' +\n      this._start +\n      '...' +\n      this._end +\n      (this._step !== 1 ? ' by ' + this._step : '') +\n      ' ]'\n    );\n  };\n\n  Range.prototype.get = function get (index, notSetValue) {\n    return this.has(index)\n      ? this._start + wrapIndex(this, index) * this._step\n      : notSetValue;\n  };\n\n  Range.prototype.includes = function includes (searchValue) {\n    var possibleIndex = (searchValue - this._start) / this._step;\n    return (\n      possibleIndex >= 0 &&\n      possibleIndex < this.size &&\n      possibleIndex === Math.floor(possibleIndex)\n    );\n  };\n\n  Range.prototype.slice = function slice (begin, end) {\n    if (wholeSlice(begin, end, this.size)) {\n      return this;\n    }\n    begin = resolveBegin(begin, this.size);\n    end = resolveEnd(end, this.size);\n    if (end <= begin) {\n      return new Range(0, 0);\n    }\n    return new Range(\n      this.get(begin, this._end),\n      this.get(end, this._end),\n      this._step\n    );\n  };\n\n  Range.prototype.indexOf = function indexOf (searchValue) {\n    var offsetValue = searchValue - this._start;\n    if (offsetValue % this._step === 0) {\n      var index = offsetValue / this._step;\n      if (index >= 0 && index < this.size) {\n        return index;\n      }\n    }\n    return -1;\n  };\n\n  Range.prototype.lastIndexOf = function lastIndexOf (searchValue) {\n    return this.indexOf(searchValue);\n  };\n\n  Range.prototype.__iterate = function __iterate (fn, reverse) {\n    var size = this.size;\n    var step = this._step;\n    var value = reverse ? this._start + (size - 1) * step : this._start;\n    var i = 0;\n    while (i !== size) {\n      if (fn(value, reverse ? size - ++i : i++, this) === false) {\n        break;\n      }\n      value += reverse ? -step : step;\n    }\n    return i;\n  };\n\n  Range.prototype.__iterator = function __iterator (type, reverse) {\n    var size = this.size;\n    var step = this._step;\n    var value = reverse ? this._start + (size - 1) * step : this._start;\n    var i = 0;\n    return new Iterator(function () {\n      if (i === size) {\n        return iteratorDone();\n      }\n      var v = value;\n      value += reverse ? -step : step;\n      return iteratorValue(type, reverse ? size - ++i : i++, v);\n    });\n  };\n\n  Range.prototype.equals = function equals (other) {\n    return other instanceof Range\n      ? this._start === other._start &&\n          this._end === other._end &&\n          this._step === other._step\n      : deepEqual(this, other);\n  };\n\n  return Range;\n}(IndexedSeq));\n\nvar EMPTY_RANGE;\n\nfunction getIn$1(collection, searchKeyPath, notSetValue) {\n  var keyPath = coerceKeyPath(searchKeyPath);\n  var i = 0;\n  while (i !== keyPath.length) {\n    collection = get(collection, keyPath[i++], NOT_SET);\n    if (collection === NOT_SET) {\n      return notSetValue;\n    }\n  }\n  return collection;\n}\n\nfunction getIn(searchKeyPath, notSetValue) {\n  return getIn$1(this, searchKeyPath, notSetValue);\n}\n\nfunction hasIn$1(collection, keyPath) {\n  return getIn$1(collection, keyPath, NOT_SET) !== NOT_SET;\n}\n\nfunction hasIn(searchKeyPath) {\n  return hasIn$1(this, searchKeyPath);\n}\n\nfunction toObject() {\n  assertNotInfinite(this.size);\n  var object = {};\n  this.__iterate(function (v, k) {\n    object[k] = v;\n  });\n  return object;\n}\n\n// Note: all of these methods are deprecated.\nCollection.isIterable = isCollection;\nCollection.isKeyed = isKeyed;\nCollection.isIndexed = isIndexed;\nCollection.isAssociative = isAssociative;\nCollection.isOrdered = isOrdered;\n\nCollection.Iterator = Iterator;\n\nmixin(Collection, {\n  // ### Conversion to other types\n\n  toArray: function toArray() {\n    assertNotInfinite(this.size);\n    var array = new Array(this.size || 0);\n    var useTuples = isKeyed(this);\n    var i = 0;\n    this.__iterate(function (v, k) {\n      // Keyed collections produce an array of tuples.\n      array[i++] = useTuples ? [k, v] : v;\n    });\n    return array;\n  },\n\n  toIndexedSeq: function toIndexedSeq() {\n    return new ToIndexedSequence(this);\n  },\n\n  toJS: function toJS$1() {\n    return toJS(this);\n  },\n\n  toKeyedSeq: function toKeyedSeq() {\n    return new ToKeyedSequence(this, true);\n  },\n\n  toMap: function toMap() {\n    // Use Late Binding here to solve the circular dependency.\n    return immutable_es_Map(this.toKeyedSeq());\n  },\n\n  toObject: toObject,\n\n  toOrderedMap: function toOrderedMap() {\n    // Use Late Binding here to solve the circular dependency.\n    return OrderedMap(this.toKeyedSeq());\n  },\n\n  toOrderedSet: function toOrderedSet() {\n    // Use Late Binding here to solve the circular dependency.\n    return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n  },\n\n  toSet: function toSet() {\n    // Use Late Binding here to solve the circular dependency.\n    return immutable_es_Set(isKeyed(this) ? this.valueSeq() : this);\n  },\n\n  toSetSeq: function toSetSeq() {\n    return new ToSetSequence(this);\n  },\n\n  toSeq: function toSeq() {\n    return isIndexed(this)\n      ? this.toIndexedSeq()\n      : isKeyed(this)\n      ? this.toKeyedSeq()\n      : this.toSetSeq();\n  },\n\n  toStack: function toStack() {\n    // Use Late Binding here to solve the circular dependency.\n    return Stack(isKeyed(this) ? this.valueSeq() : this);\n  },\n\n  toList: function toList() {\n    // Use Late Binding here to solve the circular dependency.\n    return List(isKeyed(this) ? this.valueSeq() : this);\n  },\n\n  // ### Common JavaScript methods and properties\n\n  toString: function toString() {\n    return '[Collection]';\n  },\n\n  __toString: function __toString(head, tail) {\n    if (this.size === 0) {\n      return head + tail;\n    }\n    return (\n      head +\n      ' ' +\n      this.toSeq().map(this.__toStringMapper).join(', ') +\n      ' ' +\n      tail\n    );\n  },\n\n  // ### ES6 Collection methods (ES6 Array and Map)\n\n  concat: function concat() {\n    var values = [], len = arguments.length;\n    while ( len-- ) values[ len ] = arguments[ len ];\n\n    return reify(this, concatFactory(this, values));\n  },\n\n  includes: function includes(searchValue) {\n    return this.some(function (value) { return immutable_es_is(value, searchValue); });\n  },\n\n  entries: function entries() {\n    return this.__iterator(ITERATE_ENTRIES);\n  },\n\n  every: function every(predicate, context) {\n    assertNotInfinite(this.size);\n    var returnValue = true;\n    this.__iterate(function (v, k, c) {\n      if (!predicate.call(context, v, k, c)) {\n        returnValue = false;\n        return false;\n      }\n    });\n    return returnValue;\n  },\n\n  filter: function filter(predicate, context) {\n    return reify(this, filterFactory(this, predicate, context, true));\n  },\n\n  find: function find(predicate, context, notSetValue) {\n    var entry = this.findEntry(predicate, context);\n    return entry ? entry[1] : notSetValue;\n  },\n\n  forEach: function forEach(sideEffect, context) {\n    assertNotInfinite(this.size);\n    return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n  },\n\n  join: function join(separator) {\n    assertNotInfinite(this.size);\n    separator = separator !== undefined ? '' + separator : ',';\n    var joined = '';\n    var isFirst = true;\n    this.__iterate(function (v) {\n      isFirst ? (isFirst = false) : (joined += separator);\n      joined += v !== null && v !== undefined ? v.toString() : '';\n    });\n    return joined;\n  },\n\n  keys: function keys() {\n    return this.__iterator(ITERATE_KEYS);\n  },\n\n  map: function map(mapper, context) {\n    return reify(this, mapFactory(this, mapper, context));\n  },\n\n  reduce: function reduce$1(reducer, initialReduction, context) {\n    return reduce(\n      this,\n      reducer,\n      initialReduction,\n      context,\n      arguments.length < 2,\n      false\n    );\n  },\n\n  reduceRight: function reduceRight(reducer, initialReduction, context) {\n    return reduce(\n      this,\n      reducer,\n      initialReduction,\n      context,\n      arguments.length < 2,\n      true\n    );\n  },\n\n  reverse: function reverse() {\n    return reify(this, reverseFactory(this, true));\n  },\n\n  slice: function slice(begin, end) {\n    return reify(this, sliceFactory(this, begin, end, true));\n  },\n\n  some: function some(predicate, context) {\n    return !this.every(not(predicate), context);\n  },\n\n  sort: function sort(comparator) {\n    return reify(this, sortFactory(this, comparator));\n  },\n\n  values: function values() {\n    return this.__iterator(ITERATE_VALUES);\n  },\n\n  // ### More sequential methods\n\n  butLast: function butLast() {\n    return this.slice(0, -1);\n  },\n\n  isEmpty: function isEmpty() {\n    return this.size !== undefined ? this.size === 0 : !this.some(function () { return true; });\n  },\n\n  count: function count(predicate, context) {\n    return ensureSize(\n      predicate ? this.toSeq().filter(predicate, context) : this\n    );\n  },\n\n  countBy: function countBy(grouper, context) {\n    return countByFactory(this, grouper, context);\n  },\n\n  equals: function equals(other) {\n    return deepEqual(this, other);\n  },\n\n  entrySeq: function entrySeq() {\n    var collection = this;\n    if (collection._cache) {\n      // We cache as an entries array, so we can just return the cache!\n      return new ArraySeq(collection._cache);\n    }\n    var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();\n    entriesSequence.fromEntrySeq = function () { return collection.toSeq(); };\n    return entriesSequence;\n  },\n\n  filterNot: function filterNot(predicate, context) {\n    return this.filter(not(predicate), context);\n  },\n\n  findEntry: function findEntry(predicate, context, notSetValue) {\n    var found = notSetValue;\n    this.__iterate(function (v, k, c) {\n      if (predicate.call(context, v, k, c)) {\n        found = [k, v];\n        return false;\n      }\n    });\n    return found;\n  },\n\n  findKey: function findKey(predicate, context) {\n    var entry = this.findEntry(predicate, context);\n    return entry && entry[0];\n  },\n\n  findLast: function findLast(predicate, context, notSetValue) {\n    return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n  },\n\n  findLastEntry: function findLastEntry(predicate, context, notSetValue) {\n    return this.toKeyedSeq()\n      .reverse()\n      .findEntry(predicate, context, notSetValue);\n  },\n\n  findLastKey: function findLastKey(predicate, context) {\n    return this.toKeyedSeq().reverse().findKey(predicate, context);\n  },\n\n  first: function first(notSetValue) {\n    return this.find(returnTrue, null, notSetValue);\n  },\n\n  flatMap: function flatMap(mapper, context) {\n    return reify(this, flatMapFactory(this, mapper, context));\n  },\n\n  flatten: function flatten(depth) {\n    return reify(this, flattenFactory(this, depth, true));\n  },\n\n  fromEntrySeq: function fromEntrySeq() {\n    return new FromEntriesSequence(this);\n  },\n\n  get: function get(searchKey, notSetValue) {\n    return this.find(function (_, key) { return immutable_es_is(key, searchKey); }, undefined, notSetValue);\n  },\n\n  getIn: getIn,\n\n  groupBy: function groupBy(grouper, context) {\n    return groupByFactory(this, grouper, context);\n  },\n\n  has: function has(searchKey) {\n    return this.get(searchKey, NOT_SET) !== NOT_SET;\n  },\n\n  hasIn: hasIn,\n\n  isSubset: function isSubset(iter) {\n    iter = typeof iter.includes === 'function' ? iter : Collection(iter);\n    return this.every(function (value) { return iter.includes(value); });\n  },\n\n  isSuperset: function isSuperset(iter) {\n    iter = typeof iter.isSubset === 'function' ? iter : Collection(iter);\n    return iter.isSubset(this);\n  },\n\n  keyOf: function keyOf(searchValue) {\n    return this.findKey(function (value) { return immutable_es_is(value, searchValue); });\n  },\n\n  keySeq: function keySeq() {\n    return this.toSeq().map(keyMapper).toIndexedSeq();\n  },\n\n  last: function last(notSetValue) {\n    return this.toSeq().reverse().first(notSetValue);\n  },\n\n  lastKeyOf: function lastKeyOf(searchValue) {\n    return this.toKeyedSeq().reverse().keyOf(searchValue);\n  },\n\n  max: function max(comparator) {\n    return maxFactory(this, comparator);\n  },\n\n  maxBy: function maxBy(mapper, comparator) {\n    return maxFactory(this, comparator, mapper);\n  },\n\n  min: function min(comparator) {\n    return maxFactory(\n      this,\n      comparator ? neg(comparator) : defaultNegComparator\n    );\n  },\n\n  minBy: function minBy(mapper, comparator) {\n    return maxFactory(\n      this,\n      comparator ? neg(comparator) : defaultNegComparator,\n      mapper\n    );\n  },\n\n  rest: function rest() {\n    return this.slice(1);\n  },\n\n  skip: function skip(amount) {\n    return amount === 0 ? this : this.slice(Math.max(0, amount));\n  },\n\n  skipLast: function skipLast(amount) {\n    return amount === 0 ? this : this.slice(0, -Math.max(0, amount));\n  },\n\n  skipWhile: function skipWhile(predicate, context) {\n    return reify(this, skipWhileFactory(this, predicate, context, true));\n  },\n\n  skipUntil: function skipUntil(predicate, context) {\n    return this.skipWhile(not(predicate), context);\n  },\n\n  sortBy: function sortBy(mapper, comparator) {\n    return reify(this, sortFactory(this, comparator, mapper));\n  },\n\n  take: function take(amount) {\n    return this.slice(0, Math.max(0, amount));\n  },\n\n  takeLast: function takeLast(amount) {\n    return this.slice(-Math.max(0, amount));\n  },\n\n  takeWhile: function takeWhile(predicate, context) {\n    return reify(this, takeWhileFactory(this, predicate, context));\n  },\n\n  takeUntil: function takeUntil(predicate, context) {\n    return this.takeWhile(not(predicate), context);\n  },\n\n  update: function update(fn) {\n    return fn(this);\n  },\n\n  valueSeq: function valueSeq() {\n    return this.toIndexedSeq();\n  },\n\n  // ### Hashable Object\n\n  hashCode: function hashCode() {\n    return this.__hash || (this.__hash = hashCollection(this));\n  },\n\n  // ### Internal\n\n  // abstract __iterate(fn, reverse)\n\n  // abstract __iterator(type, reverse)\n});\n\nvar CollectionPrototype = Collection.prototype;\nCollectionPrototype[IS_COLLECTION_SYMBOL] = true;\nCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;\nCollectionPrototype.toJSON = CollectionPrototype.toArray;\nCollectionPrototype.__toStringMapper = quoteString;\nCollectionPrototype.inspect = CollectionPrototype.toSource = function () {\n  return this.toString();\n};\nCollectionPrototype.chain = CollectionPrototype.flatMap;\nCollectionPrototype.contains = CollectionPrototype.includes;\n\nmixin(KeyedCollection, {\n  // ### More sequential methods\n\n  flip: function flip() {\n    return reify(this, flipFactory(this));\n  },\n\n  mapEntries: function mapEntries(mapper, context) {\n    var this$1$1 = this;\n\n    var iterations = 0;\n    return reify(\n      this,\n      this.toSeq()\n        .map(function (v, k) { return mapper.call(context, [k, v], iterations++, this$1$1); })\n        .fromEntrySeq()\n    );\n  },\n\n  mapKeys: function mapKeys(mapper, context) {\n    var this$1$1 = this;\n\n    return reify(\n      this,\n      this.toSeq()\n        .flip()\n        .map(function (k, v) { return mapper.call(context, k, v, this$1$1); })\n        .flip()\n    );\n  },\n});\n\nvar KeyedCollectionPrototype = KeyedCollection.prototype;\nKeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;\nKeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;\nKeyedCollectionPrototype.toJSON = toObject;\nKeyedCollectionPrototype.__toStringMapper = function (v, k) { return quoteString(k) + ': ' + quoteString(v); };\n\nmixin(IndexedCollection, {\n  // ### Conversion to other types\n\n  toKeyedSeq: function toKeyedSeq() {\n    return new ToKeyedSequence(this, false);\n  },\n\n  // ### ES6 Collection methods (ES6 Array and Map)\n\n  filter: function filter(predicate, context) {\n    return reify(this, filterFactory(this, predicate, context, false));\n  },\n\n  findIndex: function findIndex(predicate, context) {\n    var entry = this.findEntry(predicate, context);\n    return entry ? entry[0] : -1;\n  },\n\n  indexOf: function indexOf(searchValue) {\n    var key = this.keyOf(searchValue);\n    return key === undefined ? -1 : key;\n  },\n\n  lastIndexOf: function lastIndexOf(searchValue) {\n    var key = this.lastKeyOf(searchValue);\n    return key === undefined ? -1 : key;\n  },\n\n  reverse: function reverse() {\n    return reify(this, reverseFactory(this, false));\n  },\n\n  slice: function slice(begin, end) {\n    return reify(this, sliceFactory(this, begin, end, false));\n  },\n\n  splice: function splice(index, removeNum /*, ...values*/) {\n    var numArgs = arguments.length;\n    removeNum = Math.max(removeNum || 0, 0);\n    if (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n      return this;\n    }\n    // If index is negative, it should resolve relative to the size of the\n    // collection. However size may be expensive to compute if not cached, so\n    // only call count() if the number is in fact negative.\n    index = resolveBegin(index, index < 0 ? this.count() : this.size);\n    var spliced = this.slice(0, index);\n    return reify(\n      this,\n      numArgs === 1\n        ? spliced\n        : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n    );\n  },\n\n  // ### More collection methods\n\n  findLastIndex: function findLastIndex(predicate, context) {\n    var entry = this.findLastEntry(predicate, context);\n    return entry ? entry[0] : -1;\n  },\n\n  first: function first(notSetValue) {\n    return this.get(0, notSetValue);\n  },\n\n  flatten: function flatten(depth) {\n    return reify(this, flattenFactory(this, depth, false));\n  },\n\n  get: function get(index, notSetValue) {\n    index = wrapIndex(this, index);\n    return index < 0 ||\n      this.size === Infinity ||\n      (this.size !== undefined && index > this.size)\n      ? notSetValue\n      : this.find(function (_, key) { return key === index; }, undefined, notSetValue);\n  },\n\n  has: function has(index) {\n    index = wrapIndex(this, index);\n    return (\n      index >= 0 &&\n      (this.size !== undefined\n        ? this.size === Infinity || index < this.size\n        : this.indexOf(index) !== -1)\n    );\n  },\n\n  interpose: function interpose(separator) {\n    return reify(this, interposeFactory(this, separator));\n  },\n\n  interleave: function interleave(/*...collections*/) {\n    var collections = [this].concat(arrCopy(arguments));\n    var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);\n    var interleaved = zipped.flatten(true);\n    if (zipped.size) {\n      interleaved.size = zipped.size * collections.length;\n    }\n    return reify(this, interleaved);\n  },\n\n  keySeq: function keySeq() {\n    return Range(0, this.size);\n  },\n\n  last: function last(notSetValue) {\n    return this.get(-1, notSetValue);\n  },\n\n  skipWhile: function skipWhile(predicate, context) {\n    return reify(this, skipWhileFactory(this, predicate, context, false));\n  },\n\n  zip: function zip(/*, ...collections */) {\n    var collections = [this].concat(arrCopy(arguments));\n    return reify(this, zipWithFactory(this, defaultZipper, collections));\n  },\n\n  zipAll: function zipAll(/*, ...collections */) {\n    var collections = [this].concat(arrCopy(arguments));\n    return reify(this, zipWithFactory(this, defaultZipper, collections, true));\n  },\n\n  zipWith: function zipWith(zipper /*, ...collections */) {\n    var collections = arrCopy(arguments);\n    collections[0] = this;\n    return reify(this, zipWithFactory(this, zipper, collections));\n  },\n});\n\nvar IndexedCollectionPrototype = IndexedCollection.prototype;\nIndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;\nIndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;\n\nmixin(SetCollection, {\n  // ### ES6 Collection methods (ES6 Array and Map)\n\n  get: function get(value, notSetValue) {\n    return this.has(value) ? value : notSetValue;\n  },\n\n  includes: function includes(value) {\n    return this.has(value);\n  },\n\n  // ### More sequential methods\n\n  keySeq: function keySeq() {\n    return this.valueSeq();\n  },\n});\n\nvar SetCollectionPrototype = SetCollection.prototype;\nSetCollectionPrototype.has = CollectionPrototype.includes;\nSetCollectionPrototype.contains = SetCollectionPrototype.includes;\nSetCollectionPrototype.keys = SetCollectionPrototype.values;\n\n// Mixin subclasses\n\nmixin(KeyedSeq, KeyedCollectionPrototype);\nmixin(IndexedSeq, IndexedCollectionPrototype);\nmixin(SetSeq, SetCollectionPrototype);\n\n// #pragma Helper functions\n\nfunction reduce(collection, reducer, reduction, context, useFirst, reverse) {\n  assertNotInfinite(collection.size);\n  collection.__iterate(function (v, k, c) {\n    if (useFirst) {\n      useFirst = false;\n      reduction = v;\n    } else {\n      reduction = reducer.call(context, reduction, v, k, c);\n    }\n  }, reverse);\n  return reduction;\n}\n\nfunction keyMapper(v, k) {\n  return k;\n}\n\nfunction entryMapper(v, k) {\n  return [k, v];\n}\n\nfunction not(predicate) {\n  return function () {\n    return !predicate.apply(this, arguments);\n  };\n}\n\nfunction neg(predicate) {\n  return function () {\n    return -predicate.apply(this, arguments);\n  };\n}\n\nfunction defaultZipper() {\n  return arrCopy(arguments);\n}\n\nfunction defaultNegComparator(a, b) {\n  return a < b ? 1 : a > b ? -1 : 0;\n}\n\nfunction hashCollection(collection) {\n  if (collection.size === Infinity) {\n    return 0;\n  }\n  var ordered = isOrdered(collection);\n  var keyed = isKeyed(collection);\n  var h = ordered ? 1 : 0;\n  var size = collection.__iterate(\n    keyed\n      ? ordered\n        ? function (v, k) {\n            h = (31 * h + hashMerge(hash(v), hash(k))) | 0;\n          }\n        : function (v, k) {\n            h = (h + hashMerge(hash(v), hash(k))) | 0;\n          }\n      : ordered\n      ? function (v) {\n          h = (31 * h + hash(v)) | 0;\n        }\n      : function (v) {\n          h = (h + hash(v)) | 0;\n        }\n  );\n  return murmurHashOfSize(size, h);\n}\n\nfunction murmurHashOfSize(size, h) {\n  h = imul(h, 0xcc9e2d51);\n  h = imul((h << 15) | (h >>> -15), 0x1b873593);\n  h = imul((h << 13) | (h >>> -13), 5);\n  h = ((h + 0xe6546b64) | 0) ^ size;\n  h = imul(h ^ (h >>> 16), 0x85ebca6b);\n  h = imul(h ^ (h >>> 13), 0xc2b2ae35);\n  h = smi(h ^ (h >>> 16));\n  return h;\n}\n\nfunction hashMerge(a, b) {\n  return (a ^ (b + 0x9e3779b9 + (a << 6) + (a >> 2))) | 0; // int\n}\n\nvar OrderedSet = /*@__PURE__*/(function (Set) {\n  function OrderedSet(value) {\n    return value === undefined || value === null\n      ? emptyOrderedSet()\n      : isOrderedSet(value)\n      ? value\n      : emptyOrderedSet().withMutations(function (set) {\n          var iter = SetCollection(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function (v) { return set.add(v); });\n        });\n  }\n\n  if ( Set ) OrderedSet.__proto__ = Set;\n  OrderedSet.prototype = Object.create( Set && Set.prototype );\n  OrderedSet.prototype.constructor = OrderedSet;\n\n  OrderedSet.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  OrderedSet.fromKeys = function fromKeys (value) {\n    return this(KeyedCollection(value).keySeq());\n  };\n\n  OrderedSet.prototype.toString = function toString () {\n    return this.__toString('OrderedSet {', '}');\n  };\n\n  return OrderedSet;\n}(immutable_es_Set));\n\nOrderedSet.isOrderedSet = isOrderedSet;\n\nvar OrderedSetPrototype = OrderedSet.prototype;\nOrderedSetPrototype[IS_ORDERED_SYMBOL] = true;\nOrderedSetPrototype.zip = IndexedCollectionPrototype.zip;\nOrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;\nOrderedSetPrototype.zipAll = IndexedCollectionPrototype.zipAll;\n\nOrderedSetPrototype.__empty = emptyOrderedSet;\nOrderedSetPrototype.__make = makeOrderedSet;\n\nfunction makeOrderedSet(map, ownerID) {\n  var set = Object.create(OrderedSetPrototype);\n  set.size = map ? map.size : 0;\n  set._map = map;\n  set.__ownerID = ownerID;\n  return set;\n}\n\nvar EMPTY_ORDERED_SET;\nfunction emptyOrderedSet() {\n  return (\n    EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()))\n  );\n}\n\nfunction throwOnInvalidDefaultValues(defaultValues) {\n  if (isRecord(defaultValues)) {\n    throw new Error(\n      'Can not call `Record` with an immutable Record as default values. Use a plain javascript object instead.'\n    );\n  }\n\n  if (isImmutable(defaultValues)) {\n    throw new Error(\n      'Can not call `Record` with an immutable Collection as default values. Use a plain javascript object instead.'\n    );\n  }\n\n  if (defaultValues === null || typeof defaultValues !== 'object') {\n    throw new Error(\n      'Can not call `Record` with a non-object as default values. Use a plain javascript object instead.'\n    );\n  }\n}\n\nvar Record = function Record(defaultValues, name) {\n  var hasInitialized;\n\n  throwOnInvalidDefaultValues(defaultValues);\n\n  var RecordType = function Record(values) {\n    var this$1$1 = this;\n\n    if (values instanceof RecordType) {\n      return values;\n    }\n    if (!(this instanceof RecordType)) {\n      return new RecordType(values);\n    }\n    if (!hasInitialized) {\n      hasInitialized = true;\n      var keys = Object.keys(defaultValues);\n      var indices = (RecordTypePrototype._indices = {});\n      // Deprecated: left to attempt not to break any external code which\n      // relies on a ._name property existing on record instances.\n      // Use Record.getDescriptiveName() instead\n      RecordTypePrototype._name = name;\n      RecordTypePrototype._keys = keys;\n      RecordTypePrototype._defaultValues = defaultValues;\n      for (var i = 0; i < keys.length; i++) {\n        var propName = keys[i];\n        indices[propName] = i;\n        if (RecordTypePrototype[propName]) {\n          /* eslint-disable no-console */\n          typeof console === 'object' &&\n            console.warn &&\n            console.warn(\n              'Cannot define ' +\n                recordName(this) +\n                ' with property \"' +\n                propName +\n                '\" since that property name is part of the Record API.'\n            );\n          /* eslint-enable no-console */\n        } else {\n          setProp(RecordTypePrototype, propName);\n        }\n      }\n    }\n    this.__ownerID = undefined;\n    this._values = List().withMutations(function (l) {\n      l.setSize(this$1$1._keys.length);\n      KeyedCollection(values).forEach(function (v, k) {\n        l.set(this$1$1._indices[k], v === this$1$1._defaultValues[k] ? undefined : v);\n      });\n    });\n    return this;\n  };\n\n  var RecordTypePrototype = (RecordType.prototype =\n    Object.create(RecordPrototype));\n  RecordTypePrototype.constructor = RecordType;\n\n  if (name) {\n    RecordType.displayName = name;\n  }\n\n  return RecordType;\n};\n\nRecord.prototype.toString = function toString () {\n  var str = recordName(this) + ' { ';\n  var keys = this._keys;\n  var k;\n  for (var i = 0, l = keys.length; i !== l; i++) {\n    k = keys[i];\n    str += (i ? ', ' : '') + k + ': ' + quoteString(this.get(k));\n  }\n  return str + ' }';\n};\n\nRecord.prototype.equals = function equals (other) {\n  return (\n    this === other ||\n    (isRecord(other) && recordSeq(this).equals(recordSeq(other)))\n  );\n};\n\nRecord.prototype.hashCode = function hashCode () {\n  return recordSeq(this).hashCode();\n};\n\n// @pragma Access\n\nRecord.prototype.has = function has (k) {\n  return this._indices.hasOwnProperty(k);\n};\n\nRecord.prototype.get = function get (k, notSetValue) {\n  if (!this.has(k)) {\n    return notSetValue;\n  }\n  var index = this._indices[k];\n  var value = this._values.get(index);\n  return value === undefined ? this._defaultValues[k] : value;\n};\n\n// @pragma Modification\n\nRecord.prototype.set = function set (k, v) {\n  if (this.has(k)) {\n    var newValues = this._values.set(\n      this._indices[k],\n      v === this._defaultValues[k] ? undefined : v\n    );\n    if (newValues !== this._values && !this.__ownerID) {\n      return makeRecord(this, newValues);\n    }\n  }\n  return this;\n};\n\nRecord.prototype.remove = function remove (k) {\n  return this.set(k);\n};\n\nRecord.prototype.clear = function clear () {\n  var newValues = this._values.clear().setSize(this._keys.length);\n\n  return this.__ownerID ? this : makeRecord(this, newValues);\n};\n\nRecord.prototype.wasAltered = function wasAltered () {\n  return this._values.wasAltered();\n};\n\nRecord.prototype.toSeq = function toSeq () {\n  return recordSeq(this);\n};\n\nRecord.prototype.toJS = function toJS$1 () {\n  return toJS(this);\n};\n\nRecord.prototype.entries = function entries () {\n  return this.__iterator(ITERATE_ENTRIES);\n};\n\nRecord.prototype.__iterator = function __iterator (type, reverse) {\n  return recordSeq(this).__iterator(type, reverse);\n};\n\nRecord.prototype.__iterate = function __iterate (fn, reverse) {\n  return recordSeq(this).__iterate(fn, reverse);\n};\n\nRecord.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n  if (ownerID === this.__ownerID) {\n    return this;\n  }\n  var newValues = this._values.__ensureOwner(ownerID);\n  if (!ownerID) {\n    this.__ownerID = ownerID;\n    this._values = newValues;\n    return this;\n  }\n  return makeRecord(this, newValues, ownerID);\n};\n\nRecord.isRecord = isRecord;\nRecord.getDescriptiveName = recordName;\nvar RecordPrototype = Record.prototype;\nRecordPrototype[IS_RECORD_SYMBOL] = true;\nRecordPrototype[DELETE] = RecordPrototype.remove;\nRecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;\nRecordPrototype.getIn = getIn;\nRecordPrototype.hasIn = CollectionPrototype.hasIn;\nRecordPrototype.merge = merge$1;\nRecordPrototype.mergeWith = mergeWith$1;\nRecordPrototype.mergeIn = mergeIn;\nRecordPrototype.mergeDeep = mergeDeep;\nRecordPrototype.mergeDeepWith = mergeDeepWith;\nRecordPrototype.mergeDeepIn = mergeDeepIn;\nRecordPrototype.setIn = setIn;\nRecordPrototype.update = update;\nRecordPrototype.updateIn = updateIn;\nRecordPrototype.withMutations = withMutations;\nRecordPrototype.asMutable = asMutable;\nRecordPrototype.asImmutable = asImmutable;\nRecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;\nRecordPrototype.toJSON = RecordPrototype.toObject =\n  CollectionPrototype.toObject;\nRecordPrototype.inspect = RecordPrototype.toSource = function () {\n  return this.toString();\n};\n\nfunction makeRecord(likeRecord, values, ownerID) {\n  var record = Object.create(Object.getPrototypeOf(likeRecord));\n  record._values = values;\n  record.__ownerID = ownerID;\n  return record;\n}\n\nfunction recordName(record) {\n  return record.constructor.displayName || record.constructor.name || 'Record';\n}\n\nfunction recordSeq(record) {\n  return keyedSeqFromValue(record._keys.map(function (k) { return [k, record.get(k)]; }));\n}\n\nfunction setProp(prototype, name) {\n  try {\n    Object.defineProperty(prototype, name, {\n      get: function () {\n        return this.get(name);\n      },\n      set: function (value) {\n        invariant(this.__ownerID, 'Cannot set on an immutable record.');\n        this.set(name, value);\n      },\n    });\n  } catch (error) {\n    // Object.defineProperty failed. Probably IE8.\n  }\n}\n\n/**\n * Returns a lazy Seq of `value` repeated `times` times. When `times` is\n * undefined, returns an infinite sequence of `value`.\n */\nvar Repeat = /*@__PURE__*/(function (IndexedSeq) {\n  function Repeat(value, times) {\n    if (!(this instanceof Repeat)) {\n      return new Repeat(value, times);\n    }\n    this._value = value;\n    this.size = times === undefined ? Infinity : Math.max(0, times);\n    if (this.size === 0) {\n      if (EMPTY_REPEAT) {\n        return EMPTY_REPEAT;\n      }\n      EMPTY_REPEAT = this;\n    }\n  }\n\n  if ( IndexedSeq ) Repeat.__proto__ = IndexedSeq;\n  Repeat.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n  Repeat.prototype.constructor = Repeat;\n\n  Repeat.prototype.toString = function toString () {\n    if (this.size === 0) {\n      return 'Repeat []';\n    }\n    return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n  };\n\n  Repeat.prototype.get = function get (index, notSetValue) {\n    return this.has(index) ? this._value : notSetValue;\n  };\n\n  Repeat.prototype.includes = function includes (searchValue) {\n    return immutable_es_is(this._value, searchValue);\n  };\n\n  Repeat.prototype.slice = function slice (begin, end) {\n    var size = this.size;\n    return wholeSlice(begin, end, size)\n      ? this\n      : new Repeat(\n          this._value,\n          resolveEnd(end, size) - resolveBegin(begin, size)\n        );\n  };\n\n  Repeat.prototype.reverse = function reverse () {\n    return this;\n  };\n\n  Repeat.prototype.indexOf = function indexOf (searchValue) {\n    if (immutable_es_is(this._value, searchValue)) {\n      return 0;\n    }\n    return -1;\n  };\n\n  Repeat.prototype.lastIndexOf = function lastIndexOf (searchValue) {\n    if (immutable_es_is(this._value, searchValue)) {\n      return this.size;\n    }\n    return -1;\n  };\n\n  Repeat.prototype.__iterate = function __iterate (fn, reverse) {\n    var size = this.size;\n    var i = 0;\n    while (i !== size) {\n      if (fn(this._value, reverse ? size - ++i : i++, this) === false) {\n        break;\n      }\n    }\n    return i;\n  };\n\n  Repeat.prototype.__iterator = function __iterator (type, reverse) {\n    var this$1$1 = this;\n\n    var size = this.size;\n    var i = 0;\n    return new Iterator(function () { return i === size\n        ? iteratorDone()\n        : iteratorValue(type, reverse ? size - ++i : i++, this$1$1._value); }\n    );\n  };\n\n  Repeat.prototype.equals = function equals (other) {\n    return other instanceof Repeat\n      ? immutable_es_is(this._value, other._value)\n      : deepEqual(other);\n  };\n\n  return Repeat;\n}(IndexedSeq));\n\nvar EMPTY_REPEAT;\n\nfunction fromJS(value, converter) {\n  return fromJSWith(\n    [],\n    converter || defaultConverter,\n    value,\n    '',\n    converter && converter.length > 2 ? [] : undefined,\n    { '': value }\n  );\n}\n\nfunction fromJSWith(stack, converter, value, key, keyPath, parentValue) {\n  if (\n    typeof value !== 'string' &&\n    !isImmutable(value) &&\n    (isArrayLike(value) || hasIterator(value) || isPlainObject(value))\n  ) {\n    if (~stack.indexOf(value)) {\n      throw new TypeError('Cannot convert circular structure to Immutable');\n    }\n    stack.push(value);\n    keyPath && key !== '' && keyPath.push(key);\n    var converted = converter.call(\n      parentValue,\n      key,\n      Seq(value).map(function (v, k) { return fromJSWith(stack, converter, v, k, keyPath, value); }\n      ),\n      keyPath && keyPath.slice()\n    );\n    stack.pop();\n    keyPath && keyPath.pop();\n    return converted;\n  }\n  return value;\n}\n\nfunction defaultConverter(k, v) {\n  // Effectively the opposite of \"Collection.toSeq()\"\n  return isIndexed(v) ? v.toList() : isKeyed(v) ? v.toMap() : v.toSet();\n}\n\nvar version = \"4.1.0\";\n\nvar immutable_es_Immutable = {\n  version: version,\n\n  Collection: Collection,\n  // Note: Iterable is deprecated\n  Iterable: Collection,\n\n  Seq: Seq,\n  Map: immutable_es_Map,\n  OrderedMap: OrderedMap,\n  List: List,\n  Stack: Stack,\n  Set: immutable_es_Set,\n  OrderedSet: OrderedSet,\n\n  Record: Record,\n  Range: Range,\n  Repeat: Repeat,\n\n  is: immutable_es_is,\n  fromJS: fromJS,\n  hash: hash,\n\n  isImmutable: isImmutable,\n  isCollection: isCollection,\n  isKeyed: isKeyed,\n  isIndexed: isIndexed,\n  isAssociative: isAssociative,\n  isOrdered: isOrdered,\n  isValueObject: isValueObject,\n  isPlainObject: isPlainObject,\n  isSeq: isSeq,\n  isList: isList,\n  isMap: isMap,\n  isOrderedMap: isOrderedMap,\n  isStack: isStack,\n  isSet: isSet,\n  isOrderedSet: isOrderedSet,\n  isRecord: isRecord,\n\n  get: get,\n  getIn: getIn$1,\n  has: has,\n  hasIn: hasIn$1,\n  merge: merge,\n  mergeDeep: mergeDeep$1,\n  mergeWith: mergeWith,\n  mergeDeepWith: mergeDeepWith$1,\n  remove: remove,\n  removeIn: removeIn,\n  set: set,\n  setIn: setIn$1,\n  update: update$1,\n  updateIn: updateIn$1,\n};\n\n// Note: Iterable is deprecated\nvar Iterable = (/* unused pure expression or super */ null && (Collection));\n\n/* harmony default export */ const immutable_es = (immutable_es_Immutable);\n\n\n;// CONCATENATED MODULE: ./src/constants/index.js\nvar EPSILON = 0.01;\n;// CONCATENATED MODULE: ./src/math/utils.js\n\nvar degreesToRadians = function degreesToRadians(degrees) {\n  return degrees * Math.PI / 180;\n};\nvar radiansToDegrees = function radiansToDegrees(radians) {\n  return radians * 180 / Math.PI;\n};\nvar randRangeFloat = function randRangeFloat(min, max) {\n  return Math.random() * (max - min) + min;\n};\nvar randRangeInt = function randRangeInt(min, max) {\n  var _min = Math.ceil(min);\n\n  var _max = Math.floor(max);\n\n  return Math.floor(Math.random() * (_max - _min) + _min);\n};\nvar clampFloat = function clampFloat(n, min, max) {\n  if (n < min) {\n    return min;\n  }\n\n  if (n > max) {\n    return max;\n  }\n\n  return n;\n};\nvar approximately = function approximately(n, value) {\n  if (n >= value - EPSILON && n <= value + EPSILON) {\n    return true;\n  }\n\n  return false;\n};\n;// CONCATENATED MODULE: ./src/math/Vector2.js\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\nvar Vector2_Vector2 = /*#__PURE__*/function () {\n  function Vector2(_ref) {\n    var _this = this;\n\n    var x = _ref.x,\n        y = _ref.y;\n\n    _classCallCheck(this, Vector2);\n\n    _defineProperty(this, \"addVector\", function (vector) {\n      return new Vector2({\n        x: _this.x + vector.x,\n        y: _this.y + vector.y\n      });\n    });\n\n    _defineProperty(this, \"multiplyScalar\", function (scalar) {\n      return new Vector2({\n        x: _this.x * scalar,\n        y: _this.y * scalar\n      });\n    });\n\n    _defineProperty(this, \"multiplyVector\", function (vector) {\n      return new Vector2({\n        x: _this.x * vector.x,\n        y: _this.y * vector.y\n      });\n    });\n\n    _defineProperty(this, \"divideScalar\", function (scalar) {\n      return new Vector2({\n        x: _this.x / scalar,\n        y: _this.y / scalar\n      });\n    });\n\n    _defineProperty(this, \"distanceTo\", function (vector) {\n      return Math.sqrt(Math.pow(_this.x - vector.x, 2) + Math.pow(_this.y - vector.y, 2));\n    });\n\n    _defineProperty(this, \"invertY\", function (worldHeight) {\n      return new Vector2({\n        x: _this.x,\n        y: worldHeight - _this.y\n      });\n    });\n\n    _defineProperty(this, \"isBetween\", function (vector1, vector2) {\n      var distanceWithMidpoint = _this.distanceTo(vector1) + _this.distanceTo(vector2);\n\n      var distanceWithoutMidpoint = vector1.distanceTo(vector2);\n      var difference = distanceWithMidpoint - distanceWithoutMidpoint;\n\n      if (approximately(difference, 0)) {\n        return true;\n      }\n\n      return false;\n    });\n\n    _defineProperty(this, \"rotate\", function (angleRadians) {\n      return new Vector2({\n        x: _this.x * Math.cos(angleRadians) - _this.y * Math.sin(angleRadians),\n        y: _this.x * Math.sin(angleRadians) + _this.y * Math.cos(angleRadians)\n      });\n    });\n\n    _defineProperty(this, \"testableObj\", function () {\n      return {\n        x: _this.x,\n        y: _this.y\n      };\n    });\n\n    this.x = x;\n    this.y = y;\n  }\n\n  _createClass(Vector2, [{\n    key: \"magnitude\",\n    get: function get() {\n      return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));\n    }\n  }, {\n    key: \"polarCoords\",\n    get: function get() {\n      if (!this.x) {\n        return {\n          angle: 0,\n          radius: 0\n        };\n      }\n\n      return {\n        angle: Math.atan(this.y / this.x),\n        radius: this.magnitude\n      };\n    }\n  }]);\n\n  return Vector2;\n}();\n\n_defineProperty(Vector2_Vector2, \"polarCoordinates\", function (angleRadians) {\n  var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  return new Vector2_Vector2({\n    x: radius * Math.cos(angleRadians),\n    y: radius * Math.sin(angleRadians)\n  });\n});\n\n_defineProperty(Vector2_Vector2, \"generateRandom\", function () {\n  var rangeLengthStart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  var rangeLengthEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n  var rangeRadiansStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var rangeRadiansEnd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2 * Math.PI;\n  var radians = randRangeFloat(rangeRadiansStart, rangeRadiansEnd);\n  var length = randRangeFloat(rangeLengthStart, rangeLengthEnd);\n  return Vector2_Vector2.polarCoordinates(radians, length);\n});\n\n_defineProperty(Vector2_Vector2, \"generateRandomFromCoords\", function () {\n  var rangeXStart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var rangeXEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n  var rangeYStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var rangeYEnd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1000;\n  var x = randRangeFloat(rangeXStart, rangeXEnd);\n  var y = randRangeFloat(rangeYStart, rangeYEnd);\n  return new Vector2_Vector2({\n    x: x,\n    y: y\n  });\n});\n;// CONCATENATED MODULE: ./src/math/Line.js\nfunction Line_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction Line_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Line_createClass(Constructor, protoProps, staticProps) { if (protoProps) Line_defineProperties(Constructor.prototype, protoProps); if (staticProps) Line_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction Line_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nvar Line_Line = /*#__PURE__*/function () {\n  function Line(_ref) {\n    var _this = this;\n\n    var point1 = _ref.point1,\n        point2 = _ref.point2;\n\n    Line_classCallCheck(this, Line);\n\n    Line_defineProperty(this, \"solveY\", function (x) {\n      return _this.slope * x + _this.yIntercept;\n    });\n\n    Line_defineProperty(this, \"calculateIntersection\", function (otherLine) {\n      var bothVertical = Number.isNaN(_this.slope) && Number.isNaN(otherLine.slope);\n      var sameSlopes = bothVertical || approximately(_this.slope, otherLine.slope);\n\n      if (bothVertical) {\n        // doesn't matter which point we check\n        if (_this.point1.x === otherLine.point1.x) {\n          return true; // lines are equal\n        } // lines are vertical and parallel\n\n\n        return false;\n      } // this line is vertical\n\n\n      if (Number.isNaN(_this.slope)) {\n        var _x = _this.point1.x;\n\n        var _y = otherLine.solveY(_x);\n\n        return new Vector2_Vector2({\n          x: _x,\n          y: _y\n        });\n      } // the other line is vertical\n\n\n      if (Number.isNaN(otherLine.slope)) {\n        var _x2 = otherLine.point1.x;\n\n        var _y2 = _this.solveY(_x2);\n\n        return new Vector2_Vector2({\n          x: _x2,\n          y: _y2\n        });\n      }\n\n      var sameYIntercepts = approximately(_this.yIntercept, otherLine.yIntercept); // check if the lines are equal:\n\n      if (sameSlopes && sameYIntercepts) {\n        return true;\n      } // check if the lines are parallel:\n\n\n      if (sameSlopes && !sameYIntercepts) {\n        return false;\n      } // first, we have two equations:\n      //\n      //  y1 = (a1 * x1) + b1\n      //  y2 = (a2 * x2) + b2\n      //\n      // assign these into a system of equations to solve for X\n      // like this (X is now same in both equations):\n      //\n      //  (a1 * x) + b1 = (a2 * x) + b2\n      //  (a1 * x) - (a2 * x) = b2 - b1\n      //  x = (b2 - b1) / (a1 - a2)\n\n\n      var x = (otherLine.yIntercept - _this.yIntercept) / (_this.slope - otherLine.slope);\n\n      var y = _this.solveY(x);\n\n      return new Vector2_Vector2({\n        x: x,\n        y: y\n      });\n    });\n\n    Line_defineProperty(this, \"calculateSegmentIntersection\", function (otherLine) {\n      var intersection = _this.calculateIntersection(otherLine); // parallel\n\n\n      if (!intersection) {\n        return false;\n      }\n\n      var equalLines = intersection === true;\n\n      var overlappingSegments = _this.point1.isBetween(otherLine.point1, otherLine.point2) || _this.point2.isBetween(otherLine.point1, otherLine.point2);\n\n      if (equalLines && overlappingSegments) {\n        return true;\n      }\n\n      if (equalLines && !overlappingSegments) {\n        return false;\n      } // check if line segments intersect\n\n\n      if (intersection.isBetween(_this.point1, _this.point2) && intersection.isBetween(otherLine.point1, otherLine.point2)) {\n        return intersection;\n      } // the lines intersect but line segments do not\n\n\n      return false;\n    });\n\n    Line_defineProperty(this, \"testableObj\", function () {\n      return {\n        point1: _this.point1.testableObj(),\n        point2: _this.point2.testableObj()\n      };\n    });\n\n    this.point1 = point1;\n    this.point2 = point2;\n  }\n\n  Line_createClass(Line, [{\n    key: \"slope\",\n    get: function get() {\n      if (this.point1 && this.point2) {\n        var denominator = this.point1.x - this.point2.x;\n\n        if (denominator !== 0) {\n          return (this.point1.y - this.point2.y) / denominator;\n        }\n      } // vertical line\n\n\n      return Number.NaN;\n    }\n  }, {\n    key: \"yIntercept\",\n    get: function get() {\n      if (Number.isNaN(this.slope)) {\n        return Number.NaN;\n      } // calculate the Y intercept by assigning the coordinates of the\n      // first point to the variables of the slope-intercept equation\n      // (y = ax + b)\n\n\n      return this.point1.y - this.slope * this.point1.x;\n    }\n  }]);\n\n  return Line;\n}();\n;// CONCATENATED MODULE: ./src/math/Polygon.js\nfunction Polygon_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Polygon_createClass(Constructor, protoProps, staticProps) { if (protoProps) Polygon_defineProperties(Constructor.prototype, protoProps); if (staticProps) Polygon_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction Polygon_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction Polygon_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\nvar Polygon = /*#__PURE__*/Polygon_createClass(function Polygon(_ref) {\n  var _this = this;\n\n  var points = _ref.points,\n      radius = _ref.radius;\n\n  Polygon_classCallCheck(this, Polygon);\n\n  Polygon_defineProperty(this, \"getKonvaPoints\", function () {\n    return _this.points.map(function (point) {\n      return [point.x, point.y];\n    }).flat();\n  });\n\n  Polygon_defineProperty(this, \"getLines\", function () {\n    var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    return immutable_es.fromJS(_this.points.map(function (point, i) {\n      var nextIndex = i < _this.points.length - 1 ? i + 1 : 0;\n      var point1 = point;\n      var point2 = _this.points[nextIndex];\n\n      if (position) {\n        point1 = point1.addVector(position);\n        point2 = point2.addVector(position);\n      }\n\n      return new Line_Line({\n        point1: point1,\n        point2: point2\n      });\n    }));\n  });\n\n  Polygon_defineProperty(this, \"rotate\", function (angleRadians) {\n    _this.points = _this.points.map(function (point) {\n      return point.rotate(angleRadians);\n    });\n  });\n\n  this.points = points;\n  this.radius = radius;\n});\n\nPolygon_defineProperty(Polygon, \"generateRandom\", function (nCorners) {\n  var step = 2 * Math.PI / nCorners;\n  var radius = randRangeInt(50, 100);\n  var prev = 0;\n  var next = prev + step;\n  var points = [];\n\n  for (var i = 0; i < nCorners; i += 1) {\n    var angle = randRangeFloat(prev, next);\n    var coords = Vector2_Vector2.polarCoordinates(angle, radius);\n    points.push(coords);\n    prev = next;\n    next += step;\n  }\n\n  return new Polygon({\n    points: points,\n    radius: radius\n  });\n});\n;// CONCATENATED MODULE: ./src/math/index.js\n\n\n\n;// CONCATENATED MODULE: ./src/components/KonvaPolygon.jsx\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction KonvaPolygon_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction KonvaPolygon_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction KonvaPolygon_createClass(Constructor, protoProps, staticProps) { if (protoProps) KonvaPolygon_defineProperties(Constructor.prototype, protoProps); if (staticProps) KonvaPolygon_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) KonvaPolygon_setPrototypeOf(subClass, superClass); }\n\nfunction KonvaPolygon_setPrototypeOf(o, p) { KonvaPolygon_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return KonvaPolygon_setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n\nvar KonvaPolygon = /*#__PURE__*/function (_React$Component) {\n  _inherits(KonvaPolygon, _React$Component);\n\n  var _super = _createSuper(KonvaPolygon);\n\n  function KonvaPolygon() {\n    KonvaPolygon_classCallCheck(this, KonvaPolygon);\n\n    return _super.apply(this, arguments);\n  }\n\n  KonvaPolygon_createClass(KonvaPolygon, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          polygon = _this$props.polygon,\n          position = _this$props.position;\n      var x = position.x,\n          y = position.y;\n\n      if (!x && !y) {\n        return null;\n      }\n\n      return /*#__PURE__*/react.createElement(ReactKonvaCore_Line, {\n        points: polygon.getKonvaPoints(),\n        stroke: \"black\",\n        strokeWidth: 2,\n        x: x,\n        y: y,\n        closed: true\n      });\n    }\n  }]);\n\n  return KonvaPolygon;\n}(react.Component);\nKonvaPolygon.propTypes = {\n  polygon: prop_types_default().instanceOf(Polygon).isRequired,\n  position: prop_types_default().instanceOf(Vector2_Vector2).isRequired\n};\n;// CONCATENATED MODULE: ./src/actions/simulation.js\nvar SET_STAGE_BOUNDS = 'SET_STAGE_BOUNDS';\nvar simulation_setStageBounds = function setStageBounds(width, height) {\n  return {\n    type: SET_STAGE_BOUNDS,\n    payload: {\n      width: width,\n      height: height\n    }\n  };\n};\n;// CONCATENATED MODULE: ./src/actions/polygons.js\nvar SAVE_POLYGONS = 'SAVE_POLYGONS';\nvar UPDATE_POLYGONS = 'UPDATE_POLYGONS';\nvar savePolygons = function savePolygons(polygons) {\n  return {\n    type: SAVE_POLYGONS,\n    payload: {\n      polygons: polygons\n    }\n  };\n};\nvar polygons_updatePolygons = function updatePolygons(deltaTime) {\n  return {\n    type: UPDATE_POLYGONS,\n    payload: {\n      deltaTime: deltaTime\n    }\n  };\n};\n;// CONCATENATED MODULE: ./node_modules/reselect/es/defaultMemoize.js\n// Cache implementation based on Erik Rasmussen's `lru-memoize`:\n// https://github.com/erikras/lru-memoize\nvar NOT_FOUND = 'NOT_FOUND';\n\nfunction createSingletonCache(equals) {\n  var entry;\n  return {\n    get: function get(key) {\n      if (entry && equals(entry.key, key)) {\n        return entry.value;\n      }\n\n      return NOT_FOUND;\n    },\n    put: function put(key, value) {\n      entry = {\n        key: key,\n        value: value\n      };\n    },\n    getEntries: function getEntries() {\n      return entry ? [entry] : [];\n    },\n    clear: function clear() {\n      entry = undefined;\n    }\n  };\n}\n\nfunction createLruCache(maxSize, equals) {\n  var entries = [];\n\n  function get(key) {\n    var cacheIndex = entries.findIndex(function (entry) {\n      return equals(key, entry.key);\n    }); // We found a cached entry\n\n    if (cacheIndex > -1) {\n      var entry = entries[cacheIndex]; // Cached entry not at top of cache, move it to the top\n\n      if (cacheIndex > 0) {\n        entries.splice(cacheIndex, 1);\n        entries.unshift(entry);\n      }\n\n      return entry.value;\n    } // No entry found in cache, return sentinel\n\n\n    return NOT_FOUND;\n  }\n\n  function put(key, value) {\n    if (get(key) === NOT_FOUND) {\n      // TODO Is unshift slow?\n      entries.unshift({\n        key: key,\n        value: value\n      });\n\n      if (entries.length > maxSize) {\n        entries.pop();\n      }\n    }\n  }\n\n  function getEntries() {\n    return entries;\n  }\n\n  function clear() {\n    entries = [];\n  }\n\n  return {\n    get: get,\n    put: put,\n    getEntries: getEntries,\n    clear: clear\n  };\n}\n\nvar defaultEqualityCheck = function defaultEqualityCheck(a, b) {\n  return a === b;\n};\nfunction createCacheKeyComparator(equalityCheck) {\n  return function areArgumentsShallowlyEqual(prev, next) {\n    if (prev === null || next === null || prev.length !== next.length) {\n      return false;\n    } // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\n\n\n    var length = prev.length;\n\n    for (var i = 0; i < length; i++) {\n      if (!equalityCheck(prev[i], next[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n}\n// defaultMemoize now supports a configurable cache size with LRU behavior,\n// and optional comparison of the result value with existing values\nfunction defaultMemoize(func, equalityCheckOrOptions) {\n  var providedOptions = typeof equalityCheckOrOptions === 'object' ? equalityCheckOrOptions : {\n    equalityCheck: equalityCheckOrOptions\n  };\n  var _providedOptions$equa = providedOptions.equalityCheck,\n      equalityCheck = _providedOptions$equa === void 0 ? defaultEqualityCheck : _providedOptions$equa,\n      _providedOptions$maxS = providedOptions.maxSize,\n      maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS,\n      resultEqualityCheck = providedOptions.resultEqualityCheck;\n  var comparator = createCacheKeyComparator(equalityCheck);\n  var cache = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator); // we reference arguments instead of spreading them for performance reasons\n\n  function memoized() {\n    var value = cache.get(arguments);\n\n    if (value === NOT_FOUND) {\n      // @ts-ignore\n      value = func.apply(null, arguments);\n\n      if (resultEqualityCheck) {\n        var entries = cache.getEntries();\n        var matchingEntry = entries.find(function (entry) {\n          return resultEqualityCheck(entry.value, value);\n        });\n\n        if (matchingEntry) {\n          value = matchingEntry.value;\n        }\n      }\n\n      cache.put(arguments, value);\n    }\n\n    return value;\n  }\n\n  memoized.clearCache = function () {\n    return cache.clear();\n  };\n\n  return memoized;\n}\n;// CONCATENATED MODULE: ./node_modules/reselect/es/index.js\n\n\n\nfunction getDependencies(funcs) {\n  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;\n\n  if (!dependencies.every(function (dep) {\n    return typeof dep === 'function';\n  })) {\n    var dependencyTypes = dependencies.map(function (dep) {\n      return typeof dep === 'function' ? \"function \" + (dep.name || 'unnamed') + \"()\" : typeof dep;\n    }).join(', ');\n    throw new Error(\"createSelector expects all input-selectors to be functions, but received the following types: [\" + dependencyTypes + \"]\");\n  }\n\n  return dependencies;\n}\n\nfunction createSelectorCreator(memoize) {\n  for (var _len = arguments.length, memoizeOptionsFromArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    memoizeOptionsFromArgs[_key - 1] = arguments[_key];\n  }\n\n  var createSelector = function createSelector() {\n    for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      funcs[_key2] = arguments[_key2];\n    }\n\n    var _recomputations = 0;\n\n    var _lastResult; // Due to the intricacies of rest params, we can't do an optional arg after `...funcs`.\n    // So, start by declaring the default value here.\n    // (And yes, the words 'memoize' and 'options' appear too many times in this next sequence.)\n\n\n    var directlyPassedOptions = {\n      memoizeOptions: undefined\n    }; // Normally, the result func or \"output selector\" is the last arg\n\n    var resultFunc = funcs.pop(); // If the result func is actually an _object_, assume it's our options object\n\n    if (typeof resultFunc === 'object') {\n      directlyPassedOptions = resultFunc; // and pop the real result func off\n\n      resultFunc = funcs.pop();\n    }\n\n    if (typeof resultFunc !== 'function') {\n      throw new Error(\"createSelector expects an output function after the inputs, but received: [\" + typeof resultFunc + \"]\");\n    } // Determine which set of options we're using. Prefer options passed directly,\n    // but fall back to options given to createSelectorCreator.\n\n\n    var _directlyPassedOption = directlyPassedOptions,\n        _directlyPassedOption2 = _directlyPassedOption.memoizeOptions,\n        memoizeOptions = _directlyPassedOption2 === void 0 ? memoizeOptionsFromArgs : _directlyPassedOption2; // Simplifying assumption: it's unlikely that the first options arg of the provided memoizer\n    // is an array. In most libs I've looked at, it's an equality function or options object.\n    // Based on that, if `memoizeOptions` _is_ an array, we assume it's a full\n    // user-provided array of options. Otherwise, it must be just the _first_ arg, and so\n    // we wrap it in an array so we can apply it.\n\n    var finalMemoizeOptions = Array.isArray(memoizeOptions) ? memoizeOptions : [memoizeOptions];\n    var dependencies = getDependencies(funcs);\n    var memoizedResultFunc = memoize.apply(void 0, [function recomputationWrapper() {\n      _recomputations++; // apply arguments instead of spreading for performance.\n\n      return resultFunc.apply(null, arguments);\n    }].concat(finalMemoizeOptions)); // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\n\n    var selector = memoize(function dependenciesChecker() {\n      var params = [];\n      var length = dependencies.length;\n\n      for (var i = 0; i < length; i++) {\n        // apply arguments instead of spreading and mutate a local list of params for performance.\n        // @ts-ignore\n        params.push(dependencies[i].apply(null, arguments));\n      } // apply arguments instead of spreading for performance.\n\n\n      _lastResult = memoizedResultFunc.apply(null, params);\n      return _lastResult;\n    });\n    Object.assign(selector, {\n      resultFunc: resultFunc,\n      memoizedResultFunc: memoizedResultFunc,\n      dependencies: dependencies,\n      lastResult: function lastResult() {\n        return _lastResult;\n      },\n      recomputations: function recomputations() {\n        return _recomputations;\n      },\n      resetRecomputations: function resetRecomputations() {\n        return _recomputations = 0;\n      }\n    });\n    return selector;\n  }; // @ts-ignore\n\n\n  return createSelector;\n}\nvar es_createSelector = /* #__PURE__ */createSelectorCreator(defaultMemoize);\n// Manual definition of state and output arguments\nvar createStructuredSelector = function createStructuredSelector(selectors, selectorCreator) {\n  if (selectorCreator === void 0) {\n    selectorCreator = es_createSelector;\n  }\n\n  if (typeof selectors !== 'object') {\n    throw new Error('createStructuredSelector expects first argument to be an object ' + (\"where each property is a selector, instead received a \" + typeof selectors));\n  }\n\n  var objectKeys = Object.keys(selectors);\n  var resultSelector = selectorCreator( // @ts-ignore\n  objectKeys.map(function (key) {\n    return selectors[key];\n  }), function () {\n    for (var _len3 = arguments.length, values = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      values[_key3] = arguments[_key3];\n    }\n\n    return values.reduce(function (composition, value, index) {\n      composition[objectKeys[index]] = value;\n      return composition;\n    }, {});\n  });\n  return resultSelector;\n};\n;// CONCATENATED MODULE: ./src/selectors/polygons.js\n\n\nvar getPolygons = function getPolygons(state) {\n  return state.polygons;\n};\nvar getPolygonList = es_createSelector(getPolygons, function (polygons) {\n  return polygons.get('polygons');\n});\n;// CONCATENATED MODULE: ./src/selectors/simulation.js\n\n\n\nvar getSimulationState = function getSimulationState(state) {\n  return state.simulation;\n};\nvar getStageBounds = es_createSelector(getSimulationState, function (simulationState) {\n  return immutable_es.fromJS({\n    width: simulationState.get('width'),\n    height: simulationState.get('height')\n  });\n});\nvar getStageBorderingLines = es_createSelector(getStageBounds, function (bounds) {\n  var _bounds$toJS = bounds.toJS(),\n      width = _bounds$toJS.width,\n      height = _bounds$toJS.height;\n\n  var topLine = new Line_Line({\n    point1: new Vector2_Vector2({\n      x: 0,\n      y: 0\n    }),\n    point2: new Vector2_Vector2({\n      x: width,\n      y: 0\n    })\n  });\n  var rightLine = new Line_Line({\n    point1: new Vector2_Vector2({\n      x: width,\n      y: 0\n    }),\n    point2: new Vector2_Vector2({\n      x: width,\n      y: height\n    })\n  });\n  var bottomLine = new Line_Line({\n    point1: new Vector2_Vector2({\n      x: 0,\n      y: height\n    }),\n    point2: new Vector2_Vector2({\n      x: width,\n      y: height\n    })\n  });\n  var leftLine = new Line_Line({\n    point1: new Vector2_Vector2({\n      x: 0,\n      y: 0\n    }),\n    point2: new Vector2_Vector2({\n      x: 0,\n      y: height\n    })\n  });\n  return immutable_es.fromJS({\n    topLine: topLine,\n    rightLine: rightLine,\n    bottomLine: bottomLine,\n    leftLine: leftLine\n  });\n});\n;// CONCATENATED MODULE: ./src/components/SimulationView.jsx\nfunction SimulationView_typeof(obj) { \"@babel/helpers - typeof\"; return SimulationView_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, SimulationView_typeof(obj); }\n\nvar SimulationView_templateObject;\n\nfunction SimulationView_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction SimulationView_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction SimulationView_createClass(Constructor, protoProps, staticProps) { if (protoProps) SimulationView_defineProperties(Constructor.prototype, protoProps); if (staticProps) SimulationView_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction SimulationView_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) SimulationView_setPrototypeOf(subClass, superClass); }\n\nfunction SimulationView_setPrototypeOf(o, p) { SimulationView_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return SimulationView_setPrototypeOf(o, p); }\n\nfunction SimulationView_createSuper(Derived) { var hasNativeReflectConstruct = SimulationView_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = SimulationView_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = SimulationView_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return SimulationView_possibleConstructorReturn(this, result); }; }\n\nfunction SimulationView_possibleConstructorReturn(self, call) { if (call && (SimulationView_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return SimulationView_assertThisInitialized(self); }\n\nfunction SimulationView_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction SimulationView_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction SimulationView_getPrototypeOf(o) { SimulationView_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return SimulationView_getPrototypeOf(o); }\n\nfunction SimulationView_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction SimulationView_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar PaddedContainer = styled_components_browser_esm.div(SimulationView_templateObject || (SimulationView_templateObject = SimulationView_taggedTemplateLiteral([\"\\n  background-color: #ddd;\\n  margin: 30px;\\n\"])));\nvar FRAME_LENGTH = 1000 / 60;\n\nvar SimulationViewCls = /*#__PURE__*/function (_React$Component) {\n  SimulationView_inherits(SimulationViewCls, _React$Component);\n\n  var _super = SimulationView_createSuper(SimulationViewCls);\n\n  function SimulationViewCls(props) {\n    var _this;\n\n    SimulationView_classCallCheck(this, SimulationViewCls);\n\n    _this = _super.call(this, props);\n\n    SimulationView_defineProperty(SimulationView_assertThisInitialized(_this), \"animateFrame\", function (now) {\n      var updatePolygons = _this.props.updatePolygons;\n      var delta = now - _this.lastTime;\n\n      if (delta >= FRAME_LENGTH) {\n        updatePolygons(delta);\n        _this.lastTime = now;\n      }\n\n      requestAnimationFrame(_this.animateFrame);\n    });\n\n    _this.lastTime = 0;\n    return _this;\n  }\n\n  SimulationView_createClass(SimulationViewCls, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      requestAnimationFrame(this.animateFrame);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          bounds = _this$props.bounds,\n          polygons = _this$props.polygons,\n          setStageBounds = _this$props.setStageBounds;\n\n      var _bounds$toJS = bounds.toJS(),\n          width = _bounds$toJS.width,\n          height = _bounds$toJS.height;\n\n      return /*#__PURE__*/react.createElement(PaddedContainer, null, /*#__PURE__*/react.createElement(index_esm, {\n        bounds: true,\n        onResize: function onResize(rect) {\n          var _width = rect.bounds.width;\n\n          if (_width !== width) {\n            setStageBounds(_width, _width);\n          }\n        }\n      }, function (_ref) {\n        var measureRef = _ref.measureRef;\n        return /*#__PURE__*/react.createElement(\"div\", {\n          ref: measureRef\n        }, /*#__PURE__*/react.createElement(ReactKonvaCore_Stage, {\n          width: width,\n          height: height\n        }, /*#__PURE__*/react.createElement(ReactKonvaCore_Layer, null, polygons.map(function (polygon) {\n          return /*#__PURE__*/react.createElement(KonvaPolygon, {\n            key: polygon.get('id'),\n            polygon: polygon.get('polygon'),\n            position: polygon.get('position'),\n            stageWidth: width,\n            stageHeight: height\n          });\n        }))));\n      }));\n    }\n  }]);\n\n  return SimulationViewCls;\n}(react.Component);\n\nSimulationViewCls.propTypes = {\n  bounds: prop_types_default().instanceOf(immutable_es.Map),\n  polygons: prop_types_default().instanceOf(immutable_es.List),\n  setStageBounds: (prop_types_default()).func.isRequired,\n  updatePolygons: (prop_types_default()).func.isRequired\n};\nSimulationViewCls.defaultProps = {\n  bounds: {\n    width: 0,\n    height: 0\n  },\n  polygons: immutable_es.List()\n};\n\nvar mapStateToProps = function mapStateToProps(state) {\n  return {\n    bounds: getStageBounds(state),\n    polygons: getPolygonList(state)\n  };\n};\n\nvar mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    setStageBounds: function setStageBounds(width, height) {\n      return dispatch(simulation_setStageBounds(width, height));\n    },\n    updatePolygons: function updatePolygons(delta) {\n      return dispatch(polygons_updatePolygons(delta));\n    }\n  };\n};\n\nvar SimulationView = components_connect(mapStateToProps, mapDispatchToProps)(SimulationViewCls);\n;// CONCATENATED MODULE: ./src/components/DialBase.jsx\nvar DialBase_templateObject;\n\nfunction DialBase_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\n\nvar dialBaseDimensions = \"\".concat(dialBaseDimensionsPx, \"px\");\nvar DialBase = styled_components_browser_esm.span(DialBase_templateObject || (DialBase_templateObject = DialBase_taggedTemplateLiteral([\"\\n  border: 2px solid #fff;\\n  border-radius: 100%;\\n\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n\\n  color: #fff;\\n  font-size: \", \";\\n\\n  width: \", \";\\n  height: \", \";\\n\"])), function (props) {\n  return props.fontSize;\n}, dialBaseDimensions, dialBaseDimensions);\nDialBase.defaultProps = {\n  fontSize: '60px'\n};\n;// CONCATENATED MODULE: ./src/components/ScalarDial.jsx\nvar ScalarDial_excluded = [\"value\"];\n\nfunction ScalarDial_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ScalarDial_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ScalarDial_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar ScalarDial = function ScalarDial(_ref) {\n  var value = _ref.value,\n      props = ScalarDial_objectWithoutProperties(_ref, ScalarDial_excluded);\n\n  return /*#__PURE__*/react.createElement(DialBase, null, value);\n};\nScalarDial.propTypes = {\n  value: (prop_types_default()).number\n};\nScalarDial.defaultProps = {\n  value: 0\n};\n;// CONCATENATED MODULE: ./src/components/CoordsDial.jsx\nvar CoordsDial_excluded = [\"coords\"];\n\nfunction CoordsDial_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CoordsDial_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CoordsDial_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar CoordsDial = function CoordsDial(_ref) {\n  var coords = _ref.coords,\n      props = CoordsDial_objectWithoutProperties(_ref, CoordsDial_excluded);\n\n  if (!coords) {\n    return /*#__PURE__*/react.createElement(DialBase, null);\n  }\n\n  return /*#__PURE__*/react.createElement(DialBase, {\n    fontSize: \"20px\"\n  }, \"(\".concat(Math.round(coords.x), \",\").concat(Math.round(coords.y), \")\"));\n};\nCoordsDial.propTypes = {\n  coords: prop_types_default().instanceOf(Vector2_Vector2)\n};\nCoordsDial.defaultProps = {\n  coords: new Vector2_Vector2({\n    x: 0,\n    y: 0\n  })\n};\n;// CONCATENATED MODULE: ./src/components/AngleDial.jsx\nvar AngleDial_excluded = [\"angle\"];\n\nfunction AngleDial_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = AngleDial_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction AngleDial_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar AngleDial = function AngleDial(_ref) {\n  var angle = _ref.angle,\n      props = AngleDial_objectWithoutProperties(_ref, AngleDial_excluded);\n\n  var text = (0,react.useRef)(null);\n  var dimHalved = dialBaseDimensionsPx / 2;\n\n  var _angle = angle < 0 ? 360 + angle : angle;\n\n  return /*#__PURE__*/react.createElement(DialBase, null, /*#__PURE__*/react.createElement(ReactKonvaCore_Stage, {\n    width: dialBaseDimensionsPx,\n    height: dialBaseDimensionsPx\n  }, /*#__PURE__*/react.createElement(ReactKonvaCore_Layer, null, /*#__PURE__*/react.createElement(ReactKonvaCore_Circle, {\n    x: dimHalved,\n    y: dimHalved,\n    radius: dimHalved,\n    fill: \"#fff\"\n  }), /*#__PURE__*/react.createElement(ReactKonvaCore_Arc, {\n    x: dimHalved,\n    y: dimHalved,\n    innerRadius: dimHalved / 2,\n    outerRadius: dimHalved,\n    angle: _angle,\n    rotationDeg: -90,\n    fill: lightBlue\n  }), /*#__PURE__*/react.createElement(ReactKonvaCore_Text, {\n    ref: text,\n    x: dimHalved,\n    y: dimHalved,\n    offsetX: text && text.current ? text.current.width() / 2 : 0,\n    offsetY: 10,\n    text: Math.round(_angle).toString(),\n    fontSize: 20,\n    fontFamily: \"monospace\",\n    fill: dark\n  }))));\n};\nAngleDial.propTypes = {\n  angle: (prop_types_default()).number\n};\nAngleDial.defaultProps = {\n  angle: 0\n};\n;// CONCATENATED MODULE: ./src/components/VectorDial.jsx\nfunction VectorDial_typeof(obj) { \"@babel/helpers - typeof\"; return VectorDial_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, VectorDial_typeof(obj); }\n\nfunction VectorDial_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction VectorDial_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction VectorDial_createClass(Constructor, protoProps, staticProps) { if (protoProps) VectorDial_defineProperties(Constructor.prototype, protoProps); if (staticProps) VectorDial_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction VectorDial_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) VectorDial_setPrototypeOf(subClass, superClass); }\n\nfunction VectorDial_setPrototypeOf(o, p) { VectorDial_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return VectorDial_setPrototypeOf(o, p); }\n\nfunction VectorDial_createSuper(Derived) { var hasNativeReflectConstruct = VectorDial_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = VectorDial_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = VectorDial_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return VectorDial_possibleConstructorReturn(this, result); }; }\n\nfunction VectorDial_possibleConstructorReturn(self, call) { if (call && (VectorDial_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return VectorDial_assertThisInitialized(self); }\n\nfunction VectorDial_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction VectorDial_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction VectorDial_getPrototypeOf(o) { VectorDial_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return VectorDial_getPrototypeOf(o); }\n\n\n\n\n\n\n\nvar maxVectorLength = dialBaseDimensionsPx / 2;\nvar VectorDial = /*#__PURE__*/function (_React$Component) {\n  VectorDial_inherits(VectorDial, _React$Component);\n\n  var _super = VectorDial_createSuper(VectorDial);\n\n  function VectorDial(props) {\n    var _this;\n\n    VectorDial_classCallCheck(this, VectorDial);\n\n    _this = _super.call(this, props);\n    _this.state = {\n      range: 5,\n      lengthDivider: 5 / maxVectorLength\n    };\n    _this.text = /*#__PURE__*/react.createRef();\n    return _this;\n  }\n\n  VectorDial_createClass(VectorDial, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      var magnitude = this.props.vector.magnitude;\n      var range = this.state.range;\n\n      if (magnitude > range) {\n        var lengthDivider = magnitude / maxVectorLength;\n        this.setState({\n          range: magnitude,\n          lengthDivider: lengthDivider\n        });\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var vector = this.props.vector;\n      var _this$state = this.state,\n          range = _this$state.range,\n          lengthDivider = _this$state.lengthDivider;\n      var dimHalved = dialBaseDimensionsPx / 2;\n      var scaledVector = vector.divideScalar(lengthDivider);\n      return /*#__PURE__*/react.createElement(DialBase, null, /*#__PURE__*/react.createElement(ReactKonvaCore_Stage, {\n        width: dialBaseDimensionsPx,\n        height: dialBaseDimensionsPx\n      }, /*#__PURE__*/react.createElement(ReactKonvaCore_Layer, null, /*#__PURE__*/react.createElement(ReactKonvaCore_Circle, {\n        x: dimHalved,\n        y: dimHalved,\n        radius: dimHalved,\n        fill: \"#fff\"\n      }), /*#__PURE__*/react.createElement(ReactKonvaCore_Circle, {\n        x: dimHalved,\n        y: dimHalved,\n        radius: dimHalved / 2,\n        stroke: dark,\n        strokeWidth: 1\n      }), /*#__PURE__*/react.createElement(ReactKonvaCore_Text, {\n        ref: this.text,\n        x: dimHalved,\n        y: 5,\n        offsetX: this.text && this.text.current ? this.text.current.width() / 2 : 0,\n        text: Math.round(range).toString(),\n        fontSize: 10,\n        fontFamily: \"monospace\",\n        fill: dark\n      }), /*#__PURE__*/react.createElement(ReactKonvaCore_Line, {\n        points: [dimHalved, dimHalved, scaledVector.x + dimHalved, scaledVector.y + dimHalved],\n        stroke: lightBlue,\n        strokeWidth: 2\n      }))));\n    }\n  }]);\n\n  return VectorDial;\n}(react.Component);\nVectorDial.propTypes = {\n  vector: prop_types_default().instanceOf(Vector2_Vector2)\n};\nVectorDial.defaultProps = {\n  vector: new Vector2_Vector2({\n    x: 0,\n    y: 0\n  })\n};\n;// CONCATENATED MODULE: ./src/components/Dial.jsx\nvar Dial_excluded = [\"label\", \"value\", \"type\", \"unit\"];\n\nvar Dial_templateObject, Dial_templateObject2, Dial_templateObject3, Dial_templateObject4, Dial_templateObject5;\n\nfunction Dial_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Dial_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Dial_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction Dial_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\n\n\n\n\n\n\nvar Dial_DIAL_TYPES = DIAL_TYPES;\nvar DialLayout = styled_components_browser_esm.div(Dial_templateObject || (Dial_templateObject = Dial_taggedTemplateLiteral([\"\\n  display: inline-flex;\\n  flex-direction: column;\\n\\n  margin: 5px;\\n\"])));\nvar DialPanel = styled_components_browser_esm.div(Dial_templateObject2 || (Dial_templateObject2 = Dial_taggedTemplateLiteral([\"\\n  border: 1px solid \", \";\\n\\n  display: flex;\\n  justify-content: center;\\n\\n  background-color: \", \";\\n  color: #fff;\\n\\n  box-sizing: border-box;\\n  padding: 0.5rem;\\n  width: \", \";\\n\"])), dark, darkBlue, dialDimensions);\nvar DialHeader = styled_components_browser_esm(DialPanel)(Dial_templateObject3 || (Dial_templateObject3 = Dial_taggedTemplateLiteral([\"\\n  border-top-left-radius: \", \";\\n  border-top-right-radius: \", \";\\n\"])), borderRadius, borderRadius);\nvar DialContainer = styled_components_browser_esm.div(Dial_templateObject4 || (Dial_templateObject4 = Dial_taggedTemplateLiteral([\"\\n  background-color: \", \";\\n  box-sizing: border-box;\\n\\n  border-left: 1px solid \", \";\\n  border-right: 1px solid \", \";\\n\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n\\n  width: \", \";\\n  height: \", \";\\n\"])), darkBlue, dark, dark, dialDimensions, dialDimensions);\nvar DialUnit = styled_components_browser_esm(DialPanel)(Dial_templateObject5 || (Dial_templateObject5 = Dial_taggedTemplateLiteral([\"\\n  border-bottom-left-radius: \", \";\\n  border-bottom-right-radius: \", \";\\n\"])), borderRadius, borderRadius);\nvar Dial = function Dial(_ref) {\n  var label = _ref.label,\n      value = _ref.value,\n      type = _ref.type,\n      unit = _ref.unit,\n      props = Dial_objectWithoutProperties(_ref, Dial_excluded);\n\n  return /*#__PURE__*/react.createElement(DialLayout, null, /*#__PURE__*/react.createElement(DialHeader, null, label), /*#__PURE__*/react.createElement(DialContainer, null, type === Dial_DIAL_TYPES.SCALAR && /*#__PURE__*/react.createElement(ScalarDial, {\n    value: value\n  }), type === Dial_DIAL_TYPES.COORDS && /*#__PURE__*/react.createElement(CoordsDial, {\n    coords: value\n  }), type === Dial_DIAL_TYPES.ANGLE && /*#__PURE__*/react.createElement(AngleDial, {\n    angle: value\n  }), type === Dial_DIAL_TYPES.VECTOR && /*#__PURE__*/react.createElement(VectorDial, {\n    vector: value\n  })), /*#__PURE__*/react.createElement(DialUnit, null, unit));\n};\nDial.propTypes = {\n  label: (prop_types_default()).string,\n  value: prop_types_default().oneOfType([(prop_types_default()).number]),\n  type: prop_types_default().oneOf([Dial_DIAL_TYPES.SCALAR]).isRequired,\n  unit: (prop_types_default()).string\n};\nDial.defaultProps = {\n  label: '-',\n  value: 0,\n  unit: '?'\n};\n;// CONCATENATED MODULE: ./src/components/ContentView.jsx\nvar ContentView_templateObject;\n\nfunction ContentView_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\n\n\n\n\n\nvar Wrapper = styled_components_browser_esm.div(ContentView_templateObject || (ContentView_templateObject = ContentView_taggedTemplateLiteral([\"\\n  background-color: #ddd;\\n  max-width: 800px;\\n\\n  display: flex;\\n  flex-wrap: wrap;\\n  justify-content: center;\\n\\n   @media only screen and (max-width: 800px) {\\n    width: 100vw;\\n   }\\n\"])));\nvar ContentView = function ContentView() {\n  var polygons = useSelector(getPolygonList);\n  var firstPolygon = polygons.get(0);\n  return /*#__PURE__*/react.createElement(Wrapper, null, firstPolygon && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Dial, {\n    label: \"Mass\",\n    value: firstPolygon.get('mass'),\n    type: DIAL_TYPES.SCALAR,\n    unit: \"kg\"\n  }), /*#__PURE__*/react.createElement(Dial, {\n    label: \"Position\",\n    value: firstPolygon.get('position'),\n    type: DIAL_TYPES.COORDS,\n    unit: \"px\"\n  }), /*#__PURE__*/react.createElement(Dial, {\n    label: \"Rotation\",\n    value: radiansToDegrees(firstPolygon.get('rotation')) % 360,\n    type: DIAL_TYPES.ANGLE,\n    unit: \"deg\"\n  }), /*#__PURE__*/react.createElement(Dial, {\n    label: \"Velocity\",\n    value: firstPolygon.get('velocity'),\n    type: DIAL_TYPES.VECTOR,\n    unit: \"px/s\"\n  })));\n};\n;// CONCATENATED MODULE: ./node_modules/immer/dist/immer.esm.mjs\nfunction n(n){for(var r=arguments.length,t=Array(r>1?r-1:0),e=1;e<r;e++)t[e-1]=arguments[e];if(false){ var i, o; }throw Error(\"[Immer] minified error nr: \"+n+(t.length?\" \"+t.map((function(n){return\"'\"+n+\"'\"})).join(\",\"):\"\")+\". Find the full error at: https://bit.ly/3cXEKWf\")}function immer_esm_r(n){return!!n&&!!n[immer_esm_Q]}function t(n){return!!n&&(function(n){if(!n||\"object\"!=typeof n)return!1;var r=Object.getPrototypeOf(n);if(null===r)return!0;var t=Object.hasOwnProperty.call(r,\"constructor\")&&r.constructor;return t===Object||\"function\"==typeof t&&Function.toString.call(t)===immer_esm_Z}(n)||Array.isArray(n)||!!n[immer_esm_L]||!!n.constructor[immer_esm_L]||immer_esm_s(n)||immer_esm_v(n))}function e(t){return immer_esm_r(t)||n(23,t),t[immer_esm_Q].t}function immer_esm_i(n,r,t){void 0===t&&(t=!1),0===o(n)?(t?Object.keys:nn)(n).forEach((function(e){t&&\"symbol\"==typeof e||r(e,n[e],n)})):n.forEach((function(t,e){return r(e,t,n)}))}function o(n){var r=n[immer_esm_Q];return r?r.i>3?r.i-4:r.i:Array.isArray(n)?1:immer_esm_s(n)?2:immer_esm_v(n)?3:0}function u(n,r){return 2===o(n)?n.has(r):Object.prototype.hasOwnProperty.call(n,r)}function a(n,r){return 2===o(n)?n.get(r):n[r]}function f(n,r,t){var e=o(n);2===e?n.set(r,t):3===e?(n.delete(r),n.add(t)):n[r]=t}function immer_esm_c(n,r){return n===r?0!==n||1/n==1/r:n!=n&&r!=r}function immer_esm_s(n){return immer_esm_X&&n instanceof Map}function immer_esm_v(n){return immer_esm_q&&n instanceof Set}function p(n){return n.o||n.t}function l(n){if(Array.isArray(n))return Array.prototype.slice.call(n);var r=rn(n);delete r[immer_esm_Q];for(var t=nn(r),e=0;e<t.length;e++){var i=t[e],o=r[i];!1===o.writable&&(o.writable=!0,o.configurable=!0),(o.get||o.set)&&(r[i]={configurable:!0,writable:!0,enumerable:o.enumerable,value:n[i]})}return Object.create(Object.getPrototypeOf(n),r)}function immer_esm_d(n,e){return void 0===e&&(e=!1),immer_esm_y(n)||immer_esm_r(n)||!t(n)?n:(o(n)>1&&(n.set=n.add=n.clear=n.delete=h),Object.freeze(n),e&&immer_esm_i(n,(function(n,r){return immer_esm_d(r,!0)}),!0),n)}function h(){n(2)}function immer_esm_y(n){return null==n||\"object\"!=typeof n||Object.isFrozen(n)}function immer_esm_b(r){var t=tn[r];return t||n(18,r),t}function m(n,r){tn[n]||(tn[n]=r)}function immer_esm_(){return true||0,immer_esm_U}function immer_esm_j(n,r){r&&(immer_esm_b(\"Patches\"),n.u=[],n.s=[],n.v=r)}function immer_esm_O(n){immer_esm_g(n),n.p.forEach(immer_esm_S),n.p=null}function immer_esm_g(n){n===immer_esm_U&&(immer_esm_U=n.l)}function immer_esm_w(n){return immer_esm_U={p:[],l:immer_esm_U,h:n,m:!0,_:0}}function immer_esm_S(n){var r=n[immer_esm_Q];0===r.i||1===r.i?r.j():r.O=!0}function immer_esm_P(r,e){e._=e.p.length;var i=e.p[0],o=void 0!==r&&r!==i;return e.h.g||immer_esm_b(\"ES5\").S(e,r,o),o?(i[immer_esm_Q].P&&(immer_esm_O(e),n(4)),t(r)&&(r=immer_esm_M(e,r),e.l||immer_esm_x(e,r)),e.u&&immer_esm_b(\"Patches\").M(i[immer_esm_Q].t,r,e.u,e.s)):r=immer_esm_M(e,i,[]),immer_esm_O(e),e.u&&e.v(e.u,e.s),r!==immer_esm_H?r:void 0}function immer_esm_M(n,r,t){if(immer_esm_y(r))return r;var e=r[immer_esm_Q];if(!e)return immer_esm_i(r,(function(i,o){return immer_esm_A(n,e,r,i,o,t)}),!0),r;if(e.A!==n)return r;if(!e.P)return immer_esm_x(n,e.t,!0),e.t;if(!e.I){e.I=!0,e.A._--;var o=4===e.i||5===e.i?e.o=l(e.k):e.o;immer_esm_i(3===e.i?new Set(o):o,(function(r,i){return immer_esm_A(n,e,o,r,i,t)})),immer_esm_x(n,o,!1),t&&n.u&&immer_esm_b(\"Patches\").R(e,t,n.u,n.s)}return e.o}function immer_esm_A(e,i,o,a,c,s){if( false&&0,immer_esm_r(c)){var v=immer_esm_M(e,c,s&&i&&3!==i.i&&!u(i.D,a)?s.concat(a):void 0);if(f(o,a,v),!immer_esm_r(v))return;e.m=!1}if(t(c)&&!immer_esm_y(c)){if(!e.h.F&&e._<1)return;immer_esm_M(e,c),i&&i.A.l||immer_esm_x(e,c)}}function immer_esm_x(n,r,t){void 0===t&&(t=!1),n.h.F&&n.m&&immer_esm_d(r,t)}function immer_esm_z(n,r){var t=n[immer_esm_Q];return(t?p(t):n)[r]}function immer_esm_I(n,r){if(r in n)for(var t=Object.getPrototypeOf(n);t;){var e=Object.getOwnPropertyDescriptor(t,r);if(e)return e;t=Object.getPrototypeOf(t)}}function immer_esm_k(n){n.P||(n.P=!0,n.l&&immer_esm_k(n.l))}function immer_esm_E(n){n.o||(n.o=l(n.t))}function immer_esm_R(n,r,t){var e=immer_esm_s(r)?immer_esm_b(\"MapSet\").N(r,t):immer_esm_v(r)?immer_esm_b(\"MapSet\").T(r,t):n.g?function(n,r){var t=Array.isArray(n),e={i:t?1:0,A:r?r.A:immer_esm_(),P:!1,I:!1,D:{},l:r,t:n,k:null,o:null,j:null,C:!1},i=e,o=en;t&&(i=[e],o=on);var u=Proxy.revocable(i,o),a=u.revoke,f=u.proxy;return e.k=f,e.j=a,f}(r,t):immer_esm_b(\"ES5\").J(r,t);return(t?t.A:immer_esm_()).p.push(e),e}function immer_esm_D(e){return immer_esm_r(e)||n(22,e),function n(r){if(!t(r))return r;var e,u=r[immer_esm_Q],c=o(r);if(u){if(!u.P&&(u.i<4||!immer_esm_b(\"ES5\").K(u)))return u.t;u.I=!0,e=immer_esm_F(r,c),u.I=!1}else e=immer_esm_F(r,c);return immer_esm_i(e,(function(r,t){u&&a(u.t,r)===t||f(e,r,n(t))})),3===c?new Set(e):e}(e)}function immer_esm_F(n,r){switch(r){case 2:return new Map(n);case 3:return Array.from(n)}return l(n)}function immer_esm_N(){function t(n,r){var t=s[n];return t?t.enumerable=r:s[n]=t={configurable:!0,enumerable:r,get:function(){var r=this[immer_esm_Q];return false&&0,en.get(r,n)},set:function(r){var t=this[immer_esm_Q]; false&&0,en.set(t,n,r)}},t}function e(n){for(var r=n.length-1;r>=0;r--){var t=n[r][immer_esm_Q];if(!t.P)switch(t.i){case 5:a(t)&&immer_esm_k(t);break;case 4:o(t)&&immer_esm_k(t)}}}function o(n){for(var r=n.t,t=n.k,e=nn(t),i=e.length-1;i>=0;i--){var o=e[i];if(o!==immer_esm_Q){var a=r[o];if(void 0===a&&!u(r,o))return!0;var f=t[o],s=f&&f[immer_esm_Q];if(s?s.t!==a:!immer_esm_c(f,a))return!0}}var v=!!r[immer_esm_Q];return e.length!==nn(r).length+(v?0:1)}function a(n){var r=n.k;if(r.length!==n.t.length)return!0;var t=Object.getOwnPropertyDescriptor(r,r.length-1);if(t&&!t.get)return!0;for(var e=0;e<r.length;e++)if(!r.hasOwnProperty(e))return!0;return!1}function f(r){r.O&&n(3,JSON.stringify(p(r)))}var s={};m(\"ES5\",{J:function(n,r){var e=Array.isArray(n),i=function(n,r){if(n){for(var e=Array(r.length),i=0;i<r.length;i++)Object.defineProperty(e,\"\"+i,t(i,!0));return e}var o=rn(r);delete o[immer_esm_Q];for(var u=nn(o),a=0;a<u.length;a++){var f=u[a];o[f]=t(f,n||!!o[f].enumerable)}return Object.create(Object.getPrototypeOf(r),o)}(e,n),o={i:e?5:4,A:r?r.A:immer_esm_(),P:!1,I:!1,D:{},l:r,t:n,k:i,o:null,O:!1,C:!1};return Object.defineProperty(i,immer_esm_Q,{value:o,writable:!0}),i},S:function(n,t,o){o?immer_esm_r(t)&&t[immer_esm_Q].A===n&&e(n.p):(n.u&&function n(r){if(r&&\"object\"==typeof r){var t=r[immer_esm_Q];if(t){var e=t.t,o=t.k,f=t.D,c=t.i;if(4===c)immer_esm_i(o,(function(r){r!==immer_esm_Q&&(void 0!==e[r]||u(e,r)?f[r]||n(o[r]):(f[r]=!0,immer_esm_k(t)))})),immer_esm_i(e,(function(n){void 0!==o[n]||u(o,n)||(f[n]=!1,immer_esm_k(t))}));else if(5===c){if(a(t)&&(immer_esm_k(t),f.length=!0),o.length<e.length)for(var s=o.length;s<e.length;s++)f[s]=!1;else for(var v=e.length;v<o.length;v++)f[v]=!0;for(var p=Math.min(o.length,e.length),l=0;l<p;l++)o.hasOwnProperty(l)||(f[l]=!0),void 0===f[l]&&n(o[l])}}}}(n.p[0]),e(n.p))},K:function(n){return 4===n.i?o(n):a(n)}})}function immer_esm_T(){function e(n){if(!t(n))return n;if(Array.isArray(n))return n.map(e);if(immer_esm_s(n))return new Map(Array.from(n.entries()).map((function(n){return[n[0],e(n[1])]})));if(immer_esm_v(n))return new Set(Array.from(n).map(e));var r=Object.create(Object.getPrototypeOf(n));for(var i in n)r[i]=e(n[i]);return u(n,immer_esm_L)&&(r[immer_esm_L]=n[immer_esm_L]),r}function f(n){return immer_esm_r(n)?e(n):n}var c=\"add\";m(\"Patches\",{$:function(r,t){return t.forEach((function(t){for(var i=t.path,u=t.op,f=r,s=0;s<i.length-1;s++){var v=o(f),p=\"\"+i[s];0!==v&&1!==v||\"__proto__\"!==p&&\"constructor\"!==p||n(24),\"function\"==typeof f&&\"prototype\"===p&&n(24),\"object\"!=typeof(f=a(f,p))&&n(15,i.join(\"/\"))}var l=o(f),d=e(t.value),h=i[i.length-1];switch(u){case\"replace\":switch(l){case 2:return f.set(h,d);case 3:n(16);default:return f[h]=d}case c:switch(l){case 1:return\"-\"===h?f.push(d):f.splice(h,0,d);case 2:return f.set(h,d);case 3:return f.add(d);default:return f[h]=d}case\"remove\":switch(l){case 1:return f.splice(h,1);case 2:return f.delete(h);case 3:return f.delete(t.value);default:return delete f[h]}default:n(17,u)}})),r},R:function(n,r,t,e){switch(n.i){case 0:case 4:case 2:return function(n,r,t,e){var o=n.t,s=n.o;immer_esm_i(n.D,(function(n,i){var v=a(o,n),p=a(s,n),l=i?u(o,n)?\"replace\":c:\"remove\";if(v!==p||\"replace\"!==l){var d=r.concat(n);t.push(\"remove\"===l?{op:l,path:d}:{op:l,path:d,value:p}),e.push(l===c?{op:\"remove\",path:d}:\"remove\"===l?{op:c,path:d,value:f(v)}:{op:\"replace\",path:d,value:f(v)})}}))}(n,r,t,e);case 5:case 1:return function(n,r,t,e){var i=n.t,o=n.D,u=n.o;if(u.length<i.length){var a=[u,i];i=a[0],u=a[1];var s=[e,t];t=s[0],e=s[1]}for(var v=0;v<i.length;v++)if(o[v]&&u[v]!==i[v]){var p=r.concat([v]);t.push({op:\"replace\",path:p,value:f(u[v])}),e.push({op:\"replace\",path:p,value:f(i[v])})}for(var l=i.length;l<u.length;l++){var d=r.concat([l]);t.push({op:c,path:d,value:f(u[l])})}i.length<u.length&&e.push({op:\"replace\",path:r.concat([\"length\"]),value:i.length})}(n,r,t,e);case 3:return function(n,r,t,e){var i=n.t,o=n.o,u=0;i.forEach((function(n){if(!o.has(n)){var i=r.concat([u]);t.push({op:\"remove\",path:i,value:n}),e.unshift({op:c,path:i,value:n})}u++})),u=0,o.forEach((function(n){if(!i.has(n)){var o=r.concat([u]);t.push({op:c,path:o,value:n}),e.unshift({op:\"remove\",path:o,value:n})}u++}))}(n,r,t,e)}},M:function(n,r,t,e){t.push({op:\"replace\",path:[],value:r===immer_esm_H?void 0:r}),e.push({op:\"replace\",path:[],value:n})}})}function immer_esm_C(){function r(n,r){function t(){this.constructor=n}a(n,r),n.prototype=(t.prototype=r.prototype,new t)}function e(n){n.o||(n.D=new Map,n.o=new Map(n.t))}function o(n){n.o||(n.o=new Set,n.t.forEach((function(r){if(t(r)){var e=immer_esm_R(n.A.h,r,n);n.p.set(r,e),n.o.add(e)}else n.o.add(r)})))}function u(r){r.O&&n(3,JSON.stringify(p(r)))}var a=function(n,r){return(a=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,r){n.__proto__=r}||function(n,r){for(var t in r)r.hasOwnProperty(t)&&(n[t]=r[t])})(n,r)},f=function(){function n(n,r){return this[immer_esm_Q]={i:2,l:r,A:r?r.A:immer_esm_(),P:!1,I:!1,o:void 0,D:void 0,t:n,k:this,C:!1,O:!1},this}r(n,Map);var o=n.prototype;return Object.defineProperty(o,\"size\",{get:function(){return p(this[immer_esm_Q]).size}}),o.has=function(n){return p(this[immer_esm_Q]).has(n)},o.set=function(n,r){var t=this[immer_esm_Q];return u(t),p(t).has(n)&&p(t).get(n)===r||(e(t),immer_esm_k(t),t.D.set(n,!0),t.o.set(n,r),t.D.set(n,!0)),this},o.delete=function(n){if(!this.has(n))return!1;var r=this[immer_esm_Q];return u(r),e(r),immer_esm_k(r),r.t.has(n)?r.D.set(n,!1):r.D.delete(n),r.o.delete(n),!0},o.clear=function(){var n=this[immer_esm_Q];u(n),p(n).size&&(e(n),immer_esm_k(n),n.D=new Map,immer_esm_i(n.t,(function(r){n.D.set(r,!1)})),n.o.clear())},o.forEach=function(n,r){var t=this;p(this[immer_esm_Q]).forEach((function(e,i){n.call(r,t.get(i),i,t)}))},o.get=function(n){var r=this[immer_esm_Q];u(r);var i=p(r).get(n);if(r.I||!t(i))return i;if(i!==r.t.get(n))return i;var o=immer_esm_R(r.A.h,i,r);return e(r),r.o.set(n,o),o},o.keys=function(){return p(this[immer_esm_Q]).keys()},o.values=function(){var n,r=this,t=this.keys();return(n={})[immer_esm_V]=function(){return r.values()},n.next=function(){var n=t.next();return n.done?n:{done:!1,value:r.get(n.value)}},n},o.entries=function(){var n,r=this,t=this.keys();return(n={})[immer_esm_V]=function(){return r.entries()},n.next=function(){var n=t.next();if(n.done)return n;var e=r.get(n.value);return{done:!1,value:[n.value,e]}},n},o[immer_esm_V]=function(){return this.entries()},n}(),c=function(){function n(n,r){return this[immer_esm_Q]={i:3,l:r,A:r?r.A:immer_esm_(),P:!1,I:!1,o:void 0,t:n,k:this,p:new Map,O:!1,C:!1},this}r(n,Set);var t=n.prototype;return Object.defineProperty(t,\"size\",{get:function(){return p(this[immer_esm_Q]).size}}),t.has=function(n){var r=this[immer_esm_Q];return u(r),r.o?!!r.o.has(n)||!(!r.p.has(n)||!r.o.has(r.p.get(n))):r.t.has(n)},t.add=function(n){var r=this[immer_esm_Q];return u(r),this.has(n)||(o(r),immer_esm_k(r),r.o.add(n)),this},t.delete=function(n){if(!this.has(n))return!1;var r=this[immer_esm_Q];return u(r),o(r),immer_esm_k(r),r.o.delete(n)||!!r.p.has(n)&&r.o.delete(r.p.get(n))},t.clear=function(){var n=this[immer_esm_Q];u(n),p(n).size&&(o(n),immer_esm_k(n),n.o.clear())},t.values=function(){var n=this[immer_esm_Q];return u(n),o(n),n.o.values()},t.entries=function(){var n=this[immer_esm_Q];return u(n),o(n),n.o.entries()},t.keys=function(){return this.values()},t[immer_esm_V]=function(){return this.values()},t.forEach=function(n,r){for(var t=this.values(),e=t.next();!e.done;)n.call(r,e.value,e.value,this),e=t.next()},n}();m(\"MapSet\",{N:function(n,r){return new f(n,r)},T:function(n,r){return new c(n,r)}})}function immer_esm_J(){immer_esm_N(),immer_esm_C(),immer_esm_T()}function immer_esm_K(n){return n}function immer_esm_$(n){return n}var immer_esm_G,immer_esm_U,immer_esm_W=\"undefined\"!=typeof Symbol&&\"symbol\"==typeof Symbol(\"x\"),immer_esm_X=\"undefined\"!=typeof Map,immer_esm_q=\"undefined\"!=typeof Set,immer_esm_B=\"undefined\"!=typeof Proxy&&void 0!==Proxy.revocable&&\"undefined\"!=typeof Reflect,immer_esm_H=immer_esm_W?Symbol.for(\"immer-nothing\"):((immer_esm_G={})[\"immer-nothing\"]=!0,immer_esm_G),immer_esm_L=immer_esm_W?Symbol.for(\"immer-draftable\"):\"__$immer_draftable\",immer_esm_Q=immer_esm_W?Symbol.for(\"immer-state\"):\"__$immer_state\",immer_esm_V=\"undefined\"!=typeof Symbol&&Symbol.iterator||\"@@iterator\",immer_esm_Y={0:\"Illegal state\",1:\"Immer drafts cannot have computed properties\",2:\"This object has been frozen and should not be mutated\",3:function(n){return\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \"+n},4:\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",5:\"Immer forbids circular references\",6:\"The first or second argument to `produce` must be a function\",7:\"The third argument to `produce` must be a function or undefined\",8:\"First argument to `createDraft` must be a plain object, an array, or an immerable object\",9:\"First argument to `finishDraft` must be a draft returned by `createDraft`\",10:\"The given draft is already finalized\",11:\"Object.defineProperty() cannot be used on an Immer draft\",12:\"Object.setPrototypeOf() cannot be used on an Immer draft\",13:\"Immer only supports deleting array indices\",14:\"Immer only supports setting array indices and the 'length' property\",15:function(n){return\"Cannot apply patch, path doesn't resolve: \"+n},16:'Sets cannot have \"replace\" patches.',17:function(n){return\"Unsupported patch operation: \"+n},18:function(n){return\"The plugin for '\"+n+\"' has not been loaded into Immer. To enable the plugin, import and call `enable\"+n+\"()` when initializing your application.\"},20:\"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",21:function(n){return\"produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '\"+n+\"'\"},22:function(n){return\"'current' expects a draft, got: \"+n},23:function(n){return\"'original' expects a draft, got: \"+n},24:\"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"},immer_esm_Z=\"\"+Object.prototype.constructor,nn=\"undefined\"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(n){return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n))}:Object.getOwnPropertyNames,rn=Object.getOwnPropertyDescriptors||function(n){var r={};return nn(n).forEach((function(t){r[t]=Object.getOwnPropertyDescriptor(n,t)})),r},tn={},en={get:function(n,r){if(r===immer_esm_Q)return n;var e=p(n);if(!u(e,r))return function(n,r,t){var e,i=immer_esm_I(r,t);return i?\"value\"in i?i.value:null===(e=i.get)||void 0===e?void 0:e.call(n.k):void 0}(n,e,r);var i=e[r];return n.I||!t(i)?i:i===immer_esm_z(n.t,r)?(immer_esm_E(n),n.o[r]=immer_esm_R(n.A.h,i,n)):i},has:function(n,r){return r in p(n)},ownKeys:function(n){return Reflect.ownKeys(p(n))},set:function(n,r,t){var e=immer_esm_I(p(n),r);if(null==e?void 0:e.set)return e.set.call(n.k,t),!0;if(!n.P){var i=immer_esm_z(p(n),r),o=null==i?void 0:i[immer_esm_Q];if(o&&o.t===t)return n.o[r]=t,n.D[r]=!1,!0;if(immer_esm_c(t,i)&&(void 0!==t||u(n.t,r)))return!0;immer_esm_E(n),immer_esm_k(n)}return n.o[r]===t&&\"number\"!=typeof t&&(void 0!==t||r in n.o)||(n.o[r]=t,n.D[r]=!0,!0)},deleteProperty:function(n,r){return void 0!==immer_esm_z(n.t,r)||r in n.t?(n.D[r]=!1,immer_esm_E(n),immer_esm_k(n)):delete n.D[r],n.o&&delete n.o[r],!0},getOwnPropertyDescriptor:function(n,r){var t=p(n),e=Reflect.getOwnPropertyDescriptor(t,r);return e?{writable:!0,configurable:1!==n.i||\"length\"!==r,enumerable:e.enumerable,value:t[r]}:e},defineProperty:function(){n(11)},getPrototypeOf:function(n){return Object.getPrototypeOf(n.t)},setPrototypeOf:function(){n(12)}},on={};immer_esm_i(en,(function(n,r){on[n]=function(){return arguments[0]=arguments[0][0],r.apply(this,arguments)}})),on.deleteProperty=function(r,t){return false&&0,on.set.call(this,r,t,void 0)},on.set=function(r,t,e){return false&&0,en.set.call(this,r[0],t,e,r[0])};var un=function(){function e(r){var e=this;this.g=immer_esm_B,this.F=!0,this.produce=function(r,i,o){if(\"function\"==typeof r&&\"function\"!=typeof i){var u=i;i=r;var a=e;return function(n){var r=this;void 0===n&&(n=u);for(var t=arguments.length,e=Array(t>1?t-1:0),o=1;o<t;o++)e[o-1]=arguments[o];return a.produce(n,(function(n){var t;return(t=i).call.apply(t,[r,n].concat(e))}))}}var f;if(\"function\"!=typeof i&&n(6),void 0!==o&&\"function\"!=typeof o&&n(7),t(r)){var c=immer_esm_w(e),s=immer_esm_R(e,r,void 0),v=!0;try{f=i(s),v=!1}finally{v?immer_esm_O(c):immer_esm_g(c)}return\"undefined\"!=typeof Promise&&f instanceof Promise?f.then((function(n){return immer_esm_j(c,o),immer_esm_P(n,c)}),(function(n){throw immer_esm_O(c),n})):(immer_esm_j(c,o),immer_esm_P(f,c))}if(!r||\"object\"!=typeof r){if(void 0===(f=i(r))&&(f=r),f===immer_esm_H&&(f=void 0),e.F&&immer_esm_d(f,!0),o){var p=[],l=[];immer_esm_b(\"Patches\").M(r,f,p,l),o(p,l)}return f}n(21,r)},this.produceWithPatches=function(n,r){if(\"function\"==typeof n)return function(r){for(var t=arguments.length,i=Array(t>1?t-1:0),o=1;o<t;o++)i[o-1]=arguments[o];return e.produceWithPatches(r,(function(r){return n.apply(void 0,[r].concat(i))}))};var t,i,o=e.produce(n,r,(function(n,r){t=n,i=r}));return\"undefined\"!=typeof Promise&&o instanceof Promise?o.then((function(n){return[n,t,i]})):[o,t,i]},\"boolean\"==typeof(null==r?void 0:r.useProxies)&&this.setUseProxies(r.useProxies),\"boolean\"==typeof(null==r?void 0:r.autoFreeze)&&this.setAutoFreeze(r.autoFreeze)}var i=e.prototype;return i.createDraft=function(e){t(e)||n(8),immer_esm_r(e)&&(e=immer_esm_D(e));var i=immer_esm_w(this),o=immer_esm_R(this,e,void 0);return o[immer_esm_Q].C=!0,immer_esm_g(i),o},i.finishDraft=function(r,t){var e=r&&r[immer_esm_Q]; false&&(0);var i=e.A;return immer_esm_j(i,t),immer_esm_P(void 0,i)},i.setAutoFreeze=function(n){this.F=n},i.setUseProxies=function(r){r&&!immer_esm_B&&n(20),this.g=r},i.applyPatches=function(n,t){var e;for(e=t.length-1;e>=0;e--){var i=t[e];if(0===i.path.length&&\"replace\"===i.op){n=i.value;break}}e>-1&&(t=t.slice(e+1));var o=immer_esm_b(\"Patches\").$;return immer_esm_r(n)?o(n,t):this.produce(n,(function(n){return o(n,t)}))},e}(),an=new un,fn=an.produce,cn=an.produceWithPatches.bind(an),sn=an.setAutoFreeze.bind(an),vn=an.setUseProxies.bind(an),pn=an.applyPatches.bind(an),ln=an.createDraft.bind(an),dn=an.finishDraft.bind(an);/* harmony default export */ const immer_esm = ((/* unused pure expression or super */ null && (fn)));\n//# sourceMappingURL=immer.esm.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nfunction defineProperty_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js\n\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      defineProperty_defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n;// CONCATENATED MODULE: ./node_modules/redux/es/redux.js\n\n\n/**\n * Adapted from React: https://github.com/facebook/react/blob/master/packages/shared/formatProdErrorMessage.js\n *\n * Do not require this module directly! Use normal throw error calls. These messages will be replaced with error codes\n * during build.\n * @param {number} code\n */\nfunction formatProdErrorMessage(code) {\n  return \"Minified Redux error #\" + code + \"; visit https://redux.js.org/Errors?code=\" + code + \" for the full message or \" + 'use the non-minified dev environment for full errors. ';\n}\n\n// Inlined version of the `symbol-observable` polyfill\nvar $$observable = (function () {\n  return typeof Symbol === 'function' && Symbol.observable || '@@observable';\n})();\n\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\nvar randomString = function randomString() {\n  return Math.random().toString(36).substring(7).split('').join('.');\n};\n\nvar ActionTypes = {\n  INIT: \"@@redux/INIT\" + randomString(),\n  REPLACE: \"@@redux/REPLACE\" + randomString(),\n  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\n    return \"@@redux/PROBE_UNKNOWN_ACTION\" + randomString();\n  }\n};\n\n/**\n * @param {any} obj The object to inspect.\n * @returns {boolean} True if the argument appears to be a plain object.\n */\nfunction redux_isPlainObject(obj) {\n  if (typeof obj !== 'object' || obj === null) return false;\n  var proto = obj;\n\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(obj) === proto;\n}\n\n// Inlined / shortened version of `kindOf` from https://github.com/jonschlinkert/kind-of\nfunction miniKindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n  var type = typeof val;\n\n  switch (type) {\n    case 'boolean':\n    case 'string':\n    case 'number':\n    case 'symbol':\n    case 'function':\n      {\n        return type;\n      }\n  }\n\n  if (Array.isArray(val)) return 'array';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  var constructorName = ctorName(val);\n\n  switch (constructorName) {\n    case 'Symbol':\n    case 'Promise':\n    case 'WeakMap':\n    case 'WeakSet':\n    case 'Map':\n    case 'Set':\n      return constructorName;\n  } // other\n\n\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n}\n\nfunction ctorName(val) {\n  return typeof val.constructor === 'function' ? val.constructor.name : null;\n}\n\nfunction isError(val) {\n  return val instanceof Error || typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number';\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function' && typeof val.getDate === 'function' && typeof val.setDate === 'function';\n}\n\nfunction kindOf(val) {\n  var typeOfVal = typeof val;\n\n  if (false) {}\n\n  return typeOfVal;\n}\n\n/**\n * @deprecated\n *\n * **We recommend using the `configureStore` method\n * of the `@reduxjs/toolkit` package**, which replaces `createStore`.\n *\n * Redux Toolkit is our recommended approach for writing Redux logic today,\n * including store setup, reducers, data fetching, and more.\n *\n * **For more details, please read this Redux docs page:**\n * **https://redux.js.org/introduction/why-rtk-is-redux-today**\n *\n * `configureStore` from Redux Toolkit is an improved version of `createStore` that\n * simplifies setup and helps avoid common bugs.\n *\n * You should not be using the `redux` core package by itself today, except for learning purposes.\n * The `createStore` method from the core `redux` package will not be removed, but we encourage\n * all users to migrate to using Redux Toolkit for all Redux code.\n *\n * If you want to use `createStore` without this visual deprecation warning, use\n * the `legacy_createStore` import instead:\n *\n * `import { legacy_createStore as createStore} from 'redux'`\n *\n */\n\nfunction createStore(reducer, preloadedState, enhancer) {\n  var _ref2;\n\n  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {\n    throw new Error( true ? formatProdErrorMessage(0) : 0);\n  }\n\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    enhancer = preloadedState;\n    preloadedState = undefined;\n  }\n\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error( true ? formatProdErrorMessage(1) : 0);\n    }\n\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n\n  if (typeof reducer !== 'function') {\n    throw new Error( true ? formatProdErrorMessage(2) : 0);\n  }\n\n  var currentReducer = reducer;\n  var currentState = preloadedState;\n  var currentListeners = [];\n  var nextListeners = currentListeners;\n  var isDispatching = false;\n  /**\n   * This makes a shallow copy of currentListeners so we can use\n   * nextListeners as a temporary list while dispatching.\n   *\n   * This prevents any bugs around consumers calling\n   * subscribe/unsubscribe in the middle of a dispatch.\n   */\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n  /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */\n\n\n  function getState() {\n    if (isDispatching) {\n      throw new Error( true ? formatProdErrorMessage(3) : 0);\n    }\n\n    return currentState;\n  }\n  /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */\n\n\n  function subscribe(listener) {\n    if (typeof listener !== 'function') {\n      throw new Error( true ? formatProdErrorMessage(4) : 0);\n    }\n\n    if (isDispatching) {\n      throw new Error( true ? formatProdErrorMessage(5) : 0);\n    }\n\n    var isSubscribed = true;\n    ensureCanMutateNextListeners();\n    nextListeners.push(listener);\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n\n      if (isDispatching) {\n        throw new Error( true ? formatProdErrorMessage(6) : 0);\n      }\n\n      isSubscribed = false;\n      ensureCanMutateNextListeners();\n      var index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n      currentListeners = null;\n    };\n  }\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing “what changed”. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n\n\n  function dispatch(action) {\n    if (!redux_isPlainObject(action)) {\n      throw new Error( true ? formatProdErrorMessage(7) : 0);\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error( true ? formatProdErrorMessage(8) : 0);\n    }\n\n    if (isDispatching) {\n      throw new Error( true ? formatProdErrorMessage(9) : 0);\n    }\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n\n    var listeners = currentListeners = nextListeners;\n\n    for (var i = 0; i < listeners.length; i++) {\n      var listener = listeners[i];\n      listener();\n    }\n\n    return action;\n  }\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */\n\n\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== 'function') {\n      throw new Error( true ? formatProdErrorMessage(10) : 0);\n    }\n\n    currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.\n    // Any reducers that existed in both the new and old rootReducer\n    // will receive the previous state. This effectively populates\n    // the new state tree with any relevant data from the old one.\n\n    dispatch({\n      type: ActionTypes.REPLACE\n    });\n  }\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */\n\n\n  function observable() {\n    var _ref;\n\n    var outerSubscribe = subscribe;\n    return _ref = {\n      /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe: function subscribe(observer) {\n        if (typeof observer !== 'object' || observer === null) {\n          throw new Error( true ? formatProdErrorMessage(11) : 0);\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = outerSubscribe(observeState);\n        return {\n          unsubscribe: unsubscribe\n        };\n      }\n    }, _ref[$$observable] = function () {\n      return this;\n    }, _ref;\n  } // When a store is created, an \"INIT\" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n\n\n  dispatch({\n    type: ActionTypes.INIT\n  });\n  return _ref2 = {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  }, _ref2[$$observable] = observable, _ref2;\n}\n/**\n * Creates a Redux store that holds the state tree.\n *\n * **We recommend using `configureStore` from the\n * `@reduxjs/toolkit` package**, which replaces `createStore`:\n * **https://redux.js.org/introduction/why-rtk-is-redux-today**\n *\n * The only way to change the data in the store is to call `dispatch()` on it.\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using `combineReducers`.\n *\n * @param {Function} reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * @param {any} [preloadedState] The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use `combineReducers` to produce the root reducer function, this must be\n * an object with the same shape as `combineReducers` keys.\n *\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is `applyMiddleware()`.\n *\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n */\n\nvar legacy_createStore = (/* unused pure expression or super */ null && (createStore));\n\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */\nfunction warning(message) {\n  /* eslint-disable no-console */\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\n    console.error(message);\n  }\n  /* eslint-enable no-console */\n\n\n  try {\n    // This error was thrown as a convenience so that if you enable\n    // \"break on all exceptions\" in your console,\n    // it would pause the execution at this line.\n    throw new Error(message);\n  } catch (e) {} // eslint-disable-line no-empty\n\n}\n\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n  var reducerKeys = Object.keys(reducers);\n  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';\n\n  if (reducerKeys.length === 0) {\n    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\n  }\n\n  if (!redux_isPlainObject(inputState)) {\n    return \"The \" + argumentName + \" has unexpected type of \\\"\" + kindOf(inputState) + \"\\\". Expected argument to be an object with the following \" + (\"keys: \\\"\" + reducerKeys.join('\", \"') + \"\\\"\");\n  }\n\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\n    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\n  });\n  unexpectedKeys.forEach(function (key) {\n    unexpectedKeyCache[key] = true;\n  });\n  if (action && action.type === ActionTypes.REPLACE) return;\n\n  if (unexpectedKeys.length > 0) {\n    return \"Unexpected \" + (unexpectedKeys.length > 1 ? 'keys' : 'key') + \" \" + (\"\\\"\" + unexpectedKeys.join('\", \"') + \"\\\" found in \" + argumentName + \". \") + \"Expected to find one of the known reducer keys instead: \" + (\"\\\"\" + reducerKeys.join('\", \"') + \"\\\". Unexpected keys will be ignored.\");\n  }\n}\n\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach(function (key) {\n    var reducer = reducers[key];\n    var initialState = reducer(undefined, {\n      type: ActionTypes.INIT\n    });\n\n    if (typeof initialState === 'undefined') {\n      throw new Error( true ? formatProdErrorMessage(12) : 0);\n    }\n\n    if (typeof reducer(undefined, {\n      type: ActionTypes.PROBE_UNKNOWN_ACTION()\n    }) === 'undefined') {\n      throw new Error( true ? formatProdErrorMessage(13) : 0);\n    }\n  });\n}\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */\n\n\nfunction combineReducers(reducers) {\n  var reducerKeys = Object.keys(reducers);\n  var finalReducers = {};\n\n  for (var i = 0; i < reducerKeys.length; i++) {\n    var key = reducerKeys[i];\n\n    if (false) {}\n\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n\n  var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same\n  // keys multiple times.\n\n  var unexpectedKeyCache;\n\n  if (false) {}\n\n  var shapeAssertionError;\n\n  try {\n    assertReducerShape(finalReducers);\n  } catch (e) {\n    shapeAssertionError = e;\n  }\n\n  return function combination(state, action) {\n    if (state === void 0) {\n      state = {};\n    }\n\n    if (shapeAssertionError) {\n      throw shapeAssertionError;\n    }\n\n    if (false) { var warningMessage; }\n\n    var hasChanged = false;\n    var nextState = {};\n\n    for (var _i = 0; _i < finalReducerKeys.length; _i++) {\n      var _key = finalReducerKeys[_i];\n      var reducer = finalReducers[_key];\n      var previousStateForKey = state[_key];\n      var nextStateForKey = reducer(previousStateForKey, action);\n\n      if (typeof nextStateForKey === 'undefined') {\n        var actionType = action && action.type;\n        throw new Error( true ? formatProdErrorMessage(14) : 0);\n      }\n\n      nextState[_key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n\n    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;\n    return hasChanged ? nextState : state;\n  };\n}\n\nfunction bindActionCreator(actionCreator, dispatch) {\n  return function () {\n    return dispatch(actionCreator.apply(this, arguments));\n  };\n}\n/**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass an action creator as the first argument,\n * and get a dispatch wrapped function in return.\n *\n * @param {Function|Object} actionCreators An object whose values are action\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\n * syntax. You may also pass a single function.\n *\n * @param {Function} dispatch The `dispatch` function available on your Redux\n * store.\n *\n * @returns {Function|Object} The object mimicking the original object, but with\n * every action creator wrapped into the `dispatch` call. If you passed a\n * function as `actionCreators`, the return value will also be a single\n * function.\n */\n\n\nfunction redux_bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch);\n  }\n\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\n    throw new Error( true ? formatProdErrorMessage(16) : 0);\n  }\n\n  var boundActionCreators = {};\n\n  for (var key in actionCreators) {\n    var actionCreator = actionCreators[key];\n\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n    }\n  }\n\n  return boundActionCreators;\n}\n\n/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for\n * the resulting composite function.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n * from right to left. For example, compose(f, g, h) is identical to doing\n * (...args) => f(g(h(...args))).\n */\nfunction compose() {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  if (funcs.length === 0) {\n    return function (arg) {\n      return arg;\n    };\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce(function (a, b) {\n    return function () {\n      return a(b.apply(void 0, arguments));\n    };\n  });\n}\n\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */\n\nfunction applyMiddleware() {\n  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {\n    middlewares[_key] = arguments[_key];\n  }\n\n  return function (createStore) {\n    return function () {\n      var store = createStore.apply(void 0, arguments);\n\n      var _dispatch = function dispatch() {\n        throw new Error( true ? formatProdErrorMessage(15) : 0);\n      };\n\n      var middlewareAPI = {\n        getState: store.getState,\n        dispatch: function dispatch() {\n          return _dispatch.apply(void 0, arguments);\n        }\n      };\n      var chain = middlewares.map(function (middleware) {\n        return middleware(middlewareAPI);\n      });\n      _dispatch = compose.apply(void 0, chain)(store.dispatch);\n      return _objectSpread2(_objectSpread2({}, store), {}, {\n        dispatch: _dispatch\n      });\n    };\n  };\n}\n\n/*\n * This is a dummy function to check if the function name has been altered by minification.\n * If the function has been minified and NODE_ENV !== 'production', warn the user.\n */\n\nfunction isCrushed() {}\n\nif (false) {}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/redux-thunk/es/index.js\n/** A function that accepts a potential \"extra argument\" value to be injected later,\r\n * and returns an instance of the thunk middleware that uses that value\r\n */\nfunction createThunkMiddleware(extraArgument) {\n  // Standard Redux middleware definition pattern:\n  // See: https://redux.js.org/tutorials/fundamentals/part-4-store#writing-custom-middleware\n  var middleware = function middleware(_ref) {\n    var dispatch = _ref.dispatch,\n        getState = _ref.getState;\n    return function (next) {\n      return function (action) {\n        // The thunk middleware looks for any functions that were passed to `store.dispatch`.\n        // If this \"action\" is really a function, call it and return the result.\n        if (typeof action === 'function') {\n          // Inject the store's `dispatch` and `getState` methods, as well as any \"extra arg\"\n          return action(dispatch, getState, extraArgument);\n        } // Otherwise, pass the action down the middleware chain as usual\n\n\n        return next(action);\n      };\n    };\n  };\n\n  return middleware;\n}\n\nvar thunk = createThunkMiddleware(); // Attach the factory function so users can create a customized version\n// with whatever \"extra arg\" they want to inject into their thunks\n\nthunk.withExtraArgument = createThunkMiddleware;\n/* harmony default export */ const es = (thunk);\n;// CONCATENATED MODULE: ./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nvar __spreadArray = (undefined && undefined.__spreadArray) || function (to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n};\r\nvar __defProp = Object.defineProperty;\r\nvar __defProps = Object.defineProperties;\r\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\r\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp = function (obj, key, value) { return key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value }) : obj[key] = value; };\r\nvar __spreadValues = function (a, b) {\r\n    for (var prop in b || (b = {}))\r\n        if (__hasOwnProp.call(b, prop))\r\n            __defNormalProp(a, prop, b[prop]);\r\n    if (__getOwnPropSymbols)\r\n        for (var _i = 0, _c = __getOwnPropSymbols(b); _i < _c.length; _i++) {\r\n            var prop = _c[_i];\r\n            if (__propIsEnum.call(b, prop))\r\n                __defNormalProp(a, prop, b[prop]);\r\n        }\r\n    return a;\r\n};\r\nvar __spreadProps = function (a, b) { return __defProps(a, __getOwnPropDescs(b)); };\r\nvar __async = function (__this, __arguments, generator) {\r\n    return new Promise(function (resolve, reject) {\r\n        var fulfilled = function (value) {\r\n            try {\r\n                step(generator.next(value));\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n            }\r\n        };\r\n        var rejected = function (value) {\r\n            try {\r\n                step(generator.throw(value));\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n            }\r\n        };\r\n        var step = function (x) { return x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected); };\r\n        step((generator = generator.apply(__this, __arguments)).next());\r\n    });\r\n};\r\n// src/index.ts\r\n\r\n\r\n\r\n\r\n// src/createDraftSafeSelector.ts\r\n\r\n\r\nvar createDraftSafeSelector = function () {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    var selector = createSelector.apply(void 0, args);\r\n    var wrappedSelector = function (value) {\r\n        var rest = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            rest[_i - 1] = arguments[_i];\r\n        }\r\n        return selector.apply(void 0, __spreadArray([isDraft(value) ? current(value) : value], rest));\r\n    };\r\n    return wrappedSelector;\r\n};\r\n// src/configureStore.ts\r\n\r\n// src/devtoolsExtension.ts\r\n\r\nvar composeWithDevTools = typeof window !== \"undefined\" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function () {\r\n    if (arguments.length === 0)\r\n        return void 0;\r\n    if (typeof arguments[0] === \"object\")\r\n        return compose;\r\n    return compose.apply(null, arguments);\r\n};\r\nvar devToolsEnhancer = typeof window !== \"undefined\" && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function () {\r\n    return function (noop2) {\r\n        return noop2;\r\n    };\r\n};\r\n// src/isPlainObject.ts\r\nfunction redux_toolkit_esm_isPlainObject(value) {\r\n    if (typeof value !== \"object\" || value === null)\r\n        return false;\r\n    var proto = Object.getPrototypeOf(value);\r\n    if (proto === null)\r\n        return true;\r\n    var baseProto = proto;\r\n    while (Object.getPrototypeOf(baseProto) !== null) {\r\n        baseProto = Object.getPrototypeOf(baseProto);\r\n    }\r\n    return proto === baseProto;\r\n}\r\n// src/getDefaultMiddleware.ts\r\n\r\n// src/utils.ts\r\nfunction getTimeMeasureUtils(maxDelay, fnName) {\r\n    var elapsed = 0;\r\n    return {\r\n        measureTime: function (fn) {\r\n            var started = Date.now();\r\n            try {\r\n                return fn();\r\n            }\r\n            finally {\r\n                var finished = Date.now();\r\n                elapsed += finished - started;\r\n            }\r\n        },\r\n        warnIfExceeded: function () {\r\n            if (elapsed > maxDelay) {\r\n                console.warn(fnName + \" took \" + elapsed + \"ms, which is more than the warning threshold of \" + maxDelay + \"ms. \\nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\\nIt is disabled in production builds, so you don't need to worry about that.\");\r\n            }\r\n        }\r\n    };\r\n}\r\nvar MiddlewareArray = /** @class */ (function (_super) {\r\n    __extends(MiddlewareArray, _super);\r\n    function MiddlewareArray() {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var _this = _super.apply(this, args) || this;\r\n        Object.setPrototypeOf(_this, MiddlewareArray.prototype);\r\n        return _this;\r\n    }\r\n    Object.defineProperty(MiddlewareArray, Symbol.species, {\r\n        get: function () {\r\n            return MiddlewareArray;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    MiddlewareArray.prototype.concat = function () {\r\n        var arr = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            arr[_i] = arguments[_i];\r\n        }\r\n        return _super.prototype.concat.apply(this, arr);\r\n    };\r\n    MiddlewareArray.prototype.prepend = function () {\r\n        var arr = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            arr[_i] = arguments[_i];\r\n        }\r\n        if (arr.length === 1 && Array.isArray(arr[0])) {\r\n            return new (MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([void 0], arr[0].concat(this))))();\r\n        }\r\n        return new (MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([void 0], arr.concat(this))))();\r\n    };\r\n    return MiddlewareArray;\r\n}(Array));\r\n// src/immutableStateInvariantMiddleware.ts\r\nvar isProduction = (/* unused pure expression or super */ null && (\"production\" === \"production\"));\r\nvar prefix = \"Invariant failed\";\r\nfunction redux_toolkit_esm_invariant(condition, message) {\r\n    if (condition) {\r\n        return;\r\n    }\r\n    if (isProduction) {\r\n        throw new Error(prefix);\r\n    }\r\n    throw new Error(prefix + \": \" + (message || \"\"));\r\n}\r\nfunction stringify(obj, serializer, indent, decycler) {\r\n    return JSON.stringify(obj, getSerialize(serializer, decycler), indent);\r\n}\r\nfunction getSerialize(serializer, decycler) {\r\n    var stack = [], keys = [];\r\n    if (!decycler)\r\n        decycler = function (_, value) {\r\n            if (stack[0] === value)\r\n                return \"[Circular ~]\";\r\n            return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\";\r\n        };\r\n    return function (key, value) {\r\n        if (stack.length > 0) {\r\n            var thisPos = stack.indexOf(this);\r\n            ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\r\n            ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\r\n            if (~stack.indexOf(value))\r\n                value = decycler.call(this, key, value);\r\n        }\r\n        else\r\n            stack.push(value);\r\n        return serializer == null ? value : serializer.call(this, key, value);\r\n    };\r\n}\r\nfunction isImmutableDefault(value) {\r\n    return typeof value !== \"object\" || value === null || typeof value === \"undefined\" || Object.isFrozen(value);\r\n}\r\nfunction trackForMutations(isImmutable, ignorePaths, obj) {\r\n    var trackedProperties = trackProperties(isImmutable, ignorePaths, obj);\r\n    return {\r\n        detectMutations: function () {\r\n            return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);\r\n        }\r\n    };\r\n}\r\nfunction trackProperties(isImmutable, ignorePaths, obj, path) {\r\n    if (ignorePaths === void 0) { ignorePaths = []; }\r\n    if (path === void 0) { path = \"\"; }\r\n    var tracked = { value: obj };\r\n    if (!isImmutable(obj)) {\r\n        tracked.children = {};\r\n        for (var key in obj) {\r\n            var childPath = path ? path + \".\" + key : key;\r\n            if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {\r\n                continue;\r\n            }\r\n            tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);\r\n        }\r\n    }\r\n    return tracked;\r\n}\r\nfunction detectMutations(isImmutable, ignorePaths, trackedProperty, obj, sameParentRef, path) {\r\n    if (ignorePaths === void 0) { ignorePaths = []; }\r\n    if (sameParentRef === void 0) { sameParentRef = false; }\r\n    if (path === void 0) { path = \"\"; }\r\n    var prevObj = trackedProperty ? trackedProperty.value : void 0;\r\n    var sameRef = prevObj === obj;\r\n    if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\r\n        return { wasMutated: true, path: path };\r\n    }\r\n    if (isImmutable(prevObj) || isImmutable(obj)) {\r\n        return { wasMutated: false };\r\n    }\r\n    var keysToDetect = {};\r\n    for (var key in trackedProperty.children) {\r\n        keysToDetect[key] = true;\r\n    }\r\n    for (var key in obj) {\r\n        keysToDetect[key] = true;\r\n    }\r\n    for (var key in keysToDetect) {\r\n        var childPath = path ? path + \".\" + key : key;\r\n        if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {\r\n            continue;\r\n        }\r\n        var result = detectMutations(isImmutable, ignorePaths, trackedProperty.children[key], obj[key], sameRef, childPath);\r\n        if (result.wasMutated) {\r\n            return result;\r\n        }\r\n    }\r\n    return { wasMutated: false };\r\n}\r\nfunction createImmutableStateInvariantMiddleware(options) {\r\n    if (options === void 0) { options = {}; }\r\n    if (true) {\r\n        return function () { return function (next) { return function (action) { return next(action); }; }; };\r\n    }\r\n    var _c = options.isImmutable, isImmutable = _c === void 0 ? isImmutableDefault : _c, ignoredPaths = options.ignoredPaths, _d = options.warnAfter, warnAfter = _d === void 0 ? 32 : _d, ignore = options.ignore;\r\n    ignoredPaths = ignoredPaths || ignore;\r\n    var track = trackForMutations.bind(null, isImmutable, ignoredPaths);\r\n    return function (_c) {\r\n        var getState = _c.getState;\r\n        var state = getState();\r\n        var tracker = track(state);\r\n        var result;\r\n        return function (next) { return function (action) {\r\n            var measureUtils = getTimeMeasureUtils(warnAfter, \"ImmutableStateInvariantMiddleware\");\r\n            measureUtils.measureTime(function () {\r\n                state = getState();\r\n                result = tracker.detectMutations();\r\n                tracker = track(state);\r\n                redux_toolkit_esm_invariant(!result.wasMutated, \"A state mutation was detected between dispatches, in the path '\" + (result.path || \"\") + \"'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)\");\r\n            });\r\n            var dispatchedAction = next(action);\r\n            measureUtils.measureTime(function () {\r\n                state = getState();\r\n                result = tracker.detectMutations();\r\n                tracker = track(state);\r\n                result.wasMutated && redux_toolkit_esm_invariant(!result.wasMutated, \"A state mutation was detected inside a dispatch, in the path: \" + (result.path || \"\") + \". Take a look at the reducer(s) handling the action \" + stringify(action) + \". (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)\");\r\n            });\r\n            measureUtils.warnIfExceeded();\r\n            return dispatchedAction;\r\n        }; };\r\n    };\r\n}\r\n// src/serializableStateInvariantMiddleware.ts\r\nfunction isPlain(val) {\r\n    var type = typeof val;\r\n    return type === \"undefined\" || val === null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(val) || redux_toolkit_esm_isPlainObject(val);\r\n}\r\nfunction findNonSerializableValue(value, path, isSerializable, getEntries, ignoredPaths) {\r\n    if (path === void 0) { path = \"\"; }\r\n    if (isSerializable === void 0) { isSerializable = isPlain; }\r\n    if (ignoredPaths === void 0) { ignoredPaths = []; }\r\n    var foundNestedSerializable;\r\n    if (!isSerializable(value)) {\r\n        return {\r\n            keyPath: path || \"<root>\",\r\n            value: value\r\n        };\r\n    }\r\n    if (typeof value !== \"object\" || value === null) {\r\n        return false;\r\n    }\r\n    var entries = getEntries != null ? getEntries(value) : Object.entries(value);\r\n    var hasIgnoredPaths = ignoredPaths.length > 0;\r\n    for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\r\n        var _c = entries_1[_i], key = _c[0], nestedValue = _c[1];\r\n        var nestedPath = path ? path + \".\" + key : key;\r\n        if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath) >= 0) {\r\n            continue;\r\n        }\r\n        if (!isSerializable(nestedValue)) {\r\n            return {\r\n                keyPath: nestedPath,\r\n                value: nestedValue\r\n            };\r\n        }\r\n        if (typeof nestedValue === \"object\") {\r\n            foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths);\r\n            if (foundNestedSerializable) {\r\n                return foundNestedSerializable;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction createSerializableStateInvariantMiddleware(options) {\r\n    if (options === void 0) { options = {}; }\r\n    if (true) {\r\n        return function () { return function (next) { return function (action) { return next(action); }; }; };\r\n    }\r\n    var _c = options.isSerializable, isSerializable = _c === void 0 ? isPlain : _c, getEntries = options.getEntries, _d = options.ignoredActions, ignoredActions = _d === void 0 ? [] : _d, _e = options.ignoredActionPaths, ignoredActionPaths = _e === void 0 ? [\"meta.arg\", \"meta.baseQueryMeta\"] : _e, _f = options.ignoredPaths, ignoredPaths = _f === void 0 ? [] : _f, _g = options.warnAfter, warnAfter = _g === void 0 ? 32 : _g, _h = options.ignoreState, ignoreState = _h === void 0 ? false : _h, _j = options.ignoreActions, ignoreActions = _j === void 0 ? false : _j;\r\n    return function (storeAPI) { return function (next) { return function (action) {\r\n        var result = next(action);\r\n        var measureUtils = getTimeMeasureUtils(warnAfter, \"SerializableStateInvariantMiddleware\");\r\n        if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {\r\n            measureUtils.measureTime(function () {\r\n                var foundActionNonSerializableValue = findNonSerializableValue(action, \"\", isSerializable, getEntries, ignoredActionPaths);\r\n                if (foundActionNonSerializableValue) {\r\n                    var keyPath = foundActionNonSerializableValue.keyPath, value = foundActionNonSerializableValue.value;\r\n                    console.error(\"A non-serializable value was detected in an action, in the path: `\" + keyPath + \"`. Value:\", value, \"\\nTake a look at the logic that dispatched this action: \", action, \"\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)\", \"\\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)\");\r\n                }\r\n            });\r\n        }\r\n        if (!ignoreState) {\r\n            measureUtils.measureTime(function () {\r\n                var state = storeAPI.getState();\r\n                var foundStateNonSerializableValue = findNonSerializableValue(state, \"\", isSerializable, getEntries, ignoredPaths);\r\n                if (foundStateNonSerializableValue) {\r\n                    var keyPath = foundStateNonSerializableValue.keyPath, value = foundStateNonSerializableValue.value;\r\n                    console.error(\"A non-serializable value was detected in the state, in the path: `\" + keyPath + \"`. Value:\", value, \"\\nTake a look at the reducer(s) handling this action type: \" + action.type + \".\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)\");\r\n                }\r\n            });\r\n            measureUtils.warnIfExceeded();\r\n        }\r\n        return result;\r\n    }; }; };\r\n}\r\n// src/getDefaultMiddleware.ts\r\nfunction isBoolean(x) {\r\n    return typeof x === \"boolean\";\r\n}\r\nfunction curryGetDefaultMiddleware() {\r\n    return function curriedGetDefaultMiddleware(options) {\r\n        return getDefaultMiddleware(options);\r\n    };\r\n}\r\nfunction getDefaultMiddleware(options) {\r\n    if (options === void 0) { options = {}; }\r\n    var _c = options.thunk, thunk = _c === void 0 ? true : _c, _d = options.immutableCheck, immutableCheck = _d === void 0 ? true : _d, _e = options.serializableCheck, serializableCheck = _e === void 0 ? true : _e;\r\n    var middlewareArray = new MiddlewareArray();\r\n    if (thunk) {\r\n        if (isBoolean(thunk)) {\r\n            middlewareArray.push(es);\r\n        }\r\n        else {\r\n            middlewareArray.push(es.withExtraArgument(thunk.extraArgument));\r\n        }\r\n    }\r\n    if (false) { var serializableOptions, immutableOptions; }\r\n    return middlewareArray;\r\n}\r\n// src/configureStore.ts\r\nvar IS_PRODUCTION = \"production\" === \"production\";\r\nfunction configureStore(options) {\r\n    var curriedGetDefaultMiddleware = curryGetDefaultMiddleware();\r\n    var _c = options || {}, _d = _c.reducer, reducer = _d === void 0 ? void 0 : _d, _e = _c.middleware, middleware = _e === void 0 ? curriedGetDefaultMiddleware() : _e, _f = _c.devTools, devTools = _f === void 0 ? true : _f, _g = _c.preloadedState, preloadedState = _g === void 0 ? void 0 : _g, _h = _c.enhancers, enhancers = _h === void 0 ? void 0 : _h;\r\n    var rootReducer;\r\n    if (typeof reducer === \"function\") {\r\n        rootReducer = reducer;\r\n    }\r\n    else if (redux_toolkit_esm_isPlainObject(reducer)) {\r\n        rootReducer = combineReducers(reducer);\r\n    }\r\n    else {\r\n        throw new Error('\"reducer\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');\r\n    }\r\n    var finalMiddleware = middleware;\r\n    if (typeof finalMiddleware === \"function\") {\r\n        finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware);\r\n        if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {\r\n            throw new Error(\"when using a middleware builder function, an array of middleware must be returned\");\r\n        }\r\n    }\r\n    if (!IS_PRODUCTION && finalMiddleware.some(function (item) { return typeof item !== \"function\"; })) {\r\n        throw new Error(\"each middleware provided to configureStore must be a function\");\r\n    }\r\n    var middlewareEnhancer = applyMiddleware.apply(void 0, finalMiddleware);\r\n    var finalCompose = compose;\r\n    if (devTools) {\r\n        finalCompose = composeWithDevTools(__spreadValues({\r\n            trace: !IS_PRODUCTION\r\n        }, typeof devTools === \"object\" && devTools));\r\n    }\r\n    var storeEnhancers = [middlewareEnhancer];\r\n    if (Array.isArray(enhancers)) {\r\n        storeEnhancers = __spreadArray([middlewareEnhancer], enhancers);\r\n    }\r\n    else if (typeof enhancers === \"function\") {\r\n        storeEnhancers = enhancers(storeEnhancers);\r\n    }\r\n    var composedEnhancer = finalCompose.apply(void 0, storeEnhancers);\r\n    return createStore(rootReducer, preloadedState, composedEnhancer);\r\n}\r\n// src/createAction.ts\r\nfunction createAction(type, prepareAction) {\r\n    function actionCreator() {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        if (prepareAction) {\r\n            var prepared = prepareAction.apply(void 0, args);\r\n            if (!prepared) {\r\n                throw new Error(\"prepareAction did not return an object\");\r\n            }\r\n            return __spreadValues(__spreadValues({\r\n                type: type,\r\n                payload: prepared.payload\r\n            }, \"meta\" in prepared && { meta: prepared.meta }), \"error\" in prepared && { error: prepared.error });\r\n        }\r\n        return { type: type, payload: args[0] };\r\n    }\r\n    actionCreator.toString = function () { return \"\" + type; };\r\n    actionCreator.type = type;\r\n    actionCreator.match = function (action) { return action.type === type; };\r\n    return actionCreator;\r\n}\r\nfunction isFSA(action) {\r\n    return redux_toolkit_esm_isPlainObject(action) && typeof action.type === \"string\" && Object.keys(action).every(isValidKey);\r\n}\r\nfunction isValidKey(key) {\r\n    return [\"type\", \"payload\", \"error\", \"meta\"].indexOf(key) > -1;\r\n}\r\nfunction getType(actionCreator) {\r\n    return \"\" + actionCreator;\r\n}\r\n// src/createReducer.ts\r\n\r\n// src/mapBuilders.ts\r\nfunction executeReducerBuilderCallback(builderCallback) {\r\n    var actionsMap = {};\r\n    var actionMatchers = [];\r\n    var defaultCaseReducer;\r\n    var builder = {\r\n        addCase: function (typeOrActionCreator, reducer) {\r\n            if (false) {}\r\n            var type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\r\n            if (type in actionsMap) {\r\n                throw new Error(\"addCase cannot be called with two reducers for the same action type\");\r\n            }\r\n            actionsMap[type] = reducer;\r\n            return builder;\r\n        },\r\n        addMatcher: function (matcher, reducer) {\r\n            if (false) {}\r\n            actionMatchers.push({ matcher: matcher, reducer: reducer });\r\n            return builder;\r\n        },\r\n        addDefaultCase: function (reducer) {\r\n            if (false) {}\r\n            defaultCaseReducer = reducer;\r\n            return builder;\r\n        }\r\n    };\r\n    builderCallback(builder);\r\n    return [actionsMap, actionMatchers, defaultCaseReducer];\r\n}\r\n// src/createReducer.ts\r\nfunction isStateFunction(x) {\r\n    return typeof x === \"function\";\r\n}\r\nfunction createReducer(initialState, mapOrBuilderCallback, actionMatchers, defaultCaseReducer) {\r\n    if (actionMatchers === void 0) { actionMatchers = []; }\r\n    var _c = typeof mapOrBuilderCallback === \"function\" ? executeReducerBuilderCallback(mapOrBuilderCallback) : [mapOrBuilderCallback, actionMatchers, defaultCaseReducer], actionsMap = _c[0], finalActionMatchers = _c[1], finalDefaultCaseReducer = _c[2];\r\n    var getInitialState;\r\n    if (isStateFunction(initialState)) {\r\n        getInitialState = function () { return createNextState(initialState(), function () {\r\n        }); };\r\n    }\r\n    else {\r\n        var frozenInitialState_1 = createNextState(initialState, function () {\r\n        });\r\n        getInitialState = function () { return frozenInitialState_1; };\r\n    }\r\n    function reducer(state, action) {\r\n        if (state === void 0) { state = getInitialState(); }\r\n        var caseReducers = __spreadArray([\r\n            actionsMap[action.type]\r\n        ], finalActionMatchers.filter(function (_c) {\r\n            var matcher = _c.matcher;\r\n            return matcher(action);\r\n        }).map(function (_c) {\r\n            var reducer2 = _c.reducer;\r\n            return reducer2;\r\n        }));\r\n        if (caseReducers.filter(function (cr) { return !!cr; }).length === 0) {\r\n            caseReducers = [finalDefaultCaseReducer];\r\n        }\r\n        return caseReducers.reduce(function (previousState, caseReducer) {\r\n            if (caseReducer) {\r\n                if (isDraft2(previousState)) {\r\n                    var draft = previousState;\r\n                    var result = caseReducer(draft, action);\r\n                    if (typeof result === \"undefined\") {\r\n                        return previousState;\r\n                    }\r\n                    return result;\r\n                }\r\n                else if (!isDraftable(previousState)) {\r\n                    var result = caseReducer(previousState, action);\r\n                    if (typeof result === \"undefined\") {\r\n                        if (previousState === null) {\r\n                            return previousState;\r\n                        }\r\n                        throw Error(\"A case reducer on a non-draftable value must not return undefined\");\r\n                    }\r\n                    return result;\r\n                }\r\n                else {\r\n                    return createNextState(previousState, function (draft) {\r\n                        return caseReducer(draft, action);\r\n                    });\r\n                }\r\n            }\r\n            return previousState;\r\n        }, state);\r\n    }\r\n    reducer.getInitialState = getInitialState;\r\n    return reducer;\r\n}\r\n// src/createSlice.ts\r\nfunction getType2(slice, actionKey) {\r\n    return slice + \"/\" + actionKey;\r\n}\r\nfunction createSlice(options) {\r\n    var name = options.name;\r\n    if (!name) {\r\n        throw new Error(\"`name` is a required option for createSlice\");\r\n    }\r\n    var initialState = typeof options.initialState == \"function\" ? options.initialState : default2(options.initialState, function () {\r\n    });\r\n    var reducers = options.reducers || {};\r\n    var reducerNames = Object.keys(reducers);\r\n    var sliceCaseReducersByName = {};\r\n    var sliceCaseReducersByType = {};\r\n    var actionCreators = {};\r\n    reducerNames.forEach(function (reducerName) {\r\n        var maybeReducerWithPrepare = reducers[reducerName];\r\n        var type = getType2(name, reducerName);\r\n        var caseReducer;\r\n        var prepareCallback;\r\n        if (\"reducer\" in maybeReducerWithPrepare) {\r\n            caseReducer = maybeReducerWithPrepare.reducer;\r\n            prepareCallback = maybeReducerWithPrepare.prepare;\r\n        }\r\n        else {\r\n            caseReducer = maybeReducerWithPrepare;\r\n        }\r\n        sliceCaseReducersByName[reducerName] = caseReducer;\r\n        sliceCaseReducersByType[type] = caseReducer;\r\n        actionCreators[reducerName] = prepareCallback ? createAction(type, prepareCallback) : createAction(type);\r\n    });\r\n    function buildReducer() {\r\n        var _c = typeof options.extraReducers === \"function\" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers], _d = _c[0], extraReducers = _d === void 0 ? {} : _d, _e = _c[1], actionMatchers = _e === void 0 ? [] : _e, _f = _c[2], defaultCaseReducer = _f === void 0 ? void 0 : _f;\r\n        var finalCaseReducers = __spreadValues(__spreadValues({}, extraReducers), sliceCaseReducersByType);\r\n        return createReducer(initialState, finalCaseReducers, actionMatchers, defaultCaseReducer);\r\n    }\r\n    var _reducer;\r\n    return {\r\n        name: name,\r\n        reducer: function (state, action) {\r\n            if (!_reducer)\r\n                _reducer = buildReducer();\r\n            return _reducer(state, action);\r\n        },\r\n        actions: actionCreators,\r\n        caseReducers: sliceCaseReducersByName,\r\n        getInitialState: function () {\r\n            if (!_reducer)\r\n                _reducer = buildReducer();\r\n            return _reducer.getInitialState();\r\n        }\r\n    };\r\n}\r\n// src/entities/entity_state.ts\r\nfunction getInitialEntityState() {\r\n    return {\r\n        ids: [],\r\n        entities: {}\r\n    };\r\n}\r\nfunction createInitialStateFactory() {\r\n    function getInitialState(additionalState) {\r\n        if (additionalState === void 0) { additionalState = {}; }\r\n        return Object.assign(getInitialEntityState(), additionalState);\r\n    }\r\n    return { getInitialState: getInitialState };\r\n}\r\n// src/entities/state_selectors.ts\r\nfunction createSelectorsFactory() {\r\n    function getSelectors(selectState) {\r\n        var selectIds = function (state) { return state.ids; };\r\n        var selectEntities = function (state) { return state.entities; };\r\n        var selectAll = createDraftSafeSelector(selectIds, selectEntities, function (ids, entities) { return ids.map(function (id) { return entities[id]; }); });\r\n        var selectId = function (_, id) { return id; };\r\n        var selectById = function (entities, id) { return entities[id]; };\r\n        var selectTotal = createDraftSafeSelector(selectIds, function (ids) { return ids.length; });\r\n        if (!selectState) {\r\n            return {\r\n                selectIds: selectIds,\r\n                selectEntities: selectEntities,\r\n                selectAll: selectAll,\r\n                selectTotal: selectTotal,\r\n                selectById: createDraftSafeSelector(selectEntities, selectId, selectById)\r\n            };\r\n        }\r\n        var selectGlobalizedEntities = createDraftSafeSelector(selectState, selectEntities);\r\n        return {\r\n            selectIds: createDraftSafeSelector(selectState, selectIds),\r\n            selectEntities: selectGlobalizedEntities,\r\n            selectAll: createDraftSafeSelector(selectState, selectAll),\r\n            selectTotal: createDraftSafeSelector(selectState, selectTotal),\r\n            selectById: createDraftSafeSelector(selectGlobalizedEntities, selectId, selectById)\r\n        };\r\n    }\r\n    return { getSelectors: getSelectors };\r\n}\r\n// src/entities/state_adapter.ts\r\n\r\nfunction createSingleArgumentStateOperator(mutator) {\r\n    var operator = createStateOperator(function (_, state) { return mutator(state); });\r\n    return function operation(state) {\r\n        return operator(state, void 0);\r\n    };\r\n}\r\nfunction createStateOperator(mutator) {\r\n    return function operation(state, arg) {\r\n        function isPayloadActionArgument(arg2) {\r\n            return isFSA(arg2);\r\n        }\r\n        var runMutator = function (draft) {\r\n            if (isPayloadActionArgument(arg)) {\r\n                mutator(arg.payload, draft);\r\n            }\r\n            else {\r\n                mutator(arg, draft);\r\n            }\r\n        };\r\n        if (isDraft3(state)) {\r\n            runMutator(state);\r\n            return state;\r\n        }\r\n        else {\r\n            return createNextState2(state, runMutator);\r\n        }\r\n    };\r\n}\r\n// src/entities/utils.ts\r\nfunction selectIdValue(entity, selectId) {\r\n    var key = selectId(entity);\r\n    if (false) {}\r\n    return key;\r\n}\r\nfunction ensureEntitiesArray(entities) {\r\n    if (!Array.isArray(entities)) {\r\n        entities = Object.values(entities);\r\n    }\r\n    return entities;\r\n}\r\nfunction splitAddedUpdatedEntities(newEntities, selectId, state) {\r\n    newEntities = ensureEntitiesArray(newEntities);\r\n    var added = [];\r\n    var updated = [];\r\n    for (var _i = 0, newEntities_1 = newEntities; _i < newEntities_1.length; _i++) {\r\n        var entity = newEntities_1[_i];\r\n        var id = selectIdValue(entity, selectId);\r\n        if (id in state.entities) {\r\n            updated.push({ id: id, changes: entity });\r\n        }\r\n        else {\r\n            added.push(entity);\r\n        }\r\n    }\r\n    return [added, updated];\r\n}\r\n// src/entities/unsorted_state_adapter.ts\r\nfunction createUnsortedStateAdapter(selectId) {\r\n    function addOneMutably(entity, state) {\r\n        var key = selectIdValue(entity, selectId);\r\n        if (key in state.entities) {\r\n            return;\r\n        }\r\n        state.ids.push(key);\r\n        state.entities[key] = entity;\r\n    }\r\n    function addManyMutably(newEntities, state) {\r\n        newEntities = ensureEntitiesArray(newEntities);\r\n        for (var _i = 0, newEntities_2 = newEntities; _i < newEntities_2.length; _i++) {\r\n            var entity = newEntities_2[_i];\r\n            addOneMutably(entity, state);\r\n        }\r\n    }\r\n    function setOneMutably(entity, state) {\r\n        var key = selectIdValue(entity, selectId);\r\n        if (!(key in state.entities)) {\r\n            state.ids.push(key);\r\n        }\r\n        state.entities[key] = entity;\r\n    }\r\n    function setManyMutably(newEntities, state) {\r\n        newEntities = ensureEntitiesArray(newEntities);\r\n        for (var _i = 0, newEntities_3 = newEntities; _i < newEntities_3.length; _i++) {\r\n            var entity = newEntities_3[_i];\r\n            setOneMutably(entity, state);\r\n        }\r\n    }\r\n    function setAllMutably(newEntities, state) {\r\n        newEntities = ensureEntitiesArray(newEntities);\r\n        state.ids = [];\r\n        state.entities = {};\r\n        addManyMutably(newEntities, state);\r\n    }\r\n    function removeOneMutably(key, state) {\r\n        return removeManyMutably([key], state);\r\n    }\r\n    function removeManyMutably(keys, state) {\r\n        var didMutate = false;\r\n        keys.forEach(function (key) {\r\n            if (key in state.entities) {\r\n                delete state.entities[key];\r\n                didMutate = true;\r\n            }\r\n        });\r\n        if (didMutate) {\r\n            state.ids = state.ids.filter(function (id) { return id in state.entities; });\r\n        }\r\n    }\r\n    function removeAllMutably(state) {\r\n        Object.assign(state, {\r\n            ids: [],\r\n            entities: {}\r\n        });\r\n    }\r\n    function takeNewKey(keys, update, state) {\r\n        var original2 = state.entities[update.id];\r\n        var updated = Object.assign({}, original2, update.changes);\r\n        var newKey = selectIdValue(updated, selectId);\r\n        var hasNewKey = newKey !== update.id;\r\n        if (hasNewKey) {\r\n            keys[update.id] = newKey;\r\n            delete state.entities[update.id];\r\n        }\r\n        state.entities[newKey] = updated;\r\n        return hasNewKey;\r\n    }\r\n    function updateOneMutably(update, state) {\r\n        return updateManyMutably([update], state);\r\n    }\r\n    function updateManyMutably(updates, state) {\r\n        var newKeys = {};\r\n        var updatesPerEntity = {};\r\n        updates.forEach(function (update) {\r\n            if (update.id in state.entities) {\r\n                updatesPerEntity[update.id] = {\r\n                    id: update.id,\r\n                    changes: __spreadValues(__spreadValues({}, updatesPerEntity[update.id] ? updatesPerEntity[update.id].changes : null), update.changes)\r\n                };\r\n            }\r\n        });\r\n        updates = Object.values(updatesPerEntity);\r\n        var didMutateEntities = updates.length > 0;\r\n        if (didMutateEntities) {\r\n            var didMutateIds = updates.filter(function (update) { return takeNewKey(newKeys, update, state); }).length > 0;\r\n            if (didMutateIds) {\r\n                state.ids = state.ids.map(function (id) { return newKeys[id] || id; });\r\n            }\r\n        }\r\n    }\r\n    function upsertOneMutably(entity, state) {\r\n        return upsertManyMutably([entity], state);\r\n    }\r\n    function upsertManyMutably(newEntities, state) {\r\n        var _c = splitAddedUpdatedEntities(newEntities, selectId, state), added = _c[0], updated = _c[1];\r\n        updateManyMutably(updated, state);\r\n        addManyMutably(added, state);\r\n    }\r\n    return {\r\n        removeAll: createSingleArgumentStateOperator(removeAllMutably),\r\n        addOne: createStateOperator(addOneMutably),\r\n        addMany: createStateOperator(addManyMutably),\r\n        setOne: createStateOperator(setOneMutably),\r\n        setMany: createStateOperator(setManyMutably),\r\n        setAll: createStateOperator(setAllMutably),\r\n        updateOne: createStateOperator(updateOneMutably),\r\n        updateMany: createStateOperator(updateManyMutably),\r\n        upsertOne: createStateOperator(upsertOneMutably),\r\n        upsertMany: createStateOperator(upsertManyMutably),\r\n        removeOne: createStateOperator(removeOneMutably),\r\n        removeMany: createStateOperator(removeManyMutably)\r\n    };\r\n}\r\n// src/entities/sorted_state_adapter.ts\r\nfunction createSortedStateAdapter(selectId, sort) {\r\n    var _c = createUnsortedStateAdapter(selectId), removeOne = _c.removeOne, removeMany = _c.removeMany, removeAll = _c.removeAll;\r\n    function addOneMutably(entity, state) {\r\n        return addManyMutably([entity], state);\r\n    }\r\n    function addManyMutably(newEntities, state) {\r\n        newEntities = ensureEntitiesArray(newEntities);\r\n        var models = newEntities.filter(function (model) { return !(selectIdValue(model, selectId) in state.entities); });\r\n        if (models.length !== 0) {\r\n            merge(models, state);\r\n        }\r\n    }\r\n    function setOneMutably(entity, state) {\r\n        return setManyMutably([entity], state);\r\n    }\r\n    function setManyMutably(newEntities, state) {\r\n        newEntities = ensureEntitiesArray(newEntities);\r\n        if (newEntities.length !== 0) {\r\n            merge(newEntities, state);\r\n        }\r\n    }\r\n    function setAllMutably(newEntities, state) {\r\n        newEntities = ensureEntitiesArray(newEntities);\r\n        state.entities = {};\r\n        state.ids = [];\r\n        addManyMutably(newEntities, state);\r\n    }\r\n    function updateOneMutably(update, state) {\r\n        return updateManyMutably([update], state);\r\n    }\r\n    function takeUpdatedModel(models, update, state) {\r\n        if (!(update.id in state.entities)) {\r\n            return false;\r\n        }\r\n        var original2 = state.entities[update.id];\r\n        var updated = Object.assign({}, original2, update.changes);\r\n        var newKey = selectIdValue(updated, selectId);\r\n        delete state.entities[update.id];\r\n        models.push(updated);\r\n        return newKey !== update.id;\r\n    }\r\n    function updateManyMutably(updates, state) {\r\n        var models = [];\r\n        updates.forEach(function (update) { return takeUpdatedModel(models, update, state); });\r\n        if (models.length !== 0) {\r\n            merge(models, state);\r\n        }\r\n    }\r\n    function upsertOneMutably(entity, state) {\r\n        return upsertManyMutably([entity], state);\r\n    }\r\n    function upsertManyMutably(newEntities, state) {\r\n        var _c = splitAddedUpdatedEntities(newEntities, selectId, state), added = _c[0], updated = _c[1];\r\n        updateManyMutably(updated, state);\r\n        addManyMutably(added, state);\r\n    }\r\n    function areArraysEqual(a, b) {\r\n        if (a.length !== b.length) {\r\n            return false;\r\n        }\r\n        for (var i = 0; i < a.length && i < b.length; i++) {\r\n            if (a[i] === b[i]) {\r\n                continue;\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    function merge(models, state) {\r\n        models.forEach(function (model) {\r\n            state.entities[selectId(model)] = model;\r\n        });\r\n        var allEntities = Object.values(state.entities);\r\n        allEntities.sort(sort);\r\n        var newSortedIds = allEntities.map(selectId);\r\n        var ids = state.ids;\r\n        if (!areArraysEqual(ids, newSortedIds)) {\r\n            state.ids = newSortedIds;\r\n        }\r\n    }\r\n    return {\r\n        removeOne: removeOne,\r\n        removeMany: removeMany,\r\n        removeAll: removeAll,\r\n        addOne: createStateOperator(addOneMutably),\r\n        updateOne: createStateOperator(updateOneMutably),\r\n        upsertOne: createStateOperator(upsertOneMutably),\r\n        setOne: createStateOperator(setOneMutably),\r\n        setMany: createStateOperator(setManyMutably),\r\n        setAll: createStateOperator(setAllMutably),\r\n        addMany: createStateOperator(addManyMutably),\r\n        updateMany: createStateOperator(updateManyMutably),\r\n        upsertMany: createStateOperator(upsertManyMutably)\r\n    };\r\n}\r\n// src/entities/create_adapter.ts\r\nfunction createEntityAdapter(options) {\r\n    if (options === void 0) { options = {}; }\r\n    var _c = __spreadValues({\r\n        sortComparer: false,\r\n        selectId: function (instance) { return instance.id; }\r\n    }, options), selectId = _c.selectId, sortComparer = _c.sortComparer;\r\n    var stateFactory = createInitialStateFactory();\r\n    var selectorsFactory = createSelectorsFactory();\r\n    var stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);\r\n    return __spreadValues(__spreadValues(__spreadValues({\r\n        selectId: selectId,\r\n        sortComparer: sortComparer\r\n    }, stateFactory), selectorsFactory), stateAdapter);\r\n}\r\n// src/nanoid.ts\r\nvar urlAlphabet = \"ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW\";\r\nvar nanoid = function (size) {\r\n    if (size === void 0) { size = 21; }\r\n    var id = \"\";\r\n    var i = size;\r\n    while (i--) {\r\n        id += urlAlphabet[Math.random() * 64 | 0];\r\n    }\r\n    return id;\r\n};\r\n// src/createAsyncThunk.ts\r\nvar commonProperties = (/* unused pure expression or super */ null && ([\r\n    \"name\",\r\n    \"message\",\r\n    \"stack\",\r\n    \"code\"\r\n]));\r\nvar RejectWithValue = /** @class */ (function () {\r\n    function RejectWithValue(payload, meta) {\r\n        this.payload = payload;\r\n        this.meta = meta;\r\n    }\r\n    return RejectWithValue;\r\n}());\r\nvar FulfillWithMeta = /** @class */ (function () {\r\n    function FulfillWithMeta(payload, meta) {\r\n        this.payload = payload;\r\n        this.meta = meta;\r\n    }\r\n    return FulfillWithMeta;\r\n}());\r\nvar miniSerializeError = function (value) {\r\n    if (typeof value === \"object\" && value !== null) {\r\n        var simpleError = {};\r\n        for (var _i = 0, commonProperties_1 = commonProperties; _i < commonProperties_1.length; _i++) {\r\n            var property = commonProperties_1[_i];\r\n            if (typeof value[property] === \"string\") {\r\n                simpleError[property] = value[property];\r\n            }\r\n        }\r\n        return simpleError;\r\n    }\r\n    return { message: String(value) };\r\n};\r\nfunction createAsyncThunk(typePrefix, payloadCreator, options) {\r\n    var fulfilled = createAction(typePrefix + \"/fulfilled\", function (payload, requestId, arg, meta) { return ({\r\n        payload: payload,\r\n        meta: __spreadProps(__spreadValues({}, meta || {}), {\r\n            arg: arg,\r\n            requestId: requestId,\r\n            requestStatus: \"fulfilled\"\r\n        })\r\n    }); });\r\n    var pending = createAction(typePrefix + \"/pending\", function (requestId, arg, meta) { return ({\r\n        payload: void 0,\r\n        meta: __spreadProps(__spreadValues({}, meta || {}), {\r\n            arg: arg,\r\n            requestId: requestId,\r\n            requestStatus: \"pending\"\r\n        })\r\n    }); });\r\n    var rejected = createAction(typePrefix + \"/rejected\", function (error, requestId, arg, payload, meta) { return ({\r\n        payload: payload,\r\n        error: (options && options.serializeError || miniSerializeError)(error || \"Rejected\"),\r\n        meta: __spreadProps(__spreadValues({}, meta || {}), {\r\n            arg: arg,\r\n            requestId: requestId,\r\n            rejectedWithValue: !!payload,\r\n            requestStatus: \"rejected\",\r\n            aborted: (error == null ? void 0 : error.name) === \"AbortError\",\r\n            condition: (error == null ? void 0 : error.name) === \"ConditionError\"\r\n        })\r\n    }); });\r\n    var displayedWarning = false;\r\n    var AC = typeof AbortController !== \"undefined\" ? AbortController : /** @class */ (function () {\r\n        function class_1() {\r\n            this.signal = {\r\n                aborted: false,\r\n                addEventListener: function () {\r\n                },\r\n                dispatchEvent: function () {\r\n                    return false;\r\n                },\r\n                onabort: function () {\r\n                },\r\n                removeEventListener: function () {\r\n                }\r\n            };\r\n        }\r\n        class_1.prototype.abort = function () {\r\n            if (false) {}\r\n        };\r\n        return class_1;\r\n    }());\r\n    function actionCreator(arg) {\r\n        return function (dispatch, getState, extra) {\r\n            var requestId = (options == null ? void 0 : options.idGenerator) ? options.idGenerator(arg) : nanoid();\r\n            var abortController = new AC();\r\n            var abortReason;\r\n            var abortedPromise = new Promise(function (_, reject) { return abortController.signal.addEventListener(\"abort\", function () { return reject({ name: \"AbortError\", message: abortReason || \"Aborted\" }); }); });\r\n            var started = false;\r\n            function abort(reason) {\r\n                if (started) {\r\n                    abortReason = reason;\r\n                    abortController.abort();\r\n                }\r\n            }\r\n            var promise = function () {\r\n                return __async(this, null, function () {\r\n                    var _a, _b, finalAction, conditionResult, err_1, skipDispatch;\r\n                    return __generator(this, function (_c) {\r\n                        switch (_c.label) {\r\n                            case 0:\r\n                                _c.trys.push([0, 4, , 5]);\r\n                                conditionResult = (_a = options == null ? void 0 : options.condition) == null ? void 0 : _a.call(options, arg, { getState: getState, extra: extra });\r\n                                if (!isThenable(conditionResult)) return [3 /*break*/, 2];\r\n                                return [4 /*yield*/, conditionResult];\r\n                            case 1:\r\n                                conditionResult = _c.sent();\r\n                                _c.label = 2;\r\n                            case 2:\r\n                                if (conditionResult === false) {\r\n                                    throw {\r\n                                        name: \"ConditionError\",\r\n                                        message: \"Aborted due to condition callback returning false.\"\r\n                                    };\r\n                                }\r\n                                started = true;\r\n                                dispatch(pending(requestId, arg, (_b = options == null ? void 0 : options.getPendingMeta) == null ? void 0 : _b.call(options, { requestId: requestId, arg: arg }, { getState: getState, extra: extra })));\r\n                                return [4 /*yield*/, Promise.race([\r\n                                        abortedPromise,\r\n                                        Promise.resolve(payloadCreator(arg, {\r\n                                            dispatch: dispatch,\r\n                                            getState: getState,\r\n                                            extra: extra,\r\n                                            requestId: requestId,\r\n                                            signal: abortController.signal,\r\n                                            rejectWithValue: function (value, meta) {\r\n                                                return new RejectWithValue(value, meta);\r\n                                            },\r\n                                            fulfillWithValue: function (value, meta) {\r\n                                                return new FulfillWithMeta(value, meta);\r\n                                            }\r\n                                        })).then(function (result) {\r\n                                            if (result instanceof RejectWithValue) {\r\n                                                throw result;\r\n                                            }\r\n                                            if (result instanceof FulfillWithMeta) {\r\n                                                return fulfilled(result.payload, requestId, arg, result.meta);\r\n                                            }\r\n                                            return fulfilled(result, requestId, arg);\r\n                                        })\r\n                                    ])];\r\n                            case 3:\r\n                                finalAction = _c.sent();\r\n                                return [3 /*break*/, 5];\r\n                            case 4:\r\n                                err_1 = _c.sent();\r\n                                finalAction = err_1 instanceof RejectWithValue ? rejected(null, requestId, arg, err_1.payload, err_1.meta) : rejected(err_1, requestId, arg);\r\n                                return [3 /*break*/, 5];\r\n                            case 5:\r\n                                skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;\r\n                                if (!skipDispatch) {\r\n                                    dispatch(finalAction);\r\n                                }\r\n                                return [2 /*return*/, finalAction];\r\n                        }\r\n                    });\r\n                });\r\n            }();\r\n            return Object.assign(promise, {\r\n                abort: abort,\r\n                requestId: requestId,\r\n                arg: arg,\r\n                unwrap: function () {\r\n                    return promise.then(unwrapResult);\r\n                }\r\n            });\r\n        };\r\n    }\r\n    return Object.assign(actionCreator, {\r\n        pending: pending,\r\n        rejected: rejected,\r\n        fulfilled: fulfilled,\r\n        typePrefix: typePrefix\r\n    });\r\n}\r\nfunction unwrapResult(action) {\r\n    if (action.meta && action.meta.rejectedWithValue) {\r\n        throw action.payload;\r\n    }\r\n    if (action.error) {\r\n        throw action.error;\r\n    }\r\n    return action.payload;\r\n}\r\nfunction isThenable(value) {\r\n    return value !== null && typeof value === \"object\" && typeof value.then === \"function\";\r\n}\r\n// src/tsHelpers.ts\r\nvar hasMatchFunction = function (v) {\r\n    return v && typeof v.match === \"function\";\r\n};\r\n// src/matchers.ts\r\nvar matches = function (matcher, action) {\r\n    if (hasMatchFunction(matcher)) {\r\n        return matcher.match(action);\r\n    }\r\n    else {\r\n        return matcher(action);\r\n    }\r\n};\r\nfunction isAnyOf() {\r\n    var matchers = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        matchers[_i] = arguments[_i];\r\n    }\r\n    return function (action) {\r\n        return matchers.some(function (matcher) { return matches(matcher, action); });\r\n    };\r\n}\r\nfunction isAllOf() {\r\n    var matchers = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        matchers[_i] = arguments[_i];\r\n    }\r\n    return function (action) {\r\n        return matchers.every(function (matcher) { return matches(matcher, action); });\r\n    };\r\n}\r\nfunction hasExpectedRequestMetadata(action, validStatus) {\r\n    if (!action || !action.meta)\r\n        return false;\r\n    var hasValidRequestId = typeof action.meta.requestId === \"string\";\r\n    var hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;\r\n    return hasValidRequestId && hasValidRequestStatus;\r\n}\r\nfunction isAsyncThunkArray(a) {\r\n    return typeof a[0] === \"function\" && \"pending\" in a[0] && \"fulfilled\" in a[0] && \"rejected\" in a[0];\r\n}\r\nfunction isPending() {\r\n    var asyncThunks = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        asyncThunks[_i] = arguments[_i];\r\n    }\r\n    if (asyncThunks.length === 0) {\r\n        return function (action) { return hasExpectedRequestMetadata(action, [\"pending\"]); };\r\n    }\r\n    if (!isAsyncThunkArray(asyncThunks)) {\r\n        return isPending()(asyncThunks[0]);\r\n    }\r\n    return function (action) {\r\n        var matchers = asyncThunks.map(function (asyncThunk) { return asyncThunk.pending; });\r\n        var combinedMatcher = isAnyOf.apply(void 0, matchers);\r\n        return combinedMatcher(action);\r\n    };\r\n}\r\nfunction isRejected() {\r\n    var asyncThunks = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        asyncThunks[_i] = arguments[_i];\r\n    }\r\n    if (asyncThunks.length === 0) {\r\n        return function (action) { return hasExpectedRequestMetadata(action, [\"rejected\"]); };\r\n    }\r\n    if (!isAsyncThunkArray(asyncThunks)) {\r\n        return isRejected()(asyncThunks[0]);\r\n    }\r\n    return function (action) {\r\n        var matchers = asyncThunks.map(function (asyncThunk) { return asyncThunk.rejected; });\r\n        var combinedMatcher = isAnyOf.apply(void 0, matchers);\r\n        return combinedMatcher(action);\r\n    };\r\n}\r\nfunction isRejectedWithValue() {\r\n    var asyncThunks = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        asyncThunks[_i] = arguments[_i];\r\n    }\r\n    var hasFlag = function (action) {\r\n        return action && action.meta && action.meta.rejectedWithValue;\r\n    };\r\n    if (asyncThunks.length === 0) {\r\n        return function (action) {\r\n            var combinedMatcher = isAllOf(isRejected.apply(void 0, asyncThunks), hasFlag);\r\n            return combinedMatcher(action);\r\n        };\r\n    }\r\n    if (!isAsyncThunkArray(asyncThunks)) {\r\n        return isRejectedWithValue()(asyncThunks[0]);\r\n    }\r\n    return function (action) {\r\n        var combinedMatcher = isAllOf(isRejected.apply(void 0, asyncThunks), hasFlag);\r\n        return combinedMatcher(action);\r\n    };\r\n}\r\nfunction isFulfilled() {\r\n    var asyncThunks = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        asyncThunks[_i] = arguments[_i];\r\n    }\r\n    if (asyncThunks.length === 0) {\r\n        return function (action) { return hasExpectedRequestMetadata(action, [\"fulfilled\"]); };\r\n    }\r\n    if (!isAsyncThunkArray(asyncThunks)) {\r\n        return isFulfilled()(asyncThunks[0]);\r\n    }\r\n    return function (action) {\r\n        var matchers = asyncThunks.map(function (asyncThunk) { return asyncThunk.fulfilled; });\r\n        var combinedMatcher = isAnyOf.apply(void 0, matchers);\r\n        return combinedMatcher(action);\r\n    };\r\n}\r\nfunction isAsyncThunkAction() {\r\n    var asyncThunks = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        asyncThunks[_i] = arguments[_i];\r\n    }\r\n    if (asyncThunks.length === 0) {\r\n        return function (action) { return hasExpectedRequestMetadata(action, [\"pending\", \"fulfilled\", \"rejected\"]); };\r\n    }\r\n    if (!isAsyncThunkArray(asyncThunks)) {\r\n        return isAsyncThunkAction()(asyncThunks[0]);\r\n    }\r\n    return function (action) {\r\n        var matchers = [];\r\n        for (var _i = 0, asyncThunks_1 = asyncThunks; _i < asyncThunks_1.length; _i++) {\r\n            var asyncThunk = asyncThunks_1[_i];\r\n            matchers.push(asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled);\r\n        }\r\n        var combinedMatcher = isAnyOf.apply(void 0, matchers);\r\n        return combinedMatcher(action);\r\n    };\r\n}\r\n// src/listenerMiddleware/utils.ts\r\nvar assertFunction = function (func, expected) {\r\n    if (typeof func !== \"function\") {\r\n        throw new TypeError(expected + \" is not a function\");\r\n    }\r\n};\r\nvar noop = function () {\r\n};\r\nvar catchRejection = function (promise, onError) {\r\n    if (onError === void 0) { onError = noop; }\r\n    promise.catch(onError);\r\n    return promise;\r\n};\r\nvar addAbortSignalListener = function (abortSignal, callback) {\r\n    abortSignal.addEventListener(\"abort\", callback, { once: true });\r\n};\r\nvar abortControllerWithReason = function (abortController, reason) {\r\n    var signal = abortController.signal;\r\n    if (signal.aborted) {\r\n        return;\r\n    }\r\n    if (!(\"reason\" in signal)) {\r\n        Object.defineProperty(signal, \"reason\", {\r\n            enumerable: true,\r\n            value: reason,\r\n            configurable: true,\r\n            writable: true\r\n        });\r\n    }\r\n    ;\r\n    abortController.abort(reason);\r\n};\r\n// src/listenerMiddleware/exceptions.ts\r\nvar task = \"task\";\r\nvar listener = \"listener\";\r\nvar completed = \"completed\";\r\nvar cancelled = \"cancelled\";\r\nvar taskCancelled = \"task-\" + cancelled;\r\nvar taskCompleted = \"task-\" + completed;\r\nvar listenerCancelled = listener + \"-\" + cancelled;\r\nvar listenerCompleted = listener + \"-\" + completed;\r\nvar TaskAbortError = /** @class */ (function () {\r\n    function TaskAbortError(code) {\r\n        this.code = code;\r\n        this.name = \"TaskAbortError\";\r\n        this.message = task + \" \" + cancelled + \" (reason: \" + code + \")\";\r\n    }\r\n    return TaskAbortError;\r\n}());\r\n// src/listenerMiddleware/task.ts\r\nvar validateActive = function (signal) {\r\n    if (signal.aborted) {\r\n        throw new TaskAbortError(signal.reason);\r\n    }\r\n};\r\nvar promisifyAbortSignal = function (signal) {\r\n    return catchRejection(new Promise(function (_, reject) {\r\n        var notifyRejection = function () { return reject(new TaskAbortError(signal.reason)); };\r\n        if (signal.aborted) {\r\n            notifyRejection();\r\n        }\r\n        else {\r\n            addAbortSignalListener(signal, notifyRejection);\r\n        }\r\n    }));\r\n};\r\nvar runTask = function (task2, cleanUp) { return __async(void 0, null, function () {\r\n    var value, error_1;\r\n    return __generator(this, function (_c) {\r\n        switch (_c.label) {\r\n            case 0:\r\n                _c.trys.push([0, 3, 4, 5]);\r\n                return [4 /*yield*/, Promise.resolve()];\r\n            case 1:\r\n                _c.sent();\r\n                return [4 /*yield*/, task2()];\r\n            case 2:\r\n                value = _c.sent();\r\n                return [2 /*return*/, {\r\n                        status: \"ok\",\r\n                        value: value\r\n                    }];\r\n            case 3:\r\n                error_1 = _c.sent();\r\n                return [2 /*return*/, {\r\n                        status: error_1 instanceof TaskAbortError ? \"cancelled\" : \"rejected\",\r\n                        error: error_1\r\n                    }];\r\n            case 4:\r\n                cleanUp == null ? void 0 : cleanUp();\r\n                return [7 /*endfinally*/];\r\n            case 5: return [2 /*return*/];\r\n        }\r\n    });\r\n}); };\r\nvar createPause = function (signal) {\r\n    return function (promise) {\r\n        return catchRejection(Promise.race([promisifyAbortSignal(signal), promise]).then(function (output) {\r\n            validateActive(signal);\r\n            return output;\r\n        }));\r\n    };\r\n};\r\nvar createDelay = function (signal) {\r\n    var pause = createPause(signal);\r\n    return function (timeoutMs) {\r\n        return pause(new Promise(function (resolve) { return setTimeout(resolve, timeoutMs); }));\r\n    };\r\n};\r\n// src/listenerMiddleware/index.ts\r\nvar redux_toolkit_esm_assign = Object.assign;\r\nvar INTERNAL_NIL_TOKEN = {};\r\nvar alm = \"listenerMiddleware\";\r\nvar createFork = function (parentAbortSignal) {\r\n    var linkControllers = function (controller) { return addAbortSignalListener(parentAbortSignal, function () { return abortControllerWithReason(controller, parentAbortSignal.reason); }); };\r\n    return function (taskExecutor) {\r\n        assertFunction(taskExecutor, \"taskExecutor\");\r\n        var childAbortController = new AbortController();\r\n        linkControllers(childAbortController);\r\n        var result = runTask(function () { return __async(void 0, null, function () {\r\n            var result2;\r\n            return __generator(this, function (_c) {\r\n                switch (_c.label) {\r\n                    case 0:\r\n                        validateActive(parentAbortSignal);\r\n                        validateActive(childAbortController.signal);\r\n                        return [4 /*yield*/, taskExecutor({\r\n                                pause: createPause(childAbortController.signal),\r\n                                delay: createDelay(childAbortController.signal),\r\n                                signal: childAbortController.signal\r\n                            })];\r\n                    case 1:\r\n                        result2 = _c.sent();\r\n                        validateActive(childAbortController.signal);\r\n                        return [2 /*return*/, result2];\r\n                }\r\n            });\r\n        }); }, function () { return abortControllerWithReason(childAbortController, taskCompleted); });\r\n        return {\r\n            result: createPause(parentAbortSignal)(result),\r\n            cancel: function () {\r\n                abortControllerWithReason(childAbortController, taskCancelled);\r\n            }\r\n        };\r\n    };\r\n};\r\nvar createTakePattern = function (startListening, signal) {\r\n    var take = function (predicate, timeout) { return __async(void 0, null, function () {\r\n        var unsubscribe, tuplePromise, promises, output;\r\n        return __generator(this, function (_c) {\r\n            switch (_c.label) {\r\n                case 0:\r\n                    validateActive(signal);\r\n                    unsubscribe = function () {\r\n                    };\r\n                    tuplePromise = new Promise(function (resolve) {\r\n                        unsubscribe = startListening({\r\n                            predicate: predicate,\r\n                            effect: function (action, listenerApi) {\r\n                                listenerApi.unsubscribe();\r\n                                resolve([\r\n                                    action,\r\n                                    listenerApi.getState(),\r\n                                    listenerApi.getOriginalState()\r\n                                ]);\r\n                            }\r\n                        });\r\n                    });\r\n                    promises = [\r\n                        promisifyAbortSignal(signal),\r\n                        tuplePromise\r\n                    ];\r\n                    if (timeout != null) {\r\n                        promises.push(new Promise(function (resolve) { return setTimeout(resolve, timeout, null); }));\r\n                    }\r\n                    _c.label = 1;\r\n                case 1:\r\n                    _c.trys.push([1, , 3, 4]);\r\n                    return [4 /*yield*/, Promise.race(promises)];\r\n                case 2:\r\n                    output = _c.sent();\r\n                    validateActive(signal);\r\n                    return [2 /*return*/, output];\r\n                case 3:\r\n                    unsubscribe();\r\n                    return [7 /*endfinally*/];\r\n                case 4: return [2 /*return*/];\r\n            }\r\n        });\r\n    }); };\r\n    return function (predicate, timeout) { return catchRejection(take(predicate, timeout)); };\r\n};\r\nvar getListenerEntryPropsFrom = function (options) {\r\n    var type = options.type, actionCreator = options.actionCreator, matcher = options.matcher, predicate = options.predicate, effect = options.effect;\r\n    if (type) {\r\n        predicate = createAction(type).match;\r\n    }\r\n    else if (actionCreator) {\r\n        type = actionCreator.type;\r\n        predicate = actionCreator.match;\r\n    }\r\n    else if (matcher) {\r\n        predicate = matcher;\r\n    }\r\n    else if (predicate) {\r\n    }\r\n    else {\r\n        throw new Error(\"Creating or removing a listener requires one of the known fields for matching an action\");\r\n    }\r\n    assertFunction(effect, \"options.listener\");\r\n    return { predicate: predicate, type: type, effect: effect };\r\n};\r\nvar createListenerEntry = function (options) {\r\n    var _c = getListenerEntryPropsFrom(options), type = _c.type, predicate = _c.predicate, effect = _c.effect;\r\n    var id = nanoid();\r\n    var entry = {\r\n        id: id,\r\n        effect: effect,\r\n        type: type,\r\n        predicate: predicate,\r\n        pending: new Set(),\r\n        unsubscribe: function () {\r\n            throw new Error(\"Unsubscribe not initialized\");\r\n        }\r\n    };\r\n    return entry;\r\n};\r\nvar createClearListenerMiddleware = function (listenerMap) {\r\n    return function () {\r\n        listenerMap.forEach(cancelActiveListeners);\r\n        listenerMap.clear();\r\n    };\r\n};\r\nvar safelyNotifyError = function (errorHandler, errorToNotify, errorInfo) {\r\n    try {\r\n        errorHandler(errorToNotify, errorInfo);\r\n    }\r\n    catch (errorHandlerError) {\r\n        setTimeout(function () {\r\n            throw errorHandlerError;\r\n        }, 0);\r\n    }\r\n};\r\nvar addListener = createAction(alm + \"/add\");\r\nvar clearAllListeners = createAction(alm + \"/removeAll\");\r\nvar removeListener = createAction(alm + \"/remove\");\r\nvar defaultErrorHandler = function () {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    console.error.apply(console, __spreadArray([alm + \"/error\"], args));\r\n};\r\nvar cancelActiveListeners = function (entry) {\r\n    entry.pending.forEach(function (controller) {\r\n        abortControllerWithReason(controller, listenerCancelled);\r\n    });\r\n};\r\nfunction createListenerMiddleware(middlewareOptions) {\r\n    var _this = this;\r\n    if (middlewareOptions === void 0) { middlewareOptions = {}; }\r\n    var listenerMap = new Map();\r\n    var extra = middlewareOptions.extra, _c = middlewareOptions.onError, onError = _c === void 0 ? defaultErrorHandler : _c;\r\n    assertFunction(onError, \"onError\");\r\n    var insertEntry = function (entry) {\r\n        entry.unsubscribe = function () { return listenerMap.delete(entry.id); };\r\n        listenerMap.set(entry.id, entry);\r\n        return function (cancelOptions) {\r\n            entry.unsubscribe();\r\n            if (cancelOptions == null ? void 0 : cancelOptions.cancelActive) {\r\n                cancelActiveListeners(entry);\r\n            }\r\n        };\r\n    };\r\n    var findListenerEntry = function (comparator) {\r\n        for (var _i = 0, _c = Array.from(listenerMap.values()); _i < _c.length; _i++) {\r\n            var entry = _c[_i];\r\n            if (comparator(entry)) {\r\n                return entry;\r\n            }\r\n        }\r\n        return void 0;\r\n    };\r\n    var startListening = function (options) {\r\n        var entry = findListenerEntry(function (existingEntry) { return existingEntry.effect === options.effect; });\r\n        if (!entry) {\r\n            entry = createListenerEntry(options);\r\n        }\r\n        return insertEntry(entry);\r\n    };\r\n    var stopListening = function (options) {\r\n        var _c = getListenerEntryPropsFrom(options), type = _c.type, effect = _c.effect, predicate = _c.predicate;\r\n        var entry = findListenerEntry(function (entry2) {\r\n            var matchPredicateOrType = typeof type === \"string\" ? entry2.type === type : entry2.predicate === predicate;\r\n            return matchPredicateOrType && entry2.effect === effect;\r\n        });\r\n        if (entry) {\r\n            entry.unsubscribe();\r\n            if (options.cancelActive) {\r\n                cancelActiveListeners(entry);\r\n            }\r\n        }\r\n        return !!entry;\r\n    };\r\n    var notifyListener = function (entry, action, api, getOriginalState) { return __async(_this, null, function () {\r\n        var internalTaskController, take, listenerError_1;\r\n        return __generator(this, function (_c) {\r\n            switch (_c.label) {\r\n                case 0:\r\n                    internalTaskController = new AbortController();\r\n                    take = createTakePattern(startListening, internalTaskController.signal);\r\n                    _c.label = 1;\r\n                case 1:\r\n                    _c.trys.push([1, 3, 4, 5]);\r\n                    entry.pending.add(internalTaskController);\r\n                    return [4 /*yield*/, Promise.resolve(entry.effect(action, redux_toolkit_esm_assign({}, api, {\r\n                            getOriginalState: getOriginalState,\r\n                            condition: function (predicate, timeout) { return take(predicate, timeout).then(Boolean); },\r\n                            take: take,\r\n                            delay: createDelay(internalTaskController.signal),\r\n                            pause: createPause(internalTaskController.signal),\r\n                            extra: extra,\r\n                            signal: internalTaskController.signal,\r\n                            fork: createFork(internalTaskController.signal),\r\n                            unsubscribe: entry.unsubscribe,\r\n                            subscribe: function () {\r\n                                listenerMap.set(entry.id, entry);\r\n                            },\r\n                            cancelActiveListeners: function () {\r\n                                entry.pending.forEach(function (controller, _, set) {\r\n                                    if (controller !== internalTaskController) {\r\n                                        abortControllerWithReason(controller, listenerCancelled);\r\n                                        set.delete(controller);\r\n                                    }\r\n                                });\r\n                            }\r\n                        })))];\r\n                case 2:\r\n                    _c.sent();\r\n                    return [3 /*break*/, 5];\r\n                case 3:\r\n                    listenerError_1 = _c.sent();\r\n                    if (!(listenerError_1 instanceof TaskAbortError)) {\r\n                        safelyNotifyError(onError, listenerError_1, {\r\n                            raisedBy: \"effect\"\r\n                        });\r\n                    }\r\n                    return [3 /*break*/, 5];\r\n                case 4:\r\n                    abortControllerWithReason(internalTaskController, listenerCompleted);\r\n                    entry.pending.delete(internalTaskController);\r\n                    return [7 /*endfinally*/];\r\n                case 5: return [2 /*return*/];\r\n            }\r\n        });\r\n    }); };\r\n    var clearListenerMiddleware = createClearListenerMiddleware(listenerMap);\r\n    var middleware = function (api) { return function (next) { return function (action) {\r\n        if (addListener.match(action)) {\r\n            return startListening(action.payload);\r\n        }\r\n        if (clearAllListeners.match(action)) {\r\n            clearListenerMiddleware();\r\n            return;\r\n        }\r\n        if (removeListener.match(action)) {\r\n            return stopListening(action.payload);\r\n        }\r\n        var originalState = api.getState();\r\n        var getOriginalState = function () {\r\n            if (originalState === INTERNAL_NIL_TOKEN) {\r\n                throw new Error(alm + \": getOriginalState can only be called synchronously\");\r\n            }\r\n            return originalState;\r\n        };\r\n        var result;\r\n        try {\r\n            result = next(action);\r\n            if (listenerMap.size > 0) {\r\n                var currentState = api.getState();\r\n                var listenerEntries = Array.from(listenerMap.values());\r\n                for (var _i = 0, listenerEntries_1 = listenerEntries; _i < listenerEntries_1.length; _i++) {\r\n                    var entry = listenerEntries_1[_i];\r\n                    var runListener = false;\r\n                    try {\r\n                        runListener = entry.predicate(action, currentState, originalState);\r\n                    }\r\n                    catch (predicateError) {\r\n                        runListener = false;\r\n                        safelyNotifyError(onError, predicateError, {\r\n                            raisedBy: \"predicate\"\r\n                        });\r\n                    }\r\n                    if (!runListener) {\r\n                        continue;\r\n                    }\r\n                    notifyListener(entry, action, api, getOriginalState);\r\n                }\r\n            }\r\n        }\r\n        finally {\r\n            originalState = INTERNAL_NIL_TOKEN;\r\n        }\r\n        return result;\r\n    }; }; };\r\n    return {\r\n        middleware: middleware,\r\n        startListening: startListening,\r\n        stopListening: stopListening,\r\n        clearListeners: clearListenerMiddleware\r\n    };\r\n}\r\n// src/index.ts\r\nimmer_esm_N();\r\n\r\n//# sourceMappingURL=redux-toolkit.esm.js.map\n;// CONCATENATED MODULE: ./node_modules/@redux-saga/symbols/dist/redux-saga-symbols.esm.js\nvar createSymbol = function createSymbol(name) {\n  return \"@@redux-saga/\" + name;\n};\n\nvar CANCEL =\n/*#__PURE__*/\ncreateSymbol('CANCEL_PROMISE');\nvar CHANNEL_END_TYPE =\n/*#__PURE__*/\ncreateSymbol('CHANNEL_END');\nvar redux_saga_symbols_esm_IO =\n/*#__PURE__*/\ncreateSymbol('IO');\nvar MATCH =\n/*#__PURE__*/\ncreateSymbol('MATCH');\nvar MULTICAST =\n/*#__PURE__*/\ncreateSymbol('MULTICAST');\nvar redux_saga_symbols_esm_SAGA_ACTION =\n/*#__PURE__*/\ncreateSymbol('SAGA_ACTION');\nvar redux_saga_symbols_esm_SELF_CANCELLATION =\n/*#__PURE__*/\ncreateSymbol('SELF_CANCELLATION');\nvar redux_saga_symbols_esm_TASK =\n/*#__PURE__*/\ncreateSymbol('TASK');\nvar TASK_CANCEL =\n/*#__PURE__*/\ncreateSymbol('TASK_CANCEL');\nvar TERMINATE =\n/*#__PURE__*/\ncreateSymbol('TERMINATE');\nvar SAGA_LOCATION =\n/*#__PURE__*/\ncreateSymbol('LOCATION');\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@redux-saga/is/dist/redux-saga-is.esm.js\n\n\nvar undef = function undef(v) {\n  return v === null || v === undefined;\n};\nvar redux_saga_is_esm_notUndef = function notUndef(v) {\n  return v !== null && v !== undefined;\n};\nvar redux_saga_is_esm_func = function func(f) {\n  return typeof f === 'function';\n};\nvar number = function number(n) {\n  return typeof n === 'number';\n};\nvar redux_saga_is_esm_string = function string(s) {\n  return typeof s === 'string';\n};\nvar redux_saga_is_esm_array = Array.isArray;\nvar redux_saga_is_esm_object = function object(obj) {\n  return obj && !redux_saga_is_esm_array(obj) && typeof obj === 'object';\n};\nvar promise = function promise(p) {\n  return p && redux_saga_is_esm_func(p.then);\n};\nvar iterator = function iterator(it) {\n  return it && redux_saga_is_esm_func(it.next) && redux_saga_is_esm_func(it.throw);\n};\nvar iterable = function iterable(it) {\n  return it && redux_saga_is_esm_func(Symbol) ? redux_saga_is_esm_func(it[Symbol.iterator]) : redux_saga_is_esm_array(it);\n};\nvar redux_saga_is_esm_task = function task(t) {\n  return t && t[TASK];\n};\nvar sagaAction = function sagaAction(a) {\n  return Boolean(a && a[SAGA_ACTION]);\n};\nvar observable = function observable(ob) {\n  return ob && redux_saga_is_esm_func(ob.subscribe);\n};\nvar buffer = function buffer(buf) {\n  return buf && redux_saga_is_esm_func(buf.isEmpty) && redux_saga_is_esm_func(buf.take) && redux_saga_is_esm_func(buf.put);\n};\nvar pattern = function pattern(pat) {\n  return pat && (redux_saga_is_esm_string(pat) || symbol(pat) || redux_saga_is_esm_func(pat) || redux_saga_is_esm_array(pat) && pat.every(pattern));\n};\nvar channel = function channel(ch) {\n  return ch && redux_saga_is_esm_func(ch.take) && redux_saga_is_esm_func(ch.close);\n};\nvar stringableFunc = function stringableFunc(f) {\n  return redux_saga_is_esm_func(f) && f.hasOwnProperty('toString');\n};\nvar symbol = function symbol(sym) {\n  return Boolean(sym) && typeof Symbol === 'function' && sym.constructor === Symbol && sym !== Symbol.prototype;\n};\nvar multicast = function multicast(ch) {\n  return channel(ch) && ch[MULTICAST];\n};\nvar redux_saga_is_esm_effect = function effect(eff) {\n  return eff && eff[IO];\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@redux-saga/delay-p/dist/redux-saga-delay-p.esm.js\n\n\nfunction delayP(ms, val) {\n  if (val === void 0) {\n    val = true;\n  }\n\n  var timeoutId;\n  var promise = new Promise(function (resolve) {\n    timeoutId = setTimeout(resolve, ms, val);\n  });\n\n  promise[CANCEL] = function () {\n    clearTimeout(timeoutId);\n  };\n\n  return promise;\n}\n\n/* harmony default export */ const redux_saga_delay_p_esm = (delayP);\n\n;// CONCATENATED MODULE: ./node_modules/@redux-saga/core/dist/io-6de156f3.js\n\n\n\n\n\nvar konst = function konst(v) {\n  return function () {\n    return v;\n  };\n};\nvar kTrue =\n/*#__PURE__*/\nkonst(true);\n\nvar io_6de156f3_noop = function noop() {};\n\nif (false) {}\nvar identity = function identity(v) {\n  return v;\n};\nvar hasSymbol = typeof Symbol === 'function';\nvar asyncIteratorSymbol = hasSymbol && Symbol.asyncIterator ? Symbol.asyncIterator : '@@asyncIterator';\nfunction io_6de156f3_check(value, predicate, error) {\n  if (!predicate(value)) {\n    throw new Error(error);\n  }\n}\nvar assignWithSymbols = function assignWithSymbols(target, source) {\n  extends_extends(target, source);\n\n  if (Object.getOwnPropertySymbols) {\n    Object.getOwnPropertySymbols(source).forEach(function (s) {\n      target[s] = source[s];\n    });\n  }\n};\nvar flatMap = function flatMap(mapper, arr) {\n  var _ref;\n\n  return (_ref = []).concat.apply(_ref, arr.map(mapper));\n};\nfunction io_6de156f3_remove(array, item) {\n  var index = array.indexOf(item);\n\n  if (index >= 0) {\n    array.splice(index, 1);\n  }\n}\nfunction io_6de156f3_once(fn) {\n  var called = false;\n  return function () {\n    if (called) {\n      return;\n    }\n\n    called = true;\n    fn();\n  };\n}\n\nvar kThrow = function kThrow(err) {\n  throw err;\n};\n\nvar kReturn = function kReturn(value) {\n  return {\n    value: value,\n    done: true\n  };\n};\n\nfunction makeIterator(next, thro, name) {\n  if (thro === void 0) {\n    thro = kThrow;\n  }\n\n  if (name === void 0) {\n    name = 'iterator';\n  }\n\n  var iterator = {\n    meta: {\n      name: name\n    },\n    next: next,\n    throw: thro,\n    return: kReturn,\n    isSagaIterator: true\n  };\n\n  if (typeof Symbol !== 'undefined') {\n    iterator[Symbol.iterator] = function () {\n      return iterator;\n    };\n  }\n\n  return iterator;\n}\nfunction logError(error, _ref2) {\n  var sagaStack = _ref2.sagaStack;\n\n  /*eslint-disable no-console*/\n  console.error(error);\n  console.error(sagaStack);\n}\nvar internalErr = function internalErr(err) {\n  return new Error(\"\\n  redux-saga: Error checking hooks detected an inconsistent state. This is likely a bug\\n  in redux-saga code and not yours. Thanks for reporting this in the project's github repo.\\n  Error: \" + err + \"\\n\");\n};\nvar createSetContextWarning = function createSetContextWarning(ctx, props) {\n  return (ctx ? ctx + '.' : '') + \"setContext(props): argument \" + props + \" is not a plain object\";\n};\nvar FROZEN_ACTION_ERROR = \"You can't put (a.k.a. dispatch from saga) frozen actions.\\nWe have to define a special non-enumerable property on those actions for scheduling purposes.\\nOtherwise you wouldn't be able to communicate properly between sagas & other subscribers (action ordering would become far less predictable).\\nIf you are using redux and you care about this behaviour (frozen actions),\\nthen you might want to switch to freezing actions in a middleware rather than in action creator.\\nExample implementation:\\n\\nconst freezeActions = store => next => action => next(Object.freeze(action))\\n\"; // creates empty, but not-holey array\n\nvar createEmptyArray = function createEmptyArray(n) {\n  return Array.apply(null, new Array(n));\n};\nvar wrapSagaDispatch = function wrapSagaDispatch(dispatch) {\n  return function (action) {\n    if (false) {}\n\n    return dispatch(Object.defineProperty(action, redux_saga_symbols_esm_SAGA_ACTION, {\n      value: true\n    }));\n  };\n};\nvar shouldTerminate = function shouldTerminate(res) {\n  return res === TERMINATE;\n};\nvar shouldCancel = function shouldCancel(res) {\n  return res === TASK_CANCEL;\n};\nvar shouldComplete = function shouldComplete(res) {\n  return shouldTerminate(res) || shouldCancel(res);\n};\nfunction createAllStyleChildCallbacks(shape, parentCallback) {\n  var keys = Object.keys(shape);\n  var totalCount = keys.length;\n\n  if (false) {}\n\n  var completedCount = 0;\n  var completed;\n  var results = redux_saga_is_esm_array(shape) ? createEmptyArray(totalCount) : {};\n  var childCallbacks = {};\n\n  function checkEnd() {\n    if (completedCount === totalCount) {\n      completed = true;\n      parentCallback(results);\n    }\n  }\n\n  keys.forEach(function (key) {\n    var chCbAtKey = function chCbAtKey(res, isErr) {\n      if (completed) {\n        return;\n      }\n\n      if (isErr || shouldComplete(res)) {\n        parentCallback.cancel();\n        parentCallback(res, isErr);\n      } else {\n        results[key] = res;\n        completedCount++;\n        checkEnd();\n      }\n    };\n\n    chCbAtKey.cancel = io_6de156f3_noop;\n    childCallbacks[key] = chCbAtKey;\n  });\n\n  parentCallback.cancel = function () {\n    if (!completed) {\n      completed = true;\n      keys.forEach(function (key) {\n        return childCallbacks[key].cancel();\n      });\n    }\n  };\n\n  return childCallbacks;\n}\nfunction getMetaInfo(fn) {\n  return {\n    name: fn.name || 'anonymous',\n    location: getLocation(fn)\n  };\n}\nfunction getLocation(instrumented) {\n  return instrumented[SAGA_LOCATION];\n}\n\nvar BUFFER_OVERFLOW = \"Channel's Buffer overflow!\";\nvar ON_OVERFLOW_THROW = 1;\nvar ON_OVERFLOW_DROP = 2;\nvar ON_OVERFLOW_SLIDE = 3;\nvar ON_OVERFLOW_EXPAND = 4;\nvar zeroBuffer = {\n  isEmpty: kTrue,\n  put: io_6de156f3_noop,\n  take: io_6de156f3_noop\n};\n\nfunction ringBuffer(limit, overflowAction) {\n  if (limit === void 0) {\n    limit = 10;\n  }\n\n  var arr = new Array(limit);\n  var length = 0;\n  var pushIndex = 0;\n  var popIndex = 0;\n\n  var push = function push(it) {\n    arr[pushIndex] = it;\n    pushIndex = (pushIndex + 1) % limit;\n    length++;\n  };\n\n  var take = function take() {\n    if (length != 0) {\n      var it = arr[popIndex];\n      arr[popIndex] = null;\n      length--;\n      popIndex = (popIndex + 1) % limit;\n      return it;\n    }\n  };\n\n  var flush = function flush() {\n    var items = [];\n\n    while (length) {\n      items.push(take());\n    }\n\n    return items;\n  };\n\n  return {\n    isEmpty: function isEmpty() {\n      return length == 0;\n    },\n    put: function put(it) {\n      if (length < limit) {\n        push(it);\n      } else {\n        var doubledLimit;\n\n        switch (overflowAction) {\n          case ON_OVERFLOW_THROW:\n            throw new Error(BUFFER_OVERFLOW);\n\n          case ON_OVERFLOW_SLIDE:\n            arr[pushIndex] = it;\n            pushIndex = (pushIndex + 1) % limit;\n            popIndex = pushIndex;\n            break;\n\n          case ON_OVERFLOW_EXPAND:\n            doubledLimit = 2 * limit;\n            arr = flush();\n            length = arr.length;\n            pushIndex = arr.length;\n            popIndex = 0;\n            arr.length = doubledLimit;\n            limit = doubledLimit;\n            push(it);\n            break;\n\n          default: // DROP\n\n        }\n      }\n    },\n    take: take,\n    flush: flush\n  };\n}\n\nvar io_6de156f3_none = function none() {\n  return zeroBuffer;\n};\nvar fixed = function fixed(limit) {\n  return ringBuffer(limit, ON_OVERFLOW_THROW);\n};\nvar dropping = function dropping(limit) {\n  return ringBuffer(limit, ON_OVERFLOW_DROP);\n};\nvar io_6de156f3_sliding = function sliding(limit) {\n  return ringBuffer(limit, ON_OVERFLOW_SLIDE);\n};\nvar expanding = function expanding(initialSize) {\n  return ringBuffer(initialSize, ON_OVERFLOW_EXPAND);\n};\n\nvar buffers = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  none: io_6de156f3_none,\n  fixed: fixed,\n  dropping: dropping,\n  sliding: io_6de156f3_sliding,\n  expanding: expanding\n});\n\nvar TAKE = 'TAKE';\nvar PUT = 'PUT';\nvar ALL = 'ALL';\nvar RACE = 'RACE';\nvar CALL = 'CALL';\nvar CPS = 'CPS';\nvar FORK = 'FORK';\nvar JOIN = 'JOIN';\nvar io_6de156f3_CANCEL = 'CANCEL';\nvar SELECT = 'SELECT';\nvar ACTION_CHANNEL = 'ACTION_CHANNEL';\nvar CANCELLED = 'CANCELLED';\nvar FLUSH = 'FLUSH';\nvar GET_CONTEXT = 'GET_CONTEXT';\nvar SET_CONTEXT = 'SET_CONTEXT';\n\nvar effectTypes = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  TAKE: TAKE,\n  PUT: PUT,\n  ALL: ALL,\n  RACE: RACE,\n  CALL: CALL,\n  CPS: CPS,\n  FORK: FORK,\n  JOIN: JOIN,\n  CANCEL: io_6de156f3_CANCEL,\n  SELECT: SELECT,\n  ACTION_CHANNEL: ACTION_CHANNEL,\n  CANCELLED: CANCELLED,\n  FLUSH: FLUSH,\n  GET_CONTEXT: GET_CONTEXT,\n  SET_CONTEXT: SET_CONTEXT\n});\n\nvar TEST_HINT = '\\n(HINT: if you are getting these errors in tests, consider using createMockTask from @redux-saga/testing-utils)';\n\nvar makeEffect = function makeEffect(type, payload) {\n  var _ref;\n\n  return _ref = {}, _ref[redux_saga_symbols_esm_IO] = true, _ref.combinator = false, _ref.type = type, _ref.payload = payload, _ref;\n};\n\nvar isForkEffect = function isForkEffect(eff) {\n  return effect(eff) && eff.type === FORK;\n};\n\nvar detach = function detach(eff) {\n  if (false) {}\n\n  return makeEffect(FORK, _extends({}, eff.payload, {\n    detached: true\n  }));\n};\nfunction io_6de156f3_take(patternOrChannel, multicastPattern) {\n  if (patternOrChannel === void 0) {\n    patternOrChannel = '*';\n  }\n\n  if (false) {}\n\n  if (pattern(patternOrChannel)) {\n    return makeEffect(TAKE, {\n      pattern: patternOrChannel\n    });\n  }\n\n  if (multicast(patternOrChannel) && redux_saga_is_esm_notUndef(multicastPattern) && pattern(multicastPattern)) {\n    return makeEffect(TAKE, {\n      channel: patternOrChannel,\n      pattern: multicastPattern\n    });\n  }\n\n  if (channel(patternOrChannel)) {\n    return makeEffect(TAKE, {\n      channel: patternOrChannel\n    });\n  }\n\n  if (false) {}\n}\nvar takeMaybe = function takeMaybe() {\n  var eff = io_6de156f3_take.apply(void 0, arguments);\n  eff.payload.maybe = true;\n  return eff;\n};\nfunction put(channel$1, action) {\n  if (false) {}\n\n  if (undef(action)) {\n    action = channel$1; // `undefined` instead of `null` to make default parameter work\n\n    channel$1 = undefined;\n  }\n\n  return makeEffect(PUT, {\n    channel: channel$1,\n    action: action\n  });\n}\nvar putResolve = function putResolve() {\n  var eff = put.apply(void 0, arguments);\n  eff.payload.resolve = true;\n  return eff;\n};\nfunction io_6de156f3_all(effects) {\n  var eff = makeEffect(ALL, effects);\n  eff.combinator = true;\n  return eff;\n}\nfunction io_6de156f3_race(effects) {\n  var eff = makeEffect(RACE, effects);\n  eff.combinator = true;\n  return eff;\n} // this match getFnCallDescriptor logic\n\nvar validateFnDescriptor = function validateFnDescriptor(effectName, fnDescriptor) {\n  io_6de156f3_check(fnDescriptor, notUndef, effectName + \": argument fn is undefined or null\");\n\n  if (func(fnDescriptor)) {\n    return;\n  }\n\n  var context = null;\n  var fn;\n\n  if (array(fnDescriptor)) {\n    context = fnDescriptor[0];\n    fn = fnDescriptor[1];\n    io_6de156f3_check(fn, notUndef, effectName + \": argument of type [context, fn] has undefined or null `fn`\");\n  } else if (object(fnDescriptor)) {\n    context = fnDescriptor.context;\n    fn = fnDescriptor.fn;\n    io_6de156f3_check(fn, notUndef, effectName + \": argument of type {context, fn} has undefined or null `fn`\");\n  } else {\n    io_6de156f3_check(fnDescriptor, func, effectName + \": argument fn is not function\");\n    return;\n  }\n\n  if (context && string(fn)) {\n    io_6de156f3_check(context[fn], func, effectName + \": context arguments has no such method - \\\"\" + fn + \"\\\"\");\n    return;\n  }\n\n  io_6de156f3_check(fn, func, effectName + \": unpacked fn argument (from [context, fn] or {context, fn}) is not a function\");\n};\n\nfunction getFnCallDescriptor(fnDescriptor, args) {\n  var context = null;\n  var fn;\n\n  if (redux_saga_is_esm_func(fnDescriptor)) {\n    fn = fnDescriptor;\n  } else {\n    if (redux_saga_is_esm_array(fnDescriptor)) {\n      context = fnDescriptor[0];\n      fn = fnDescriptor[1];\n    } else {\n      context = fnDescriptor.context;\n      fn = fnDescriptor.fn;\n    }\n\n    if (context && redux_saga_is_esm_string(fn) && redux_saga_is_esm_func(context[fn])) {\n      fn = context[fn];\n    }\n  }\n\n  return {\n    context: context,\n    fn: fn,\n    args: args\n  };\n}\n\nvar isNotDelayEffect = function isNotDelayEffect(fn) {\n  return fn !== io_6de156f3_delay;\n};\n\nfunction io_6de156f3_call(fnDescriptor) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  if (false) { var arg0; }\n\n  return makeEffect(CALL, getFnCallDescriptor(fnDescriptor, args));\n}\nfunction apply(context, fn, args) {\n  if (args === void 0) {\n    args = [];\n  }\n\n  var fnDescriptor = [context, fn];\n\n  if (false) {}\n\n  return makeEffect(CALL, getFnCallDescriptor([context, fn], args));\n}\nfunction cps(fnDescriptor) {\n  if (false) {}\n\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n\n  return makeEffect(CPS, getFnCallDescriptor(fnDescriptor, args));\n}\nfunction io_6de156f3_fork(fnDescriptor) {\n  if (false) {}\n\n  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    args[_key3 - 1] = arguments[_key3];\n  }\n\n  return makeEffect(FORK, getFnCallDescriptor(fnDescriptor, args));\n}\nfunction spawn(fnDescriptor) {\n  if (false) {}\n\n  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    args[_key4 - 1] = arguments[_key4];\n  }\n\n  return detach(io_6de156f3_fork.apply(void 0, [fnDescriptor].concat(args)));\n}\nfunction join(taskOrTasks) {\n  if (false) {}\n\n  return makeEffect(JOIN, taskOrTasks);\n}\nfunction io_6de156f3_cancel(taskOrTasks) {\n  if (taskOrTasks === void 0) {\n    taskOrTasks = SELF_CANCELLATION;\n  }\n\n  if (false) {}\n\n  return makeEffect(io_6de156f3_CANCEL, taskOrTasks);\n}\nfunction io_6de156f3_select(selector) {\n  if (selector === void 0) {\n    selector = identity;\n  }\n\n  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n    args[_key5 - 1] = arguments[_key5];\n  }\n\n  if (false) {}\n\n  return makeEffect(SELECT, {\n    selector: selector,\n    args: args\n  });\n}\n/**\n  channel(pattern, [buffer])    => creates a proxy channel for store actions\n**/\n\nfunction io_6de156f3_actionChannel(pattern$1, buffer$1) {\n  if (false) {}\n\n  return makeEffect(ACTION_CHANNEL, {\n    pattern: pattern$1,\n    buffer: buffer$1\n  });\n}\nfunction io_6de156f3_cancelled() {\n  return makeEffect(CANCELLED, {});\n}\nfunction flush(channel$1) {\n  if (false) {}\n\n  return makeEffect(FLUSH, channel$1);\n}\nfunction getContext(prop) {\n  if (false) {}\n\n  return makeEffect(GET_CONTEXT, prop);\n}\nfunction setContext(props) {\n  if (false) {}\n\n  return makeEffect(SET_CONTEXT, props);\n}\nvar io_6de156f3_delay =\n/*#__PURE__*/\nio_6de156f3_call.bind(null, redux_saga_delay_p_esm);\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@redux-saga/deferred/dist/redux-saga-deferred.esm.js\nfunction deferred() {\n  var def = {};\n  def.promise = new Promise(function (resolve, reject) {\n    def.resolve = resolve;\n    def.reject = reject;\n  });\n  return def;\n}\nfunction arrayOfDeferred(length) {\n  var arr = [];\n\n  for (var i = 0; i < length; i++) {\n    arr.push(deferred());\n  }\n\n  return arr;\n}\n\n/* harmony default export */ const redux_saga_deferred_esm = (deferred);\n\n\n;// CONCATENATED MODULE: ./node_modules/@redux-saga/core/dist/redux-saga-core.esm.js\n\n\n\n\n\n\n\n\n\n\n\nvar queue = [];\n/**\n  Variable to hold a counting semaphore\n  - Incrementing adds a lock and puts the scheduler in a `suspended` state (if it's not\n    already suspended)\n  - Decrementing releases a lock. Zero locks puts the scheduler in a `released` state. This\n    triggers flushing the queued tasks.\n**/\n\nvar semaphore = 0;\n/**\n  Executes a task 'atomically'. Tasks scheduled during this execution will be queued\n  and flushed after this task has finished (assuming the scheduler endup in a released\n  state).\n**/\n\nfunction exec(task) {\n  try {\n    suspend();\n    task();\n  } finally {\n    release();\n  }\n}\n/**\n  Executes or queues a task depending on the state of the scheduler (`suspended` or `released`)\n**/\n\n\nfunction asap(task) {\n  queue.push(task);\n\n  if (!semaphore) {\n    suspend();\n    redux_saga_core_esm_flush();\n  }\n}\n/**\n * Puts the scheduler in a `suspended` state and executes a task immediately.\n */\n\nfunction immediately(task) {\n  try {\n    suspend();\n    return task();\n  } finally {\n    redux_saga_core_esm_flush();\n  }\n}\n/**\n  Puts the scheduler in a `suspended` state. Scheduled tasks will be queued until the\n  scheduler is released.\n**/\n\nfunction suspend() {\n  semaphore++;\n}\n/**\n  Puts the scheduler in a `released` state.\n**/\n\n\nfunction release() {\n  semaphore--;\n}\n/**\n  Releases the current lock. Executes all queued tasks if the scheduler is in the released state.\n**/\n\n\nfunction redux_saga_core_esm_flush() {\n  release();\n  var task;\n\n  while (!semaphore && (task = queue.shift()) !== undefined) {\n    exec(task);\n  }\n}\n\nvar redux_saga_core_esm_array = function array(patterns) {\n  return function (input) {\n    return patterns.some(function (p) {\n      return matcher(p)(input);\n    });\n  };\n};\nvar predicate = function predicate(_predicate) {\n  return function (input) {\n    return _predicate(input);\n  };\n};\nvar redux_saga_core_esm_string = function string(pattern) {\n  return function (input) {\n    return input.type === String(pattern);\n  };\n};\nvar redux_saga_core_esm_symbol = function symbol(pattern) {\n  return function (input) {\n    return input.type === pattern;\n  };\n};\nvar wildcard = function wildcard() {\n  return kTrue;\n};\nfunction matcher(pattern) {\n  // prettier-ignore\n  var matcherCreator = pattern === '*' ? wildcard : redux_saga_is_esm_string(pattern) ? redux_saga_core_esm_string : redux_saga_is_esm_array(pattern) ? redux_saga_core_esm_array : stringableFunc(pattern) ? redux_saga_core_esm_string : redux_saga_is_esm_func(pattern) ? predicate : symbol(pattern) ? redux_saga_core_esm_symbol : null;\n\n  if (matcherCreator === null) {\n    throw new Error(\"invalid pattern: \" + pattern);\n  }\n\n  return matcherCreator(pattern);\n}\n\nvar END = {\n  type: CHANNEL_END_TYPE\n};\nvar isEnd = function isEnd(a) {\n  return a && a.type === CHANNEL_END_TYPE;\n};\nvar CLOSED_CHANNEL_WITH_TAKERS = 'Cannot have a closed channel with pending takers';\nvar INVALID_BUFFER = 'invalid buffer passed to channel factory function';\nvar UNDEFINED_INPUT_ERROR = \"Saga or channel was provided with an undefined action\\nHints:\\n  - check that your Action Creator returns a non-undefined value\\n  - if the Saga was started using runSaga, check that your subscribe source provides the action to its listeners\";\nfunction redux_saga_core_esm_channel(buffer$1) {\n  if (buffer$1 === void 0) {\n    buffer$1 = expanding();\n  }\n\n  var closed = false;\n  var takers = [];\n\n  if (false) {}\n\n  function checkForbiddenStates() {\n    if (closed && takers.length) {\n      throw internalErr(CLOSED_CHANNEL_WITH_TAKERS);\n    }\n\n    if (takers.length && !buffer$1.isEmpty()) {\n      throw internalErr('Cannot have pending takers with non empty buffer');\n    }\n  }\n\n  function put(input) {\n    if (false) {}\n\n    if (closed) {\n      return;\n    }\n\n    if (takers.length === 0) {\n      return buffer$1.put(input);\n    }\n\n    var cb = takers.shift();\n    cb(input);\n  }\n\n  function take(cb) {\n    if (false) {}\n\n    if (closed && buffer$1.isEmpty()) {\n      cb(END);\n    } else if (!buffer$1.isEmpty()) {\n      cb(buffer$1.take());\n    } else {\n      takers.push(cb);\n\n      cb.cancel = function () {\n        io_6de156f3_remove(takers, cb);\n      };\n    }\n  }\n\n  function flush(cb) {\n    if (false) {}\n\n    if (closed && buffer$1.isEmpty()) {\n      cb(END);\n      return;\n    }\n\n    cb(buffer$1.flush());\n  }\n\n  function close() {\n    if (false) {}\n\n    if (closed) {\n      return;\n    }\n\n    closed = true;\n    var arr = takers;\n    takers = [];\n\n    for (var i = 0, len = arr.length; i < len; i++) {\n      var taker = arr[i];\n      taker(END);\n    }\n  }\n\n  return {\n    take: take,\n    put: put,\n    flush: flush,\n    close: close\n  };\n}\nfunction eventChannel(subscribe, buffer) {\n  if (buffer === void 0) {\n    buffer = none();\n  }\n\n  var closed = false;\n  var unsubscribe;\n  var chan = redux_saga_core_esm_channel(buffer);\n\n  var close = function close() {\n    if (closed) {\n      return;\n    }\n\n    closed = true;\n\n    if (func(unsubscribe)) {\n      unsubscribe();\n    }\n\n    chan.close();\n  };\n\n  unsubscribe = subscribe(function (input) {\n    if (isEnd(input)) {\n      close();\n      return;\n    }\n\n    chan.put(input);\n  });\n\n  if (false) {}\n\n  unsubscribe = once(unsubscribe);\n\n  if (closed) {\n    unsubscribe();\n  }\n\n  return {\n    take: chan.take,\n    flush: chan.flush,\n    close: close\n  };\n}\nfunction multicastChannel() {\n  var _ref;\n\n  var closed = false;\n  var currentTakers = [];\n  var nextTakers = currentTakers;\n\n  function checkForbiddenStates() {\n    if (closed && nextTakers.length) {\n      throw internalErr(CLOSED_CHANNEL_WITH_TAKERS);\n    }\n  }\n\n  var ensureCanMutateNextTakers = function ensureCanMutateNextTakers() {\n    if (nextTakers !== currentTakers) {\n      return;\n    }\n\n    nextTakers = currentTakers.slice();\n  };\n\n  var close = function close() {\n    if (false) {}\n\n    closed = true;\n    var takers = currentTakers = nextTakers;\n    nextTakers = [];\n    takers.forEach(function (taker) {\n      taker(END);\n    });\n  };\n\n  return _ref = {}, _ref[MULTICAST] = true, _ref.put = function put(input) {\n    if (false) {}\n\n    if (closed) {\n      return;\n    }\n\n    if (isEnd(input)) {\n      close();\n      return;\n    }\n\n    var takers = currentTakers = nextTakers;\n\n    for (var i = 0, len = takers.length; i < len; i++) {\n      var taker = takers[i];\n\n      if (taker[MATCH](input)) {\n        taker.cancel();\n        taker(input);\n      }\n    }\n  }, _ref.take = function take(cb, matcher) {\n    if (matcher === void 0) {\n      matcher = wildcard;\n    }\n\n    if (false) {}\n\n    if (closed) {\n      cb(END);\n      return;\n    }\n\n    cb[MATCH] = matcher;\n    ensureCanMutateNextTakers();\n    nextTakers.push(cb);\n    cb.cancel = io_6de156f3_once(function () {\n      ensureCanMutateNextTakers();\n      io_6de156f3_remove(nextTakers, cb);\n    });\n  }, _ref.close = close, _ref;\n}\nfunction stdChannel() {\n  var chan = multicastChannel();\n  var put = chan.put;\n\n  chan.put = function (input) {\n    if (input[redux_saga_symbols_esm_SAGA_ACTION]) {\n      put(input);\n      return;\n    }\n\n    asap(function () {\n      put(input);\n    });\n  };\n\n  return chan;\n}\n\nvar RUNNING = 0;\nvar redux_saga_core_esm_CANCELLED = 1;\nvar ABORTED = 2;\nvar redux_saga_core_esm_DONE = 3;\n\nfunction resolvePromise(promise, cb) {\n  var cancelPromise = promise[CANCEL];\n\n  if (redux_saga_is_esm_func(cancelPromise)) {\n    cb.cancel = cancelPromise;\n  }\n\n  promise.then(cb, function (error) {\n    cb(error, true);\n  });\n}\n\nvar redux_saga_core_esm_current = 0;\nvar nextSagaId = (function () {\n  return ++redux_saga_core_esm_current;\n});\n\nvar _effectRunnerMap;\n\nfunction getIteratorMetaInfo(iterator, fn) {\n  if (iterator.isSagaIterator) {\n    return {\n      name: iterator.meta.name\n    };\n  }\n\n  return getMetaInfo(fn);\n}\n\nfunction createTaskIterator(_ref) {\n  var context = _ref.context,\n      fn = _ref.fn,\n      args = _ref.args;\n\n  // catch synchronous failures; see #152 and #441\n  try {\n    var result = fn.apply(context, args); // i.e. a generator function returns an iterator\n\n    if (iterator(result)) {\n      return result;\n    }\n\n    var resolved = false;\n\n    var next = function next(arg) {\n      if (!resolved) {\n        resolved = true; // Only promises returned from fork will be interpreted. See #1573\n\n        return {\n          value: result,\n          done: !promise(result)\n        };\n      } else {\n        return {\n          value: arg,\n          done: true\n        };\n      }\n    };\n\n    return makeIterator(next);\n  } catch (err) {\n    // do not bubble up synchronous failures for detached forks\n    // instead create a failed task. See #152 and #441\n    return makeIterator(function () {\n      throw err;\n    });\n  }\n}\n\nfunction runPutEffect(env, _ref2, cb) {\n  var channel = _ref2.channel,\n      action = _ref2.action,\n      resolve = _ref2.resolve;\n\n  /**\n   Schedule the put in case another saga is holding a lock.\n   The put will be executed atomically. ie nested puts will execute after\n   this put has terminated.\n   **/\n  asap(function () {\n    var result;\n\n    try {\n      result = (channel ? channel.put : env.dispatch)(action);\n    } catch (error) {\n      cb(error, true);\n      return;\n    }\n\n    if (resolve && promise(result)) {\n      resolvePromise(result, cb);\n    } else {\n      cb(result);\n    }\n  }); // Put effects are non cancellables\n}\n\nfunction runTakeEffect(env, _ref3, cb) {\n  var _ref3$channel = _ref3.channel,\n      channel = _ref3$channel === void 0 ? env.channel : _ref3$channel,\n      pattern = _ref3.pattern,\n      maybe = _ref3.maybe;\n\n  var takeCb = function takeCb(input) {\n    if (input instanceof Error) {\n      cb(input, true);\n      return;\n    }\n\n    if (isEnd(input) && !maybe) {\n      cb(TERMINATE);\n      return;\n    }\n\n    cb(input);\n  };\n\n  try {\n    channel.take(takeCb, redux_saga_is_esm_notUndef(pattern) ? matcher(pattern) : null);\n  } catch (err) {\n    cb(err, true);\n    return;\n  }\n\n  cb.cancel = takeCb.cancel;\n}\n\nfunction runCallEffect(env, _ref4, cb, _ref5) {\n  var context = _ref4.context,\n      fn = _ref4.fn,\n      args = _ref4.args;\n  var task = _ref5.task;\n\n  // catch synchronous failures; see #152\n  try {\n    var result = fn.apply(context, args);\n\n    if (promise(result)) {\n      resolvePromise(result, cb);\n      return;\n    }\n\n    if (iterator(result)) {\n      // resolve iterator\n      proc(env, result, task.context, redux_saga_core_esm_current, getMetaInfo(fn),\n      /* isRoot */\n      false, cb);\n      return;\n    }\n\n    cb(result);\n  } catch (error) {\n    cb(error, true);\n  }\n}\n\nfunction runCPSEffect(env, _ref6, cb) {\n  var context = _ref6.context,\n      fn = _ref6.fn,\n      args = _ref6.args;\n\n  // CPS (ie node style functions) can define their own cancellation logic\n  // by setting cancel field on the cb\n  // catch synchronous failures; see #152\n  try {\n    var cpsCb = function cpsCb(err, res) {\n      if (undef(err)) {\n        cb(res);\n      } else {\n        cb(err, true);\n      }\n    };\n\n    fn.apply(context, args.concat(cpsCb));\n\n    if (cpsCb.cancel) {\n      cb.cancel = cpsCb.cancel;\n    }\n  } catch (error) {\n    cb(error, true);\n  }\n}\n\nfunction runForkEffect(env, _ref7, cb, _ref8) {\n  var context = _ref7.context,\n      fn = _ref7.fn,\n      args = _ref7.args,\n      detached = _ref7.detached;\n  var parent = _ref8.task;\n  var taskIterator = createTaskIterator({\n    context: context,\n    fn: fn,\n    args: args\n  });\n  var meta = getIteratorMetaInfo(taskIterator, fn);\n  immediately(function () {\n    var child = proc(env, taskIterator, parent.context, redux_saga_core_esm_current, meta, detached, undefined);\n\n    if (detached) {\n      cb(child);\n    } else {\n      if (child.isRunning()) {\n        parent.queue.addTask(child);\n        cb(child);\n      } else if (child.isAborted()) {\n        parent.queue.abort(child.error());\n      } else {\n        cb(child);\n      }\n    }\n  }); // Fork effects are non cancellables\n}\n\nfunction runJoinEffect(env, taskOrTasks, cb, _ref9) {\n  var task = _ref9.task;\n\n  var joinSingleTask = function joinSingleTask(taskToJoin, cb) {\n    if (taskToJoin.isRunning()) {\n      var joiner = {\n        task: task,\n        cb: cb\n      };\n\n      cb.cancel = function () {\n        if (taskToJoin.isRunning()) io_6de156f3_remove(taskToJoin.joiners, joiner);\n      };\n\n      taskToJoin.joiners.push(joiner);\n    } else {\n      if (taskToJoin.isAborted()) {\n        cb(taskToJoin.error(), true);\n      } else {\n        cb(taskToJoin.result());\n      }\n    }\n  };\n\n  if (redux_saga_is_esm_array(taskOrTasks)) {\n    if (taskOrTasks.length === 0) {\n      cb([]);\n      return;\n    }\n\n    var childCallbacks = createAllStyleChildCallbacks(taskOrTasks, cb);\n    taskOrTasks.forEach(function (t, i) {\n      joinSingleTask(t, childCallbacks[i]);\n    });\n  } else {\n    joinSingleTask(taskOrTasks, cb);\n  }\n}\n\nfunction cancelSingleTask(taskToCancel) {\n  if (taskToCancel.isRunning()) {\n    taskToCancel.cancel();\n  }\n}\n\nfunction runCancelEffect(env, taskOrTasks, cb, _ref10) {\n  var task = _ref10.task;\n\n  if (taskOrTasks === redux_saga_symbols_esm_SELF_CANCELLATION) {\n    cancelSingleTask(task);\n  } else if (redux_saga_is_esm_array(taskOrTasks)) {\n    taskOrTasks.forEach(cancelSingleTask);\n  } else {\n    cancelSingleTask(taskOrTasks);\n  }\n\n  cb(); // cancel effects are non cancellables\n}\n\nfunction runAllEffect(env, effects, cb, _ref11) {\n  var digestEffect = _ref11.digestEffect;\n  var effectId = redux_saga_core_esm_current;\n  var keys = Object.keys(effects);\n\n  if (keys.length === 0) {\n    cb(redux_saga_is_esm_array(effects) ? [] : {});\n    return;\n  }\n\n  var childCallbacks = createAllStyleChildCallbacks(effects, cb);\n  keys.forEach(function (key) {\n    digestEffect(effects[key], effectId, childCallbacks[key], key);\n  });\n}\n\nfunction runRaceEffect(env, effects, cb, _ref12) {\n  var digestEffect = _ref12.digestEffect;\n  var effectId = redux_saga_core_esm_current;\n  var keys = Object.keys(effects);\n  var response = redux_saga_is_esm_array(effects) ? createEmptyArray(keys.length) : {};\n  var childCbs = {};\n  var completed = false;\n  keys.forEach(function (key) {\n    var chCbAtKey = function chCbAtKey(res, isErr) {\n      if (completed) {\n        return;\n      }\n\n      if (isErr || shouldComplete(res)) {\n        // Race Auto cancellation\n        cb.cancel();\n        cb(res, isErr);\n      } else {\n        cb.cancel();\n        completed = true;\n        response[key] = res;\n        cb(response);\n      }\n    };\n\n    chCbAtKey.cancel = io_6de156f3_noop;\n    childCbs[key] = chCbAtKey;\n  });\n\n  cb.cancel = function () {\n    // prevents unnecessary cancellation\n    if (!completed) {\n      completed = true;\n      keys.forEach(function (key) {\n        return childCbs[key].cancel();\n      });\n    }\n  };\n\n  keys.forEach(function (key) {\n    if (completed) {\n      return;\n    }\n\n    digestEffect(effects[key], effectId, childCbs[key], key);\n  });\n}\n\nfunction runSelectEffect(env, _ref13, cb) {\n  var selector = _ref13.selector,\n      args = _ref13.args;\n\n  try {\n    var state = selector.apply(void 0, [env.getState()].concat(args));\n    cb(state);\n  } catch (error) {\n    cb(error, true);\n  }\n}\n\nfunction runChannelEffect(env, _ref14, cb) {\n  var pattern = _ref14.pattern,\n      buffer = _ref14.buffer;\n  var chan = redux_saga_core_esm_channel(buffer);\n  var match = matcher(pattern);\n\n  var taker = function taker(action) {\n    if (!isEnd(action)) {\n      env.channel.take(taker, match);\n    }\n\n    chan.put(action);\n  };\n\n  var close = chan.close;\n\n  chan.close = function () {\n    taker.cancel();\n    close();\n  };\n\n  env.channel.take(taker, match);\n  cb(chan);\n}\n\nfunction runCancelledEffect(env, data, cb, _ref15) {\n  var task = _ref15.task;\n  cb(task.isCancelled());\n}\n\nfunction runFlushEffect(env, channel, cb) {\n  channel.flush(cb);\n}\n\nfunction runGetContextEffect(env, prop, cb, _ref16) {\n  var task = _ref16.task;\n  cb(task.context[prop]);\n}\n\nfunction runSetContextEffect(env, props, cb, _ref17) {\n  var task = _ref17.task;\n  assignWithSymbols(task.context, props);\n  cb();\n}\n\nvar effectRunnerMap = (_effectRunnerMap = {}, _effectRunnerMap[TAKE] = runTakeEffect, _effectRunnerMap[PUT] = runPutEffect, _effectRunnerMap[ALL] = runAllEffect, _effectRunnerMap[RACE] = runRaceEffect, _effectRunnerMap[CALL] = runCallEffect, _effectRunnerMap[CPS] = runCPSEffect, _effectRunnerMap[FORK] = runForkEffect, _effectRunnerMap[JOIN] = runJoinEffect, _effectRunnerMap[io_6de156f3_CANCEL] = runCancelEffect, _effectRunnerMap[SELECT] = runSelectEffect, _effectRunnerMap[ACTION_CHANNEL] = runChannelEffect, _effectRunnerMap[CANCELLED] = runCancelledEffect, _effectRunnerMap[FLUSH] = runFlushEffect, _effectRunnerMap[GET_CONTEXT] = runGetContextEffect, _effectRunnerMap[SET_CONTEXT] = runSetContextEffect, _effectRunnerMap);\n\n/**\n Used to track a parent task and its forks\n In the fork model, forked tasks are attached by default to their parent\n We model this using the concept of Parent task && main Task\n main task is the main flow of the current Generator, the parent tasks is the\n aggregation of the main tasks + all its forked tasks.\n Thus the whole model represents an execution tree with multiple branches (vs the\n linear execution tree in sequential (non parallel) programming)\n\n A parent tasks has the following semantics\n - It completes if all its forks either complete or all cancelled\n - If it's cancelled, all forks are cancelled as well\n - It aborts if any uncaught error bubbles up from forks\n - If it completes, the return value is the one returned by the main task\n **/\n\nfunction forkQueue(mainTask, onAbort, cont) {\n  var tasks = [];\n  var result;\n  var completed = false;\n  addTask(mainTask);\n\n  var getTasks = function getTasks() {\n    return tasks;\n  };\n\n  function abort(err) {\n    onAbort();\n    cancelAll();\n    cont(err, true);\n  }\n\n  function addTask(task) {\n    tasks.push(task);\n\n    task.cont = function (res, isErr) {\n      if (completed) {\n        return;\n      }\n\n      io_6de156f3_remove(tasks, task);\n      task.cont = io_6de156f3_noop;\n\n      if (isErr) {\n        abort(res);\n      } else {\n        if (task === mainTask) {\n          result = res;\n        }\n\n        if (!tasks.length) {\n          completed = true;\n          cont(result);\n        }\n      }\n    };\n  }\n\n  function cancelAll() {\n    if (completed) {\n      return;\n    }\n\n    completed = true;\n    tasks.forEach(function (t) {\n      t.cont = io_6de156f3_noop;\n      t.cancel();\n    });\n    tasks = [];\n  }\n\n  return {\n    addTask: addTask,\n    cancelAll: cancelAll,\n    abort: abort,\n    getTasks: getTasks\n  };\n}\n\n// there can be only a single saga error created at any given moment\n\nfunction formatLocation(fileName, lineNumber) {\n  return fileName + \"?\" + lineNumber;\n}\n\nfunction effectLocationAsString(effect) {\n  var location = getLocation(effect);\n\n  if (location) {\n    var code = location.code,\n        fileName = location.fileName,\n        lineNumber = location.lineNumber;\n    var source = code + \"  \" + formatLocation(fileName, lineNumber);\n    return source;\n  }\n\n  return '';\n}\n\nfunction sagaLocationAsString(sagaMeta) {\n  var name = sagaMeta.name,\n      location = sagaMeta.location;\n\n  if (location) {\n    return name + \"  \" + formatLocation(location.fileName, location.lineNumber);\n  }\n\n  return name;\n}\n\nfunction cancelledTasksAsString(sagaStack) {\n  var cancelledTasks = flatMap(function (i) {\n    return i.cancelledTasks;\n  }, sagaStack);\n\n  if (!cancelledTasks.length) {\n    return '';\n  }\n\n  return ['Tasks cancelled due to error:'].concat(cancelledTasks).join('\\n');\n}\n\nvar crashedEffect = null;\nvar sagaStack = [];\nvar addSagaFrame = function addSagaFrame(frame) {\n  frame.crashedEffect = crashedEffect;\n  sagaStack.push(frame);\n};\nvar clear = function clear() {\n  crashedEffect = null;\n  sagaStack.length = 0;\n}; // this sets crashed effect for the soon-to-be-reported saga frame\n// this slightly streatches the singleton nature of this module into wrong direction\n// as it's even less obvious what's the data flow here, but it is what it is for now\n\nvar setCrashedEffect = function setCrashedEffect(effect) {\n  crashedEffect = effect;\n};\n/**\n  @returns {string}\n\n  @example\n  The above error occurred in task errorInPutSaga {pathToFile}\n  when executing effect put({type: 'REDUCER_ACTION_ERROR_IN_PUT'}) {pathToFile}\n      created by fetchSaga {pathToFile}\n      created by rootSaga {pathToFile}\n*/\n\nvar redux_saga_core_esm_toString = function toString() {\n  var firstSaga = sagaStack[0],\n      otherSagas = sagaStack.slice(1);\n  var crashedEffectLocation = firstSaga.crashedEffect ? effectLocationAsString(firstSaga.crashedEffect) : null;\n  var errorMessage = \"The above error occurred in task \" + sagaLocationAsString(firstSaga.meta) + (crashedEffectLocation ? \" \\n when executing effect \" + crashedEffectLocation : '');\n  return [errorMessage].concat(otherSagas.map(function (s) {\n    return \"    created by \" + sagaLocationAsString(s.meta);\n  }), [cancelledTasksAsString(sagaStack)]).join('\\n');\n};\n\nfunction newTask(env, mainTask, parentContext, parentEffectId, meta, isRoot, cont) {\n  var _task;\n\n  if (cont === void 0) {\n    cont = io_6de156f3_noop;\n  }\n\n  var status = RUNNING;\n  var taskResult;\n  var taskError;\n  var deferredEnd = null;\n  var cancelledDueToErrorTasks = [];\n  var context = Object.create(parentContext);\n  var queue = forkQueue(mainTask, function onAbort() {\n    cancelledDueToErrorTasks.push.apply(cancelledDueToErrorTasks, queue.getTasks().map(function (t) {\n      return t.meta.name;\n    }));\n  }, end);\n  /**\n   This may be called by a parent generator to trigger/propagate cancellation\n   cancel all pending tasks (including the main task), then end the current task.\n    Cancellation propagates down to the whole execution tree held by this Parent task\n   It's also propagated to all joiners of this task and their execution tree/joiners\n    Cancellation is noop for terminated/Cancelled tasks tasks\n   **/\n\n  function cancel() {\n    if (status === RUNNING) {\n      // Setting status to CANCELLED does not necessarily mean that the task/iterators are stopped\n      // effects in the iterator's finally block will still be executed\n      status = redux_saga_core_esm_CANCELLED;\n      queue.cancelAll(); // Ending with a TASK_CANCEL will propagate the Cancellation to all joiners\n\n      end(TASK_CANCEL, false);\n    }\n  }\n\n  function end(result, isErr) {\n    if (!isErr) {\n      // The status here may be RUNNING or CANCELLED\n      // If the status is CANCELLED, then we do not need to change it here\n      if (result === TASK_CANCEL) {\n        status = redux_saga_core_esm_CANCELLED;\n      } else if (status !== redux_saga_core_esm_CANCELLED) {\n        status = redux_saga_core_esm_DONE;\n      }\n\n      taskResult = result;\n      deferredEnd && deferredEnd.resolve(result);\n    } else {\n      status = ABORTED;\n      addSagaFrame({\n        meta: meta,\n        cancelledTasks: cancelledDueToErrorTasks\n      });\n\n      if (task.isRoot) {\n        var sagaStack = redux_saga_core_esm_toString(); // we've dumped the saga stack to string and are passing it to user's code\n        // we know that it won't be needed anymore and we need to clear it\n\n        clear();\n        env.onError(result, {\n          sagaStack: sagaStack\n        });\n      }\n\n      taskError = result;\n      deferredEnd && deferredEnd.reject(result);\n    }\n\n    task.cont(result, isErr);\n    task.joiners.forEach(function (joiner) {\n      joiner.cb(result, isErr);\n    });\n    task.joiners = null;\n  }\n\n  function setContext(props) {\n    if (false) {}\n\n    assignWithSymbols(context, props);\n  }\n\n  function toPromise() {\n    if (deferredEnd) {\n      return deferredEnd.promise;\n    }\n\n    deferredEnd = redux_saga_deferred_esm();\n\n    if (status === ABORTED) {\n      deferredEnd.reject(taskError);\n    } else if (status !== RUNNING) {\n      deferredEnd.resolve(taskResult);\n    }\n\n    return deferredEnd.promise;\n  }\n\n  var task = (_task = {}, _task[redux_saga_symbols_esm_TASK] = true, _task.id = parentEffectId, _task.meta = meta, _task.isRoot = isRoot, _task.context = context, _task.joiners = [], _task.queue = queue, _task.cancel = cancel, _task.cont = cont, _task.end = end, _task.setContext = setContext, _task.toPromise = toPromise, _task.isRunning = function isRunning() {\n    return status === RUNNING;\n  }, _task.isCancelled = function isCancelled() {\n    return status === redux_saga_core_esm_CANCELLED || status === RUNNING && mainTask.status === redux_saga_core_esm_CANCELLED;\n  }, _task.isAborted = function isAborted() {\n    return status === ABORTED;\n  }, _task.result = function result() {\n    return taskResult;\n  }, _task.error = function error() {\n    return taskError;\n  }, _task);\n  return task;\n}\n\nfunction proc(env, iterator$1, parentContext, parentEffectId, meta, isRoot, cont) {\n  if (false) {}\n\n  var finalRunEffect = env.finalizeRunEffect(runEffect);\n  /**\n    Tracks the current effect cancellation\n    Each time the generator progresses. calling runEffect will set a new value\n    on it. It allows propagating cancellation to child effects\n  **/\n\n  next.cancel = io_6de156f3_noop;\n  /** Creates a main task to track the main flow */\n\n  var mainTask = {\n    meta: meta,\n    cancel: cancelMain,\n    status: RUNNING\n  };\n  /**\n   Creates a new task descriptor for this generator.\n   A task is the aggregation of it's mainTask and all it's forked tasks.\n   **/\n\n  var task = newTask(env, mainTask, parentContext, parentEffectId, meta, isRoot, cont);\n  var executingContext = {\n    task: task,\n    digestEffect: digestEffect\n  };\n  /**\n    cancellation of the main task. We'll simply resume the Generator with a TASK_CANCEL\n  **/\n\n  function cancelMain() {\n    if (mainTask.status === RUNNING) {\n      mainTask.status = redux_saga_core_esm_CANCELLED;\n      next(TASK_CANCEL);\n    }\n  }\n  /**\n    attaches cancellation logic to this task's continuation\n    this will permit cancellation to propagate down the call chain\n  **/\n\n\n  if (cont) {\n    cont.cancel = task.cancel;\n  } // kicks up the generator\n\n\n  next(); // then return the task descriptor to the caller\n\n  return task;\n  /**\n   * This is the generator driver\n   * It's a recursive async/continuation function which calls itself\n   * until the generator terminates or throws\n   * @param {internal commands(TASK_CANCEL | TERMINATE) | any} arg - value, generator will be resumed with.\n   * @param {boolean} isErr - the flag shows if effect finished with an error\n   *\n   * receives either (command | effect result, false) or (any thrown thing, true)\n   */\n\n  function next(arg, isErr) {\n    try {\n      var result;\n\n      if (isErr) {\n        result = iterator$1.throw(arg); // user handled the error, we can clear bookkept values\n\n        clear();\n      } else if (shouldCancel(arg)) {\n        /**\n          getting TASK_CANCEL automatically cancels the main task\n          We can get this value here\n           - By cancelling the parent task manually\n          - By joining a Cancelled task\n        **/\n        mainTask.status = redux_saga_core_esm_CANCELLED;\n        /**\n          Cancels the current effect; this will propagate the cancellation down to any called tasks\n        **/\n\n        next.cancel();\n        /**\n          If this Generator has a `return` method then invokes it\n          This will jump to the finally block\n        **/\n\n        result = redux_saga_is_esm_func(iterator$1.return) ? iterator$1.return(TASK_CANCEL) : {\n          done: true,\n          value: TASK_CANCEL\n        };\n      } else if (shouldTerminate(arg)) {\n        // We get TERMINATE flag, i.e. by taking from a channel that ended using `take` (and not `takem` used to trap End of channels)\n        result = redux_saga_is_esm_func(iterator$1.return) ? iterator$1.return() : {\n          done: true\n        };\n      } else {\n        result = iterator$1.next(arg);\n      }\n\n      if (!result.done) {\n        digestEffect(result.value, parentEffectId, next);\n      } else {\n        /**\n          This Generator has ended, terminate the main task and notify the fork queue\n        **/\n        if (mainTask.status !== redux_saga_core_esm_CANCELLED) {\n          mainTask.status = redux_saga_core_esm_DONE;\n        }\n\n        mainTask.cont(result.value);\n      }\n    } catch (error) {\n      if (mainTask.status === redux_saga_core_esm_CANCELLED) {\n        throw error;\n      }\n\n      mainTask.status = ABORTED;\n      mainTask.cont(error, true);\n    }\n  }\n\n  function runEffect(effect, effectId, currCb) {\n    /**\n      each effect runner must attach its own logic of cancellation to the provided callback\n      it allows this generator to propagate cancellation downward.\n       ATTENTION! effect runners must setup the cancel logic by setting cb.cancel = [cancelMethod]\n      And the setup must occur before calling the callback\n       This is a sort of inversion of control: called async functions are responsible\n      of completing the flow by calling the provided continuation; while caller functions\n      are responsible for aborting the current flow by calling the attached cancel function\n       Library users can attach their own cancellation logic to promises by defining a\n      promise[CANCEL] method in their returned promises\n      ATTENTION! calling cancel must have no effect on an already completed or cancelled effect\n    **/\n    if (promise(effect)) {\n      resolvePromise(effect, currCb);\n    } else if (iterator(effect)) {\n      // resolve iterator\n      proc(env, effect, task.context, effectId, meta,\n      /* isRoot */\n      false, currCb);\n    } else if (effect && effect[redux_saga_symbols_esm_IO]) {\n      var effectRunner = effectRunnerMap[effect.type];\n      effectRunner(env, effect.payload, currCb, executingContext);\n    } else {\n      // anything else returned as is\n      currCb(effect);\n    }\n  }\n\n  function digestEffect(effect, parentEffectId, cb, label) {\n    if (label === void 0) {\n      label = '';\n    }\n\n    var effectId = nextSagaId();\n    env.sagaMonitor && env.sagaMonitor.effectTriggered({\n      effectId: effectId,\n      parentEffectId: parentEffectId,\n      label: label,\n      effect: effect\n    });\n    /**\n      completion callback and cancel callback are mutually exclusive\n      We can't cancel an already completed effect\n      And We can't complete an already cancelled effectId\n    **/\n\n    var effectSettled; // Completion callback passed to the appropriate effect runner\n\n    function currCb(res, isErr) {\n      if (effectSettled) {\n        return;\n      }\n\n      effectSettled = true;\n      cb.cancel = io_6de156f3_noop; // defensive measure\n\n      if (env.sagaMonitor) {\n        if (isErr) {\n          env.sagaMonitor.effectRejected(effectId, res);\n        } else {\n          env.sagaMonitor.effectResolved(effectId, res);\n        }\n      }\n\n      if (isErr) {\n        setCrashedEffect(effect);\n      }\n\n      cb(res, isErr);\n    } // tracks down the current cancel\n\n\n    currCb.cancel = io_6de156f3_noop; // setup cancellation logic on the parent cb\n\n    cb.cancel = function () {\n      // prevents cancelling an already completed effect\n      if (effectSettled) {\n        return;\n      }\n\n      effectSettled = true;\n      currCb.cancel(); // propagates cancel downward\n\n      currCb.cancel = io_6de156f3_noop; // defensive measure\n\n      env.sagaMonitor && env.sagaMonitor.effectCancelled(effectId);\n    };\n\n    finalRunEffect(effect, effectId, currCb);\n  }\n}\n\nvar RUN_SAGA_SIGNATURE = 'runSaga(options, saga, ...args)';\nvar NON_GENERATOR_ERR = RUN_SAGA_SIGNATURE + \": saga argument must be a Generator function!\";\nfunction runSaga(_ref, saga) {\n  var _ref$channel = _ref.channel,\n      channel = _ref$channel === void 0 ? stdChannel() : _ref$channel,\n      dispatch = _ref.dispatch,\n      getState = _ref.getState,\n      _ref$context = _ref.context,\n      context = _ref$context === void 0 ? {} : _ref$context,\n      sagaMonitor = _ref.sagaMonitor,\n      effectMiddlewares = _ref.effectMiddlewares,\n      _ref$onError = _ref.onError,\n      onError = _ref$onError === void 0 ? logError : _ref$onError;\n\n  if (false) {}\n\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  var iterator$1 = saga.apply(void 0, args);\n\n  if (false) {}\n\n  var effectId = nextSagaId();\n\n  if (sagaMonitor) {\n    // monitors are expected to have a certain interface, let's fill-in any missing ones\n    sagaMonitor.rootSagaStarted = sagaMonitor.rootSagaStarted || io_6de156f3_noop;\n    sagaMonitor.effectTriggered = sagaMonitor.effectTriggered || io_6de156f3_noop;\n    sagaMonitor.effectResolved = sagaMonitor.effectResolved || io_6de156f3_noop;\n    sagaMonitor.effectRejected = sagaMonitor.effectRejected || io_6de156f3_noop;\n    sagaMonitor.effectCancelled = sagaMonitor.effectCancelled || io_6de156f3_noop;\n    sagaMonitor.actionDispatched = sagaMonitor.actionDispatched || io_6de156f3_noop;\n    sagaMonitor.rootSagaStarted({\n      effectId: effectId,\n      saga: saga,\n      args: args\n    });\n  }\n\n  if (false) { var MIDDLEWARE_TYPE_ERROR; }\n\n  var finalizeRunEffect;\n\n  if (effectMiddlewares) {\n    var middleware = compose.apply(void 0, effectMiddlewares);\n\n    finalizeRunEffect = function finalizeRunEffect(runEffect) {\n      return function (effect, effectId, currCb) {\n        var plainRunEffect = function plainRunEffect(eff) {\n          return runEffect(eff, effectId, currCb);\n        };\n\n        return middleware(plainRunEffect)(effect);\n      };\n    };\n  } else {\n    finalizeRunEffect = identity;\n  }\n\n  var env = {\n    channel: channel,\n    dispatch: wrapSagaDispatch(dispatch),\n    getState: getState,\n    sagaMonitor: sagaMonitor,\n    onError: onError,\n    finalizeRunEffect: finalizeRunEffect\n  };\n  return immediately(function () {\n    var task = proc(env, iterator$1, context, effectId, getMetaInfo(saga),\n    /* isRoot */\n    true, undefined);\n\n    if (sagaMonitor) {\n      sagaMonitor.effectResolved(effectId, task);\n    }\n\n    return task;\n  });\n}\n\nfunction sagaMiddlewareFactory(_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      _ref$context = _ref.context,\n      context = _ref$context === void 0 ? {} : _ref$context,\n      _ref$channel = _ref.channel,\n      channel = _ref$channel === void 0 ? stdChannel() : _ref$channel,\n      sagaMonitor = _ref.sagaMonitor,\n      options = _objectWithoutPropertiesLoose(_ref, [\"context\", \"channel\", \"sagaMonitor\"]);\n\n  var boundRunSaga;\n\n  if (false) {}\n\n  function sagaMiddleware(_ref2) {\n    var getState = _ref2.getState,\n        dispatch = _ref2.dispatch;\n    boundRunSaga = runSaga.bind(null, extends_extends({}, options, {\n      context: context,\n      channel: channel,\n      dispatch: dispatch,\n      getState: getState,\n      sagaMonitor: sagaMonitor\n    }));\n    return function (next) {\n      return function (action) {\n        if (sagaMonitor && sagaMonitor.actionDispatched) {\n          sagaMonitor.actionDispatched(action);\n        }\n\n        var result = next(action); // hit reducers\n\n        channel.put(action);\n        return result;\n      };\n    };\n  }\n\n  sagaMiddleware.run = function () {\n    if (false) {}\n\n    return boundRunSaga.apply(void 0, arguments);\n  };\n\n  sagaMiddleware.setContext = function (props) {\n    if (false) {}\n\n    assignWithSymbols(context, props);\n  };\n\n  return sagaMiddleware;\n}\n\n/* harmony default export */ const redux_saga_core_esm = (sagaMiddlewareFactory);\n\n\n;// CONCATENATED MODULE: ./node_modules/redux-saga/dist/redux-saga-core-npm-proxy.esm.js\n\n\n\n\n\n/* harmony default export */ const redux_saga_core_npm_proxy_esm = (redux_saga_core_esm);\n\n;// CONCATENATED MODULE: ./src/reducers/polygons.js\n\n // see sagas/index.js for polygon initial state\n\nvar initialState = immutable_es.fromJS({\n  polygons: []\n});\n/* harmony default export */ const polygons = (function () {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  var action = arguments.length > 1 ? arguments[1] : undefined;\n\n  switch (action.type) {\n    case SAVE_POLYGONS:\n      {\n        var polygons = action.payload.polygons;\n        return state.set('polygons', polygons);\n      }\n\n    default:\n      return state;\n  }\n});\n;// CONCATENATED MODULE: ./src/reducers/simulation.js\n\n\nvar simulation_initialState = immutable_es.fromJS({\n  width: 0,\n  height: 0\n});\n/* harmony default export */ const simulation = (function () {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : simulation_initialState;\n  var action = arguments.length > 1 ? arguments[1] : undefined;\n\n  switch (action.type) {\n    case SET_STAGE_BOUNDS:\n      {\n        var _action$payload = action.payload,\n            width = _action$payload.width,\n            height = _action$payload.height;\n        return state.set('width', width).set('height', height);\n      }\n\n    default:\n      return state;\n  }\n});\n;// CONCATENATED MODULE: ./src/reducers/index.js\n\n\n\n/* harmony default export */ const reducers = (combineReducers({\n  polygons: polygons,\n  simulation: simulation\n}));\n;// CONCATENATED MODULE: ./node_modules/@redux-saga/core/dist/redux-saga-effects.esm.js\n\n\n\n\n\n\n\nvar done = function done(value) {\n  return {\n    done: true,\n    value: value\n  };\n};\n\nvar qEnd = {};\nfunction safeName(patternOrChannel) {\n  if (channel(patternOrChannel)) {\n    return 'channel';\n  }\n\n  if (stringableFunc(patternOrChannel)) {\n    return String(patternOrChannel);\n  }\n\n  if (redux_saga_is_esm_func(patternOrChannel)) {\n    return patternOrChannel.name;\n  }\n\n  return String(patternOrChannel);\n}\nfunction fsmIterator(fsm, startState, name) {\n  var stateUpdater,\n      errorState,\n      effect,\n      nextState = startState;\n\n  function next(arg, error) {\n    if (nextState === qEnd) {\n      return done(arg);\n    }\n\n    if (error && !errorState) {\n      nextState = qEnd;\n      throw error;\n    } else {\n      stateUpdater && stateUpdater(arg);\n      var currentState = error ? fsm[errorState](error) : fsm[nextState]();\n      nextState = currentState.nextState;\n      effect = currentState.effect;\n      stateUpdater = currentState.stateUpdater;\n      errorState = currentState.errorState;\n      return nextState === qEnd ? done(arg) : effect;\n    }\n  }\n\n  return makeIterator(next, function (error) {\n    return next(null, error);\n  }, name);\n}\n\nfunction takeEvery(patternOrChannel, worker) {\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  var yTake = {\n    done: false,\n    value: io_6de156f3_take(patternOrChannel)\n  };\n\n  var yFork = function yFork(ac) {\n    return {\n      done: false,\n      value: io_6de156f3_fork.apply(void 0, [worker].concat(args, [ac]))\n    };\n  };\n\n  var action,\n      setAction = function setAction(ac) {\n    return action = ac;\n  };\n\n  return fsmIterator({\n    q1: function q1() {\n      return {\n        nextState: 'q2',\n        effect: yTake,\n        stateUpdater: setAction\n      };\n    },\n    q2: function q2() {\n      return {\n        nextState: 'q1',\n        effect: yFork(action)\n      };\n    }\n  }, 'q1', \"takeEvery(\" + safeName(patternOrChannel) + \", \" + worker.name + \")\");\n}\n\nfunction takeLatest(patternOrChannel, worker) {\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  var yTake = {\n    done: false,\n    value: take(patternOrChannel)\n  };\n\n  var yFork = function yFork(ac) {\n    return {\n      done: false,\n      value: fork.apply(void 0, [worker].concat(args, [ac]))\n    };\n  };\n\n  var yCancel = function yCancel(task) {\n    return {\n      done: false,\n      value: cancel(task)\n    };\n  };\n\n  var task, action;\n\n  var setTask = function setTask(t) {\n    return task = t;\n  };\n\n  var setAction = function setAction(ac) {\n    return action = ac;\n  };\n\n  return fsmIterator({\n    q1: function q1() {\n      return {\n        nextState: 'q2',\n        effect: yTake,\n        stateUpdater: setAction\n      };\n    },\n    q2: function q2() {\n      return task ? {\n        nextState: 'q3',\n        effect: yCancel(task)\n      } : {\n        nextState: 'q1',\n        effect: yFork(action),\n        stateUpdater: setTask\n      };\n    },\n    q3: function q3() {\n      return {\n        nextState: 'q1',\n        effect: yFork(action),\n        stateUpdater: setTask\n      };\n    }\n  }, 'q1', \"takeLatest(\" + safeName(patternOrChannel) + \", \" + worker.name + \")\");\n}\n\nfunction takeLeading(patternOrChannel, worker) {\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  var yTake = {\n    done: false,\n    value: take(patternOrChannel)\n  };\n\n  var yCall = function yCall(ac) {\n    return {\n      done: false,\n      value: call.apply(void 0, [worker].concat(args, [ac]))\n    };\n  };\n\n  var action;\n\n  var setAction = function setAction(ac) {\n    return action = ac;\n  };\n\n  return fsmIterator({\n    q1: function q1() {\n      return {\n        nextState: 'q2',\n        effect: yTake,\n        stateUpdater: setAction\n      };\n    },\n    q2: function q2() {\n      return {\n        nextState: 'q1',\n        effect: yCall(action)\n      };\n    }\n  }, 'q1', \"takeLeading(\" + safeName(patternOrChannel) + \", \" + worker.name + \")\");\n}\n\nfunction redux_saga_effects_esm_throttle(delayLength, pattern, worker) {\n  for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    args[_key - 3] = arguments[_key];\n  }\n\n  var action, channel;\n  var yActionChannel = {\n    done: false,\n    value: actionChannel(pattern, sliding(1))\n  };\n\n  var yTake = function yTake() {\n    return {\n      done: false,\n      value: take(channel)\n    };\n  };\n\n  var yFork = function yFork(ac) {\n    return {\n      done: false,\n      value: fork.apply(void 0, [worker].concat(args, [ac]))\n    };\n  };\n\n  var yDelay = {\n    done: false,\n    value: delay(delayLength)\n  };\n\n  var setAction = function setAction(ac) {\n    return action = ac;\n  };\n\n  var setChannel = function setChannel(ch) {\n    return channel = ch;\n  };\n\n  return fsmIterator({\n    q1: function q1() {\n      return {\n        nextState: 'q2',\n        effect: yActionChannel,\n        stateUpdater: setChannel\n      };\n    },\n    q2: function q2() {\n      return {\n        nextState: 'q3',\n        effect: yTake(),\n        stateUpdater: setAction\n      };\n    },\n    q3: function q3() {\n      return {\n        nextState: 'q4',\n        effect: yFork(action)\n      };\n    },\n    q4: function q4() {\n      return {\n        nextState: 'q2',\n        effect: yDelay\n      };\n    }\n  }, 'q1', \"throttle(\" + safeName(pattern) + \", \" + worker.name + \")\");\n}\n\nfunction retry(maxTries, delayLength, fn) {\n  var counter = maxTries;\n\n  for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    args[_key - 3] = arguments[_key];\n  }\n\n  var yCall = {\n    done: false,\n    value: call.apply(void 0, [fn].concat(args))\n  };\n  var yDelay = {\n    done: false,\n    value: delay(delayLength)\n  };\n  return fsmIterator({\n    q1: function q1() {\n      return {\n        nextState: 'q2',\n        effect: yCall,\n        errorState: 'q10'\n      };\n    },\n    q2: function q2() {\n      return {\n        nextState: qEnd\n      };\n    },\n    q10: function q10(error) {\n      counter -= 1;\n\n      if (counter <= 0) {\n        throw error;\n      }\n\n      return {\n        nextState: 'q1',\n        effect: yDelay\n      };\n    }\n  }, 'q1', \"retry(\" + fn.name + \")\");\n}\n\nfunction debounceHelper(delayLength, patternOrChannel, worker) {\n  for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    args[_key - 3] = arguments[_key];\n  }\n\n  var action, raceOutput;\n  var yTake = {\n    done: false,\n    value: take(patternOrChannel)\n  };\n  var yRace = {\n    done: false,\n    value: race({\n      action: take(patternOrChannel),\n      debounce: delay(delayLength)\n    })\n  };\n\n  var yFork = function yFork(ac) {\n    return {\n      done: false,\n      value: fork.apply(void 0, [worker].concat(args, [ac]))\n    };\n  };\n\n  var yNoop = function yNoop(value) {\n    return {\n      done: false,\n      value: value\n    };\n  };\n\n  var setAction = function setAction(ac) {\n    return action = ac;\n  };\n\n  var setRaceOutput = function setRaceOutput(ro) {\n    return raceOutput = ro;\n  };\n\n  return fsmIterator({\n    q1: function q1() {\n      return {\n        nextState: 'q2',\n        effect: yTake,\n        stateUpdater: setAction\n      };\n    },\n    q2: function q2() {\n      return {\n        nextState: 'q3',\n        effect: yRace,\n        stateUpdater: setRaceOutput\n      };\n    },\n    q3: function q3() {\n      return raceOutput.debounce ? {\n        nextState: 'q1',\n        effect: yFork(action)\n      } : {\n        nextState: 'q2',\n        effect: yNoop(raceOutput.action),\n        stateUpdater: setAction\n      };\n    }\n  }, 'q1', \"debounce(\" + safeName(patternOrChannel) + \", \" + worker.name + \")\");\n}\n\nvar validateTakeEffect = function validateTakeEffect(fn, patternOrChannel, worker) {\n  check(patternOrChannel, notUndef, fn.name + \" requires a pattern or channel\");\n  check(worker, notUndef, fn.name + \" requires a saga parameter\");\n};\n\nfunction takeEvery$1(patternOrChannel, worker) {\n  if (false) {}\n\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  return io_6de156f3_fork.apply(void 0, [takeEvery, patternOrChannel, worker].concat(args));\n}\nfunction takeLatest$1(patternOrChannel, worker) {\n  if (false) {}\n\n  for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n    args[_key2 - 2] = arguments[_key2];\n  }\n\n  return fork.apply(void 0, [takeLatest, patternOrChannel, worker].concat(args));\n}\nfunction takeLeading$1(patternOrChannel, worker) {\n  if (false) {}\n\n  for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n    args[_key3 - 2] = arguments[_key3];\n  }\n\n  return fork.apply(void 0, [takeLeading, patternOrChannel, worker].concat(args));\n}\nfunction throttle$1(ms, pattern, worker) {\n  if (false) {}\n\n  for (var _len4 = arguments.length, args = new Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {\n    args[_key4 - 3] = arguments[_key4];\n  }\n\n  return fork.apply(void 0, [redux_saga_effects_esm_throttle, ms, pattern, worker].concat(args));\n}\nfunction retry$1(maxTries, delayLength, worker) {\n  for (var _len5 = arguments.length, args = new Array(_len5 > 3 ? _len5 - 3 : 0), _key5 = 3; _key5 < _len5; _key5++) {\n    args[_key5 - 3] = arguments[_key5];\n  }\n\n  return call.apply(void 0, [retry, maxTries, delayLength, worker].concat(args));\n}\nfunction debounce(delayLength, pattern, worker) {\n  for (var _len6 = arguments.length, args = new Array(_len6 > 3 ? _len6 - 3 : 0), _key6 = 3; _key6 < _len6; _key6++) {\n    args[_key6 - 3] = arguments[_key6];\n  }\n\n  return fork.apply(void 0, [debounceHelper, delayLength, pattern, worker].concat(args));\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/redux-saga/dist/redux-saga-effects-npm-proxy.esm.js\n\n\n;// CONCATENATED MODULE: ./src/utils/randomJson.js\n\n\n\nvar generateRandomPolygon = function generateRandomPolygon() {\n  return immutable_es.fromJS(Polygon.generateRandom(randRangeInt(3, 6 + 1)));\n};\nvar generateRandomVector = function generateRandomVector() {\n  var rangeLengthStart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  var rangeLengthEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n  return immutable_es.fromJS(Vector2_Vector2.generateRandom(rangeLengthStart, rangeLengthEnd));\n};\nvar generateRandomVectorFromCoords = function generateRandomVectorFromCoords(rangeXStart, rangeXEnd, rangeYStart, rangeYEnd) {\n  return Immutable.fromJS(Vector2.generateRandomFromCoords(rangeXStart, rangeXEnd, rangeYStart, rangeYEnd));\n};\n;// CONCATENATED MODULE: ./src/sagas/index.js\nfunction sagas_typeof(obj) { \"@babel/helpers - typeof\"; return sagas_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, sagas_typeof(obj); }\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == sagas_typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime().mark(generatePolygons),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime().mark(updatePolygons),\n    _marked3 = /*#__PURE__*/_regeneratorRuntime().mark(watch),\n    _marked4 = /*#__PURE__*/_regeneratorRuntime().mark(rootSaga);\n\n\n\n\n\n\n\n\n\n\nvar CIRCLE_RADIANS = 2 * Math.PI;\nvar OMEGA_RANGE_PERCENTAGE = 0.15;\nvar OMEGA_RANGE_ABS = CIRCLE_RADIANS * OMEGA_RANGE_PERCENTAGE;\nvar MIN_POSITION_X = 100;\nvar MAX_POSITION_X;\nvar MIN_POSITION_Y = 100;\nvar MAX_POSITION_Y;\nvar loop = 0;\n\nvar getPolygonInitialState = function getPolygonInitialState(id, position) {\n  var polygon = generateRandomPolygon();\n  return immutable_es.fromJS({\n    id: id,\n    polygon: polygon,\n    radius: polygon.radius,\n    mass: randRangeInt(5, 20),\n    // kg\n    position: position,\n    rotation: 0,\n    velocity: generateRandomVector(75, 150),\n    // magnitude: speed per second\n    angularVelocity: randRangeFloat(-OMEGA_RANGE_ABS, OMEGA_RANGE_ABS) // radians per second\n\n  });\n};\n\nfunction generatePolygons(action) {\n  var _action$payload, width, height, poly1XRange, poly2XRange, poly1Position, poly2Position, poly1, poly2, polygons;\n\n  return _regeneratorRuntime().wrap(function generatePolygons$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _action$payload = action.payload, width = _action$payload.width, height = _action$payload.height;\n          MAX_POSITION_X = width - 100;\n          MAX_POSITION_Y = height - 100;\n          poly1XRange = [MIN_POSITION_X, width / 2];\n          poly2XRange = [width / 2, MAX_POSITION_X];\n          poly1Position = Vector2_Vector2.generateRandomFromCoords(poly1XRange[0], poly1XRange[1], 0, height);\n          poly2Position = Vector2_Vector2.generateRandomFromCoords(poly2XRange[0], poly2XRange[1], 0, height);\n          poly1 = getPolygonInitialState(1, poly1Position.invertY(540));\n          poly2 = getPolygonInitialState(2, poly2Position.invertY(540));\n          polygons = immutable_es.fromJS([poly1, poly2]);\n          _context.next = 12;\n          return put(savePolygons(polygons));\n\n        case 12:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\nfunction updatePolygons(action) {\n  var deltaTime, deltaSeconds, polygons, stageBounds, stageBorderingLines, polyCollisionsChecked, _loop, i, debugStr;\n\n  return _regeneratorRuntime().wrap(function updatePolygons$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          deltaTime = action.payload.deltaTime;\n          deltaSeconds = deltaTime / 3600;\n          _context2.next = 4;\n          return io_6de156f3_select(getPolygonList);\n\n        case 4:\n          polygons = _context2.sent;\n          _context2.next = 7;\n          return io_6de156f3_select(getStageBounds);\n\n        case 7:\n          stageBounds = _context2.sent;\n          _context2.next = 10;\n          return io_6de156f3_select(getStageBorderingLines);\n\n        case 10:\n          stageBorderingLines = _context2.sent;\n          polyCollisionsChecked = [];\n\n          _loop = function _loop(i) {\n            loop += 1;\n            var polygon = polygons.get(i);\n            var velocity = polygon.get('velocity');\n            var positionDelta = velocity.multiplyScalar(deltaSeconds);\n            var newPosition = polygon.get('position').addVector(positionDelta);\n            polygons = polygons.setIn([i, 'position'], newPosition);\n            var rotationDelta = polygon.get('angularVelocity') * deltaSeconds;\n            var newRotation = polygon.get('rotation') + rotationDelta;\n            polygons = polygons.setIn([i, 'rotation'], newRotation);\n            var mathPolygon = polygon.get('polygon');\n            mathPolygon.rotate(rotationDelta);\n            var polyLines = mathPolygon.getLines(newPosition);\n            var hitTopLine = polyLines.some(function (line) {\n              return line.calculateSegmentIntersection(stageBorderingLines.get('topLine'));\n            }) && velocity.y < 0;\n            var hitRightLine = polyLines.some(function (line) {\n              return line.calculateSegmentIntersection(stageBorderingLines.get('rightLine'));\n            }) && velocity.x > 0;\n            var hitBottomLine = polyLines.some(function (line) {\n              return line.calculateSegmentIntersection(stageBorderingLines.get('bottomLine'));\n            }) && velocity.y > 0;\n            var hitLeftLine = polyLines.some(function (line) {\n              return line.calculateSegmentIntersection(stageBorderingLines.get('leftLine'));\n            }) && velocity.x < 0;\n\n            var _loop2 = function _loop2(j) {\n              if (j === i) {\n                return \"continue\";\n              }\n\n              if (polyCollisionsChecked.some(function (set) {\n                return set.has(i) && set.has(j);\n              })) {\n                return \"continue\";\n              }\n\n              polyCollisionsChecked.push(new Set([i, j]));\n              var intersection = void 0;\n\n              for (var k = 0; k < polyLines.size; k += 1) {\n                var line = polyLines.get(k);\n                var otherPolygonLines = polygons.getIn([j, 'polygon']).getLines(polygons.getIn([j, 'position']));\n\n                for (var l = 0; l < otherPolygonLines.size; l += 1) {\n                  var otherLine = otherPolygonLines.get(l);\n\n                  var _intersection = line.calculateSegmentIntersection(otherLine);\n\n                  if (_intersection) {\n                    intersection = _intersection;\n                    break;\n                  }\n                }\n\n                if (intersection) {\n                  break;\n                }\n              }\n\n              if (intersection) {\n                var currentPolygonMass = polygons.getIn([i, 'mass']);\n                var otherPolygonMass = polygons.getIn([j, 'mass']);\n                var currentPolygonInitialVelocity = polygons.getIn([i, 'velocity']);\n                var otherPolygonInitialVelocity = polygons.getIn([j, 'velocity']);\n                var multiplier1 = (currentPolygonMass - otherPolygonMass) / (currentPolygonMass + otherPolygonMass);\n                var multiplier2 = 2 * otherPolygonMass / (currentPolygonMass + otherPolygonMass);\n                var multiplier3 = 2 * currentPolygonMass / (currentPolygonMass + otherPolygonMass);\n                var multiplier4 = (otherPolygonMass - currentPolygonMass) / (currentPolygonMass + otherPolygonMass);\n                var currentPolygonNewVelocity = currentPolygonInitialVelocity.multiplyScalar(multiplier1).addVector(otherPolygonInitialVelocity.multiplyScalar(multiplier2));\n                var otherPolygonNewVelocity = currentPolygonInitialVelocity.multiplyScalar(multiplier3).addVector(otherPolygonInitialVelocity.multiplyScalar(multiplier4));\n                polygons = polygons.setIn([i, 'velocity'], currentPolygonNewVelocity);\n                polygons = polygons.setIn([j, 'velocity'], otherPolygonNewVelocity);\n              }\n            };\n\n            for (var j = 0; j < polygons.size; j += 1) {\n              var _ret = _loop2(j);\n\n              if (_ret === \"continue\") continue;\n            }\n\n            if (hitTopLine || hitBottomLine) {\n              var multiplier = new Vector2_Vector2({\n                x: 1,\n                y: -1\n              }); // invert Y component\n\n              var newVelocity = polygons.getIn([i, 'velocity']).multiplyVector(multiplier);\n              polygons = polygons.setIn([i, 'velocity'], newVelocity);\n            }\n\n            if (hitRightLine || hitLeftLine) {\n              var _multiplier = new Vector2_Vector2({\n                x: -1,\n                y: 1\n              }); // invert X component\n\n\n              var _newVelocity = polygons.getIn([i, 'velocity']).multiplyVector(_multiplier);\n\n              polygons = polygons.setIn([i, 'velocity'], _newVelocity);\n            }\n          };\n\n          for (i = 0; i < polygons.size; i += 1) {\n            _loop(i);\n          }\n\n          debugStr = polygons.map(function (poly, i) {\n            var res = [\"POLY \".concat(i)];\n            res.push(\"position: \".concat(JSON.stringify(poly.get('position').testableObj())));\n            res.push(\"velocity: \".concat(JSON.stringify(poly.get('velocity').testableObj())));\n            return res.join('\\n');\n          }).toJS().join('\\n');\n          document.getElementById('debugView').innerText = debugStr;\n          _context2.next = 18;\n          return put(savePolygons(polygons));\n\n        case 18:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2);\n}\nfunction watch() {\n  return _regeneratorRuntime().wrap(function watch$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.next = 2;\n          return takeEvery$1(SET_STAGE_BOUNDS, generatePolygons);\n\n        case 2:\n          _context3.next = 4;\n          return takeEvery$1(UPDATE_POLYGONS, updatePolygons);\n\n        case 4:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked3);\n}\nfunction rootSaga() {\n  return _regeneratorRuntime().wrap(function rootSaga$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          _context4.next = 2;\n          return io_6de156f3_all([watch()]);\n\n        case 2:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, _marked4);\n}\n;// CONCATENATED MODULE: ./src/store/index.js\n\n\n\n\nvar sagaMiddleware = redux_saga_core_npm_proxy_esm();\n/* harmony default export */ const store = (configureStore({\n  reducer: reducers,\n  middleware: [sagaMiddleware]\n}));\nsagaMiddleware.run(rootSaga);\n;// CONCATENATED MODULE: ./src/components/App.jsx\nfunction App_extends() { App_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return App_extends.apply(this, arguments); }\n\n\n\n\n\n\n\nvar App = function App(_ref) {\n  var props = App_extends({}, _ref);\n\n  return /*#__PURE__*/react.createElement(components_Provider, {\n    store: store\n  }, /*#__PURE__*/react.createElement(DashboardTemplate, {\n    SimulationView: SimulationView,\n    ContentView: ContentView\n  }));\n};\n;// CONCATENATED MODULE: ./src/index.jsx\n\n\n\nvar root = (0,client/* createRoot */.s)(document.getElementById('app'));\nroot.render( /*#__PURE__*/react.createElement(App, null));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVTs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLE9BQU87QUFDNUIsMEJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xC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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixTQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU0sU0FBSTtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVCQUF1QixTQUFJO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdCQUFnQixTQUFJO0FBQ3BCLFlBQVksU0FBSTtBQUNoQixZQUFZLFNBQUk7QUFDaEIsWUFBWSxTQUFJO0FBQ2hCLFlBQVksU0FBSTtBQUNoQixZQUFZLFNBQUk7QUFDaEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJIQUEySDtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU0sZUFBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBTztBQUNqQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMLENBQUM7QUFDTSwyQkFBMkIsZUFBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHlCQUF5QixlQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxTQUFTO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLENBQUMsbUJBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBYztBQUN4Qyx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBK0I7QUFDOUM7QUFDQTtBQUNBLFFBQVEs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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsVUFBVTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxVQUFVO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLENBQUMsSUFBSSxtQkFBbUIsa0JBQWtCLElBQUksc0JBQXNCOzs7QUN4ckJuRDtBQUNOO0FBQ29CO0FBQy9DO0FBQ1A7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLENBQUMsSUFBSSxtQkFBbUIsa0JBQWtCLElBQUksc0JBQXNCOzs7QUNYbkQ7QUFDTjtBQUNvQjtBQUMvQztBQUNQO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLENBQUMsSUFBSSxpQkFBaUIsa0JBQWtCLElBQUksc0JBQXNCOzs7QUNqQ2pEO0FBQ047QUFDQTtBQUNvQjtBQUMvQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE1BQU07QUFDTjtBQUNBLHVCQUF1QixDQUFDLElBQUkseUJBQXlCLGtCQUFrQixJQUFJLHNCQUFzQjtBQUNqRyx1QkFBdUIsQ0FBQyxJQUFJLDJCQUEyQixrQkFBa0IsSUFBSSxzQkFBc0I7QUFDbkcsdUJBQXVCLENBQUMsSUFBSSx1Q0FBdUMsc0JBQXNCO0FBQ3pGLHVCQUF1QixDQUFDLElBQUksOEJBQThCLHNCQUFzQjs7O0FDckd4QztBQUNOO0FBQ29CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLENBQUMsSUFBSSxnQkFBZ0Isa0JBQWtCLElBQUksc0JBQXNCOzs7QUNsRmpGO0FBQ1A7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1J3QztBQUNOO0FBQ29CO0FBQ3RELHVCQUF1QixDQUFDLElBQUksWUFBWSxrQkFBa0IsSUFBSSxzQkFBc0I7QUFDcEYsdUJBQXVCLENBQUMsSUFBSSxtQkFBbUIsa0JBQWtCLElBQUksc0JBQXNCO0FBQzNGLHVCQUF1QixDQUFDLElBQUksa0JBQWtCLGtCQUFrQixJQUFJLHNCQUFzQjtBQUNuRjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2QndDO0FBQ047QUFDb0I7QUFDL0M7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixDQUFDLElBQUksWUFBWSxrQkFBa0IsSUFBSSxzQkFBc0I7QUFDcEYsdUJBQXVCLENBQUMsSUFBSSxtQkFBbUIsa0JBQWtCLElBQUksc0JBQXNCO0FBQzNGLHVCQUF1QixDQUFDLElBQUksY0FBYyxrQkFBa0IsSUFBSSxzQkFBc0I7OztBQ3ZCL0U7QUFDUDtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1B3QztBQUNOO0FBQ0E7QUFDb0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0Isb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCLHlCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQSxvQkFBb0IsV0FBVztBQUMvQix3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msa0JBQWtCO0FBQzFEO0FBQ0EsdUJBQXVCLENBQUMsSUFBSSwwQkFBMEIsa0JBQWtCLElBQUksc0JBQXNCO0FBQ2xHLHVCQUF1QixDQUFDLElBQUksMEJBQTBCLGtCQUFrQixJQUFJLHNCQUFzQjs7O0FDbkkxRDtBQUNOO0FBQ29CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0NBQWdDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQWdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1Qix3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7QUFDeEMsaUNBQWlDLFdBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1Qix3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7QUFDeEMsaUNBQWlDLFdBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1Qix3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7QUFDeEMsaUNBQWlDLFdBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLENBQUMsSUFBSSxrQkFBa0Isa0JBQWtCLElBQUksc0JBQXNCOzs7QUMzSWxEO0FBQ047QUFDb0I7QUFDL0M7QUFDUDtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsQ0FBQyxJQUFJLGdCQUFnQixrQkFBa0IsSUFBSSxzQkFBc0I7OztBQ1hoRDtBQUNOO0FBQ0E7QUFDb0I7QUFDL0M7QUFDUDtBQUNBO0FBQ0EsUUFBUSxlQUFVO0FBQ2xCO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQyx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsYUFBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsYUFBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixDQUFDLElBQUksa0JBQWtCLGtCQUFrQixJQUFJLHNCQUFzQjs7O0FDM0RsRDtBQUNOO0FBQ29CO0FBQy9DO0FBQ1A7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsQ0FBQyxJQUFJLGlCQUFpQixrQkFBa0IsSUFBSSxzQkFBc0I7OztBQ1RqRDtBQUNOO0FBQ2M7QUFDekM7QUFDUDtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsQ0FBQyxJQUFJO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVCQUF1QixDQUFDLElBQUk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUJBQXVCLENBQUMsSUFBSSxhQUFhLFlBQVksRUFBRSxzQkFBc0I7OztBQ3RDckM7QUFDTjtBQUNjO0FBQ3pDO0FBQ1A7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsQ0FBQyxJQUFJO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVCQUF1QixDQUFDLElBQUk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUJBQXVCLENBQUMsSUFBSSxhQUFhLFlBQVksRUFBRSxzQkFBc0I7QUFDN0UsdUJBQXVCLENBQUMsSUFBSTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQ2hETTtBQUNQO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVk87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsTUFBTTtBQUNOOzs7QUN4QndDO0FBQ047QUFDb0I7QUFDL0M7QUFDUDtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixDQUFDLElBQUksb0JBQW9CLGtCQUFrQixJQUFJLHNCQUFzQjs7O0FDVHhDO0FBQ2Q7QUFDSTtBQUNFO0FBQ0U7QUFDSjtBQUNLO0FBQ1A7QUFDQTtBQUNBO0FBQ29CO0FBQ3BCO0FBQ0k7QUFDSjtBQUNBO0FBQ1E7QUFDTTtBQUNaO0FBQ0Q7QUFDUTtBQUNBO0FBQ0o7QUFDRTtBQUNJO0FBQ1o7QUFDQTtBQUNNO0FBQ1k7QUFDaEI7QUFDRTtBQUNNO0FBQ0U7QUFDWjtBQUNFO0FBQ0U7QUFDTTtBQUNFO0FBQzVDLE1BQU0sb0JBQUssR0FBRyxpQ0FBaUIsQ0FBQyxvQkFBSTtBQUMzQyxPQUFPO0FBQ1AsU0FBUztBQUNULFVBQVU7QUFDVixXQUFXO0FBQ1gsU0FBUztBQUNULFNBQVM7QUFDVCxPQUFPO0FBQ1AsUUFBUTtBQUNSLFFBQVE7QUFDUixRQUFRO0FBQ1Isa0JBQWtCO0FBQ2xCLFFBQVE7QUFDUixVQUFVO0FBQ1YsUUFBUTtBQUNSLFFBQVE7QUFDUixZQUFZO0FBQ1osZUFBZTtBQUNmLFNBQVM7QUFDVDtBQUNBLFlBQVk7QUFDWixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZCxlQUFlO0FBQ2YsaUJBQWlCO0FBQ2pCLFdBQVc7QUFDWCxXQUFXO0FBQ1gsY0FBYztBQUNkLG9CQUFvQjtBQUNwQixZQUFZO0FBQ1osYUFBYTtBQUNiLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIsV0FBVztBQUNYLFlBQVk7QUFDWixhQUFhO0FBQ2IsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0wsQ0FBQzs7O0FDN0UyQztBQUM1QywwQ0FBZSxxREFBSyxJQUFDOzs7QUNEdUI7QUFDQTtBQUM1QywyQ0FBZSxvQkFBSyxFQUFDOzs7Ozs7OztBQ0ZvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPLFNBQVMsNEJBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsU0FBUyw0QkFBcUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcEhtQztBQUM2QztBQUN5QztBQUN2RDtBQUNsRTtBQUNBO0FBQ0E7QUFDQSwrQkFBZ0MsR0FBRyxjQUFjO0FBQzFDO0FBQ1A7QUFDQTtBQUNBLDJGQUEyRixNQUFNO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLElBQUksYUFBYTtBQUNqQjtBQUNPO0FBQ1Asb0JBQW9CLElBQUs7QUFDekI7QUFDQSx5REFBeUQsS0FBSyw0SUFBNEksS0FBSztBQUMvTSxvQkFBb0IsVUFBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksY0FBYztBQUNsQjtBQUNBO0FBQ087QUFDUCw2RkFBNkYsS0FBSztBQUNsRztBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxhQUFhO0FBQ2pCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGFBQWE7QUFDakI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksYUFBYTtBQUNqQjtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QixJQUFJLGFBQWE7QUFDakI7QUFDTztBQUNQO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUIsSUFBSSxhQUFhO0FBQ2pCO0FBQ087QUFDUCx3RkFBd0YsUUFBUTtBQUNoRztBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1AsSUFBSSxjQUFjO0FBQ2xCO0FBQ087QUFDUDtBQUNBLElBQUksYUFBYTtBQUNqQjtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNBLHNDQUFzQyw4QkFBb0I7OztBQzdKakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNhO0FBQ1M7QUFDaUI7QUFDUTtBQUNQO0FBQ1k7QUFDakU7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QixJQUFJLHFCQUFxQjtBQUN6QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQyxrQkFBa0IsWUFBWTtBQUM5QixxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQjtBQUN6Qiw0QkFBNEIsVUFBVztBQUN2QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3RUFBd0Usd0JBQWM7QUFDdEY7QUFDQTtBQUNBLGlCQUFpQixjQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLHFCQUFxQjtBQUN6QjtBQUNBLFFBQVEsY0FBYztBQUN0QjtBQUNBLEtBQUs7QUFDTCxXQUFXLG1CQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPLE1BQU0sb0JBQUs7QUFDWCxNQUFNLHdCQUFTO0FBQ2YsTUFBTSxvQkFBSztBQUNYLE1BQU0sb0JBQUs7QUFDWCxNQUFNLG1CQUFJO0FBQ1YsTUFBTSxxQkFBTTtBQUNaLE1BQU0sc0JBQU87QUFDYixNQUFNLG9CQUFLO0FBQ1gsTUFBTSxtQkFBSTtBQUNWLE1BQU0scUJBQU07QUFDWixNQUFNLG9CQUFLO0FBQ1gsTUFBTSxtQkFBSTtBQUNWLE1BQU0sdUJBQVE7QUFDZCxNQUFNLG1CQUFJO0FBQ1YsTUFBTSxtQkFBSTtBQUNWLE1BQU0sa0JBQUc7QUFDVCxNQUFNLGtCQUFHO0FBQ1QsTUFBTSxtQkFBSTtBQUNWLE1BQU0sNkJBQWM7QUFDcEIsTUFBTSxvQkFBSztBQUNYLE1BQU0sb0JBQUs7QUFDWCxNQUFNLDBCQUFXO0FBQ2pCLHNCQUFzQiwwQkFBb0IsQ0FBQyxvQ0FBVTtBQUM1RDtBQUNBO0FBQ0EsZ0JBQWdCLE1BQXFDLEdBQUcsQ0FBQztBQUN6RCxhQUFhLGFBQWE7QUFDMUI7QUFDQSxDQUFDO0FBQ00sTUFBTSxvQkFBSyxHQUFHLGdCQUFnQjtBQUNyQyxXQUFXLG1CQUFtQixjQUFjLDZCQUE2QjtBQUN6RSxDQUFDO0FBQ00sTUFBTSw0QkFBYSxHQUFHLGdFQUFnQjs7O0FDdkc3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ0U7QUFDa0I7OztBQ1RqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksMkJBQWM7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsS0FBSztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVywyQkFBYztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGVBQUU7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsb0JBQU87O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxvQkFBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrREFBa0QsNEJBQTRCO0FBQzlFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOERBQThEO0FBQ25GO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQ0FBK0MsNEJBQTRCO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSwyREFBMkQ7QUFDM0QsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0Qsc0NBQXNDO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLGtFQUFrRTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsMENBQTBDO0FBQzFDLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRFQUE0RTtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGdCQUFHO0FBQ2xCO0FBQ0EsNkVBQTZFLGVBQWU7QUFDNUYsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxnQkFBRztBQUMxRDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxHQUFHO0FBQ0g7QUFDQSxxQ0FBcUMsd0NBQXdDO0FBQzdFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwyQkFBMkIsc0JBQXNCOztBQUVqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNwQixRQUFRLGVBQUU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLFVBQVU7QUFDbkQsUUFBUSxlQUFFO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVztBQUNwQixRQUFRLGVBQUU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLGVBQUU7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQUU7QUFDbkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxnQkFBZ0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsVUFBVTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGFBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHdCQUF3QjtBQUM3RCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHNDQUFzQywwQkFBMEIsSUFBSTtBQUN4RyxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHVCQUF1QjtBQUNoRSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxLQUFLO0FBQzdDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixtREFBbUQ7QUFDNUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLENBQUMsZ0JBQUc7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwwQ0FBMEM7QUFDOUY7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsNEJBQTRCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxXQUFXLGdCQUFHO0FBQ2QsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFdBQVcsZ0JBQUc7QUFDZCxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSx3Q0FBd0MsT0FBTyxlQUFFLHVCQUF1QjtBQUN4RSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxnRkFBZ0YsY0FBYztBQUM5RixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EseUNBQXlDLE9BQU8sZUFBRSxtQkFBbUI7QUFDckUsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLDhCQUE4QjtBQUN2RSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQ0FBMkMsT0FBTyxlQUFFLHVCQUF1QjtBQUMzRSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw4REFBOEQ7QUFDN0Y7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw4Q0FBOEM7QUFDN0U7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEOztBQUU5RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHVCQUF1QjtBQUM3RCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyREFBMkQ7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG9CQUFvQjtBQUMxRCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsS0FBSztBQUM3Qzs7QUFFQTtBQUNBLENBQUMsQ0FBQyxnQkFBRzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJELDRCQUE0QjtBQUN2Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGVBQUU7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxlQUFFO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGVBQUU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsNkRBQTZEO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxpREFBaUQ7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOEJBQThCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFD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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSx5RkFBeUYsYUFBYTtBQUN0RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLFNBQVMsK0JBQVE7QUFDakIseUZBQXlGLGFBQWE7QUFDdEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQSx5RkFBeUYsYUFBYTtBQUN0RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EseUZBQXlGLGFBQWE7QUFDdEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLEtBQXFDLEVBQUUsRUFFMUM7O0FBRUgseUZBQXlGLGFBQWE7QUFDdEc7QUFDQTs7QUFFQSxTQUFTLHNCQUFVO0FBQ25CO0FBQ0E7QUFDQSxNQUFNLEtBQXFDLEVBQUUsRUFFMUM7O0FBRUgsNkZBQTZGLGVBQWU7QUFDNUc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDLEVBQUUsRUFFMUM7O0FBRUgsNkZBQTZGLGVBQWU7QUFDNUc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDLEVBQUUsRUFHMUM7O0FBRUgsNkZBQTZGLGVBQWU7QUFDNUc7QUFDQTs7QUFFQSw2QkFBNkIsK0JBQVE7QUFDckM7QUFDQTtBQUNBLDZGQUE2RixlQUFlO0FBQzVHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLGVBQWU7QUFDNUc7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QU8sRUFBRUYsUUFEbUI7RUFFNUJHLFVBQVUsRUFBRSxDQUFDRixjQUFEO0FBRmdCLENBQUQsQ0FBN0I7QUFLQUEsY0FBYyxDQUFDRyxHQUFmLENBQW1CcEYsUUFBbkIsRTs7OztBQ2JBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUVPLElBQU11RixHQUFHLEdBQUcsU0FBTkEsR0FBTSxPQUFrQjtFQUFBLElBQVpuUyxLQUFZOztFQUNuQyxvQkFDRSxvQkFBQyxtQkFBRDtJQUFVLEtBQUssRUFBRWtTLEtBQUtBO0VBQXRCLGdCQUNFLG9CQUFDLGlCQUFEO0lBQ0UsY0FBYyxFQUFFL1IsY0FEbEI7SUFFRSxXQUFXLEVBQUVDLFdBQVdBO0VBRjFCLEVBREYsQ0FERjtBQVFELENBVE0sQzs7QUNWUDtBQUNBO0FBRUE7QUFFQSxJQUFNaVMsSUFBSSxHQUFHRCw0QkFBVSxDQUFDZCxRQUFRLENBQUNDLGNBQVQsQ0FBd0IsS0FBeEIsQ0FBRCxDQUF2QjtBQUNBYyxJQUFJLENBQUNDLE1BQUwsZUFBWSxvQkFBQyxHQUFELE9BQVoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy9yZWFjdEJhdGNoZWRVcGRhdGVzLmpzP2Y1ZjUiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvYmF0Y2guanM/NGRmMiIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb21wb25lbnRzL0NvbnRleHQuanM/OGU4NyIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9ob29rcy91c2VSZWR1eENvbnRleHQuanM/OTgyNSIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy91c2VTeW5jRXh0ZXJuYWxTdG9yZS5qcz9iNDgwIiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2hvb2tzL3VzZVNlbGVjdG9yLmpzPzMzOWMiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcy5qcz9hOWRhIiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UuanM/ZGM0YiIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L3NlbGVjdG9yRmFjdG9yeS5qcz83OTA2Iiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL2JpbmRBY3Rpb25DcmVhdG9ycy5qcz84ODk0Iiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3Qvd3JhcE1hcFRvUHJvcHMuanM/MjQyNSIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L2ludmFsaWRBcmdGYWN0b3J5LmpzP2QwZmQiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9tYXBEaXNwYXRjaFRvUHJvcHMuanM/MmY1ZCIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L21hcFN0YXRlVG9Qcm9wcy5qcz9lNDU3Iiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvbWVyZ2VQcm9wcy5qcz9iZjRjIiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL1N1YnNjcmlwdGlvbi5qcz83OWQ2Iiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL3VzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QuanM/NTdlNiIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy9zaGFsbG93RXF1YWwuanM/MWEwOCIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb21wb25lbnRzL2Nvbm5lY3QuanM/YzhkYSIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb21wb25lbnRzL1Byb3ZpZGVyLmpzPzExZjgiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvaG9va3MvdXNlU3RvcmUuanM/Y2I4NyIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9ob29rcy91c2VEaXNwYXRjaC5qcz9lZTI0Iiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2V4cG9ydHMuanM/NGE3MSIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9pbmRleC5qcz9mY2MyIiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BlbW90aW9uL3N0eWxpcy9kaXN0L3N0eWxpcy5icm93c2VyLmVzbS5qcz9kMzFkIiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BlbW90aW9uL3VuaXRsZXNzL2Rpc3QvdW5pdGxlc3MuYnJvd3Nlci5lc20uanM/MzA0ZSIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9AZW1vdGlvbi9tZW1vaXplL2Rpc3QvZW1vdGlvbi1tZW1vaXplLmJyb3dzZXIuZXNtLmpzPzQ5NTgiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vaXMtcHJvcC12YWxpZC9kaXN0L2Vtb3Rpb24taXMtcHJvcC12YWxpZC5icm93c2VyLmVzbS5qcz8wOTM4Iiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3N0eWxlZC1jb21wb25lbnRzL2Rpc3Qvc3R5bGVkLWNvbXBvbmVudHMuYnJvd3Nlci5lc20uanM/YmNlOSIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1ib290c3RyYXAvZXNtL1RoZW1lUHJvdmlkZXIuanM/YmQ0NyIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1ib290c3RyYXAvZXNtL0NvbnRhaW5lci5qcz9lZWZhIiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWJvb3RzdHJhcC9lc20vUm93LmpzP2RkOWYiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvcmVhY3QtYm9vdHN0cmFwL2VzbS9Db2wuanM/MjQ4ZSIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL3NyYy9jb25zdGFudHMvdWlDb25zdGFudHMuanM/NTZhNCIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL3NyYy90ZW1wbGF0ZXMvRGFzaGJvYXJkVGVtcGxhdGUuanN4PzlkYzkiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2V0UHJvdG90eXBlT2YuanM/MmExNiIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c0xvb3NlLmpzPzg0MTQiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvcmVzaXplLW9ic2VydmVyLXBvbHlmaWxsL2Rpc3QvUmVzaXplT2JzZXJ2ZXIuZXMuanM/NmRkOCIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tZWFzdXJlL2Rpc3QvaW5kZXguZXNtLmpzPzA4Y2IiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMva29udmEvbGliL0dsb2JhbC5qcz85ZTc1Iiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2tvbnZhL2xpYi9VdGlsLmpzPzEzN2MiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMva29udmEvbGliL1ZhbGlkYXRvcnMuanM/ODc1NyIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9rb252YS9saWIvRmFjdG9yeS5qcz83ZTdkIiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2tvbnZhL2xpYi9Db250ZXh0LmpzPzA2ZGQiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMva29udmEvbGliL0NhbnZhcy5qcz85YThmIiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2tvbnZhL2xpYi9EcmFnQW5kRHJvcC5qcz9jMjlmIiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2tvbnZhL2xpYi9Ob2RlLmpzPzk4ZWEiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMva29udmEvbGliL0NvbnRhaW5lci5qcz9jYTQ0Iiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2tvbnZhL2xpYi9Qb2ludGVyRXZlbnRzLmpzPzIyNWMiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMva29udmEvbGliL1N0YWdlLmpzPzkxZjMiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMva29udmEvbGliL1NoYXBlLmpzP2M5NWMiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMva29udmEvbGliL0xheWVyLmpzPzg3YjAiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMva29udmEvbGliL0Zhc3RMYXllci5qcz84OGQ3Iiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2tvbnZhL2xpYi9Hcm91cC5qcz9kZWJiIiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2tvbnZhL2xpYi9BbmltYXRpb24uanM/ODZlYiIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9rb252YS9saWIvVHdlZW4uanM/OTgyOCIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9rb252YS9saWIvX0NvcmVJbnRlcm5hbHMuanM/YzE4YyIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9rb252YS9saWIvc2hhcGVzL0FyYy5qcz81MDVkIiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2tvbnZhL2xpYi9zaGFwZXMvTGluZS5qcz9jODA2Iiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2tvbnZhL2xpYi9zaGFwZXMvUGF0aC5qcz9lMWU3Iiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2tvbnZhL2xpYi9zaGFwZXMvQXJyb3cuanM/MDgzMyIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9rb252YS9saWIvc2hhcGVzL0NpcmNsZS5qcz9mYjRhIiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2tvbnZhL2xpYi9zaGFwZXMvRWxsaXBzZS5qcz9jOGVjIiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2tvbnZhL2xpYi9zaGFwZXMvSW1hZ2UuanM/ZjM5NyIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9rb252YS9saWIvc2hhcGVzL0xhYmVsLmpzP2Y1NGIiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMva29udmEvbGliL3NoYXBlcy9SZWN0LmpzPzJjNjkiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMva29udmEvbGliL3NoYXBlcy9SZWd1bGFyUG9seWdvbi5qcz9lNDZlIiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2tvbnZhL2xpYi9zaGFwZXMvUmluZy5qcz82MDY0Iiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2tvbnZhL2xpYi9zaGFwZXMvU3ByaXRlLmpzPzZmZTAiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMva29udmEvbGliL3NoYXBlcy9TdGFyLmpzPzRlNWMiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMva29udmEvbGliL3NoYXBlcy9UZXh0LmpzPzFkOWMiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMva29udmEvbGliL3NoYXBlcy9UZXh0UGF0aC5qcz85OGI3Iiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2tvbnZhL2xpYi9zaGFwZXMvVHJhbnNmb3JtZXIuanM/M2EyMSIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9rb252YS9saWIvc2hhcGVzL1dlZGdlLmpzP2FhZTIiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMva29udmEvbGliL2ZpbHRlcnMvQmx1ci5qcz83OWM4Iiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2tvbnZhL2xpYi9maWx0ZXJzL0JyaWdodGVuLmpzP2ZiNWEiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMva29udmEvbGliL2ZpbHRlcnMvQ29udHJhc3QuanM/MzBiZCIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9rb252YS9saWIvZmlsdGVycy9FbWJvc3MuanM/Y2ZjZiIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9rb252YS9saWIvZmlsdGVycy9FbmhhbmNlLmpzP2Q5YmEiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMva29udmEvbGliL2ZpbHRlcnMvR3JheXNjYWxlLmpzPzU0YWMiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMva29udmEvbGliL2ZpbHRlcnMvSFNMLmpzPzViNjUiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMva29udmEvbGliL2ZpbHRlcnMvSFNWLmpzPzI5ODQiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMva29udmEvbGliL2ZpbHRlcnMvSW52ZXJ0LmpzP2JlYTAiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMva29udmEvbGliL2ZpbHRlcnMvS2FsZWlkb3Njb3BlLmpzPzMxNTkiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMva29udmEvbGliL2ZpbHRlcnMvTWFzay5qcz84NGQ2Iiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2tvbnZhL2xpYi9maWx0ZXJzL05vaXNlLmpzP2RiOWMiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMva29udmEvbGliL2ZpbHRlcnMvUGl4ZWxhdGUuanM/NTljMyIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9rb252YS9saWIvZmlsdGVycy9Qb3N0ZXJpemUuanM/MjQ2NiIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9rb252YS9saWIvZmlsdGVycy9SR0IuanM/NmI2MCIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9rb252YS9saWIvZmlsdGVycy9SR0JBLmpzP2U0MDciLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMva29udmEvbGliL2ZpbHRlcnMvU2VwaWEuanM/YWY5YyIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9rb252YS9saWIvZmlsdGVycy9Tb2xhcml6ZS5qcz82MWZmIiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2tvbnZhL2xpYi9maWx0ZXJzL1RocmVzaG9sZC5qcz85Yjk2Iiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2tvbnZhL2xpYi9fRnVsbEludGVybmFscy5qcz9mMjM4Iiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2tvbnZhL2xpYi9pbmRleC5qcz80ZTZjIiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2tvbnZhL2xpYi9Db3JlLmpzPzU5YzciLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvcmVhY3Qta29udmEvZXMvbWFrZVVwZGF0ZXMuanM/NjRhYSIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1rb252YS9lcy9SZWFjdEtvbnZhSG9zdENvbmZpZy5qcz9jODA4Iiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWtvbnZhL2VzL1JlYWN0S29udmFDb3JlLmpzPzk0ZGYiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvcmVhY3Qta29udmEvZXMvUmVhY3RLb252YS5qcz85ODhkIiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2ltbXV0YWJsZS9kaXN0L2ltbXV0YWJsZS5lcy5qcz8zMjliIiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vc3JjL2NvbnN0YW50cy9pbmRleC5qcz81YTUwIiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vc3JjL21hdGgvdXRpbHMuanM/ZjQ1MyIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL3NyYy9tYXRoL1ZlY3RvcjIuanM/MDIwZCIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL3NyYy9tYXRoL0xpbmUuanM/MzgwMyIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL3NyYy9tYXRoL1BvbHlnb24uanM/M2Q4OSIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL3NyYy9tYXRoL2luZGV4LmpzP2U1MmQiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9zcmMvY29tcG9uZW50cy9Lb252YVBvbHlnb24uanN4P2ZlYTAiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9zcmMvYWN0aW9ucy9zaW11bGF0aW9uLmpzP2NiNGIiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9zcmMvYWN0aW9ucy9wb2x5Z29ucy5qcz82MGU1Iiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3Jlc2VsZWN0L2VzL2RlZmF1bHRNZW1vaXplLmpzPzEyYzgiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvcmVzZWxlY3QvZXMvaW5kZXguanM/MWI4YSIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL3NyYy9zZWxlY3RvcnMvcG9seWdvbnMuanM/MzVmMCIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL3NyYy9zZWxlY3RvcnMvc2ltdWxhdGlvbi5qcz81YjkzIiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vc3JjL2NvbXBvbmVudHMvU2ltdWxhdGlvblZpZXcuanN4P2ZjZGIiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9zcmMvY29tcG9uZW50cy9EaWFsQmFzZS5qc3g/MTQwNSIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL3NyYy9jb21wb25lbnRzL1NjYWxhckRpYWwuanN4PzgzMTYiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9zcmMvY29tcG9uZW50cy9Db29yZHNEaWFsLmpzeD9hYTZhIiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vc3JjL2NvbXBvbmVudHMvQW5nbGVEaWFsLmpzeD84NjBmIiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vc3JjL2NvbXBvbmVudHMvVmVjdG9yRGlhbC5qc3g/MmM3OCIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL3NyYy9jb21wb25lbnRzL0RpYWwuanN4PzM3OTYiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9zcmMvY29tcG9uZW50cy9Db250ZW50Vmlldy5qc3g/MDlhMCIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9pbW1lci9kaXN0L2ltbWVyLmVzbS5tanM/ZWNmNyIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eS5qcz9jNWI5Iiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFNwcmVhZDIuanM/MTAxNyIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWR1eC9lcy9yZWR1eC5qcz8wMGQ4Iiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3JlZHV4LXRodW5rL2VzL2luZGV4LmpzP2IwODMiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3JlZHV4LXRvb2xraXQuZXNtLmpzPzhiYjMiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQHJlZHV4LXNhZ2Evc3ltYm9scy9kaXN0L3JlZHV4LXNhZ2Etc3ltYm9scy5lc20uanM/ZjE4MyIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9AcmVkdXgtc2FnYS9pcy9kaXN0L3JlZHV4LXNhZ2EtaXMuZXNtLmpzP2I4ZmQiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQHJlZHV4LXNhZ2EvZGVsYXktcC9kaXN0L3JlZHV4LXNhZ2EtZGVsYXktcC5lc20uanM/YjFlYiIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9AcmVkdXgtc2FnYS9jb3JlL2Rpc3QvaW8tNmRlMTU2ZjMuanM/ODZhYSIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9AcmVkdXgtc2FnYS9kZWZlcnJlZC9kaXN0L3JlZHV4LXNhZ2EtZGVmZXJyZWQuZXNtLmpzPzg5ZTMiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQHJlZHV4LXNhZ2EvY29yZS9kaXN0L3JlZHV4LXNhZ2EtY29yZS5lc20uanM/NDJhOSIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWR1eC1zYWdhL2Rpc3QvcmVkdXgtc2FnYS1jb3JlLW5wbS1wcm94eS5lc20uanM/YWQxNSIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL3NyYy9yZWR1Y2Vycy9wb2x5Z29ucy5qcz9iOGE3Iiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vc3JjL3JlZHVjZXJzL3NpbXVsYXRpb24uanM/YzliYiIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL3NyYy9yZWR1Y2Vycy9pbmRleC5qcz83Mjg5Iiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0ByZWR1eC1zYWdhL2NvcmUvZGlzdC9yZWR1eC1zYWdhLWVmZmVjdHMuZXNtLmpzP2ZjMWMiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvcmVkdXgtc2FnYS9kaXN0L3JlZHV4LXNhZ2EtZWZmZWN0cy1ucG0tcHJveHkuZXNtLmpzP2U2YjEiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9zcmMvdXRpbHMvcmFuZG9tSnNvbi5qcz8zZTRiIiwid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vc3JjL3NhZ2FzL2luZGV4LmpzPzlmNTMiLCJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9zcmMvc3RvcmUvaW5kZXguanM/NDM2MCIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL3NyYy9jb21wb25lbnRzL0FwcC5qc3g/YzU4YyIsIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL3NyYy9pbmRleC5qc3g/ZWQxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyB9IGZyb20gJ3JlYWN0LWRvbSc7IiwiLy8gRGVmYXVsdCB0byBhIGR1bW15IFwiYmF0Y2hcIiBpbXBsZW1lbnRhdGlvbiB0aGF0IGp1c3QgcnVucyB0aGUgY2FsbGJhY2tcbmZ1bmN0aW9uIGRlZmF1bHROb29wQmF0Y2goY2FsbGJhY2spIHtcbiAgY2FsbGJhY2soKTtcbn1cblxubGV0IGJhdGNoID0gZGVmYXVsdE5vb3BCYXRjaDsgLy8gQWxsb3cgaW5qZWN0aW5nIGFub3RoZXIgYmF0Y2hpbmcgZnVuY3Rpb24gbGF0ZXJcblxuZXhwb3J0IGNvbnN0IHNldEJhdGNoID0gbmV3QmF0Y2ggPT4gYmF0Y2ggPSBuZXdCYXRjaDsgLy8gU3VwcGx5IGEgZ2V0dGVyIGp1c3QgdG8gc2tpcCBkZWFsaW5nIHdpdGggRVNNIGJpbmRpbmdzXG5cbmV4cG9ydCBjb25zdCBnZXRCYXRjaCA9ICgpID0+IGJhdGNoOyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5leHBvcnQgY29uc3QgUmVhY3RSZWR1eENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgUmVhY3RSZWR1eENvbnRleHQuZGlzcGxheU5hbWUgPSAnUmVhY3RSZWR1eCc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlYWN0UmVkdXhDb250ZXh0OyIsImltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBSZWFjdFJlZHV4Q29udGV4dCB9IGZyb20gJy4uL2NvbXBvbmVudHMvQ29udGV4dCc7XG5cbi8qKlxyXG4gKiBBIGhvb2sgdG8gYWNjZXNzIHRoZSB2YWx1ZSBvZiB0aGUgYFJlYWN0UmVkdXhDb250ZXh0YC4gVGhpcyBpcyBhIGxvdy1sZXZlbFxyXG4gKiBob29rIHRoYXQgeW91IHNob3VsZCB1c3VhbGx5IG5vdCBuZWVkIHRvIGNhbGwgZGlyZWN0bHkuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHthbnl9IHRoZSB2YWx1ZSBvZiB0aGUgYFJlYWN0UmVkdXhDb250ZXh0YFxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXHJcbiAqIGltcG9ydCB7IHVzZVJlZHV4Q29udGV4dCB9IGZyb20gJ3JlYWN0LXJlZHV4J1xyXG4gKlxyXG4gKiBleHBvcnQgY29uc3QgQ291bnRlckNvbXBvbmVudCA9ICgpID0+IHtcclxuICogICBjb25zdCB7IHN0b3JlIH0gPSB1c2VSZWR1eENvbnRleHQoKVxyXG4gKiAgIHJldHVybiA8ZGl2PntzdG9yZS5nZXRTdGF0ZSgpfTwvZGl2PlxyXG4gKiB9XHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZHV4Q29udGV4dCgpIHtcbiAgY29uc3QgY29udGV4dFZhbHVlID0gdXNlQ29udGV4dChSZWFjdFJlZHV4Q29udGV4dCk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWNvbnRleHRWYWx1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IGZpbmQgcmVhY3QtcmVkdXggY29udGV4dCB2YWx1ZTsgcGxlYXNlIGVuc3VyZSB0aGUgY29tcG9uZW50IGlzIHdyYXBwZWQgaW4gYSA8UHJvdmlkZXI+Jyk7XG4gIH1cblxuICByZXR1cm4gY29udGV4dFZhbHVlO1xufSIsImV4cG9ydCBjb25zdCBub3RJbml0aWFsaXplZCA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKCd1U0VTIG5vdCBpbml0aWFsaXplZCEnKTtcbn07IiwiaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlRGVidWdWYWx1ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVJlZHV4Q29udGV4dCBhcyB1c2VEZWZhdWx0UmVkdXhDb250ZXh0IH0gZnJvbSAnLi91c2VSZWR1eENvbnRleHQnO1xuaW1wb3J0IHsgUmVhY3RSZWR1eENvbnRleHQgfSBmcm9tICcuLi9jb21wb25lbnRzL0NvbnRleHQnO1xuaW1wb3J0IHsgbm90SW5pdGlhbGl6ZWQgfSBmcm9tICcuLi91dGlscy91c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG5sZXQgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgPSBub3RJbml0aWFsaXplZDtcbmV4cG9ydCBjb25zdCBpbml0aWFsaXplVXNlU2VsZWN0b3IgPSBmbiA9PiB7XG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yID0gZm47XG59O1xuXG5jb25zdCByZWZFcXVhbGl0eSA9IChhLCBiKSA9PiBhID09PSBiO1xuLyoqXHJcbiAqIEhvb2sgZmFjdG9yeSwgd2hpY2ggY3JlYXRlcyBhIGB1c2VTZWxlY3RvcmAgaG9vayBib3VuZCB0byBhIGdpdmVuIGNvbnRleHQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhY3QuQ29udGV4dH0gW2NvbnRleHQ9UmVhY3RSZWR1eENvbnRleHRdIENvbnRleHQgcGFzc2VkIHRvIHlvdXIgYDxQcm92aWRlcj5gLlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgYHVzZVNlbGVjdG9yYCBob29rIGJvdW5kIHRvIHRoZSBzcGVjaWZpZWQgY29udGV4dC5cclxuICovXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9ySG9vayhjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHQpIHtcbiAgY29uc3QgdXNlUmVkdXhDb250ZXh0ID0gY29udGV4dCA9PT0gUmVhY3RSZWR1eENvbnRleHQgPyB1c2VEZWZhdWx0UmVkdXhDb250ZXh0IDogKCkgPT4gdXNlQ29udGV4dChjb250ZXh0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVzZVNlbGVjdG9yKHNlbGVjdG9yLCBlcXVhbGl0eUZuID0gcmVmRXF1YWxpdHkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtdXN0IHBhc3MgYSBzZWxlY3RvciB0byB1c2VTZWxlY3RvcmApO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHNlbGVjdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IG11c3QgcGFzcyBhIGZ1bmN0aW9uIGFzIGEgc2VsZWN0b3IgdG8gdXNlU2VsZWN0b3JgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBlcXVhbGl0eUZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IG11c3QgcGFzcyBhIGZ1bmN0aW9uIGFzIGFuIGVxdWFsaXR5IGZ1bmN0aW9uIHRvIHVzZVNlbGVjdG9yYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgc3RvcmUsXG4gICAgICBzdWJzY3JpcHRpb24sXG4gICAgICBnZXRTZXJ2ZXJTdGF0ZVxuICAgIH0gPSB1c2VSZWR1eENvbnRleHQoKTtcbiAgICBjb25zdCBzZWxlY3RlZFN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3Ioc3Vic2NyaXB0aW9uLmFkZE5lc3RlZFN1Yiwgc3RvcmUuZ2V0U3RhdGUsIGdldFNlcnZlclN0YXRlIHx8IHN0b3JlLmdldFN0YXRlLCBzZWxlY3RvciwgZXF1YWxpdHlGbik7XG4gICAgdXNlRGVidWdWYWx1ZShzZWxlY3RlZFN0YXRlKTtcbiAgICByZXR1cm4gc2VsZWN0ZWRTdGF0ZTtcbiAgfTtcbn1cbi8qKlxyXG4gKiBBIGhvb2sgdG8gYWNjZXNzIHRoZSByZWR1eCBzdG9yZSdzIHN0YXRlLiBUaGlzIGhvb2sgdGFrZXMgYSBzZWxlY3RvciBmdW5jdGlvblxyXG4gKiBhcyBhbiBhcmd1bWVudC4gVGhlIHNlbGVjdG9yIGlzIGNhbGxlZCB3aXRoIHRoZSBzdG9yZSBzdGF0ZS5cclxuICpcclxuICogVGhpcyBob29rIHRha2VzIGFuIG9wdGlvbmFsIGVxdWFsaXR5IGNvbXBhcmlzb24gZnVuY3Rpb24gYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXJcclxuICogdGhhdCBhbGxvd3MgeW91IHRvIGN1c3RvbWl6ZSB0aGUgd2F5IHRoZSBzZWxlY3RlZCBzdGF0ZSBpcyBjb21wYXJlZCB0byBkZXRlcm1pbmVcclxuICogd2hldGhlciB0aGUgY29tcG9uZW50IG5lZWRzIHRvIGJlIHJlLXJlbmRlcmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZWxlY3RvciB0aGUgc2VsZWN0b3IgZnVuY3Rpb25cclxuICogQHBhcmFtIHtGdW5jdGlvbj19IGVxdWFsaXR5Rm4gdGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGRldGVybWluZSBlcXVhbGl0eVxyXG4gKlxyXG4gKiBAcmV0dXJucyB7YW55fSB0aGUgc2VsZWN0ZWQgc3RhdGVcclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xyXG4gKiBpbXBvcnQgeyB1c2VTZWxlY3RvciB9IGZyb20gJ3JlYWN0LXJlZHV4J1xyXG4gKlxyXG4gKiBleHBvcnQgY29uc3QgQ291bnRlckNvbXBvbmVudCA9ICgpID0+IHtcclxuICogICBjb25zdCBjb3VudGVyID0gdXNlU2VsZWN0b3Ioc3RhdGUgPT4gc3RhdGUuY291bnRlcilcclxuICogICByZXR1cm4gPGRpdj57Y291bnRlcn08L2Rpdj5cclxuICogfVxyXG4gKi9cblxuZXhwb3J0IGNvbnN0IHVzZVNlbGVjdG9yID0gLyojX19QVVJFX18qL2NyZWF0ZVNlbGVjdG9ySG9vaygpOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn0iLCJpbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2VcIjtcbmNvbnN0IF9leGNsdWRlZCA9IFtcImluaXRNYXBTdGF0ZVRvUHJvcHNcIiwgXCJpbml0TWFwRGlzcGF0Y2hUb1Byb3BzXCIsIFwiaW5pdE1lcmdlUHJvcHNcIl07XG5pbXBvcnQgdmVyaWZ5U3Vic2VsZWN0b3JzIGZyb20gJy4vdmVyaWZ5U3Vic2VsZWN0b3JzJztcbmV4cG9ydCBmdW5jdGlvbiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgZGlzcGF0Y2gsIHtcbiAgYXJlU3RhdGVzRXF1YWwsXG4gIGFyZU93blByb3BzRXF1YWwsXG4gIGFyZVN0YXRlUHJvcHNFcXVhbFxufSkge1xuICBsZXQgaGFzUnVuQXRMZWFzdE9uY2UgPSBmYWxzZTtcbiAgbGV0IHN0YXRlO1xuICBsZXQgb3duUHJvcHM7XG4gIGxldCBzdGF0ZVByb3BzO1xuICBsZXQgZGlzcGF0Y2hQcm9wcztcbiAgbGV0IG1lcmdlZFByb3BzO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZUZpcnN0Q2FsbChmaXJzdFN0YXRlLCBmaXJzdE93blByb3BzKSB7XG4gICAgc3RhdGUgPSBmaXJzdFN0YXRlO1xuICAgIG93blByb3BzID0gZmlyc3RPd25Qcm9wcztcbiAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgaGFzUnVuQXRMZWFzdE9uY2UgPSB0cnVlO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU5ld1Byb3BzQW5kTmV3U3RhdGUoKSB7XG4gICAgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGlmIChtYXBEaXNwYXRjaFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU5ld1Byb3BzKCkge1xuICAgIGlmIChtYXBTdGF0ZVRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICBpZiAobWFwRGlzcGF0Y2hUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKSBkaXNwYXRjaFByb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVOZXdTdGF0ZSgpIHtcbiAgICBjb25zdCBuZXh0U3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGNvbnN0IHN0YXRlUHJvcHNDaGFuZ2VkID0gIWFyZVN0YXRlUHJvcHNFcXVhbChuZXh0U3RhdGVQcm9wcywgc3RhdGVQcm9wcyk7XG4gICAgc3RhdGVQcm9wcyA9IG5leHRTdGF0ZVByb3BzO1xuICAgIGlmIChzdGF0ZVByb3BzQ2hhbmdlZCkgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdWJzZXF1ZW50Q2FsbHMobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIHtcbiAgICBjb25zdCBwcm9wc0NoYW5nZWQgPSAhYXJlT3duUHJvcHNFcXVhbChuZXh0T3duUHJvcHMsIG93blByb3BzKTtcbiAgICBjb25zdCBzdGF0ZUNoYW5nZWQgPSAhYXJlU3RhdGVzRXF1YWwobmV4dFN0YXRlLCBzdGF0ZSk7XG4gICAgc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgb3duUHJvcHMgPSBuZXh0T3duUHJvcHM7XG4gICAgaWYgKHByb3BzQ2hhbmdlZCAmJiBzdGF0ZUNoYW5nZWQpIHJldHVybiBoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlKCk7XG4gICAgaWYgKHByb3BzQ2hhbmdlZCkgcmV0dXJuIGhhbmRsZU5ld1Byb3BzKCk7XG4gICAgaWYgKHN0YXRlQ2hhbmdlZCkgcmV0dXJuIGhhbmRsZU5ld1N0YXRlKCk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHB1cmVGaW5hbFByb3BzU2VsZWN0b3IobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIHtcbiAgICByZXR1cm4gaGFzUnVuQXRMZWFzdE9uY2UgPyBoYW5kbGVTdWJzZXF1ZW50Q2FsbHMobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIDogaGFuZGxlRmlyc3RDYWxsKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKTtcbiAgfTtcbn1cbi8vIFRPRE86IEFkZCBtb3JlIGNvbW1lbnRzXG4vLyBUaGUgc2VsZWN0b3IgcmV0dXJuZWQgYnkgc2VsZWN0b3JGYWN0b3J5IHdpbGwgbWVtb2l6ZSBpdHMgcmVzdWx0cyxcbi8vIGFsbG93aW5nIGNvbm5lY3QncyBzaG91bGRDb21wb25lbnRVcGRhdGUgdG8gcmV0dXJuIGZhbHNlIGlmIGZpbmFsXG4vLyBwcm9wcyBoYXZlIG5vdCBjaGFuZ2VkLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShkaXNwYXRjaCwgX3JlZikge1xuICBsZXQge1xuICAgIGluaXRNYXBTdGF0ZVRvUHJvcHMsXG4gICAgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyxcbiAgICBpbml0TWVyZ2VQcm9wc1xuICB9ID0gX3JlZixcbiAgICAgIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBfZXhjbHVkZWQpO1xuXG4gIGNvbnN0IG1hcFN0YXRlVG9Qcm9wcyA9IGluaXRNYXBTdGF0ZVRvUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuICBjb25zdCBtYXBEaXNwYXRjaFRvUHJvcHMgPSBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcbiAgY29uc3QgbWVyZ2VQcm9wcyA9IGluaXRNZXJnZVByb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZlcmlmeVN1YnNlbGVjdG9ycyhtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcyk7XG4gIH1cblxuICByZXR1cm4gcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoLCBvcHRpb25zKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKSB7XG4gIGNvbnN0IGJvdW5kQWN0aW9uQ3JlYXRvcnMgPSB7fTtcblxuICBmb3IgKGNvbnN0IGtleSBpbiBhY3Rpb25DcmVhdG9ycykge1xuICAgIGNvbnN0IGFjdGlvbkNyZWF0b3IgPSBhY3Rpb25DcmVhdG9yc1trZXldO1xuXG4gICAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBib3VuZEFjdGlvbkNyZWF0b3JzW2tleV0gPSAoLi4uYXJncykgPT4gZGlzcGF0Y2goYWN0aW9uQ3JlYXRvciguLi5hcmdzKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJvdW5kQWN0aW9uQ3JlYXRvcnM7XG59IiwiaW1wb3J0IHZlcmlmeVBsYWluT2JqZWN0IGZyb20gJy4uL3V0aWxzL3ZlcmlmeVBsYWluT2JqZWN0JztcbmV4cG9ydCBmdW5jdGlvbiB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KCAvLyAqIE5vdGU6XG4vLyAgSXQgc2VlbXMgdGhhdCB0aGUgZGlzcGF0Y2ggYXJndW1lbnRcbi8vICBjb3VsZCBiZSBhIGRpc3BhdGNoIGZ1bmN0aW9uIGluIHNvbWUgY2FzZXMgKGV4OiB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNNaXNzaW5nKVxuLy8gIGFuZCBhIHN0YXRlIG9iamVjdCBpbiBzb21lIG90aGVycyAoZXg6IHdoZW5NYXBTdGF0ZVRvUHJvcHNJc01pc3NpbmcpXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbmdldENvbnN0YW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0Q29uc3RhbnRTZWxlY3RvcihkaXNwYXRjaCkge1xuICAgIGNvbnN0IGNvbnN0YW50ID0gZ2V0Q29uc3RhbnQoZGlzcGF0Y2gpO1xuXG4gICAgZnVuY3Rpb24gY29uc3RhbnRTZWxlY3RvcigpIHtcbiAgICAgIHJldHVybiBjb25zdGFudDtcbiAgICB9XG5cbiAgICBjb25zdGFudFNlbGVjdG9yLmRlcGVuZHNPbk93blByb3BzID0gZmFsc2U7XG4gICAgcmV0dXJuIGNvbnN0YW50U2VsZWN0b3I7XG4gIH07XG59IC8vIGRlcGVuZHNPbk93blByb3BzIGlzIHVzZWQgYnkgY3JlYXRlTWFwVG9Qcm9wc1Byb3h5IHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHBhc3MgcHJvcHMgYXMgYXJnc1xuLy8gdG8gdGhlIG1hcFRvUHJvcHMgZnVuY3Rpb24gYmVpbmcgd3JhcHBlZC4gSXQgaXMgYWxzbyB1c2VkIGJ5IG1ha2VQdXJlUHJvcHNTZWxlY3RvciB0byBkZXRlcm1pbmVcbi8vIHdoZXRoZXIgbWFwVG9Qcm9wcyBuZWVkcyB0byBiZSBpbnZva2VkIHdoZW4gcHJvcHMgaGF2ZSBjaGFuZ2VkLlxuLy9cbi8vIEEgbGVuZ3RoIG9mIG9uZSBzaWduYWxzIHRoYXQgbWFwVG9Qcm9wcyBkb2VzIG5vdCBkZXBlbmQgb24gcHJvcHMgZnJvbSB0aGUgcGFyZW50IGNvbXBvbmVudC5cbi8vIEEgbGVuZ3RoIG9mIHplcm8gaXMgYXNzdW1lZCB0byBtZWFuIG1hcFRvUHJvcHMgaXMgZ2V0dGluZyBhcmdzIHZpYSBhcmd1bWVudHMgb3IgLi4uYXJncyBhbmRcbi8vIHRoZXJlZm9yZSBub3QgcmVwb3J0aW5nIGl0cyBsZW5ndGggYWNjdXJhdGVseS4uXG4vLyBUT0RPIENhbiB0aGlzIGdldCBwdWxsZWQgb3V0IHNvIHRoYXQgd2UgY2FuIHN1YnNjcmliZSBkaXJlY3RseSB0byB0aGUgc3RvcmUgaWYgd2UgZG9uJ3QgbmVlZCBvd25Qcm9wcz9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERlcGVuZHNPbk93blByb3BzKG1hcFRvUHJvcHMpIHtcbiAgcmV0dXJuIG1hcFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMgPyBCb29sZWFuKG1hcFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpIDogbWFwVG9Qcm9wcy5sZW5ndGggIT09IDE7XG59IC8vIFVzZWQgYnkgd2hlbk1hcFN0YXRlVG9Qcm9wc0lzRnVuY3Rpb24gYW5kIHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc0Z1bmN0aW9uLFxuLy8gdGhpcyBmdW5jdGlvbiB3cmFwcyBtYXBUb1Byb3BzIGluIGEgcHJveHkgZnVuY3Rpb24gd2hpY2ggZG9lcyBzZXZlcmFsIHRoaW5nczpcbi8vXG4vLyAgKiBEZXRlY3RzIHdoZXRoZXIgdGhlIG1hcFRvUHJvcHMgZnVuY3Rpb24gYmVpbmcgY2FsbGVkIGRlcGVuZHMgb24gcHJvcHMsIHdoaWNoXG4vLyAgICBpcyB1c2VkIGJ5IHNlbGVjdG9yRmFjdG9yeSB0byBkZWNpZGUgaWYgaXQgc2hvdWxkIHJlaW52b2tlIG9uIHByb3BzIGNoYW5nZXMuXG4vL1xuLy8gICogT24gZmlyc3QgY2FsbCwgaGFuZGxlcyBtYXBUb1Byb3BzIGlmIHJldHVybnMgYW5vdGhlciBmdW5jdGlvbiwgYW5kIHRyZWF0cyB0aGF0XG4vLyAgICBuZXcgZnVuY3Rpb24gYXMgdGhlIHRydWUgbWFwVG9Qcm9wcyBmb3Igc3Vic2VxdWVudCBjYWxscy5cbi8vXG4vLyAgKiBPbiBmaXJzdCBjYWxsLCB2ZXJpZmllcyB0aGUgZmlyc3QgcmVzdWx0IGlzIGEgcGxhaW4gb2JqZWN0LCBpbiBvcmRlciB0byB3YXJuXG4vLyAgICB0aGUgZGV2ZWxvcGVyIHRoYXQgdGhlaXIgbWFwVG9Qcm9wcyBmdW5jdGlvbiBpcyBub3QgcmV0dXJuaW5nIGEgdmFsaWQgcmVzdWx0LlxuLy9cblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBNYXBUb1Byb3BzRnVuYyhtYXBUb1Byb3BzLCBtZXRob2ROYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0UHJveHlTZWxlY3RvcihkaXNwYXRjaCwge1xuICAgIGRpc3BsYXlOYW1lXG4gIH0pIHtcbiAgICBjb25zdCBwcm94eSA9IGZ1bmN0aW9uIG1hcFRvUHJvcHNQcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKSB7XG4gICAgICByZXR1cm4gcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPyBwcm94eS5tYXBUb1Byb3BzKHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIDogcHJveHkubWFwVG9Qcm9wcyhzdGF0ZU9yRGlzcGF0Y2gsIHVuZGVmaW5lZCk7XG4gICAgfTsgLy8gYWxsb3cgZGV0ZWN0RmFjdG9yeUFuZFZlcmlmeSB0byBnZXQgb3duUHJvcHNcblxuXG4gICAgcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPSB0cnVlO1xuXG4gICAgcHJveHkubWFwVG9Qcm9wcyA9IGZ1bmN0aW9uIGRldGVjdEZhY3RvcnlBbmRWZXJpZnkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykge1xuICAgICAgcHJveHkubWFwVG9Qcm9wcyA9IG1hcFRvUHJvcHM7XG4gICAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IGdldERlcGVuZHNPbk93blByb3BzKG1hcFRvUHJvcHMpO1xuICAgICAgbGV0IHByb3BzID0gcHJveHkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcyk7XG5cbiAgICAgIGlmICh0eXBlb2YgcHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJveHkubWFwVG9Qcm9wcyA9IHByb3BzO1xuICAgICAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IGdldERlcGVuZHNPbk93blByb3BzKHByb3BzKTtcbiAgICAgICAgcHJvcHMgPSBwcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHZlcmlmeVBsYWluT2JqZWN0KHByb3BzLCBkaXNwbGF5TmFtZSwgbWV0aG9kTmFtZSk7XG4gICAgICByZXR1cm4gcHJvcHM7XG4gICAgfTtcblxuICAgIHJldHVybiBwcm94eTtcbiAgfTtcbn0iLCJleHBvcnQgZnVuY3Rpb24gY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkoYXJnLCBuYW1lKSB7XG4gIHJldHVybiAoZGlzcGF0Y2gsIG9wdGlvbnMpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBhcmd9IGZvciAke25hbWV9IGFyZ3VtZW50IHdoZW4gY29ubmVjdGluZyBjb21wb25lbnQgJHtvcHRpb25zLndyYXBwZWRDb21wb25lbnROYW1lfS5gKTtcbiAgfTtcbn0iLCJpbXBvcnQgYmluZEFjdGlvbkNyZWF0b3JzIGZyb20gJy4uL3V0aWxzL2JpbmRBY3Rpb25DcmVhdG9ycyc7XG5pbXBvcnQgeyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50LCB3cmFwTWFwVG9Qcm9wc0Z1bmMgfSBmcm9tICcuL3dyYXBNYXBUb1Byb3BzJztcbmltcG9ydCB7IGNyZWF0ZUludmFsaWRBcmdGYWN0b3J5IH0gZnJvbSAnLi9pbnZhbGlkQXJnRmFjdG9yeSc7XG5leHBvcnQgZnVuY3Rpb24gbWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yeShtYXBEaXNwYXRjaFRvUHJvcHMpIHtcbiAgcmV0dXJuIG1hcERpc3BhdGNoVG9Qcm9wcyAmJiB0eXBlb2YgbWFwRGlzcGF0Y2hUb1Byb3BzID09PSAnb2JqZWN0JyA/IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoZGlzcGF0Y2ggPT4gLy8gQHRzLWlnbm9yZVxuICBiaW5kQWN0aW9uQ3JlYXRvcnMobWFwRGlzcGF0Y2hUb1Byb3BzLCBkaXNwYXRjaCkpIDogIW1hcERpc3BhdGNoVG9Qcm9wcyA/IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoZGlzcGF0Y2ggPT4gKHtcbiAgICBkaXNwYXRjaFxuICB9KSkgOiB0eXBlb2YgbWFwRGlzcGF0Y2hUb1Byb3BzID09PSAnZnVuY3Rpb24nID8gLy8gQHRzLWlnbm9yZVxuICB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwRGlzcGF0Y2hUb1Byb3BzLCAnbWFwRGlzcGF0Y2hUb1Byb3BzJykgOiBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeShtYXBEaXNwYXRjaFRvUHJvcHMsICdtYXBEaXNwYXRjaFRvUHJvcHMnKTtcbn0iLCJpbXBvcnQgeyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50LCB3cmFwTWFwVG9Qcm9wc0Z1bmMgfSBmcm9tICcuL3dyYXBNYXBUb1Byb3BzJztcbmltcG9ydCB7IGNyZWF0ZUludmFsaWRBcmdGYWN0b3J5IH0gZnJvbSAnLi9pbnZhbGlkQXJnRmFjdG9yeSc7XG5leHBvcnQgZnVuY3Rpb24gbWFwU3RhdGVUb1Byb3BzRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMpIHtcbiAgcmV0dXJuICFtYXBTdGF0ZVRvUHJvcHMgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KCgpID0+ICh7fSkpIDogdHlwZW9mIG1hcFN0YXRlVG9Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyA/IC8vIEB0cy1pZ25vcmVcbiAgd3JhcE1hcFRvUHJvcHNGdW5jKG1hcFN0YXRlVG9Qcm9wcywgJ21hcFN0YXRlVG9Qcm9wcycpIDogY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCAnbWFwU3RhdGVUb1Byb3BzJyk7XG59IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgdmVyaWZ5UGxhaW5PYmplY3QgZnJvbSAnLi4vdXRpbHMvdmVyaWZ5UGxhaW5PYmplY3QnO1xuaW1wb3J0IHsgY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkgfSBmcm9tICcuL2ludmFsaWRBcmdGYWN0b3J5JztcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0TWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcykge1xuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgb3duUHJvcHMsIHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBNZXJnZVByb3BzRnVuYyhtZXJnZVByb3BzKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0TWVyZ2VQcm9wc1Byb3h5KGRpc3BhdGNoLCB7XG4gICAgZGlzcGxheU5hbWUsXG4gICAgYXJlTWVyZ2VkUHJvcHNFcXVhbFxuICB9KSB7XG4gICAgbGV0IGhhc1J1bk9uY2UgPSBmYWxzZTtcbiAgICBsZXQgbWVyZ2VkUHJvcHM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlUHJvcHNQcm94eShzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcykge1xuICAgICAgY29uc3QgbmV4dE1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG5cbiAgICAgIGlmIChoYXNSdW5PbmNlKSB7XG4gICAgICAgIGlmICghYXJlTWVyZ2VkUHJvcHNFcXVhbChuZXh0TWVyZ2VkUHJvcHMsIG1lcmdlZFByb3BzKSkgbWVyZ2VkUHJvcHMgPSBuZXh0TWVyZ2VkUHJvcHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYXNSdW5PbmNlID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VkUHJvcHMgPSBuZXh0TWVyZ2VkUHJvcHM7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB2ZXJpZnlQbGFpbk9iamVjdChtZXJnZWRQcm9wcywgZGlzcGxheU5hbWUsICdtZXJnZVByb3BzJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgICB9O1xuICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlUHJvcHNGYWN0b3J5KG1lcmdlUHJvcHMpIHtcbiAgcmV0dXJuICFtZXJnZVByb3BzID8gKCkgPT4gZGVmYXVsdE1lcmdlUHJvcHMgOiB0eXBlb2YgbWVyZ2VQcm9wcyA9PT0gJ2Z1bmN0aW9uJyA/IHdyYXBNZXJnZVByb3BzRnVuYyhtZXJnZVByb3BzKSA6IGNyZWF0ZUludmFsaWRBcmdGYWN0b3J5KG1lcmdlUHJvcHMsICdtZXJnZVByb3BzJyk7XG59IiwiaW1wb3J0IHsgZ2V0QmF0Y2ggfSBmcm9tICcuL2JhdGNoJzsgLy8gZW5jYXBzdWxhdGVzIHRoZSBzdWJzY3JpcHRpb24gbG9naWMgZm9yIGNvbm5lY3RpbmcgYSBjb21wb25lbnQgdG8gdGhlIHJlZHV4IHN0b3JlLCBhc1xuLy8gd2VsbCBhcyBuZXN0aW5nIHN1YnNjcmlwdGlvbnMgb2YgZGVzY2VuZGFudCBjb21wb25lbnRzLCBzbyB0aGF0IHdlIGNhbiBlbnN1cmUgdGhlXG4vLyBhbmNlc3RvciBjb21wb25lbnRzIHJlLXJlbmRlciBiZWZvcmUgZGVzY2VuZGFudHNcblxuZnVuY3Rpb24gY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uKCkge1xuICBjb25zdCBiYXRjaCA9IGdldEJhdGNoKCk7XG4gIGxldCBmaXJzdCA9IG51bGw7XG4gIGxldCBsYXN0ID0gbnVsbDtcbiAgcmV0dXJuIHtcbiAgICBjbGVhcigpIHtcbiAgICAgIGZpcnN0ID0gbnVsbDtcbiAgICAgIGxhc3QgPSBudWxsO1xuICAgIH0sXG5cbiAgICBub3RpZnkoKSB7XG4gICAgICBiYXRjaCgoKSA9PiB7XG4gICAgICAgIGxldCBsaXN0ZW5lciA9IGZpcnN0O1xuXG4gICAgICAgIHdoaWxlIChsaXN0ZW5lcikge1xuICAgICAgICAgIGxpc3RlbmVyLmNhbGxiYWNrKCk7XG4gICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZ2V0KCkge1xuICAgICAgbGV0IGxpc3RlbmVycyA9IFtdO1xuICAgICAgbGV0IGxpc3RlbmVyID0gZmlyc3Q7XG5cbiAgICAgIHdoaWxlIChsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIubmV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxpc3RlbmVycztcbiAgICB9LFxuXG4gICAgc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgICBsZXQgaXNTdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgIGxldCBsaXN0ZW5lciA9IGxhc3QgPSB7XG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICBwcmV2OiBsYXN0XG4gICAgICB9O1xuXG4gICAgICBpZiAobGlzdGVuZXIucHJldikge1xuICAgICAgICBsaXN0ZW5lci5wcmV2Lm5leHQgPSBsaXN0ZW5lcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0ID0gbGlzdGVuZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKCFpc1N1YnNjcmliZWQgfHwgZmlyc3QgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgaXNTdWJzY3JpYmVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGxpc3RlbmVyLm5leHQpIHtcbiAgICAgICAgICBsaXN0ZW5lci5uZXh0LnByZXYgPSBsaXN0ZW5lci5wcmV2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3QgPSBsaXN0ZW5lci5wcmV2O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3RlbmVyLnByZXYpIHtcbiAgICAgICAgICBsaXN0ZW5lci5wcmV2Lm5leHQgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpcnN0ID0gbGlzdGVuZXIubmV4dDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgfTtcbn1cblxuY29uc3QgbnVsbExpc3RlbmVycyA9IHtcbiAgbm90aWZ5KCkge30sXG5cbiAgZ2V0OiAoKSA9PiBbXVxufTtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdWJzY3JpcHRpb24oc3RvcmUsIHBhcmVudFN1Yikge1xuICBsZXQgdW5zdWJzY3JpYmU7XG4gIGxldCBsaXN0ZW5lcnMgPSBudWxsTGlzdGVuZXJzO1xuXG4gIGZ1bmN0aW9uIGFkZE5lc3RlZFN1YihsaXN0ZW5lcikge1xuICAgIHRyeVN1YnNjcmliZSgpO1xuICAgIHJldHVybiBsaXN0ZW5lcnMuc3Vic2NyaWJlKGxpc3RlbmVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGlmeU5lc3RlZFN1YnMoKSB7XG4gICAgbGlzdGVuZXJzLm5vdGlmeSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ2hhbmdlV3JhcHBlcigpIHtcbiAgICBpZiAoc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UpIHtcbiAgICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTdWJzY3JpYmVkKCkge1xuICAgIHJldHVybiBCb29sZWFuKHVuc3Vic2NyaWJlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeVN1YnNjcmliZSgpIHtcbiAgICBpZiAoIXVuc3Vic2NyaWJlKSB7XG4gICAgICB1bnN1YnNjcmliZSA9IHBhcmVudFN1YiA/IHBhcmVudFN1Yi5hZGROZXN0ZWRTdWIoaGFuZGxlQ2hhbmdlV3JhcHBlcikgOiBzdG9yZS5zdWJzY3JpYmUoaGFuZGxlQ2hhbmdlV3JhcHBlcik7XG4gICAgICBsaXN0ZW5lcnMgPSBjcmVhdGVMaXN0ZW5lckNvbGxlY3Rpb24oKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cnlVbnN1YnNjcmliZSgpIHtcbiAgICBpZiAodW5zdWJzY3JpYmUpIHtcbiAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICB1bnN1YnNjcmliZSA9IHVuZGVmaW5lZDtcbiAgICAgIGxpc3RlbmVycy5jbGVhcigpO1xuICAgICAgbGlzdGVuZXJzID0gbnVsbExpc3RlbmVycztcbiAgICB9XG4gIH1cblxuICBjb25zdCBzdWJzY3JpcHRpb24gPSB7XG4gICAgYWRkTmVzdGVkU3ViLFxuICAgIG5vdGlmeU5lc3RlZFN1YnMsXG4gICAgaGFuZGxlQ2hhbmdlV3JhcHBlcixcbiAgICBpc1N1YnNjcmliZWQsXG4gICAgdHJ5U3Vic2NyaWJlLFxuICAgIHRyeVVuc3Vic2NyaWJlLFxuICAgIGdldExpc3RlbmVyczogKCkgPT4gbGlzdGVuZXJzXG4gIH07XG4gIHJldHVybiBzdWJzY3JpcHRpb247XG59IiwiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tICdyZWFjdCc7IC8vIFJlYWN0IGN1cnJlbnRseSB0aHJvd3MgYSB3YXJuaW5nIHdoZW4gdXNpbmcgdXNlTGF5b3V0RWZmZWN0IG9uIHRoZSBzZXJ2ZXIuXG4vLyBUbyBnZXQgYXJvdW5kIGl0LCB3ZSBjYW4gY29uZGl0aW9uYWxseSB1c2VFZmZlY3Qgb24gdGhlIHNlcnZlciAobm8tb3ApIGFuZFxuLy8gdXNlTGF5b3V0RWZmZWN0IGluIHRoZSBicm93c2VyLiBXZSBuZWVkIHVzZUxheW91dEVmZmVjdCB0byBlbnN1cmUgdGhlIHN0b3JlXG4vLyBzdWJzY3JpcHRpb24gY2FsbGJhY2sgYWx3YXlzIGhhcyB0aGUgc2VsZWN0b3IgZnJvbSB0aGUgbGF0ZXN0IHJlbmRlciBjb21taXRcbi8vIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGEgc3RvcmUgdXBkYXRlIG1heSBoYXBwZW4gYmV0d2VlbiByZW5kZXIgYW5kIHRoZSBlZmZlY3QsXG4vLyB3aGljaCBtYXkgY2F1c2UgbWlzc2VkIHVwZGF0ZXM7IHdlIGFsc28gbXVzdCBlbnN1cmUgdGhlIHN0b3JlIHN1YnNjcmlwdGlvblxuLy8gaXMgY3JlYXRlZCBzeW5jaHJvbm91c2x5LCBvdGhlcndpc2UgYSBzdG9yZSB1cGRhdGUgbWF5IG9jY3VyIGJlZm9yZSB0aGVcbi8vIHN1YnNjcmlwdGlvbiBpcyBjcmVhdGVkIGFuZCBhbiBpbmNvbnNpc3RlbnQgc3RhdGUgbWF5IGJlIG9ic2VydmVkXG4vLyBNYXRjaGVzIGxvZ2ljIGluIFJlYWN0J3MgYHNoYXJlZC9FeGVjdXRpb25FbnZpcm9ubWVudGAgZmlsZVxuXG5leHBvcnQgY29uc3QgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyk7XG5leHBvcnQgY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IGNhblVzZURPTSA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDsiLCJmdW5jdGlvbiBpcyh4LCB5KSB7XG4gIGlmICh4ID09PSB5KSB7XG4gICAgcmV0dXJuIHggIT09IDAgfHwgeSAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAoaXMob2JqQSwgb2JqQikpIHJldHVybiB0cnVlO1xuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIGNvbnN0IGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgIWlzKG9iakFba2V5c0FbaV1dLCBvYmpCW2tleXNBW2ldXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn0iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZVwiO1xuY29uc3QgX2V4Y2x1ZGVkID0gW1wicmVhY3RSZWR1eEZvcndhcmRlZFJlZlwiXTtcblxuLyogZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IGhvaXN0U3RhdGljcyBmcm9tICdob2lzdC1ub24tcmVhY3Qtc3RhdGljcyc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlQ29udGV4dCwgdXNlTWVtbywgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaXNWYWxpZEVsZW1lbnRUeXBlLCBpc0NvbnRleHRDb25zdW1lciB9IGZyb20gJ3JlYWN0LWlzJztcbmltcG9ydCBkZWZhdWx0U2VsZWN0b3JGYWN0b3J5IGZyb20gJy4uL2Nvbm5lY3Qvc2VsZWN0b3JGYWN0b3J5JztcbmltcG9ydCB7IG1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcnkgfSBmcm9tICcuLi9jb25uZWN0L21hcERpc3BhdGNoVG9Qcm9wcyc7XG5pbXBvcnQgeyBtYXBTdGF0ZVRvUHJvcHNGYWN0b3J5IH0gZnJvbSAnLi4vY29ubmVjdC9tYXBTdGF0ZVRvUHJvcHMnO1xuaW1wb3J0IHsgbWVyZ2VQcm9wc0ZhY3RvcnkgfSBmcm9tICcuLi9jb25uZWN0L21lcmdlUHJvcHMnO1xuaW1wb3J0IHsgY3JlYXRlU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi4vdXRpbHMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgfSBmcm9tICcuLi91dGlscy91c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0JztcbmltcG9ydCBzaGFsbG93RXF1YWwgZnJvbSAnLi4vdXRpbHMvc2hhbGxvd0VxdWFsJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJy4uL3V0aWxzL3dhcm5pbmcnO1xuaW1wb3J0IHsgUmVhY3RSZWR1eENvbnRleHQgfSBmcm9tICcuL0NvbnRleHQnO1xuaW1wb3J0IHsgbm90SW5pdGlhbGl6ZWQgfSBmcm9tICcuLi91dGlscy91c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG5sZXQgdXNlU3luY0V4dGVybmFsU3RvcmUgPSBub3RJbml0aWFsaXplZDtcbmV4cG9ydCBjb25zdCBpbml0aWFsaXplQ29ubmVjdCA9IGZuID0+IHtcbiAgdXNlU3luY0V4dGVybmFsU3RvcmUgPSBmbjtcbn07IC8vIERlZmluZSBzb21lIGNvbnN0YW50IGFycmF5cyBqdXN0IHRvIGF2b2lkIHJlLWNyZWF0aW5nIHRoZXNlXG5cbmNvbnN0IEVNUFRZX0FSUkFZID0gW251bGwsIDBdO1xuY29uc3QgTk9fU1VCU0NSSVBUSU9OX0FSUkFZID0gW251bGwsIG51bGxdOyAvLyBBdHRlbXB0cyB0byBzdHJpbmdpZnkgd2hhdGV2ZXIgbm90LXJlYWxseS1hLWNvbXBvbmVudCB2YWx1ZSB3ZSB3ZXJlIGdpdmVuXG4vLyBmb3IgbG9nZ2luZyBpbiBhbiBlcnJvciBtZXNzYWdlXG5cbmNvbnN0IHN0cmluZ2lmeUNvbXBvbmVudCA9IENvbXAgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShDb21wKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZyhDb21wKTtcbiAgfVxufTtcblxuLy8gVGhpcyBpcyBcImp1c3RcIiBhIGB1c2VMYXlvdXRFZmZlY3RgLCBidXQgd2l0aCB0d28gbW9kaWZpY2F0aW9uczpcbi8vIC0gd2UgbmVlZCB0byBmYWxsIGJhY2sgdG8gYHVzZUVmZmVjdGAgaW4gU1NSIHRvIGF2b2lkIGFubm95aW5nIHdhcm5pbmdzXG4vLyAtIHdlIGV4dHJhY3QgdGhpcyB0byBhIHNlcGFyYXRlIGZ1bmN0aW9uIHRvIGF2b2lkIGNsb3Npbmcgb3ZlciB2YWx1ZXNcbi8vICAgYW5kIGNhdXNpbmcgbWVtb3J5IGxlYWtzXG5mdW5jdGlvbiB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0V2l0aEFyZ3MoZWZmZWN0RnVuYywgZWZmZWN0QXJncywgZGVwZW5kZW5jaWVzKSB7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4gZWZmZWN0RnVuYyguLi5lZmZlY3RBcmdzKSwgZGVwZW5kZW5jaWVzKTtcbn0gLy8gRWZmZWN0IGNhbGxiYWNrLCBleHRyYWN0ZWQ6IGFzc2lnbiB0aGUgbGF0ZXN0IHByb3BzIHZhbHVlcyB0byByZWZzIGZvciBsYXRlciB1c2FnZVxuXG5cbmZ1bmN0aW9uIGNhcHR1cmVXcmFwcGVyUHJvcHMobGFzdFdyYXBwZXJQcm9wcywgbGFzdENoaWxkUHJvcHMsIHJlbmRlcklzU2NoZWR1bGVkLCB3cmFwcGVyUHJvcHMsIC8vIGFjdHVhbENoaWxkUHJvcHM6IHVua25vd24sXG5jaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLCBub3RpZnlOZXN0ZWRTdWJzKSB7XG4gIC8vIFdlIHdhbnQgdG8gY2FwdHVyZSB0aGUgd3JhcHBlciBwcm9wcyBhbmQgY2hpbGQgcHJvcHMgd2UgdXNlZCBmb3IgbGF0ZXIgY29tcGFyaXNvbnNcbiAgbGFzdFdyYXBwZXJQcm9wcy5jdXJyZW50ID0gd3JhcHBlclByb3BzO1xuICByZW5kZXJJc1NjaGVkdWxlZC5jdXJyZW50ID0gZmFsc2U7IC8vIElmIHRoZSByZW5kZXIgd2FzIGZyb20gYSBzdG9yZSB1cGRhdGUsIGNsZWFyIG91dCB0aGF0IHJlZmVyZW5jZSBhbmQgY2FzY2FkZSB0aGUgc3Vic2NyaWJlciB1cGRhdGVcblxuICBpZiAoY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50KSB7XG4gICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ID0gbnVsbDtcbiAgICBub3RpZnlOZXN0ZWRTdWJzKCk7XG4gIH1cbn0gLy8gRWZmZWN0IGNhbGxiYWNrLCBleHRyYWN0ZWQ6IHN1YnNjcmliZSB0byB0aGUgUmVkdXggc3RvcmUgb3IgbmVhcmVzdCBjb25uZWN0ZWQgYW5jZXN0b3IsXG4vLyBjaGVjayBmb3IgdXBkYXRlcyBhZnRlciBkaXNwYXRjaGVkIGFjdGlvbnMsIGFuZCB0cmlnZ2VyIHJlLXJlbmRlcnMuXG5cblxuZnVuY3Rpb24gc3Vic2NyaWJlVXBkYXRlcyhzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsIHN0b3JlLCBzdWJzY3JpcHRpb24sIGNoaWxkUHJvcHNTZWxlY3RvciwgbGFzdFdyYXBwZXJQcm9wcywgbGFzdENoaWxkUHJvcHMsIHJlbmRlcklzU2NoZWR1bGVkLCBpc01vdW50ZWQsIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUsIG5vdGlmeU5lc3RlZFN1YnMsIC8vIGZvcmNlQ29tcG9uZW50VXBkYXRlRGlzcGF0Y2g6IFJlYWN0LkRpc3BhdGNoPGFueT4sXG5hZGRpdGlvbmFsU3Vic2NyaWJlTGlzdGVuZXIpIHtcbiAgLy8gSWYgd2UncmUgbm90IHN1YnNjcmliZWQgdG8gdGhlIHN0b3JlLCBub3RoaW5nIHRvIGRvIGhlcmVcbiAgaWYgKCFzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpIHJldHVybiAoKSA9PiB7fTsgLy8gQ2FwdHVyZSB2YWx1ZXMgZm9yIGNoZWNraW5nIGlmIGFuZCB3aGVuIHRoaXMgY29tcG9uZW50IHVubW91bnRzXG5cbiAgbGV0IGRpZFVuc3Vic2NyaWJlID0gZmFsc2U7XG4gIGxldCBsYXN0VGhyb3duRXJyb3IgPSBudWxsOyAvLyBXZSdsbCBydW4gdGhpcyBjYWxsYmFjayBldmVyeSB0aW1lIGEgc3RvcmUgc3Vic2NyaXB0aW9uIHVwZGF0ZSBwcm9wYWdhdGVzIHRvIHRoaXMgY29tcG9uZW50XG5cbiAgY29uc3QgY2hlY2tGb3JVcGRhdGVzID0gKCkgPT4ge1xuICAgIGlmIChkaWRVbnN1YnNjcmliZSB8fCAhaXNNb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgIC8vIERvbid0IHJ1biBzdGFsZSBsaXN0ZW5lcnMuXG4gICAgICAvLyBSZWR1eCBkb2Vzbid0IGd1YXJhbnRlZSB1bnN1YnNjcmlwdGlvbnMgaGFwcGVuIHVudGlsIG5leHQgZGlzcGF0Y2guXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBUT0RPIFdlJ3JlIGN1cnJlbnRseSBjYWxsaW5nIGdldFN0YXRlIG91cnNlbHZlcyBoZXJlLCByYXRoZXIgdGhhbiBsZXR0aW5nIGB1U0VTYCBkbyBpdFxuXG5cbiAgICBjb25zdCBsYXRlc3RTdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBsZXQgbmV3Q2hpbGRQcm9wcywgZXJyb3I7XG5cbiAgICB0cnkge1xuICAgICAgLy8gQWN0dWFsbHkgcnVuIHRoZSBzZWxlY3RvciB3aXRoIHRoZSBtb3N0IHJlY2VudCBzdG9yZSBzdGF0ZSBhbmQgd3JhcHBlciBwcm9wc1xuICAgICAgLy8gdG8gZGV0ZXJtaW5lIHdoYXQgdGhlIGNoaWxkIHByb3BzIHNob3VsZCBiZVxuICAgICAgbmV3Q2hpbGRQcm9wcyA9IGNoaWxkUHJvcHNTZWxlY3RvcihsYXRlc3RTdG9yZVN0YXRlLCBsYXN0V3JhcHBlclByb3BzLmN1cnJlbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yID0gZTtcbiAgICAgIGxhc3RUaHJvd25FcnJvciA9IGU7XG4gICAgfVxuXG4gICAgaWYgKCFlcnJvcikge1xuICAgICAgbGFzdFRocm93bkVycm9yID0gbnVsbDtcbiAgICB9IC8vIElmIHRoZSBjaGlsZCBwcm9wcyBoYXZlbid0IGNoYW5nZWQsIG5vdGhpbmcgdG8gZG8gaGVyZSAtIGNhc2NhZGUgdGhlIHN1YnNjcmlwdGlvbiB1cGRhdGVcblxuXG4gICAgaWYgKG5ld0NoaWxkUHJvcHMgPT09IGxhc3RDaGlsZFByb3BzLmN1cnJlbnQpIHtcbiAgICAgIGlmICghcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCkge1xuICAgICAgICBub3RpZnlOZXN0ZWRTdWJzKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNhdmUgcmVmZXJlbmNlcyB0byB0aGUgbmV3IGNoaWxkIHByb3BzLiAgTm90ZSB0aGF0IHdlIHRyYWNrIHRoZSBcImNoaWxkIHByb3BzIGZyb20gc3RvcmUgdXBkYXRlXCJcbiAgICAgIC8vIGFzIGEgcmVmIGluc3RlYWQgb2YgYSB1c2VTdGF0ZS91c2VSZWR1Y2VyIGJlY2F1c2Ugd2UgbmVlZCBhIHdheSB0byBkZXRlcm1pbmUgaWYgdGhhdCB2YWx1ZSBoYXNcbiAgICAgIC8vIGJlZW4gcHJvY2Vzc2VkLiAgSWYgdGhpcyB3ZW50IGludG8gdXNlU3RhdGUvdXNlUmVkdWNlciwgd2UgY291bGRuJ3QgY2xlYXIgb3V0IHRoZSB2YWx1ZSB3aXRob3V0XG4gICAgICAvLyBmb3JjaW5nIGFub3RoZXIgcmUtcmVuZGVyLCB3aGljaCB3ZSBkb24ndCB3YW50LlxuICAgICAgbGFzdENoaWxkUHJvcHMuY3VycmVudCA9IG5ld0NoaWxkUHJvcHM7XG4gICAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQgPSBuZXdDaGlsZFByb3BzO1xuICAgICAgcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCA9IHRydWU7IC8vIFRPRE8gVGhpcyBpcyBoYWNreSBhbmQgbm90IGhvdyBgdVNFU2AgaXMgbWVhbnQgdG8gYmUgdXNlZFxuICAgICAgLy8gVHJpZ2dlciB0aGUgUmVhY3QgYHVzZVN5bmNFeHRlcm5hbFN0b3JlYCBzdWJzY3JpYmVyXG5cbiAgICAgIGFkZGl0aW9uYWxTdWJzY3JpYmVMaXN0ZW5lcigpO1xuICAgIH1cbiAgfTsgLy8gQWN0dWFsbHkgc3Vic2NyaWJlIHRvIHRoZSBuZWFyZXN0IGNvbm5lY3RlZCBhbmNlc3RvciAob3Igc3RvcmUpXG5cblxuICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSA9IGNoZWNrRm9yVXBkYXRlcztcbiAgc3Vic2NyaXB0aW9uLnRyeVN1YnNjcmliZSgpOyAvLyBQdWxsIGRhdGEgZnJvbSB0aGUgc3RvcmUgYWZ0ZXIgZmlyc3QgcmVuZGVyIGluIGNhc2UgdGhlIHN0b3JlIGhhc1xuICAvLyBjaGFuZ2VkIHNpbmNlIHdlIGJlZ2FuLlxuXG4gIGNoZWNrRm9yVXBkYXRlcygpO1xuXG4gIGNvbnN0IHVuc3Vic2NyaWJlV3JhcHBlciA9ICgpID0+IHtcbiAgICBkaWRVbnN1YnNjcmliZSA9IHRydWU7XG4gICAgc3Vic2NyaXB0aW9uLnRyeVVuc3Vic2NyaWJlKCk7XG4gICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSBudWxsO1xuXG4gICAgaWYgKGxhc3RUaHJvd25FcnJvcikge1xuICAgICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IHdlIGNhdWdodCBhbiBlcnJvciBkdWUgdG8gYSBiYWQgbWFwU3RhdGUgZnVuY3Rpb24sIGJ1dCB0aGVcbiAgICAgIC8vIHBhcmVudCByZS1yZW5kZXJlZCB3aXRob3V0IHRoaXMgY29tcG9uZW50IGFuZCB3ZSdyZSBhYm91dCB0byB1bm1vdW50LlxuICAgICAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuIGFzIGxvbmcgYXMgd2UgZG8gdG9wLWRvd24gc3Vic2NyaXB0aW9ucyBjb3JyZWN0bHksIGJ1dFxuICAgICAgLy8gaWYgd2UgZXZlciBkbyB0aG9zZSB3cm9uZywgdGhpcyB0aHJvdyB3aWxsIHN1cmZhY2UgdGhlIGVycm9yIGluIG91ciB0ZXN0cy5cbiAgICAgIC8vIEluIHRoYXQgY2FzZSwgdGhyb3cgdGhlIGVycm9yIGZyb20gaGVyZSBzbyBpdCBkb2Vzbid0IGdldCBsb3N0LlxuICAgICAgdGhyb3cgbGFzdFRocm93bkVycm9yO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdW5zdWJzY3JpYmVXcmFwcGVyO1xufSAvLyBSZWR1Y2VyIGluaXRpYWwgc3RhdGUgY3JlYXRpb24gZm9yIG91ciB1cGRhdGUgcmVkdWNlclxuXG5cbmNvbnN0IGluaXRTdGF0ZVVwZGF0ZXMgPSAoKSA9PiBFTVBUWV9BUlJBWTtcblxuZnVuY3Rpb24gc3RyaWN0RXF1YWwoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn1cbi8qKlxyXG4gKiBJbmZlcnMgdGhlIHR5cGUgb2YgcHJvcHMgdGhhdCBhIGNvbm5lY3RvciB3aWxsIGluamVjdCBpbnRvIGEgY29tcG9uZW50LlxyXG4gKi9cblxuXG5sZXQgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkUHVyZU9wdGlvbiA9IGZhbHNlO1xuLyoqXHJcbiAqIENvbm5lY3RzIGEgUmVhY3QgY29tcG9uZW50IHRvIGEgUmVkdXggc3RvcmUuXHJcbiAqXHJcbiAqIC0gV2l0aG91dCBhcmd1bWVudHMsIGp1c3Qgd3JhcHMgdGhlIGNvbXBvbmVudCwgd2l0aG91dCBjaGFuZ2luZyB0aGUgYmVoYXZpb3IgLyBwcm9wc1xyXG4gKlxyXG4gKiAtIElmIDIgcGFyYW1zIGFyZSBwYXNzZWQgKDNyZCBwYXJhbSwgbWVyZ2VQcm9wcywgaXMgc2tpcHBlZCksIGRlZmF1bHQgYmVoYXZpb3JcclxuICogaXMgdG8gb3ZlcnJpZGUgb3duUHJvcHMgKGFzIHN0YXRlZCBpbiB0aGUgZG9jcyksIHNvIHdoYXQgcmVtYWlucyBpcyBldmVyeXRoaW5nIHRoYXQnc1xyXG4gKiBub3QgYSBzdGF0ZSBvciBkaXNwYXRjaCBwcm9wXHJcbiAqXHJcbiAqIC0gV2hlbiAzcmQgcGFyYW0gaXMgcGFzc2VkLCB3ZSBkb24ndCBrbm93IGlmIG93blByb3BzIHByb3BhZ2F0ZSBhbmQgd2hldGhlciB0aGV5XHJcbiAqIHNob3VsZCBiZSB2YWxpZCBjb21wb25lbnQgcHJvcHMsIGJlY2F1c2UgaXQgZGVwZW5kcyBvbiBtZXJnZVByb3BzIGltcGxlbWVudGF0aW9uLlxyXG4gKiBBcyBzdWNoLCBpdCBpcyB0aGUgdXNlcidzIHJlc3BvbnNpYmlsaXR5IHRvIGV4dGVuZCBvd25Qcm9wcyBpbnRlcmZhY2UgZnJvbSBzdGF0ZSBvclxyXG4gKiBkaXNwYXRjaCBwcm9wcyBvciBib3RoIHdoZW4gYXBwbGljYWJsZVxyXG4gKlxyXG4gKiBAcGFyYW0gbWFwU3RhdGVUb1Byb3BzIEEgZnVuY3Rpb24gdGhhdCBleHRyYWN0cyB2YWx1ZXMgZnJvbSBzdGF0ZVxyXG4gKiBAcGFyYW0gbWFwRGlzcGF0Y2hUb1Byb3BzIFNldHVwIGZvciBkaXNwYXRjaGluZyBhY3Rpb25zXHJcbiAqIEBwYXJhbSBtZXJnZVByb3BzIE9wdGlvbmFsIGNhbGxiYWNrIHRvIG1lcmdlIHN0YXRlIGFuZCBkaXNwYXRjaCBwcm9wcyB0b2dldGhlclxyXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciBjb25maWd1cmluZyB0aGUgY29ubmVjdGlvblxyXG4gKlxyXG4gKi9cblxuZnVuY3Rpb24gY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywge1xuICAvLyBUaGUgYHB1cmVgIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkLCBzbyBUUyBkb2Vzbid0IGxpa2UgdXMgZGVzdHJ1Y3R1cmluZyB0aGlzIHRvIGNoZWNrIGl0cyBleGlzdGVuY2UuXG4gIC8vIEB0cy1pZ25vcmVcbiAgcHVyZSxcbiAgYXJlU3RhdGVzRXF1YWwgPSBzdHJpY3RFcXVhbCxcbiAgYXJlT3duUHJvcHNFcXVhbCA9IHNoYWxsb3dFcXVhbCxcbiAgYXJlU3RhdGVQcm9wc0VxdWFsID0gc2hhbGxvd0VxdWFsLFxuICBhcmVNZXJnZWRQcm9wc0VxdWFsID0gc2hhbGxvd0VxdWFsLFxuICAvLyB1c2UgUmVhY3QncyBmb3J3YXJkUmVmIHRvIGV4cG9zZSBhIHJlZiBvZiB0aGUgd3JhcHBlZCBjb21wb25lbnRcbiAgZm9yd2FyZFJlZiA9IGZhbHNlLFxuICAvLyB0aGUgY29udGV4dCBjb25zdW1lciB0byB1c2VcbiAgY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0XG59ID0ge30pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAocHVyZSAhPT0gdW5kZWZpbmVkICYmICFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uID0gdHJ1ZTtcbiAgICAgIHdhcm5pbmcoJ1RoZSBgcHVyZWAgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWQuIGBjb25uZWN0YCBpcyBub3cgYWx3YXlzIGEgXCJwdXJlL21lbW9pemVkXCIgY29tcG9uZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgQ29udGV4dCA9IGNvbnRleHQ7XG4gIGNvbnN0IGluaXRNYXBTdGF0ZVRvUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHNGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcyk7XG4gIGNvbnN0IGluaXRNYXBEaXNwYXRjaFRvUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3J5KG1hcERpc3BhdGNoVG9Qcm9wcyk7XG4gIGNvbnN0IGluaXRNZXJnZVByb3BzID0gbWVyZ2VQcm9wc0ZhY3RvcnkobWVyZ2VQcm9wcyk7XG4gIGNvbnN0IHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyA9IEJvb2xlYW4obWFwU3RhdGVUb1Byb3BzKTtcblxuICBjb25zdCB3cmFwV2l0aENvbm5lY3QgPSBXcmFwcGVkQ29tcG9uZW50ID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhaXNWYWxpZEVsZW1lbnRUeXBlKFdyYXBwZWRDb21wb25lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtdXN0IHBhc3MgYSBjb21wb25lbnQgdG8gdGhlIGZ1bmN0aW9uIHJldHVybmVkIGJ5IGNvbm5lY3QuIEluc3RlYWQgcmVjZWl2ZWQgJHtzdHJpbmdpZnlDb21wb25lbnQoV3JhcHBlZENvbXBvbmVudCl9YCk7XG4gICAgfVxuXG4gICAgY29uc3Qgd3JhcHBlZENvbXBvbmVudE5hbWUgPSBXcmFwcGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IFdyYXBwZWRDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JztcbiAgICBjb25zdCBkaXNwbGF5TmFtZSA9IGBDb25uZWN0KCR7d3JhcHBlZENvbXBvbmVudE5hbWV9KWA7XG4gICAgY29uc3Qgc2VsZWN0b3JGYWN0b3J5T3B0aW9ucyA9IHtcbiAgICAgIHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyxcbiAgICAgIGRpc3BsYXlOYW1lLFxuICAgICAgd3JhcHBlZENvbXBvbmVudE5hbWUsXG4gICAgICBXcmFwcGVkQ29tcG9uZW50LFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaW5pdE1hcFN0YXRlVG9Qcm9wcyxcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGluaXRNYXBEaXNwYXRjaFRvUHJvcHMsXG4gICAgICBpbml0TWVyZ2VQcm9wcyxcbiAgICAgIGFyZVN0YXRlc0VxdWFsLFxuICAgICAgYXJlU3RhdGVQcm9wc0VxdWFsLFxuICAgICAgYXJlT3duUHJvcHNFcXVhbCxcbiAgICAgIGFyZU1lcmdlZFByb3BzRXF1YWxcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gQ29ubmVjdEZ1bmN0aW9uKHByb3BzKSB7XG4gICAgICBjb25zdCBbcHJvcHNDb250ZXh0LCByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmLCB3cmFwcGVyUHJvcHNdID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIC8vIERpc3Rpbmd1aXNoIGJldHdlZW4gYWN0dWFsIFwiZGF0YVwiIHByb3BzIHRoYXQgd2VyZSBwYXNzZWQgdG8gdGhlIHdyYXBwZXIgY29tcG9uZW50LFxuICAgICAgICAvLyBhbmQgdmFsdWVzIG5lZWRlZCB0byBjb250cm9sIGJlaGF2aW9yIChmb3J3YXJkZWQgcmVmcywgYWx0ZXJuYXRlIGNvbnRleHQgaW5zdGFuY2VzKS5cbiAgICAgICAgLy8gVG8gbWFpbnRhaW4gdGhlIHdyYXBwZXJQcm9wcyBvYmplY3QgcmVmZXJlbmNlLCBtZW1vaXplIHRoaXMgZGVzdHJ1Y3R1cmluZy5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJlYWN0UmVkdXhGb3J3YXJkZWRSZWZcbiAgICAgICAgfSA9IHByb3BzLFxuICAgICAgICAgICAgICB3cmFwcGVyUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkKTtcblxuICAgICAgICByZXR1cm4gW3Byb3BzLmNvbnRleHQsIHJlYWN0UmVkdXhGb3J3YXJkZWRSZWYsIHdyYXBwZXJQcm9wc107XG4gICAgICB9LCBbcHJvcHNdKTtcbiAgICAgIGNvbnN0IENvbnRleHRUb1VzZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICAvLyBVc2VycyBtYXkgb3B0aW9uYWxseSBwYXNzIGluIGEgY3VzdG9tIGNvbnRleHQgaW5zdGFuY2UgdG8gdXNlIGluc3RlYWQgb2Ygb3VyIFJlYWN0UmVkdXhDb250ZXh0LlxuICAgICAgICAvLyBNZW1vaXplIHRoZSBjaGVjayB0aGF0IGRldGVybWluZXMgd2hpY2ggY29udGV4dCBpbnN0YW5jZSB3ZSBzaG91bGQgdXNlLlxuICAgICAgICByZXR1cm4gcHJvcHNDb250ZXh0ICYmIHByb3BzQ29udGV4dC5Db25zdW1lciAmJiAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlzQ29udGV4dENvbnN1bWVyKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChwcm9wc0NvbnRleHQuQ29uc3VtZXIsIG51bGwpKSA/IHByb3BzQ29udGV4dCA6IENvbnRleHQ7XG4gICAgICB9LCBbcHJvcHNDb250ZXh0LCBDb250ZXh0XSk7IC8vIFJldHJpZXZlIHRoZSBzdG9yZSBhbmQgYW5jZXN0b3Igc3Vic2NyaXB0aW9uIHZpYSBjb250ZXh0LCBpZiBhdmFpbGFibGVcblxuICAgICAgY29uc3QgY29udGV4dFZhbHVlID0gdXNlQ29udGV4dChDb250ZXh0VG9Vc2UpOyAvLyBUaGUgc3RvcmUgX211c3RfIGV4aXN0IGFzIGVpdGhlciBhIHByb3Agb3IgaW4gY29udGV4dC5cbiAgICAgIC8vIFdlJ2xsIGNoZWNrIHRvIHNlZSBpZiBpdCBfbG9va3NfIGxpa2UgYSBSZWR1eCBzdG9yZSBmaXJzdC5cbiAgICAgIC8vIFRoaXMgYWxsb3dzIHVzIHRvIHBhc3MgdGhyb3VnaCBhIGBzdG9yZWAgcHJvcCB0aGF0IGlzIGp1c3QgYSBwbGFpbiB2YWx1ZS5cblxuICAgICAgY29uc3QgZGlkU3RvcmVDb21lRnJvbVByb3BzID0gQm9vbGVhbihwcm9wcy5zdG9yZSkgJiYgQm9vbGVhbihwcm9wcy5zdG9yZS5nZXRTdGF0ZSkgJiYgQm9vbGVhbihwcm9wcy5zdG9yZS5kaXNwYXRjaCk7XG4gICAgICBjb25zdCBkaWRTdG9yZUNvbWVGcm9tQ29udGV4dCA9IEJvb2xlYW4oY29udGV4dFZhbHVlKSAmJiBCb29sZWFuKGNvbnRleHRWYWx1ZS5zdG9yZSk7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFkaWRTdG9yZUNvbWVGcm9tUHJvcHMgJiYgIWRpZFN0b3JlQ29tZUZyb21Db250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgXCJzdG9yZVwiIGluIHRoZSBjb250ZXh0IG9mIGAgKyBgXCIke2Rpc3BsYXlOYW1lfVwiLiBFaXRoZXIgd3JhcCB0aGUgcm9vdCBjb21wb25lbnQgaW4gYSA8UHJvdmlkZXI+LCBgICsgYG9yIHBhc3MgYSBjdXN0b20gUmVhY3QgY29udGV4dCBwcm92aWRlciB0byA8UHJvdmlkZXI+IGFuZCB0aGUgY29ycmVzcG9uZGluZyBgICsgYFJlYWN0IGNvbnRleHQgY29uc3VtZXIgdG8gJHtkaXNwbGF5TmFtZX0gaW4gY29ubmVjdCBvcHRpb25zLmApO1xuICAgICAgfSAvLyBCYXNlZCBvbiB0aGUgcHJldmlvdXMgY2hlY2ssIG9uZSBvZiB0aGVzZSBtdXN0IGJlIHRydWVcblxuXG4gICAgICBjb25zdCBzdG9yZSA9IGRpZFN0b3JlQ29tZUZyb21Qcm9wcyA/IHByb3BzLnN0b3JlIDogY29udGV4dFZhbHVlLnN0b3JlO1xuICAgICAgY29uc3QgZ2V0U2VydmVyU3RhdGUgPSBkaWRTdG9yZUNvbWVGcm9tQ29udGV4dCA/IGNvbnRleHRWYWx1ZS5nZXRTZXJ2ZXJTdGF0ZSA6IHN0b3JlLmdldFN0YXRlO1xuICAgICAgY29uc3QgY2hpbGRQcm9wc1NlbGVjdG9yID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIC8vIFRoZSBjaGlsZCBwcm9wcyBzZWxlY3RvciBuZWVkcyB0aGUgc3RvcmUgcmVmZXJlbmNlIGFzIGFuIGlucHV0LlxuICAgICAgICAvLyBSZS1jcmVhdGUgdGhpcyBzZWxlY3RvciB3aGVuZXZlciB0aGUgc3RvcmUgY2hhbmdlcy5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRTZWxlY3RvckZhY3Rvcnkoc3RvcmUuZGlzcGF0Y2gsIHNlbGVjdG9yRmFjdG9yeU9wdGlvbnMpO1xuICAgICAgfSwgW3N0b3JlXSk7XG4gICAgICBjb25zdCBbc3Vic2NyaXB0aW9uLCBub3RpZnlOZXN0ZWRTdWJzXSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoIXNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykgcmV0dXJuIE5PX1NVQlNDUklQVElPTl9BUlJBWTsgLy8gVGhpcyBTdWJzY3JpcHRpb24ncyBzb3VyY2Ugc2hvdWxkIG1hdGNoIHdoZXJlIHN0b3JlIGNhbWUgZnJvbTogcHJvcHMgdnMuIGNvbnRleHQuIEEgY29tcG9uZW50XG4gICAgICAgIC8vIGNvbm5lY3RlZCB0byB0aGUgc3RvcmUgdmlhIHByb3BzIHNob3VsZG4ndCB1c2Ugc3Vic2NyaXB0aW9uIGZyb20gY29udGV4dCwgb3IgdmljZSB2ZXJzYS5cblxuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBjcmVhdGVTdWJzY3JpcHRpb24oc3RvcmUsIGRpZFN0b3JlQ29tZUZyb21Qcm9wcyA/IHVuZGVmaW5lZCA6IGNvbnRleHRWYWx1ZS5zdWJzY3JpcHRpb24pOyAvLyBgbm90aWZ5TmVzdGVkU3Vic2AgaXMgZHVwbGljYXRlZCB0byBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgaW5cbiAgICAgICAgLy8gdGhlIG1pZGRsZSBvZiB0aGUgbm90aWZpY2F0aW9uIGxvb3AsIHdoZXJlIGBzdWJzY3JpcHRpb25gIHdpbGwgdGhlbiBiZSBudWxsLiBUaGlzIGNhblxuICAgICAgICAvLyBwcm9iYWJseSBiZSBhdm9pZGVkIGlmIFN1YnNjcmlwdGlvbidzIGxpc3RlbmVycyBsb2dpYyBpcyBjaGFuZ2VkIHRvIG5vdCBjYWxsIGxpc3RlbmVyc1xuICAgICAgICAvLyB0aGF0IGhhdmUgYmVlbiB1bnN1YnNjcmliZWQgaW4gdGhlICBtaWRkbGUgb2YgdGhlIG5vdGlmaWNhdGlvbiBsb29wLlxuXG4gICAgICAgIGNvbnN0IG5vdGlmeU5lc3RlZFN1YnMgPSBzdWJzY3JpcHRpb24ubm90aWZ5TmVzdGVkU3Vicy5iaW5kKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIHJldHVybiBbc3Vic2NyaXB0aW9uLCBub3RpZnlOZXN0ZWRTdWJzXTtcbiAgICAgIH0sIFtzdG9yZSwgZGlkU3RvcmVDb21lRnJvbVByb3BzLCBjb250ZXh0VmFsdWVdKTsgLy8gRGV0ZXJtaW5lIHdoYXQge3N0b3JlLCBzdWJzY3JpcHRpb259IHZhbHVlIHNob3VsZCBiZSBwdXQgaW50byBuZXN0ZWQgY29udGV4dCwgaWYgbmVjZXNzYXJ5LFxuICAgICAgLy8gYW5kIG1lbW9pemUgdGhhdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSBjb250ZXh0IHVwZGF0ZXMuXG5cbiAgICAgIGNvbnN0IG92ZXJyaWRkZW5Db250ZXh0VmFsdWUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKGRpZFN0b3JlQ29tZUZyb21Qcm9wcykge1xuICAgICAgICAgIC8vIFRoaXMgY29tcG9uZW50IGlzIGRpcmVjdGx5IHN1YnNjcmliZWQgdG8gYSBzdG9yZSBmcm9tIHByb3BzLlxuICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgZGVzY2VuZGFudHMgcmVhZGluZyBmcm9tIHRoaXMgc3RvcmUgLSBwYXNzIGRvd24gd2hhdGV2ZXJcbiAgICAgICAgICAvLyB0aGUgZXhpc3RpbmcgY29udGV4dCB2YWx1ZSBpcyBmcm9tIHRoZSBuZWFyZXN0IGNvbm5lY3RlZCBhbmNlc3Rvci5cbiAgICAgICAgICByZXR1cm4gY29udGV4dFZhbHVlO1xuICAgICAgICB9IC8vIE90aGVyd2lzZSwgcHV0IHRoaXMgY29tcG9uZW50J3Mgc3Vic2NyaXB0aW9uIGluc3RhbmNlIGludG8gY29udGV4dCwgc28gdGhhdFxuICAgICAgICAvLyBjb25uZWN0ZWQgZGVzY2VuZGFudHMgd29uJ3QgdXBkYXRlIHVudGlsIGFmdGVyIHRoaXMgY29tcG9uZW50IGlzIGRvbmVcblxuXG4gICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgY29udGV4dFZhbHVlLCB7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfSwgW2RpZFN0b3JlQ29tZUZyb21Qcm9wcywgY29udGV4dFZhbHVlLCBzdWJzY3JpcHRpb25dKTsgLy8gU2V0IHVwIHJlZnMgdG8gY29vcmRpbmF0ZSB2YWx1ZXMgYmV0d2VlbiB0aGUgc3Vic2NyaXB0aW9uIGVmZmVjdCBhbmQgdGhlIHJlbmRlciBsb2dpY1xuXG4gICAgICBjb25zdCBsYXN0Q2hpbGRQcm9wcyA9IHVzZVJlZigpO1xuICAgICAgY29uc3QgbGFzdFdyYXBwZXJQcm9wcyA9IHVzZVJlZih3cmFwcGVyUHJvcHMpO1xuICAgICAgY29uc3QgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSA9IHVzZVJlZigpO1xuICAgICAgY29uc3QgcmVuZGVySXNTY2hlZHVsZWQgPSB1c2VSZWYoZmFsc2UpO1xuICAgICAgY29uc3QgaXNQcm9jZXNzaW5nRGlzcGF0Y2ggPSB1c2VSZWYoZmFsc2UpO1xuICAgICAgY29uc3QgaXNNb3VudGVkID0gdXNlUmVmKGZhbHNlKTtcbiAgICAgIGNvbnN0IGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IgPSB1c2VSZWYoKTtcbiAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgIH0sIFtdKTtcbiAgICAgIGNvbnN0IGFjdHVhbENoaWxkUHJvcHNTZWxlY3RvciA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9ICgpID0+IHtcbiAgICAgICAgICAvLyBUcmlja3kgbG9naWMgaGVyZTpcbiAgICAgICAgICAvLyAtIFRoaXMgcmVuZGVyIG1heSBoYXZlIGJlZW4gdHJpZ2dlcmVkIGJ5IGEgUmVkdXggc3RvcmUgdXBkYXRlIHRoYXQgcHJvZHVjZWQgbmV3IGNoaWxkIHByb3BzXG4gICAgICAgICAgLy8gLSBIb3dldmVyLCB3ZSBtYXkgaGF2ZSBnb3R0ZW4gbmV3IHdyYXBwZXIgcHJvcHMgYWZ0ZXIgdGhhdFxuICAgICAgICAgIC8vIElmIHdlIGhhdmUgbmV3IGNoaWxkIHByb3BzLCBhbmQgdGhlIHNhbWUgd3JhcHBlciBwcm9wcywgd2Uga25vdyB3ZSBzaG91bGQgdXNlIHRoZSBuZXcgY2hpbGQgcHJvcHMgYXMtaXMuXG4gICAgICAgICAgLy8gQnV0LCBpZiB3ZSBoYXZlIG5ldyB3cmFwcGVyIHByb3BzLCB0aG9zZSBtaWdodCBjaGFuZ2UgdGhlIGNoaWxkIHByb3BzLCBzbyB3ZSBoYXZlIHRvIHJlY2FsY3VsYXRlIHRoaW5ncy5cbiAgICAgICAgICAvLyBTbywgd2UnbGwgdXNlIHRoZSBjaGlsZCBwcm9wcyBmcm9tIHN0b3JlIHVwZGF0ZSBvbmx5IGlmIHRoZSB3cmFwcGVyIHByb3BzIGFyZSB0aGUgc2FtZSBhcyBsYXN0IHRpbWUuXG4gICAgICAgICAgaWYgKGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCAmJiB3cmFwcGVyUHJvcHMgPT09IGxhc3RXcmFwcGVyUHJvcHMuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudDtcbiAgICAgICAgICB9IC8vIFRPRE8gV2UncmUgcmVhZGluZyB0aGUgc3RvcmUgZGlyZWN0bHkgaW4gcmVuZGVyKCkgaGVyZS4gQmFkIGlkZWE/XG4gICAgICAgICAgLy8gVGhpcyB3aWxsIGxpa2VseSBjYXVzZSBCYWQgVGhpbmdzIChUTSkgdG8gaGFwcGVuIGluIENvbmN1cnJlbnQgTW9kZS5cbiAgICAgICAgICAvLyBOb3RlIHRoYXQgd2UgZG8gdGhpcyBiZWNhdXNlIG9uIHJlbmRlcnMgX25vdF8gY2F1c2VkIGJ5IHN0b3JlIHVwZGF0ZXMsIHdlIG5lZWQgdGhlIGxhdGVzdCBzdG9yZSBzdGF0ZVxuICAgICAgICAgIC8vIHRvIGRldGVybWluZSB3aGF0IHRoZSBjaGlsZCBwcm9wcyBzaG91bGQgYmUuXG5cblxuICAgICAgICAgIHJldHVybiBjaGlsZFByb3BzU2VsZWN0b3Ioc3RvcmUuZ2V0U3RhdGUoKSwgd3JhcHBlclByb3BzKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgICB9LCBbc3RvcmUsIHdyYXBwZXJQcm9wc10pOyAvLyBXZSBuZWVkIHRoaXMgdG8gZXhlY3V0ZSBzeW5jaHJvbm91c2x5IGV2ZXJ5IHRpbWUgd2UgcmUtcmVuZGVyLiBIb3dldmVyLCBSZWFjdCB3YXJuc1xuICAgICAgLy8gYWJvdXQgdXNlTGF5b3V0RWZmZWN0IGluIFNTUiwgc28gd2UgdHJ5IHRvIGRldGVjdCBlbnZpcm9ubWVudCBhbmQgZmFsbCBiYWNrIHRvXG4gICAgICAvLyBqdXN0IHVzZUVmZmVjdCBpbnN0ZWFkIHRvIGF2b2lkIHRoZSB3YXJuaW5nLCBzaW5jZSBuZWl0aGVyIHdpbGwgcnVuIGFueXdheS5cblxuICAgICAgY29uc3Qgc3Vic2NyaWJlRm9yUmVhY3QgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlID0gcmVhY3RMaXN0ZW5lciA9PiB7XG4gICAgICAgICAgaWYgKCFzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7fTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlVXBkYXRlcyhzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsIHN0b3JlLCBzdWJzY3JpcHRpb24sIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBjaGlsZFByb3BzU2VsZWN0b3IsIGxhc3RXcmFwcGVyUHJvcHMsIGxhc3RDaGlsZFByb3BzLCByZW5kZXJJc1NjaGVkdWxlZCwgaXNNb3VudGVkLCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLCBub3RpZnlOZXN0ZWRTdWJzLCByZWFjdExpc3RlbmVyKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc3Vic2NyaWJlO1xuICAgICAgfSwgW3N1YnNjcmlwdGlvbl0pO1xuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdFdpdGhBcmdzKGNhcHR1cmVXcmFwcGVyUHJvcHMsIFtsYXN0V3JhcHBlclByb3BzLCBsYXN0Q2hpbGRQcm9wcywgcmVuZGVySXNTY2hlZHVsZWQsIHdyYXBwZXJQcm9wcywgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSwgbm90aWZ5TmVzdGVkU3Vic10pO1xuICAgICAgbGV0IGFjdHVhbENoaWxkUHJvcHM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGFjdHVhbENoaWxkUHJvcHMgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZSggLy8gVE9ETyBXZSdyZSBwYXNzaW5nIHRocm91Z2ggYSBiaWcgd3JhcHBlciB0aGF0IGRvZXMgYSBidW5jaCBvZiBleHRyYSBzaWRlIGVmZmVjdHMgYmVzaWRlcyBzdWJzY3JpYmluZ1xuICAgICAgICBzdWJzY3JpYmVGb3JSZWFjdCwgLy8gVE9ETyBUaGlzIGlzIGluY3JlZGlibHkgaGFja3kuIFdlJ3ZlIGFscmVhZHkgcHJvY2Vzc2VkIHRoZSBzdG9yZSB1cGRhdGUgYW5kIGNhbGN1bGF0ZWQgbmV3IGNoaWxkIHByb3BzLFxuICAgICAgICAvLyBUT0RPIGFuZCB3ZSdyZSBqdXN0IHBhc3NpbmcgdGhhdCB0aHJvdWdoIHNvIGl0IHRyaWdnZXJzIGEgcmUtcmVuZGVyIGZvciB1cyByYXRoZXIgdGhhbiByZWx5aW5nIG9uIGB1U0VTYC5cbiAgICAgICAgYWN0dWFsQ2hpbGRQcm9wc1NlbGVjdG9yLCBnZXRTZXJ2ZXJTdGF0ZSA/ICgpID0+IGNoaWxkUHJvcHNTZWxlY3RvcihnZXRTZXJ2ZXJTdGF0ZSgpLCB3cmFwcGVyUHJvcHMpIDogYWN0dWFsQ2hpbGRQcm9wc1NlbGVjdG9yKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAobGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50KSB7XG4gICAgICAgICAgO1xuICAgICAgICAgIGVyci5tZXNzYWdlICs9IGBcXG5UaGUgZXJyb3IgbWF5IGJlIGNvcnJlbGF0ZWQgd2l0aCB0aGlzIHByZXZpb3VzIGVycm9yOlxcbiR7bGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50LnN0YWNrfVxcblxcbmA7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG5cbiAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGFzdENoaWxkUHJvcHMuY3VycmVudCA9IGFjdHVhbENoaWxkUHJvcHM7XG4gICAgICB9KTsgLy8gTm93IHRoYXQgYWxsIHRoYXQncyBkb25lLCB3ZSBjYW4gZmluYWxseSB0cnkgdG8gYWN0dWFsbHkgcmVuZGVyIHRoZSBjaGlsZCBjb21wb25lbnQuXG4gICAgICAvLyBXZSBtZW1vaXplIHRoZSBlbGVtZW50cyBmb3IgdGhlIHJlbmRlcmVkIGNoaWxkIGNvbXBvbmVudCBhcyBhbiBvcHRpbWl6YXRpb24uXG5cbiAgICAgIGNvbnN0IHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChXcmFwcGVkQ29tcG9uZW50LCBfZXh0ZW5kcyh7fSwgYWN0dWFsQ2hpbGRQcm9wcywge1xuICAgICAgICAgICAgcmVmOiByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmXG4gICAgICAgICAgfSkpXG4gICAgICAgICk7XG4gICAgICB9LCBbcmVhY3RSZWR1eEZvcndhcmRlZFJlZiwgV3JhcHBlZENvbXBvbmVudCwgYWN0dWFsQ2hpbGRQcm9wc10pOyAvLyBJZiBSZWFjdCBzZWVzIHRoZSBleGFjdCBzYW1lIGVsZW1lbnQgcmVmZXJlbmNlIGFzIGxhc3QgdGltZSwgaXQgYmFpbHMgb3V0IG9mIHJlLXJlbmRlcmluZ1xuICAgICAgLy8gdGhhdCBjaGlsZCwgc2FtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBSZWFjdC5tZW1vKCkgb3IgcmV0dXJuZWQgZmFsc2UgZnJvbSBzaG91bGRDb21wb25lbnRVcGRhdGUuXG5cbiAgICAgIGNvbnN0IHJlbmRlcmVkQ2hpbGQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykge1xuICAgICAgICAgIC8vIElmIHRoaXMgY29tcG9uZW50IGlzIHN1YnNjcmliZWQgdG8gc3RvcmUgdXBkYXRlcywgd2UgbmVlZCB0byBwYXNzIGl0cyBvd25cbiAgICAgICAgICAvLyBzdWJzY3JpcHRpb24gaW5zdGFuY2UgZG93biB0byBvdXIgZGVzY2VuZGFudHMuIFRoYXQgbWVhbnMgcmVuZGVyaW5nIHRoZSBzYW1lXG4gICAgICAgICAgLy8gQ29udGV4dCBpbnN0YW5jZSwgYW5kIHB1dHRpbmcgYSBkaWZmZXJlbnQgdmFsdWUgaW50byB0aGUgY29udGV4dC5cbiAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dFRvVXNlLlByb3ZpZGVyLCB7XG4gICAgICAgICAgICB2YWx1ZTogb3ZlcnJpZGRlbkNvbnRleHRWYWx1ZVxuICAgICAgICAgIH0sIHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50O1xuICAgICAgfSwgW0NvbnRleHRUb1VzZSwgcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50LCBvdmVycmlkZGVuQ29udGV4dFZhbHVlXSk7XG4gICAgICByZXR1cm4gcmVuZGVyZWRDaGlsZDtcbiAgICB9XG5cbiAgICBjb25zdCBfQ29ubmVjdCA9IFJlYWN0Lm1lbW8oQ29ubmVjdEZ1bmN0aW9uKTtcblxuICAgIC8vIEFkZCBhIGhhY2t5IGNhc3QgdG8gZ2V0IHRoZSByaWdodCBvdXRwdXQgdHlwZVxuICAgIGNvbnN0IENvbm5lY3QgPSBfQ29ubmVjdDtcbiAgICBDb25uZWN0LldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuICAgIENvbm5lY3QuZGlzcGxheU5hbWUgPSBDb25uZWN0RnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcblxuICAgIGlmIChmb3J3YXJkUmVmKSB7XG4gICAgICBjb25zdCBfZm9yd2FyZGVkID0gUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBmb3J3YXJkQ29ubmVjdFJlZihwcm9wcywgcmVmKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbm5lY3QsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgICAgIHJlYWN0UmVkdXhGb3J3YXJkZWRSZWY6IHJlZlxuICAgICAgICB9KSk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZm9yd2FyZGVkID0gX2ZvcndhcmRlZDtcbiAgICAgIGZvcndhcmRlZC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICAgICAgZm9yd2FyZGVkLldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuICAgICAgcmV0dXJuIGhvaXN0U3RhdGljcyhmb3J3YXJkZWQsIFdyYXBwZWRDb21wb25lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBob2lzdFN0YXRpY3MoQ29ubmVjdCwgV3JhcHBlZENvbXBvbmVudCk7XG4gIH07XG5cbiAgcmV0dXJuIHdyYXBXaXRoQ29ubmVjdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdDsiLCJpbXBvcnQgUmVhY3QsIHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFJlYWN0UmVkdXhDb250ZXh0IH0gZnJvbSAnLi9Db250ZXh0JztcbmltcG9ydCB7IGNyZWF0ZVN1YnNjcmlwdGlvbiB9IGZyb20gJy4uL3V0aWxzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IH0gZnJvbSAnLi4vdXRpbHMvdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCc7XG5cbmZ1bmN0aW9uIFByb3ZpZGVyKHtcbiAgc3RvcmUsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICBzZXJ2ZXJTdGF0ZVxufSkge1xuICBjb25zdCBjb250ZXh0VmFsdWUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBjcmVhdGVTdWJzY3JpcHRpb24oc3RvcmUpO1xuICAgIHJldHVybiB7XG4gICAgICBzdG9yZSxcbiAgICAgIHN1YnNjcmlwdGlvbixcbiAgICAgIGdldFNlcnZlclN0YXRlOiBzZXJ2ZXJTdGF0ZSA/ICgpID0+IHNlcnZlclN0YXRlIDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfSwgW3N0b3JlLCBzZXJ2ZXJTdGF0ZV0pO1xuICBjb25zdCBwcmV2aW91c1N0YXRlID0gdXNlTWVtbygoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLCBbc3RvcmVdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgc3Vic2NyaXB0aW9uXG4gICAgfSA9IGNvbnRleHRWYWx1ZTtcbiAgICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSA9IHN1YnNjcmlwdGlvbi5ub3RpZnlOZXN0ZWRTdWJzO1xuICAgIHN1YnNjcmlwdGlvbi50cnlTdWJzY3JpYmUoKTtcblxuICAgIGlmIChwcmV2aW91c1N0YXRlICE9PSBzdG9yZS5nZXRTdGF0ZSgpKSB7XG4gICAgICBzdWJzY3JpcHRpb24ubm90aWZ5TmVzdGVkU3VicygpO1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdWJzY3JpcHRpb24udHJ5VW5zdWJzY3JpYmUoKTtcbiAgICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gdW5kZWZpbmVkO1xuICAgIH07XG4gIH0sIFtjb250ZXh0VmFsdWUsIHByZXZpb3VzU3RhdGVdKTtcbiAgY29uc3QgQ29udGV4dCA9IGNvbnRleHQgfHwgUmVhY3RSZWR1eENvbnRleHQ7IC8vIEB0cy1pZ25vcmUgJ0FueUFjdGlvbicgaXMgYXNzaWduYWJsZSB0byB0aGUgY29uc3RyYWludCBvZiB0eXBlICdBJywgYnV0ICdBJyBjb3VsZCBiZSBpbnN0YW50aWF0ZWQgd2l0aCBhIGRpZmZlcmVudCBzdWJ0eXBlXG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFZhbHVlXG4gIH0sIGNoaWxkcmVuKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUHJvdmlkZXI7IiwiaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFJlYWN0UmVkdXhDb250ZXh0IH0gZnJvbSAnLi4vY29tcG9uZW50cy9Db250ZXh0JztcbmltcG9ydCB7IHVzZVJlZHV4Q29udGV4dCBhcyB1c2VEZWZhdWx0UmVkdXhDb250ZXh0IH0gZnJvbSAnLi91c2VSZWR1eENvbnRleHQnO1xuLyoqXHJcbiAqIEhvb2sgZmFjdG9yeSwgd2hpY2ggY3JlYXRlcyBhIGB1c2VTdG9yZWAgaG9vayBib3VuZCB0byBhIGdpdmVuIGNvbnRleHQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhY3QuQ29udGV4dH0gW2NvbnRleHQ9UmVhY3RSZWR1eENvbnRleHRdIENvbnRleHQgcGFzc2VkIHRvIHlvdXIgYDxQcm92aWRlcj5gLlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgYHVzZVN0b3JlYCBob29rIGJvdW5kIHRvIHRoZSBzcGVjaWZpZWQgY29udGV4dC5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdG9yZUhvb2soY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0KSB7XG4gIGNvbnN0IHVzZVJlZHV4Q29udGV4dCA9IC8vIEB0cy1pZ25vcmVcbiAgY29udGV4dCA9PT0gUmVhY3RSZWR1eENvbnRleHQgPyB1c2VEZWZhdWx0UmVkdXhDb250ZXh0IDogKCkgPT4gdXNlQ29udGV4dChjb250ZXh0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVzZVN0b3JlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0b3JlXG4gICAgfSA9IHVzZVJlZHV4Q29udGV4dCgpOyAvLyBAdHMtaWdub3JlXG5cbiAgICByZXR1cm4gc3RvcmU7XG4gIH07XG59XG4vKipcclxuICogQSBob29rIHRvIGFjY2VzcyB0aGUgcmVkdXggc3RvcmUuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHthbnl9IHRoZSByZWR1eCBzdG9yZVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXHJcbiAqIGltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAncmVhY3QtcmVkdXgnXHJcbiAqXHJcbiAqIGV4cG9ydCBjb25zdCBFeGFtcGxlQ29tcG9uZW50ID0gKCkgPT4ge1xyXG4gKiAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUoKVxyXG4gKiAgIHJldHVybiA8ZGl2PntzdG9yZS5nZXRTdGF0ZSgpfTwvZGl2PlxyXG4gKiB9XHJcbiAqL1xuXG5leHBvcnQgY29uc3QgdXNlU3RvcmUgPSAvKiNfX1BVUkVfXyovY3JlYXRlU3RvcmVIb29rKCk7IiwiaW1wb3J0IHsgUmVhY3RSZWR1eENvbnRleHQgfSBmcm9tICcuLi9jb21wb25lbnRzL0NvbnRleHQnO1xuaW1wb3J0IHsgdXNlU3RvcmUgYXMgdXNlRGVmYXVsdFN0b3JlLCBjcmVhdGVTdG9yZUhvb2sgfSBmcm9tICcuL3VzZVN0b3JlJztcbi8qKlxyXG4gKiBIb29rIGZhY3RvcnksIHdoaWNoIGNyZWF0ZXMgYSBgdXNlRGlzcGF0Y2hgIGhvb2sgYm91bmQgdG8gYSBnaXZlbiBjb250ZXh0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWN0LkNvbnRleHR9IFtjb250ZXh0PVJlYWN0UmVkdXhDb250ZXh0XSBDb250ZXh0IHBhc3NlZCB0byB5b3VyIGA8UHJvdmlkZXI+YC5cclxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGB1c2VEaXNwYXRjaGAgaG9vayBib3VuZCB0byB0aGUgc3BlY2lmaWVkIGNvbnRleHQuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGlzcGF0Y2hIb29rKGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dCkge1xuICBjb25zdCB1c2VTdG9yZSA9IC8vIEB0cy1pZ25vcmVcbiAgY29udGV4dCA9PT0gUmVhY3RSZWR1eENvbnRleHQgPyB1c2VEZWZhdWx0U3RvcmUgOiBjcmVhdGVTdG9yZUhvb2soY29udGV4dCk7XG4gIHJldHVybiBmdW5jdGlvbiB1c2VEaXNwYXRjaCgpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlKCk7IC8vIEB0cy1pZ25vcmVcblxuICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaDtcbiAgfTtcbn1cbi8qKlxyXG4gKiBBIGhvb2sgdG8gYWNjZXNzIHRoZSByZWR1eCBgZGlzcGF0Y2hgIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7YW55fGZ1bmN0aW9ufSByZWR1eCBzdG9yZSdzIGBkaXNwYXRjaGAgZnVuY3Rpb25cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnXHJcbiAqIGltcG9ydCB7IHVzZURpc3BhdGNoIH0gZnJvbSAncmVhY3QtcmVkdXgnXHJcbiAqXHJcbiAqIGV4cG9ydCBjb25zdCBDb3VudGVyQ29tcG9uZW50ID0gKHsgdmFsdWUgfSkgPT4ge1xyXG4gKiAgIGNvbnN0IGRpc3BhdGNoID0gdXNlRGlzcGF0Y2goKVxyXG4gKiAgIGNvbnN0IGluY3JlYXNlQ291bnRlciA9IHVzZUNhbGxiYWNrKCgpID0+IGRpc3BhdGNoKHsgdHlwZTogJ2luY3JlYXNlLWNvdW50ZXInIH0pLCBbXSlcclxuICogICByZXR1cm4gKFxyXG4gKiAgICAgPGRpdj5cclxuICogICAgICAgPHNwYW4+e3ZhbHVlfTwvc3Bhbj5cclxuICogICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtpbmNyZWFzZUNvdW50ZXJ9PkluY3JlYXNlIGNvdW50ZXI8L2J1dHRvbj5cclxuICogICAgIDwvZGl2PlxyXG4gKiAgIClcclxuICogfVxyXG4gKi9cblxuZXhwb3J0IGNvbnN0IHVzZURpc3BhdGNoID0gLyojX19QVVJFX18qL2NyZWF0ZURpc3BhdGNoSG9vaygpOyIsImltcG9ydCBQcm92aWRlciBmcm9tICcuL2NvbXBvbmVudHMvUHJvdmlkZXInO1xuaW1wb3J0IGNvbm5lY3QgZnJvbSAnLi9jb21wb25lbnRzL2Nvbm5lY3QnO1xuaW1wb3J0IHsgUmVhY3RSZWR1eENvbnRleHQgfSBmcm9tICcuL2NvbXBvbmVudHMvQ29udGV4dCc7XG5pbXBvcnQgeyB1c2VEaXNwYXRjaCwgY3JlYXRlRGlzcGF0Y2hIb29rIH0gZnJvbSAnLi9ob29rcy91c2VEaXNwYXRjaCc7XG5pbXBvcnQgeyB1c2VTZWxlY3RvciwgY3JlYXRlU2VsZWN0b3JIb29rIH0gZnJvbSAnLi9ob29rcy91c2VTZWxlY3Rvcic7XG5pbXBvcnQgeyB1c2VTdG9yZSwgY3JlYXRlU3RvcmVIb29rIH0gZnJvbSAnLi9ob29rcy91c2VTdG9yZSc7XG5pbXBvcnQgc2hhbGxvd0VxdWFsIGZyb20gJy4vdXRpbHMvc2hhbGxvd0VxdWFsJztcbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0IHsgUHJvdmlkZXIsIFJlYWN0UmVkdXhDb250ZXh0LCBjb25uZWN0LCB1c2VEaXNwYXRjaCwgY3JlYXRlRGlzcGF0Y2hIb29rLCB1c2VTZWxlY3RvciwgY3JlYXRlU2VsZWN0b3JIb29rLCB1c2VTdG9yZSwgY3JlYXRlU3RvcmVIb29rLCBzaGFsbG93RXF1YWwgfTsiLCIvLyBUaGUgcHJpbWFyeSBlbnRyeSBwb2ludCBhc3N1bWVzIHdlJ3JlIHdvcmtpbmcgd2l0aCBzdGFuZGFyZCBSZWFjdERPTS9STiwgYnV0XG4vLyBvbGRlciB2ZXJzaW9ucyB0aGF0IGRvIG5vdCBpbmNsdWRlIGB1c2VTeW5jRXh0ZXJuYWxTdG9yZWAgKFJlYWN0IDE2LjkgLSAxNy54KS5cbi8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhlIHVzZVN5bmNFeHRlcm5hbFN0b3JlIGNvbXBhdCBzaGltIGlzIG5lZWRlZC5cbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlIH0gZnJvbSAndXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbSc7XG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciB9IGZyb20gJ3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vd2l0aC1zZWxlY3Rvcic7XG5pbXBvcnQgeyB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyBhcyBiYXRjaCB9IGZyb20gJy4vdXRpbHMvcmVhY3RCYXRjaGVkVXBkYXRlcyc7XG5pbXBvcnQgeyBzZXRCYXRjaCB9IGZyb20gJy4vdXRpbHMvYmF0Y2gnO1xuaW1wb3J0IHsgaW5pdGlhbGl6ZVVzZVNlbGVjdG9yIH0gZnJvbSAnLi9ob29rcy91c2VTZWxlY3Rvcic7XG5pbXBvcnQgeyBpbml0aWFsaXplQ29ubmVjdCB9IGZyb20gJy4vY29tcG9uZW50cy9jb25uZWN0JztcbmluaXRpYWxpemVVc2VTZWxlY3Rvcih1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3Rvcik7XG5pbml0aWFsaXplQ29ubmVjdCh1c2VTeW5jRXh0ZXJuYWxTdG9yZSk7IC8vIEVuYWJsZSBiYXRjaGVkIHVwZGF0ZXMgaW4gb3VyIHN1YnNjcmlwdGlvbnMgZm9yIHVzZVxuLy8gd2l0aCBzdGFuZGFyZCBSZWFjdCByZW5kZXJlcnMgKFJlYWN0RE9NLCBSZWFjdCBOYXRpdmUpXG5cbnNldEJhdGNoKGJhdGNoKTtcbmV4cG9ydCB7IGJhdGNoIH07XG5leHBvcnQgKiBmcm9tICcuL2V4cG9ydHMnOyIsImZ1bmN0aW9uIHN0eWxpc19taW4gKFcpIHtcbiAgZnVuY3Rpb24gTShkLCBjLCBlLCBoLCBhKSB7XG4gICAgZm9yICh2YXIgbSA9IDAsIGIgPSAwLCB2ID0gMCwgbiA9IDAsIHEsIGcsIHggPSAwLCBLID0gMCwgaywgdSA9IGsgPSBxID0gMCwgbCA9IDAsIHIgPSAwLCBJID0gMCwgdCA9IDAsIEIgPSBlLmxlbmd0aCwgSiA9IEIgLSAxLCB5LCBmID0gJycsIHAgPSAnJywgRiA9ICcnLCBHID0gJycsIEM7IGwgPCBCOykge1xuICAgICAgZyA9IGUuY2hhckNvZGVBdChsKTtcbiAgICAgIGwgPT09IEogJiYgMCAhPT0gYiArIG4gKyB2ICsgbSAmJiAoMCAhPT0gYiAmJiAoZyA9IDQ3ID09PSBiID8gMTAgOiA0NyksIG4gPSB2ID0gbSA9IDAsIEIrKywgSisrKTtcblxuICAgICAgaWYgKDAgPT09IGIgKyBuICsgdiArIG0pIHtcbiAgICAgICAgaWYgKGwgPT09IEogJiYgKDAgPCByICYmIChmID0gZi5yZXBsYWNlKE4sICcnKSksIDAgPCBmLnRyaW0oKS5sZW5ndGgpKSB7XG4gICAgICAgICAgc3dpdGNoIChnKSB7XG4gICAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgY2FzZSA1OTpcbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgZiArPSBlLmNoYXJBdChsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnID0gNTk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGcpIHtcbiAgICAgICAgICBjYXNlIDEyMzpcbiAgICAgICAgICAgIGYgPSBmLnRyaW0oKTtcbiAgICAgICAgICAgIHEgPSBmLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBrID0gMTtcblxuICAgICAgICAgICAgZm9yICh0ID0gKytsOyBsIDwgQjspIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChnID0gZS5jaGFyQ29kZUF0KGwpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxMjM6XG4gICAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgMTI1OlxuICAgICAgICAgICAgICAgICAgay0tO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgICAgICAgc3dpdGNoIChnID0gZS5jaGFyQ29kZUF0KGwgKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQyOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodSA9IGwgKyAxOyB1IDwgSjsgKyt1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZS5jaGFyQ29kZUF0KHUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICg0MiA9PT0gZyAmJiA0MiA9PT0gZS5jaGFyQ29kZUF0KHUgLSAxKSAmJiBsICsgMiAhPT0gdSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gdSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICg0NyA9PT0gZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gdSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsID0gdTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDkxOlxuICAgICAgICAgICAgICAgICAgZysrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICAgICAgICAgIGcrKztcblxuICAgICAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgICAgICAgIGZvciAoOyBsKysgPCBKICYmIGUuY2hhckNvZGVBdChsKSAhPT0gZzspIHtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKDAgPT09IGspIGJyZWFrO1xuICAgICAgICAgICAgICBsKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGsgPSBlLnN1YnN0cmluZyh0LCBsKTtcbiAgICAgICAgICAgIDAgPT09IHEgJiYgKHEgPSAoZiA9IGYucmVwbGFjZShjYSwgJycpLnRyaW0oKSkuY2hhckNvZGVBdCgwKSk7XG5cbiAgICAgICAgICAgIHN3aXRjaCAocSkge1xuICAgICAgICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgICAgICAgIDAgPCByICYmIChmID0gZi5yZXBsYWNlKE4sICcnKSk7XG4gICAgICAgICAgICAgICAgZyA9IGYuY2hhckNvZGVBdCgxKTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZykge1xuICAgICAgICAgICAgICAgICAgY2FzZSAxMDA6XG4gICAgICAgICAgICAgICAgICBjYXNlIDEwOTpcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTE1OlxuICAgICAgICAgICAgICAgICAgY2FzZSA0NTpcbiAgICAgICAgICAgICAgICAgICAgciA9IGM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByID0gTztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBrID0gTShjLCByLCBrLCBnLCBhICsgMSk7XG4gICAgICAgICAgICAgICAgdCA9IGsubGVuZ3RoO1xuICAgICAgICAgICAgICAgIDAgPCBBICYmIChyID0gWChPLCBmLCBJKSwgQyA9IEgoMywgaywgciwgYywgRCwgeiwgdCwgZywgYSwgaCksIGYgPSByLmpvaW4oJycpLCB2b2lkIDAgIT09IEMgJiYgMCA9PT0gKHQgPSAoayA9IEMudHJpbSgpKS5sZW5ndGgpICYmIChnID0gMCwgayA9ICcnKSk7XG4gICAgICAgICAgICAgICAgaWYgKDAgPCB0KSBzd2l0Y2ggKGcpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTE1OlxuICAgICAgICAgICAgICAgICAgICBmID0gZi5yZXBsYWNlKGRhLCBlYSk7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTAwOlxuICAgICAgICAgICAgICAgICAgY2FzZSAxMDk6XG4gICAgICAgICAgICAgICAgICBjYXNlIDQ1OlxuICAgICAgICAgICAgICAgICAgICBrID0gZiArICd7JyArIGsgKyAnfSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDEwNzpcbiAgICAgICAgICAgICAgICAgICAgZiA9IGYucmVwbGFjZShmYSwgJyQxICQyJyk7XG4gICAgICAgICAgICAgICAgICAgIGsgPSBmICsgJ3snICsgayArICd9JztcbiAgICAgICAgICAgICAgICAgICAgayA9IDEgPT09IHcgfHwgMiA9PT0gdyAmJiBMKCdAJyArIGssIDMpID8gJ0Atd2Via2l0LScgKyBrICsgJ0AnICsgayA6ICdAJyArIGs7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBrID0gZiArIGssIDExMiA9PT0gaCAmJiAoayA9IChwICs9IGssICcnKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGsgPSAnJztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGsgPSBNKGMsIFgoYywgZiwgSSksIGssIGgsIGEgKyAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgRiArPSBrO1xuICAgICAgICAgICAgayA9IEkgPSByID0gdSA9IHEgPSAwO1xuICAgICAgICAgICAgZiA9ICcnO1xuICAgICAgICAgICAgZyA9IGUuY2hhckNvZGVBdCgrK2wpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDEyNTpcbiAgICAgICAgICBjYXNlIDU5OlxuICAgICAgICAgICAgZiA9ICgwIDwgciA/IGYucmVwbGFjZShOLCAnJykgOiBmKS50cmltKCk7XG4gICAgICAgICAgICBpZiAoMSA8ICh0ID0gZi5sZW5ndGgpKSBzd2l0Y2ggKDAgPT09IHUgJiYgKHEgPSBmLmNoYXJDb2RlQXQoMCksIDQ1ID09PSBxIHx8IDk2IDwgcSAmJiAxMjMgPiBxKSAmJiAodCA9IChmID0gZi5yZXBsYWNlKCcgJywgJzonKSkubGVuZ3RoKSwgMCA8IEEgJiYgdm9pZCAwICE9PSAoQyA9IEgoMSwgZiwgYywgZCwgRCwgeiwgcC5sZW5ndGgsIGgsIGEsIGgpKSAmJiAwID09PSAodCA9IChmID0gQy50cmltKCkpLmxlbmd0aCkgJiYgKGYgPSAnXFx4MDBcXHgwMCcpLCBxID0gZi5jaGFyQ29kZUF0KDApLCBnID0gZi5jaGFyQ29kZUF0KDEpLCBxKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgICAgICAgIGlmICgxMDUgPT09IGcgfHwgOTkgPT09IGcpIHtcbiAgICAgICAgICAgICAgICAgIEcgKz0gZiArIGUuY2hhckF0KGwpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgNTggIT09IGYuY2hhckNvZGVBdCh0IC0gMSkgJiYgKHAgKz0gUChmLCBxLCBnLCBmLmNoYXJDb2RlQXQoMikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEkgPSByID0gdSA9IHEgPSAwO1xuICAgICAgICAgICAgZiA9ICcnO1xuICAgICAgICAgICAgZyA9IGUuY2hhckNvZGVBdCgrK2wpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoZykge1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIDQ3ID09PSBiID8gYiA9IDAgOiAwID09PSAxICsgcSAmJiAxMDcgIT09IGggJiYgMCA8IGYubGVuZ3RoICYmIChyID0gMSwgZiArPSAnXFx4MDAnKTtcbiAgICAgICAgICAwIDwgQSAqIFkgJiYgSCgwLCBmLCBjLCBkLCBELCB6LCBwLmxlbmd0aCwgaCwgYSwgaCk7XG4gICAgICAgICAgeiA9IDE7XG4gICAgICAgICAgRCsrO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNTk6XG4gICAgICAgIGNhc2UgMTI1OlxuICAgICAgICAgIGlmICgwID09PSBiICsgbiArIHYgKyBtKSB7XG4gICAgICAgICAgICB6Kys7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB6Kys7XG4gICAgICAgICAgeSA9IGUuY2hhckF0KGwpO1xuXG4gICAgICAgICAgc3dpdGNoIChnKSB7XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgICBpZiAoMCA9PT0gbiArIG0gKyBiKSBzd2l0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDQ0OlxuICAgICAgICAgICAgICAgIGNhc2UgNTg6XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgICB5ID0gJyc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAzMiAhPT0gZyAmJiAoeSA9ICcgJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgeSA9ICdcXFxcMCc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICB5ID0gJ1xcXFxmJztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIHkgPSAnXFxcXHYnO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAgICAgMCA9PT0gbiArIGIgKyBtICYmIChyID0gSSA9IDEsIHkgPSAnXFxmJyArIHkpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMDg6XG4gICAgICAgICAgICAgIGlmICgwID09PSBuICsgYiArIG0gKyBFICYmIDAgPCB1KSBzd2l0Y2ggKGwgLSB1KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgMTEyID09PSB4ICYmIDU4ID09PSBlLmNoYXJDb2RlQXQobCAtIDMpICYmIChFID0geCk7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAxMTEgPT09IEsgJiYgKEUgPSBLKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA1ODpcbiAgICAgICAgICAgICAgMCA9PT0gbiArIGIgKyBtICYmICh1ID0gbCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDQ0OlxuICAgICAgICAgICAgICAwID09PSBiICsgdiArIG4gKyBtICYmIChyID0gMSwgeSArPSAnXFxyJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgICAgMCA9PT0gYiAmJiAobiA9IG4gPT09IGcgPyAwIDogMCA9PT0gbiA/IGcgOiBuKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgOTE6XG4gICAgICAgICAgICAgIDAgPT09IG4gKyBiICsgdiAmJiBtKys7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDkzOlxuICAgICAgICAgICAgICAwID09PSBuICsgYiArIHYgJiYgbS0tO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA0MTpcbiAgICAgICAgICAgICAgMCA9PT0gbiArIGIgKyBtICYmIHYtLTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgICAgIGlmICgwID09PSBuICsgYiArIG0pIHtcbiAgICAgICAgICAgICAgICBpZiAoMCA9PT0gcSkgc3dpdGNoICgyICogeCArIDMgKiBLKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDUzMzpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHEgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2Kys7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA2NDpcbiAgICAgICAgICAgICAgMCA9PT0gYiArIHYgKyBuICsgbSArIHUgKyBrICYmIChrID0gMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDQyOlxuICAgICAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgICAgICAgaWYgKCEoMCA8IG4gKyBtICsgdikpIHN3aXRjaCAoYikge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoMiAqIGcgKyAzICogZS5jaGFyQ29kZUF0KGwgKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDIzNTpcbiAgICAgICAgICAgICAgICAgICAgICBiID0gNDc7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMjA6XG4gICAgICAgICAgICAgICAgICAgICAgdCA9IGwsIGIgPSA0MjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDQyOlxuICAgICAgICAgICAgICAgICAgNDcgPT09IGcgJiYgNDIgPT09IHggJiYgdCArIDIgIT09IGwgJiYgKDMzID09PSBlLmNoYXJDb2RlQXQodCArIDIpICYmIChwICs9IGUuc3Vic3RyaW5nKHQsIGwgKyAxKSksIHkgPSAnJywgYiA9IDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgMCA9PT0gYiAmJiAoZiArPSB5KTtcbiAgICAgIH1cblxuICAgICAgSyA9IHg7XG4gICAgICB4ID0gZztcbiAgICAgIGwrKztcbiAgICB9XG5cbiAgICB0ID0gcC5sZW5ndGg7XG5cbiAgICBpZiAoMCA8IHQpIHtcbiAgICAgIHIgPSBjO1xuICAgICAgaWYgKDAgPCBBICYmIChDID0gSCgyLCBwLCByLCBkLCBELCB6LCB0LCBoLCBhLCBoKSwgdm9pZCAwICE9PSBDICYmIDAgPT09IChwID0gQykubGVuZ3RoKSkgcmV0dXJuIEcgKyBwICsgRjtcbiAgICAgIHAgPSByLmpvaW4oJywnKSArICd7JyArIHAgKyAnfSc7XG5cbiAgICAgIGlmICgwICE9PSB3ICogRSkge1xuICAgICAgICAyICE9PSB3IHx8IEwocCwgMikgfHwgKEUgPSAwKTtcblxuICAgICAgICBzd2l0Y2ggKEUpIHtcbiAgICAgICAgICBjYXNlIDExMTpcbiAgICAgICAgICAgIHAgPSBwLnJlcGxhY2UoaGEsICc6LW1vei0kMScpICsgcDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMTI6XG4gICAgICAgICAgICBwID0gcC5yZXBsYWNlKFEsICc6Oi13ZWJraXQtaW5wdXQtJDEnKSArIHAucmVwbGFjZShRLCAnOjotbW96LSQxJykgKyBwLnJlcGxhY2UoUSwgJzotbXMtaW5wdXQtJDEnKSArIHA7XG4gICAgICAgIH1cblxuICAgICAgICBFID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gRyArIHAgKyBGO1xuICB9XG5cbiAgZnVuY3Rpb24gWChkLCBjLCBlKSB7XG4gICAgdmFyIGggPSBjLnRyaW0oKS5zcGxpdChpYSk7XG4gICAgYyA9IGg7XG4gICAgdmFyIGEgPSBoLmxlbmd0aCxcbiAgICAgICAgbSA9IGQubGVuZ3RoO1xuXG4gICAgc3dpdGNoIChtKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHZhciBiID0gMDtcblxuICAgICAgICBmb3IgKGQgPSAwID09PSBtID8gJycgOiBkWzBdICsgJyAnOyBiIDwgYTsgKytiKSB7XG4gICAgICAgICAgY1tiXSA9IFooZCwgY1tiXSwgZSkudHJpbSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciB2ID0gYiA9IDA7XG5cbiAgICAgICAgZm9yIChjID0gW107IGIgPCBhOyArK2IpIHtcbiAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IG07ICsrbikge1xuICAgICAgICAgICAgY1t2KytdID0gWihkW25dICsgJyAnLCBoW2JdLCBlKS50cmltKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gYztcbiAgfVxuXG4gIGZ1bmN0aW9uIFooZCwgYywgZSkge1xuICAgIHZhciBoID0gYy5jaGFyQ29kZUF0KDApO1xuICAgIDMzID4gaCAmJiAoaCA9IChjID0gYy50cmltKCkpLmNoYXJDb2RlQXQoMCkpO1xuXG4gICAgc3dpdGNoIChoKSB7XG4gICAgICBjYXNlIDM4OlxuICAgICAgICByZXR1cm4gYy5yZXBsYWNlKEYsICckMScgKyBkLnRyaW0oKSk7XG5cbiAgICAgIGNhc2UgNTg6XG4gICAgICAgIHJldHVybiBkLnRyaW0oKSArIGMucmVwbGFjZShGLCAnJDEnICsgZC50cmltKCkpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoMCA8IDEgKiBlICYmIDAgPCBjLmluZGV4T2YoJ1xcZicpKSByZXR1cm4gYy5yZXBsYWNlKEYsICg1OCA9PT0gZC5jaGFyQ29kZUF0KDApID8gJycgOiAnJDEnKSArIGQudHJpbSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZCArIGM7XG4gIH1cblxuICBmdW5jdGlvbiBQKGQsIGMsIGUsIGgpIHtcbiAgICB2YXIgYSA9IGQgKyAnOycsXG4gICAgICAgIG0gPSAyICogYyArIDMgKiBlICsgNCAqIGg7XG5cbiAgICBpZiAoOTQ0ID09PSBtKSB7XG4gICAgICBkID0gYS5pbmRleE9mKCc6JywgOSkgKyAxO1xuICAgICAgdmFyIGIgPSBhLnN1YnN0cmluZyhkLCBhLmxlbmd0aCAtIDEpLnRyaW0oKTtcbiAgICAgIGIgPSBhLnN1YnN0cmluZygwLCBkKS50cmltKCkgKyBiICsgJzsnO1xuICAgICAgcmV0dXJuIDEgPT09IHcgfHwgMiA9PT0gdyAmJiBMKGIsIDEpID8gJy13ZWJraXQtJyArIGIgKyBiIDogYjtcbiAgICB9XG5cbiAgICBpZiAoMCA9PT0gdyB8fCAyID09PSB3ICYmICFMKGEsIDEpKSByZXR1cm4gYTtcblxuICAgIHN3aXRjaCAobSkge1xuICAgICAgY2FzZSAxMDE1OlxuICAgICAgICByZXR1cm4gOTcgPT09IGEuY2hhckNvZGVBdCgxMCkgPyAnLXdlYmtpdC0nICsgYSArIGEgOiBhO1xuXG4gICAgICBjYXNlIDk1MTpcbiAgICAgICAgcmV0dXJuIDExNiA9PT0gYS5jaGFyQ29kZUF0KDMpID8gJy13ZWJraXQtJyArIGEgKyBhIDogYTtcblxuICAgICAgY2FzZSA5NjM6XG4gICAgICAgIHJldHVybiAxMTAgPT09IGEuY2hhckNvZGVBdCg1KSA/ICctd2Via2l0LScgKyBhICsgYSA6IGE7XG5cbiAgICAgIGNhc2UgMTAwOTpcbiAgICAgICAgaWYgKDEwMCAhPT0gYS5jaGFyQ29kZUF0KDQpKSBicmVhaztcblxuICAgICAgY2FzZSA5Njk6XG4gICAgICBjYXNlIDk0MjpcbiAgICAgICAgcmV0dXJuICctd2Via2l0LScgKyBhICsgYTtcblxuICAgICAgY2FzZSA5Nzg6XG4gICAgICAgIHJldHVybiAnLXdlYmtpdC0nICsgYSArICctbW96LScgKyBhICsgYTtcblxuICAgICAgY2FzZSAxMDE5OlxuICAgICAgY2FzZSA5ODM6XG4gICAgICAgIHJldHVybiAnLXdlYmtpdC0nICsgYSArICctbW96LScgKyBhICsgJy1tcy0nICsgYSArIGE7XG5cbiAgICAgIGNhc2UgODgzOlxuICAgICAgICBpZiAoNDUgPT09IGEuY2hhckNvZGVBdCg4KSkgcmV0dXJuICctd2Via2l0LScgKyBhICsgYTtcbiAgICAgICAgaWYgKDAgPCBhLmluZGV4T2YoJ2ltYWdlLXNldCgnLCAxMSkpIHJldHVybiBhLnJlcGxhY2UoamEsICckMS13ZWJraXQtJDInKSArIGE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDkzMjpcbiAgICAgICAgaWYgKDQ1ID09PSBhLmNoYXJDb2RlQXQoNCkpIHN3aXRjaCAoYS5jaGFyQ29kZUF0KDUpKSB7XG4gICAgICAgICAgY2FzZSAxMDM6XG4gICAgICAgICAgICByZXR1cm4gJy13ZWJraXQtYm94LScgKyBhLnJlcGxhY2UoJy1ncm93JywgJycpICsgJy13ZWJraXQtJyArIGEgKyAnLW1zLScgKyBhLnJlcGxhY2UoJ2dyb3cnLCAncG9zaXRpdmUnKSArIGE7XG5cbiAgICAgICAgICBjYXNlIDExNTpcbiAgICAgICAgICAgIHJldHVybiAnLXdlYmtpdC0nICsgYSArICctbXMtJyArIGEucmVwbGFjZSgnc2hyaW5rJywgJ25lZ2F0aXZlJykgKyBhO1xuXG4gICAgICAgICAgY2FzZSA5ODpcbiAgICAgICAgICAgIHJldHVybiAnLXdlYmtpdC0nICsgYSArICctbXMtJyArIGEucmVwbGFjZSgnYmFzaXMnLCAncHJlZmVycmVkLXNpemUnKSArIGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICctd2Via2l0LScgKyBhICsgJy1tcy0nICsgYSArIGE7XG5cbiAgICAgIGNhc2UgOTY0OlxuICAgICAgICByZXR1cm4gJy13ZWJraXQtJyArIGEgKyAnLW1zLWZsZXgtJyArIGEgKyBhO1xuXG4gICAgICBjYXNlIDEwMjM6XG4gICAgICAgIGlmICg5OSAhPT0gYS5jaGFyQ29kZUF0KDgpKSBicmVhaztcbiAgICAgICAgYiA9IGEuc3Vic3RyaW5nKGEuaW5kZXhPZignOicsIDE1KSkucmVwbGFjZSgnZmxleC0nLCAnJykucmVwbGFjZSgnc3BhY2UtYmV0d2VlbicsICdqdXN0aWZ5Jyk7XG4gICAgICAgIHJldHVybiAnLXdlYmtpdC1ib3gtcGFjaycgKyBiICsgJy13ZWJraXQtJyArIGEgKyAnLW1zLWZsZXgtcGFjaycgKyBiICsgYTtcblxuICAgICAgY2FzZSAxMDA1OlxuICAgICAgICByZXR1cm4ga2EudGVzdChhKSA/IGEucmVwbGFjZShhYSwgJzotd2Via2l0LScpICsgYS5yZXBsYWNlKGFhLCAnOi1tb3otJykgKyBhIDogYTtcblxuICAgICAgY2FzZSAxZTM6XG4gICAgICAgIGIgPSBhLnN1YnN0cmluZygxMykudHJpbSgpO1xuICAgICAgICBjID0gYi5pbmRleE9mKCctJykgKyAxO1xuXG4gICAgICAgIHN3aXRjaCAoYi5jaGFyQ29kZUF0KDApICsgYi5jaGFyQ29kZUF0KGMpKSB7XG4gICAgICAgICAgY2FzZSAyMjY6XG4gICAgICAgICAgICBiID0gYS5yZXBsYWNlKEcsICd0YicpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDIzMjpcbiAgICAgICAgICAgIGIgPSBhLnJlcGxhY2UoRywgJ3RiLXJsJyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjIwOlxuICAgICAgICAgICAgYiA9IGEucmVwbGFjZShHLCAnbHInKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICctd2Via2l0LScgKyBhICsgJy1tcy0nICsgYiArIGE7XG5cbiAgICAgIGNhc2UgMTAxNzpcbiAgICAgICAgaWYgKC0xID09PSBhLmluZGV4T2YoJ3N0aWNreScsIDkpKSBicmVhaztcblxuICAgICAgY2FzZSA5NzU6XG4gICAgICAgIGMgPSAoYSA9IGQpLmxlbmd0aCAtIDEwO1xuICAgICAgICBiID0gKDMzID09PSBhLmNoYXJDb2RlQXQoYykgPyBhLnN1YnN0cmluZygwLCBjKSA6IGEpLnN1YnN0cmluZyhkLmluZGV4T2YoJzonLCA3KSArIDEpLnRyaW0oKTtcblxuICAgICAgICBzd2l0Y2ggKG0gPSBiLmNoYXJDb2RlQXQoMCkgKyAoYi5jaGFyQ29kZUF0KDcpIHwgMCkpIHtcbiAgICAgICAgICBjYXNlIDIwMzpcbiAgICAgICAgICAgIGlmICgxMTEgPiBiLmNoYXJDb2RlQXQoOCkpIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMTU6XG4gICAgICAgICAgICBhID0gYS5yZXBsYWNlKGIsICctd2Via2l0LScgKyBiKSArICc7JyArIGE7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjA3OlxuICAgICAgICAgIGNhc2UgMTAyOlxuICAgICAgICAgICAgYSA9IGEucmVwbGFjZShiLCAnLXdlYmtpdC0nICsgKDEwMiA8IG0gPyAnaW5saW5lLScgOiAnJykgKyAnYm94JykgKyAnOycgKyBhLnJlcGxhY2UoYiwgJy13ZWJraXQtJyArIGIpICsgJzsnICsgYS5yZXBsYWNlKGIsICctbXMtJyArIGIgKyAnYm94JykgKyAnOycgKyBhO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGEgKyAnOyc7XG5cbiAgICAgIGNhc2UgOTM4OlxuICAgICAgICBpZiAoNDUgPT09IGEuY2hhckNvZGVBdCg1KSkgc3dpdGNoIChhLmNoYXJDb2RlQXQoNikpIHtcbiAgICAgICAgICBjYXNlIDEwNTpcbiAgICAgICAgICAgIHJldHVybiBiID0gYS5yZXBsYWNlKCctaXRlbXMnLCAnJyksICctd2Via2l0LScgKyBhICsgJy13ZWJraXQtYm94LScgKyBiICsgJy1tcy1mbGV4LScgKyBiICsgYTtcblxuICAgICAgICAgIGNhc2UgMTE1OlxuICAgICAgICAgICAgcmV0dXJuICctd2Via2l0LScgKyBhICsgJy1tcy1mbGV4LWl0ZW0tJyArIGEucmVwbGFjZShiYSwgJycpICsgYTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gJy13ZWJraXQtJyArIGEgKyAnLW1zLWZsZXgtbGluZS1wYWNrJyArIGEucmVwbGFjZSgnYWxpZ24tY29udGVudCcsICcnKS5yZXBsYWNlKGJhLCAnJykgKyBhO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDk3MzpcbiAgICAgIGNhc2UgOTg5OlxuICAgICAgICBpZiAoNDUgIT09IGEuY2hhckNvZGVBdCgzKSB8fCAxMjIgPT09IGEuY2hhckNvZGVBdCg0KSkgYnJlYWs7XG5cbiAgICAgIGNhc2UgOTMxOlxuICAgICAgY2FzZSA5NTM6XG4gICAgICAgIGlmICghMCA9PT0gbGEudGVzdChkKSkgcmV0dXJuIDExNSA9PT0gKGIgPSBkLnN1YnN0cmluZyhkLmluZGV4T2YoJzonKSArIDEpKS5jaGFyQ29kZUF0KDApID8gUChkLnJlcGxhY2UoJ3N0cmV0Y2gnLCAnZmlsbC1hdmFpbGFibGUnKSwgYywgZSwgaCkucmVwbGFjZSgnOmZpbGwtYXZhaWxhYmxlJywgJzpzdHJldGNoJykgOiBhLnJlcGxhY2UoYiwgJy13ZWJraXQtJyArIGIpICsgYS5yZXBsYWNlKGIsICctbW96LScgKyBiLnJlcGxhY2UoJ2ZpbGwtJywgJycpKSArIGE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDk2MjpcbiAgICAgICAgaWYgKGEgPSAnLXdlYmtpdC0nICsgYSArICgxMDIgPT09IGEuY2hhckNvZGVBdCg1KSA/ICctbXMtJyArIGEgOiAnJykgKyBhLCAyMTEgPT09IGUgKyBoICYmIDEwNSA9PT0gYS5jaGFyQ29kZUF0KDEzKSAmJiAwIDwgYS5pbmRleE9mKCd0cmFuc2Zvcm0nLCAxMCkpIHJldHVybiBhLnN1YnN0cmluZygwLCBhLmluZGV4T2YoJzsnLCAyNykgKyAxKS5yZXBsYWNlKG1hLCAnJDEtd2Via2l0LSQyJykgKyBhO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9XG5cbiAgZnVuY3Rpb24gTChkLCBjKSB7XG4gICAgdmFyIGUgPSBkLmluZGV4T2YoMSA9PT0gYyA/ICc6JyA6ICd7JyksXG4gICAgICAgIGggPSBkLnN1YnN0cmluZygwLCAzICE9PSBjID8gZSA6IDEwKTtcbiAgICBlID0gZC5zdWJzdHJpbmcoZSArIDEsIGQubGVuZ3RoIC0gMSk7XG4gICAgcmV0dXJuIFIoMiAhPT0gYyA/IGggOiBoLnJlcGxhY2UobmEsICckMScpLCBlLCBjKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVhKGQsIGMpIHtcbiAgICB2YXIgZSA9IFAoYywgYy5jaGFyQ29kZUF0KDApLCBjLmNoYXJDb2RlQXQoMSksIGMuY2hhckNvZGVBdCgyKSk7XG4gICAgcmV0dXJuIGUgIT09IGMgKyAnOycgPyBlLnJlcGxhY2Uob2EsICcgb3IgKCQxKScpLnN1YnN0cmluZyg0KSA6ICcoJyArIGMgKyAnKSc7XG4gIH1cblxuICBmdW5jdGlvbiBIKGQsIGMsIGUsIGgsIGEsIG0sIGIsIHYsIG4sIHEpIHtcbiAgICBmb3IgKHZhciBnID0gMCwgeCA9IGMsIHc7IGcgPCBBOyArK2cpIHtcbiAgICAgIHN3aXRjaCAodyA9IFNbZ10uY2FsbChCLCBkLCB4LCBlLCBoLCBhLCBtLCBiLCB2LCBuLCBxKSkge1xuICAgICAgICBjYXNlIHZvaWQgMDpcbiAgICAgICAgY2FzZSAhMTpcbiAgICAgICAgY2FzZSAhMDpcbiAgICAgICAgY2FzZSBudWxsOlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgeCA9IHc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHggIT09IGMpIHJldHVybiB4O1xuICB9XG5cbiAgZnVuY3Rpb24gVChkKSB7XG4gICAgc3dpdGNoIChkKSB7XG4gICAgICBjYXNlIHZvaWQgMDpcbiAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgQSA9IFMubGVuZ3RoID0gMDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZCkgU1tBKytdID0gZDtlbHNlIGlmICgnb2JqZWN0JyA9PT0gdHlwZW9mIGQpIGZvciAodmFyIGMgPSAwLCBlID0gZC5sZW5ndGg7IGMgPCBlOyArK2MpIHtcbiAgICAgICAgICBUKGRbY10pO1xuICAgICAgICB9IGVsc2UgWSA9ICEhZCB8IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIFQ7XG4gIH1cblxuICBmdW5jdGlvbiBVKGQpIHtcbiAgICBkID0gZC5wcmVmaXg7XG4gICAgdm9pZCAwICE9PSBkICYmIChSID0gbnVsbCwgZCA/ICdmdW5jdGlvbicgIT09IHR5cGVvZiBkID8gdyA9IDEgOiAodyA9IDIsIFIgPSBkKSA6IHcgPSAwKTtcbiAgICByZXR1cm4gVTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEIoZCwgYykge1xuICAgIHZhciBlID0gZDtcbiAgICAzMyA+IGUuY2hhckNvZGVBdCgwKSAmJiAoZSA9IGUudHJpbSgpKTtcbiAgICBWID0gZTtcbiAgICBlID0gW1ZdO1xuXG4gICAgaWYgKDAgPCBBKSB7XG4gICAgICB2YXIgaCA9IEgoLTEsIGMsIGUsIGUsIEQsIHosIDAsIDAsIDAsIDApO1xuICAgICAgdm9pZCAwICE9PSBoICYmICdzdHJpbmcnID09PSB0eXBlb2YgaCAmJiAoYyA9IGgpO1xuICAgIH1cblxuICAgIHZhciBhID0gTShPLCBlLCBjLCAwLCAwKTtcbiAgICAwIDwgQSAmJiAoaCA9IEgoLTIsIGEsIGUsIGUsIEQsIHosIGEubGVuZ3RoLCAwLCAwLCAwKSwgdm9pZCAwICE9PSBoICYmIChhID0gaCkpO1xuICAgIFYgPSAnJztcbiAgICBFID0gMDtcbiAgICB6ID0gRCA9IDE7XG4gICAgcmV0dXJuIGE7XG4gIH1cblxuICB2YXIgY2EgPSAvXlxcMCsvZyxcbiAgICAgIE4gPSAvW1xcMFxcclxcZl0vZyxcbiAgICAgIGFhID0gLzogKi9nLFxuICAgICAga2EgPSAvem9vfGdyYS8sXG4gICAgICBtYSA9IC8oWyw6IF0pKHRyYW5zZm9ybSkvZyxcbiAgICAgIGlhID0gLyxcXHIrPy9nLFxuICAgICAgRiA9IC8oW1xcdFxcclxcbiBdKSpcXGY/Ji9nLFxuICAgICAgZmEgPSAvQChrXFx3KylcXHMqKFxcUyopXFxzKi8sXG4gICAgICBRID0gLzo6KHBsYWNlKS9nLFxuICAgICAgaGEgPSAvOihyZWFkLW9ubHkpL2csXG4gICAgICBHID0gL1tzdmhdXFx3Ky1bdGJscl17Mn0vLFxuICAgICAgZGEgPSAvXFwoXFxzKiguKilcXHMqXFwpL2csXG4gICAgICBvYSA9IC8oW1xcc1xcU10qPyk7L2csXG4gICAgICBiYSA9IC8tc2VsZnxmbGV4LS9nLFxuICAgICAgbmEgPSAvW15dKj8oOltycF1bZWxdYVtcXHctXSspW15dKi8sXG4gICAgICBsYSA9IC9zdHJldGNofDpcXHMqXFx3K1xcLSg/OmNvbnRlfGF2YWlsKS8sXG4gICAgICBqYSA9IC8oW14tXSkoaW1hZ2Utc2V0XFwoKS8sXG4gICAgICB6ID0gMSxcbiAgICAgIEQgPSAxLFxuICAgICAgRSA9IDAsXG4gICAgICB3ID0gMSxcbiAgICAgIE8gPSBbXSxcbiAgICAgIFMgPSBbXSxcbiAgICAgIEEgPSAwLFxuICAgICAgUiA9IG51bGwsXG4gICAgICBZID0gMCxcbiAgICAgIFYgPSAnJztcbiAgQi51c2UgPSBUO1xuICBCLnNldCA9IFU7XG4gIHZvaWQgMCAhPT0gVyAmJiBVKFcpO1xuICByZXR1cm4gQjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3R5bGlzX21pbjtcbiIsInZhciB1bml0bGVzc0tleXMgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiAxLFxuICBib3JkZXJJbWFnZU91dHNldDogMSxcbiAgYm9yZGVySW1hZ2VTbGljZTogMSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogMSxcbiAgYm94RmxleDogMSxcbiAgYm94RmxleEdyb3VwOiAxLFxuICBib3hPcmRpbmFsR3JvdXA6IDEsXG4gIGNvbHVtbkNvdW50OiAxLFxuICBjb2x1bW5zOiAxLFxuICBmbGV4OiAxLFxuICBmbGV4R3JvdzogMSxcbiAgZmxleFBvc2l0aXZlOiAxLFxuICBmbGV4U2hyaW5rOiAxLFxuICBmbGV4TmVnYXRpdmU6IDEsXG4gIGZsZXhPcmRlcjogMSxcbiAgZ3JpZFJvdzogMSxcbiAgZ3JpZFJvd0VuZDogMSxcbiAgZ3JpZFJvd1NwYW46IDEsXG4gIGdyaWRSb3dTdGFydDogMSxcbiAgZ3JpZENvbHVtbjogMSxcbiAgZ3JpZENvbHVtbkVuZDogMSxcbiAgZ3JpZENvbHVtblNwYW46IDEsXG4gIGdyaWRDb2x1bW5TdGFydDogMSxcbiAgbXNHcmlkUm93OiAxLFxuICBtc0dyaWRSb3dTcGFuOiAxLFxuICBtc0dyaWRDb2x1bW46IDEsXG4gIG1zR3JpZENvbHVtblNwYW46IDEsXG4gIGZvbnRXZWlnaHQ6IDEsXG4gIGxpbmVIZWlnaHQ6IDEsXG4gIG9wYWNpdHk6IDEsXG4gIG9yZGVyOiAxLFxuICBvcnBoYW5zOiAxLFxuICB0YWJTaXplOiAxLFxuICB3aWRvd3M6IDEsXG4gIHpJbmRleDogMSxcbiAgem9vbTogMSxcbiAgV2Via2l0TGluZUNsYW1wOiAxLFxuICAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gIGZpbGxPcGFjaXR5OiAxLFxuICBmbG9vZE9wYWNpdHk6IDEsXG4gIHN0b3BPcGFjaXR5OiAxLFxuICBzdHJva2VEYXNoYXJyYXk6IDEsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IDEsXG4gIHN0cm9rZU1pdGVybGltaXQ6IDEsXG4gIHN0cm9rZU9wYWNpdHk6IDEsXG4gIHN0cm9rZVdpZHRoOiAxXG59O1xuXG5leHBvcnQgZGVmYXVsdCB1bml0bGVzc0tleXM7XG4iLCJmdW5jdGlvbiBtZW1vaXplKGZuKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgaWYgKGNhY2hlW2FyZ10gPT09IHVuZGVmaW5lZCkgY2FjaGVbYXJnXSA9IGZuKGFyZyk7XG4gICAgcmV0dXJuIGNhY2hlW2FyZ107XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1lbW9pemU7XG4iLCJpbXBvcnQgbWVtb2l6ZSBmcm9tICdAZW1vdGlvbi9tZW1vaXplJztcblxudmFyIHJlYWN0UHJvcHNSZWdleCA9IC9eKChjaGlsZHJlbnxkYW5nZXJvdXNseVNldElubmVySFRNTHxrZXl8cmVmfGF1dG9Gb2N1c3xkZWZhdWx0VmFsdWV8ZGVmYXVsdENoZWNrZWR8aW5uZXJIVE1MfHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ3xzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmd8dmFsdWVMaW5rfGFiYnJ8YWNjZXB0fGFjY2VwdENoYXJzZXR8YWNjZXNzS2V5fGFjdGlvbnxhbGxvd3xhbGxvd1VzZXJNZWRpYXxhbGxvd1BheW1lbnRSZXF1ZXN0fGFsbG93RnVsbFNjcmVlbnxhbGxvd1RyYW5zcGFyZW5jeXxhbHR8YXN5bmN8YXV0b0NvbXBsZXRlfGF1dG9QbGF5fGNhcHR1cmV8Y2VsbFBhZGRpbmd8Y2VsbFNwYWNpbmd8Y2hhbGxlbmdlfGNoYXJTZXR8Y2hlY2tlZHxjaXRlfGNsYXNzSUR8Y2xhc3NOYW1lfGNvbHN8Y29sU3Bhbnxjb250ZW50fGNvbnRlbnRFZGl0YWJsZXxjb250ZXh0TWVudXxjb250cm9sc3xjb250cm9sc0xpc3R8Y29vcmRzfGNyb3NzT3JpZ2lufGRhdGF8ZGF0ZVRpbWV8ZGVjb2Rpbmd8ZGVmYXVsdHxkZWZlcnxkaXJ8ZGlzYWJsZWR8ZGlzYWJsZVBpY3R1cmVJblBpY3R1cmV8ZG93bmxvYWR8ZHJhZ2dhYmxlfGVuY1R5cGV8ZW50ZXJLZXlIaW50fGZvcm18Zm9ybUFjdGlvbnxmb3JtRW5jVHlwZXxmb3JtTWV0aG9kfGZvcm1Ob1ZhbGlkYXRlfGZvcm1UYXJnZXR8ZnJhbWVCb3JkZXJ8aGVhZGVyc3xoZWlnaHR8aGlkZGVufGhpZ2h8aHJlZnxocmVmTGFuZ3xodG1sRm9yfGh0dHBFcXVpdnxpZHxpbnB1dE1vZGV8aW50ZWdyaXR5fGlzfGtleVBhcmFtc3xrZXlUeXBlfGtpbmR8bGFiZWx8bGFuZ3xsaXN0fGxvYWRpbmd8bG9vcHxsb3d8bWFyZ2luSGVpZ2h0fG1hcmdpbldpZHRofG1heHxtYXhMZW5ndGh8bWVkaWF8bWVkaWFHcm91cHxtZXRob2R8bWlufG1pbkxlbmd0aHxtdWx0aXBsZXxtdXRlZHxuYW1lfG5vbmNlfG5vVmFsaWRhdGV8b3BlbnxvcHRpbXVtfHBhdHRlcm58cGxhY2Vob2xkZXJ8cGxheXNJbmxpbmV8cG9zdGVyfHByZWxvYWR8cHJvZmlsZXxyYWRpb0dyb3VwfHJlYWRPbmx5fHJlZmVycmVyUG9saWN5fHJlbHxyZXF1aXJlZHxyZXZlcnNlZHxyb2xlfHJvd3N8cm93U3BhbnxzYW5kYm94fHNjb3BlfHNjb3BlZHxzY3JvbGxpbmd8c2VhbWxlc3N8c2VsZWN0ZWR8c2hhcGV8c2l6ZXxzaXplc3xzbG90fHNwYW58c3BlbGxDaGVja3xzcmN8c3JjRG9jfHNyY0xhbmd8c3JjU2V0fHN0YXJ0fHN0ZXB8c3R5bGV8c3VtbWFyeXx0YWJJbmRleHx0YXJnZXR8dGl0bGV8dHJhbnNsYXRlfHR5cGV8dXNlTWFwfHZhbHVlfHdpZHRofHdtb2RlfHdyYXB8YWJvdXR8ZGF0YXR5cGV8aW5saXN0fHByZWZpeHxwcm9wZXJ0eXxyZXNvdXJjZXx0eXBlb2Z8dm9jYWJ8YXV0b0NhcGl0YWxpemV8YXV0b0NvcnJlY3R8YXV0b1NhdmV8Y29sb3J8aW5jcmVtZW50YWx8ZmFsbGJhY2t8aW5lcnR8aXRlbVByb3B8aXRlbVNjb3BlfGl0ZW1UeXBlfGl0ZW1JRHxpdGVtUmVmfG9ufG9wdGlvbnxyZXN1bHRzfHNlY3VyaXR5fHVuc2VsZWN0YWJsZXxhY2NlbnRIZWlnaHR8YWNjdW11bGF0ZXxhZGRpdGl2ZXxhbGlnbm1lbnRCYXNlbGluZXxhbGxvd1Jlb3JkZXJ8YWxwaGFiZXRpY3xhbXBsaXR1ZGV8YXJhYmljRm9ybXxhc2NlbnR8YXR0cmlidXRlTmFtZXxhdHRyaWJ1dGVUeXBlfGF1dG9SZXZlcnNlfGF6aW11dGh8YmFzZUZyZXF1ZW5jeXxiYXNlbGluZVNoaWZ0fGJhc2VQcm9maWxlfGJib3h8YmVnaW58Ymlhc3xieXxjYWxjTW9kZXxjYXBIZWlnaHR8Y2xpcHxjbGlwUGF0aFVuaXRzfGNsaXBQYXRofGNsaXBSdWxlfGNvbG9ySW50ZXJwb2xhdGlvbnxjb2xvckludGVycG9sYXRpb25GaWx0ZXJzfGNvbG9yUHJvZmlsZXxjb2xvclJlbmRlcmluZ3xjb250ZW50U2NyaXB0VHlwZXxjb250ZW50U3R5bGVUeXBlfGN1cnNvcnxjeHxjeXxkfGRlY2VsZXJhdGV8ZGVzY2VudHxkaWZmdXNlQ29uc3RhbnR8ZGlyZWN0aW9ufGRpc3BsYXl8ZGl2aXNvcnxkb21pbmFudEJhc2VsaW5lfGR1cnxkeHxkeXxlZGdlTW9kZXxlbGV2YXRpb258ZW5hYmxlQmFja2dyb3VuZHxlbmR8ZXhwb25lbnR8ZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZHxmaWxsfGZpbGxPcGFjaXR5fGZpbGxSdWxlfGZpbHRlcnxmaWx0ZXJSZXN8ZmlsdGVyVW5pdHN8Zmxvb2RDb2xvcnxmbG9vZE9wYWNpdHl8Zm9jdXNhYmxlfGZvbnRGYW1pbHl8Zm9udFNpemV8Zm9udFNpemVBZGp1c3R8Zm9udFN0cmV0Y2h8Zm9udFN0eWxlfGZvbnRWYXJpYW50fGZvbnRXZWlnaHR8Zm9ybWF0fGZyb218ZnJ8Znh8Znl8ZzF8ZzJ8Z2x5cGhOYW1lfGdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsfGdseXBoT3JpZW50YXRpb25WZXJ0aWNhbHxnbHlwaFJlZnxncmFkaWVudFRyYW5zZm9ybXxncmFkaWVudFVuaXRzfGhhbmdpbmd8aG9yaXpBZHZYfGhvcml6T3JpZ2luWHxpZGVvZ3JhcGhpY3xpbWFnZVJlbmRlcmluZ3xpbnxpbjJ8aW50ZXJjZXB0fGt8azF8azJ8azN8azR8a2VybmVsTWF0cml4fGtlcm5lbFVuaXRMZW5ndGh8a2VybmluZ3xrZXlQb2ludHN8a2V5U3BsaW5lc3xrZXlUaW1lc3xsZW5ndGhBZGp1c3R8bGV0dGVyU3BhY2luZ3xsaWdodGluZ0NvbG9yfGxpbWl0aW5nQ29uZUFuZ2xlfGxvY2FsfG1hcmtlckVuZHxtYXJrZXJNaWR8bWFya2VyU3RhcnR8bWFya2VySGVpZ2h0fG1hcmtlclVuaXRzfG1hcmtlcldpZHRofG1hc2t8bWFza0NvbnRlbnRVbml0c3xtYXNrVW5pdHN8bWF0aGVtYXRpY2FsfG1vZGV8bnVtT2N0YXZlc3xvZmZzZXR8b3BhY2l0eXxvcGVyYXRvcnxvcmRlcnxvcmllbnR8b3JpZW50YXRpb258b3JpZ2lufG92ZXJmbG93fG92ZXJsaW5lUG9zaXRpb258b3ZlcmxpbmVUaGlja25lc3N8cGFub3NlMXxwYWludE9yZGVyfHBhdGhMZW5ndGh8cGF0dGVybkNvbnRlbnRVbml0c3xwYXR0ZXJuVHJhbnNmb3JtfHBhdHRlcm5Vbml0c3xwb2ludGVyRXZlbnRzfHBvaW50c3xwb2ludHNBdFh8cG9pbnRzQXRZfHBvaW50c0F0WnxwcmVzZXJ2ZUFscGhhfHByZXNlcnZlQXNwZWN0UmF0aW98cHJpbWl0aXZlVW5pdHN8cnxyYWRpdXN8cmVmWHxyZWZZfHJlbmRlcmluZ0ludGVudHxyZXBlYXRDb3VudHxyZXBlYXREdXJ8cmVxdWlyZWRFeHRlbnNpb25zfHJlcXVpcmVkRmVhdHVyZXN8cmVzdGFydHxyZXN1bHR8cm90YXRlfHJ4fHJ5fHNjYWxlfHNlZWR8c2hhcGVSZW5kZXJpbmd8c2xvcGV8c3BhY2luZ3xzcGVjdWxhckNvbnN0YW50fHNwZWN1bGFyRXhwb25lbnR8c3BlZWR8c3ByZWFkTWV0aG9kfHN0YXJ0T2Zmc2V0fHN0ZERldmlhdGlvbnxzdGVtaHxzdGVtdnxzdGl0Y2hUaWxlc3xzdG9wQ29sb3J8c3RvcE9wYWNpdHl8c3RyaWtldGhyb3VnaFBvc2l0aW9ufHN0cmlrZXRocm91Z2hUaGlja25lc3N8c3RyaW5nfHN0cm9rZXxzdHJva2VEYXNoYXJyYXl8c3Ryb2tlRGFzaG9mZnNldHxzdHJva2VMaW5lY2FwfHN0cm9rZUxpbmVqb2lufHN0cm9rZU1pdGVybGltaXR8c3Ryb2tlT3BhY2l0eXxzdHJva2VXaWR0aHxzdXJmYWNlU2NhbGV8c3lzdGVtTGFuZ3VhZ2V8dGFibGVWYWx1ZXN8dGFyZ2V0WHx0YXJnZXRZfHRleHRBbmNob3J8dGV4dERlY29yYXRpb258dGV4dFJlbmRlcmluZ3x0ZXh0TGVuZ3RofHRvfHRyYW5zZm9ybXx1MXx1Mnx1bmRlcmxpbmVQb3NpdGlvbnx1bmRlcmxpbmVUaGlja25lc3N8dW5pY29kZXx1bmljb2RlQmlkaXx1bmljb2RlUmFuZ2V8dW5pdHNQZXJFbXx2QWxwaGFiZXRpY3x2SGFuZ2luZ3x2SWRlb2dyYXBoaWN8dk1hdGhlbWF0aWNhbHx2YWx1ZXN8dmVjdG9yRWZmZWN0fHZlcnNpb258dmVydEFkdll8dmVydE9yaWdpblh8dmVydE9yaWdpbll8dmlld0JveHx2aWV3VGFyZ2V0fHZpc2liaWxpdHl8d2lkdGhzfHdvcmRTcGFjaW5nfHdyaXRpbmdNb2RlfHh8eEhlaWdodHx4MXx4Mnx4Q2hhbm5lbFNlbGVjdG9yfHhsaW5rQWN0dWF0ZXx4bGlua0FyY3JvbGV8eGxpbmtIcmVmfHhsaW5rUm9sZXx4bGlua1Nob3d8eGxpbmtUaXRsZXx4bGlua1R5cGV8eG1sQmFzZXx4bWxuc3x4bWxuc1hsaW5rfHhtbExhbmd8eG1sU3BhY2V8eXx5MXx5Mnx5Q2hhbm5lbFNlbGVjdG9yfHp8em9vbUFuZFBhbnxmb3J8Y2xhc3N8YXV0b2ZvY3VzKXwoKFtEZF1bQWFdW1R0XVtBYV18W0FhXVtScl1bSWldW0FhXXx4KS0uKikpJC87IC8vIGh0dHBzOi8vZXNiZW5jaC5jb20vYmVuY2gvNWJmZWU2OGE0Y2Q3ZTYwMDllZjYxZDIzXG5cbnZhciBpc1Byb3BWYWxpZCA9IC8qICNfX1BVUkVfXyAqL21lbW9pemUoZnVuY3Rpb24gKHByb3ApIHtcbiAgcmV0dXJuIHJlYWN0UHJvcHNSZWdleC50ZXN0KHByb3ApIHx8IHByb3AuY2hhckNvZGVBdCgwKSA9PT0gMTExXG4gIC8qIG8gKi9cbiAgJiYgcHJvcC5jaGFyQ29kZUF0KDEpID09PSAxMTBcbiAgLyogbiAqL1xuICAmJiBwcm9wLmNoYXJDb2RlQXQoMikgPCA5MTtcbn1cbi8qIForMSAqL1xuKTtcblxuZXhwb3J0IGRlZmF1bHQgaXNQcm9wVmFsaWQ7XG4iLCJpbXBvcnR7dHlwZU9mIGFzIGUsaXNFbGVtZW50IGFzIHQsaXNWYWxpZEVsZW1lbnRUeXBlIGFzIG59ZnJvbVwicmVhY3QtaXNcIjtpbXBvcnQgcix7dXNlU3RhdGUgYXMgbyx1c2VDb250ZXh0IGFzIHMsdXNlTWVtbyBhcyBpLHVzZUVmZmVjdCBhcyBhLHVzZVJlZiBhcyBjLGNyZWF0ZUVsZW1lbnQgYXMgdSx1c2VEZWJ1Z1ZhbHVlIGFzIGwsdXNlTGF5b3V0RWZmZWN0IGFzIGR9ZnJvbVwicmVhY3RcIjtpbXBvcnQgaCBmcm9tXCJzaGFsbG93ZXF1YWxcIjtpbXBvcnQgcCBmcm9tXCJAZW1vdGlvbi9zdHlsaXNcIjtpbXBvcnQgZiBmcm9tXCJAZW1vdGlvbi91bml0bGVzc1wiO2ltcG9ydCBtIGZyb21cIkBlbW90aW9uL2lzLXByb3AtdmFsaWRcIjtpbXBvcnQgeSBmcm9tXCJob2lzdC1ub24tcmVhY3Qtc3RhdGljc1wiO2Z1bmN0aW9uIHYoKXtyZXR1cm4odj1PYmplY3QuYXNzaWdufHxmdW5jdGlvbihlKXtmb3IodmFyIHQ9MTt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXt2YXIgbj1hcmd1bWVudHNbdF07Zm9yKHZhciByIGluIG4pT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4scikmJihlW3JdPW5bcl0pfXJldHVybiBlfSkuYXBwbHkodGhpcyxhcmd1bWVudHMpfXZhciBnPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPVtlWzBdXSxyPTAsbz10Lmxlbmd0aDtyPG87cis9MSluLnB1c2godFtyXSxlW3IrMV0pO3JldHVybiBufSxTPWZ1bmN0aW9uKHQpe3JldHVybiBudWxsIT09dCYmXCJvYmplY3RcIj09dHlwZW9mIHQmJlwiW29iamVjdCBPYmplY3RdXCI9PT0odC50b1N0cmluZz90LnRvU3RyaW5nKCk6T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpKSYmIWUodCl9LHc9T2JqZWN0LmZyZWV6ZShbXSksRT1PYmplY3QuZnJlZXplKHt9KTtmdW5jdGlvbiBiKGUpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGV9ZnVuY3Rpb24gXyhlKXtyZXR1cm5cInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZcInN0cmluZ1wiPT10eXBlb2YgZSYmZXx8ZS5kaXNwbGF5TmFtZXx8ZS5uYW1lfHxcIkNvbXBvbmVudFwifWZ1bmN0aW9uIE4oZSl7cmV0dXJuIGUmJlwic3RyaW5nXCI9PXR5cGVvZiBlLnN0eWxlZENvbXBvbmVudElkfXZhciBBPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBwcm9jZXNzJiYocHJvY2Vzcy5lbnYuUkVBQ1RfQVBQX1NDX0FUVFJ8fHByb2Nlc3MuZW52LlNDX0FUVFIpfHxcImRhdGEtc3R5bGVkXCIsQz1cIjUuMy41XCIsST1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZcIkhUTUxFbGVtZW50XCJpbiB3aW5kb3csUD1Cb29sZWFuKFwiYm9vbGVhblwiPT10eXBlb2YgU0NfRElTQUJMRV9TUEVFRFk/U0NfRElTQUJMRV9TUEVFRFk6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHByb2Nlc3MmJnZvaWQgMCE9PXByb2Nlc3MuZW52LlJFQUNUX0FQUF9TQ19ESVNBQkxFX1NQRUVEWSYmXCJcIiE9PXByb2Nlc3MuZW52LlJFQUNUX0FQUF9TQ19ESVNBQkxFX1NQRUVEWT9cImZhbHNlXCIhPT1wcm9jZXNzLmVudi5SRUFDVF9BUFBfU0NfRElTQUJMRV9TUEVFRFkmJnByb2Nlc3MuZW52LlJFQUNUX0FQUF9TQ19ESVNBQkxFX1NQRUVEWTpcInVuZGVmaW5lZFwiIT10eXBlb2YgcHJvY2VzcyYmdm9pZCAwIT09cHJvY2Vzcy5lbnYuU0NfRElTQUJMRV9TUEVFRFkmJlwiXCIhPT1wcm9jZXNzLmVudi5TQ19ESVNBQkxFX1NQRUVEWT9cImZhbHNlXCIhPT1wcm9jZXNzLmVudi5TQ19ESVNBQkxFX1NQRUVEWSYmcHJvY2Vzcy5lbnYuU0NfRElTQUJMRV9TUEVFRFk6XCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViksTz17fSxSPVwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlY/ezE6XCJDYW5ub3QgY3JlYXRlIHN0eWxlZC1jb21wb25lbnQgZm9yIGNvbXBvbmVudDogJXMuXFxuXFxuXCIsMjpcIkNhbid0IGNvbGxlY3Qgc3R5bGVzIG9uY2UgeW91J3ZlIGNvbnN1bWVkIGEgYFNlcnZlclN0eWxlU2hlZXRgJ3Mgc3R5bGVzISBgU2VydmVyU3R5bGVTaGVldGAgaXMgYSBvbmUgb2ZmIGluc3RhbmNlIGZvciBlYWNoIHNlcnZlci1zaWRlIHJlbmRlciBjeWNsZS5cXG5cXG4tIEFyZSB5b3UgdHJ5aW5nIHRvIHJldXNlIGl0IGFjcm9zcyByZW5kZXJzP1xcbi0gQXJlIHlvdSBhY2NpZGVudGFsbHkgY2FsbGluZyBjb2xsZWN0U3R5bGVzIHR3aWNlP1xcblxcblwiLDM6XCJTdHJlYW1pbmcgU1NSIGlzIG9ubHkgc3VwcG9ydGVkIGluIGEgTm9kZS5qcyBlbnZpcm9ubWVudDsgUGxlYXNlIGRvIG5vdCB0cnkgdG8gY2FsbCB0aGlzIG1ldGhvZCBpbiB0aGUgYnJvd3Nlci5cXG5cXG5cIiw0OlwiVGhlIGBTdHlsZVNoZWV0TWFuYWdlcmAgZXhwZWN0cyBhIHZhbGlkIHRhcmdldCBvciBzaGVldCBwcm9wIVxcblxcbi0gRG9lcyB0aGlzIGVycm9yIG9jY3VyIG9uIHRoZSBjbGllbnQgYW5kIGlzIHlvdXIgdGFyZ2V0IGZhbHN5P1xcbi0gRG9lcyB0aGlzIGVycm9yIG9jY3VyIG9uIHRoZSBzZXJ2ZXIgYW5kIGlzIHRoZSBzaGVldCBmYWxzeT9cXG5cXG5cIiw1OlwiVGhlIGNsb25lIG1ldGhvZCBjYW5ub3QgYmUgdXNlZCBvbiB0aGUgY2xpZW50IVxcblxcbi0gQXJlIHlvdSBydW5uaW5nIGluIGEgY2xpZW50LWxpa2UgZW52aXJvbm1lbnQgb24gdGhlIHNlcnZlcj9cXG4tIEFyZSB5b3UgdHJ5aW5nIHRvIHJ1biBTU1Igb24gdGhlIGNsaWVudD9cXG5cXG5cIiw2OlwiVHJ5aW5nIHRvIGluc2VydCBhIG5ldyBzdHlsZSB0YWcsIGJ1dCB0aGUgZ2l2ZW4gTm9kZSBpcyB1bm1vdW50ZWQhXFxuXFxuLSBBcmUgeW91IHVzaW5nIGEgY3VzdG9tIHRhcmdldCB0aGF0IGlzbid0IG1vdW50ZWQ/XFxuLSBEb2VzIHlvdXIgZG9jdW1lbnQgbm90IGhhdmUgYSB2YWxpZCBoZWFkIGVsZW1lbnQ/XFxuLSBIYXZlIHlvdSBhY2NpZGVudGFsbHkgcmVtb3ZlZCBhIHN0eWxlIHRhZyBtYW51YWxseT9cXG5cXG5cIiw3OidUaGVtZVByb3ZpZGVyOiBQbGVhc2UgcmV0dXJuIGFuIG9iamVjdCBmcm9tIHlvdXIgXCJ0aGVtZVwiIHByb3AgZnVuY3Rpb24sIGUuZy5cXG5cXG5gYGBqc1xcbnRoZW1lPXsoKSA9PiAoe30pfVxcbmBgYFxcblxcbicsODonVGhlbWVQcm92aWRlcjogUGxlYXNlIG1ha2UgeW91ciBcInRoZW1lXCIgcHJvcCBhbiBvYmplY3QuXFxuXFxuJyw5OlwiTWlzc2luZyBkb2N1bWVudCBgPGhlYWQ+YFxcblxcblwiLDEwOlwiQ2Fubm90IGZpbmQgYSBTdHlsZVNoZWV0IGluc3RhbmNlLiBVc3VhbGx5IHRoaXMgaGFwcGVucyBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgY29waWVzIG9mIHN0eWxlZC1jb21wb25lbnRzIGxvYWRlZCBhdCBvbmNlLiBDaGVjayBvdXQgdGhpcyBpc3N1ZSBmb3IgaG93IHRvIHRyb3VibGVzaG9vdCBhbmQgZml4IHRoZSBjb21tb24gY2FzZXMgd2hlcmUgdGhpcyBzaXR1YXRpb24gY2FuIGhhcHBlbjogaHR0cHM6Ly9naXRodWIuY29tL3N0eWxlZC1jb21wb25lbnRzL3N0eWxlZC1jb21wb25lbnRzL2lzc3Vlcy8xOTQxI2lzc3VlY29tbWVudC00MTc4NjIwMjFcXG5cXG5cIiwxMTpcIl9UaGlzIGVycm9yIHdhcyByZXBsYWNlZCB3aXRoIGEgZGV2LXRpbWUgd2FybmluZywgaXQgd2lsbCBiZSBkZWxldGVkIGZvciB2NCBmaW5hbC5fIFtjcmVhdGVHbG9iYWxTdHlsZV0gcmVjZWl2ZWQgY2hpbGRyZW4gd2hpY2ggd2lsbCBub3QgYmUgcmVuZGVyZWQuIFBsZWFzZSB1c2UgdGhlIGNvbXBvbmVudCB3aXRob3V0IHBhc3NpbmcgY2hpbGRyZW4gZWxlbWVudHMuXFxuXFxuXCIsMTI6XCJJdCBzZWVtcyB5b3UgYXJlIGludGVycG9sYXRpbmcgYSBrZXlmcmFtZSBkZWNsYXJhdGlvbiAoJXMpIGludG8gYW4gdW50YWdnZWQgc3RyaW5nLiBUaGlzIHdhcyBzdXBwb3J0ZWQgaW4gc3R5bGVkLWNvbXBvbmVudHMgdjMsIGJ1dCBpcyBub3QgbG9uZ2VyIHN1cHBvcnRlZCBpbiB2NCBhcyBrZXlmcmFtZXMgYXJlIG5vdyBpbmplY3RlZCBvbi1kZW1hbmQuIFBsZWFzZSB3cmFwIHlvdXIgc3RyaW5nIGluIHRoZSBjc3NcXFxcYFxcXFxgIGhlbHBlciB3aGljaCBlbnN1cmVzIHRoZSBzdHlsZXMgYXJlIGluamVjdGVkIGNvcnJlY3RseS4gU2VlIGh0dHBzOi8vd3d3LnN0eWxlZC1jb21wb25lbnRzLmNvbS9kb2NzL2FwaSNjc3NcXG5cXG5cIiwxMzpcIiVzIGlzIG5vdCBhIHN0eWxlZCBjb21wb25lbnQgYW5kIGNhbm5vdCBiZSByZWZlcnJlZCB0byB2aWEgY29tcG9uZW50IHNlbGVjdG9yLiBTZWUgaHR0cHM6Ly93d3cuc3R5bGVkLWNvbXBvbmVudHMuY29tL2RvY3MvYWR2YW5jZWQjcmVmZXJyaW5nLXRvLW90aGVyLWNvbXBvbmVudHMgZm9yIG1vcmUgZGV0YWlscy5cXG5cXG5cIiwxNDonVGhlbWVQcm92aWRlcjogXCJ0aGVtZVwiIHByb3AgaXMgcmVxdWlyZWQuXFxuXFxuJywxNTpcIkEgc3R5bGlzIHBsdWdpbiBoYXMgYmVlbiBzdXBwbGllZCB0aGF0IGlzIG5vdCBuYW1lZC4gV2UgbmVlZCBhIG5hbWUgZm9yIGVhY2ggcGx1Z2luIHRvIGJlIGFibGUgdG8gcHJldmVudCBzdHlsaW5nIGNvbGxpc2lvbnMgYmV0d2VlbiBkaWZmZXJlbnQgc3R5bGlzIGNvbmZpZ3VyYXRpb25zIHdpdGhpbiB0aGUgc2FtZSBhcHAuIEJlZm9yZSB5b3UgcGFzcyB5b3VyIHBsdWdpbiB0byBgPFN0eWxlU2hlZXRNYW5hZ2VyIHN0eWxpc1BsdWdpbnM9e1tdfT5gLCBwbGVhc2UgbWFrZSBzdXJlIGVhY2ggcGx1Z2luIGlzIHVuaXF1ZWx5LW5hbWVkLCBlLmcuXFxuXFxuYGBganNcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoaW1wb3J0ZWRQbHVnaW4sICduYW1lJywgeyB2YWx1ZTogJ3NvbWUtdW5pcXVlLW5hbWUnIH0pO1xcbmBgYFxcblxcblwiLDE2OlwiUmVhY2hlZCB0aGUgbGltaXQgb2YgaG93IG1hbnkgc3R5bGVkIGNvbXBvbmVudHMgbWF5IGJlIGNyZWF0ZWQgYXQgZ3JvdXAgJXMuXFxuWW91IG1heSBvbmx5IGNyZWF0ZSB1cCB0byAxLDA3Myw3NDEsODI0IGNvbXBvbmVudHMuIElmIHlvdSdyZSBjcmVhdGluZyBjb21wb25lbnRzIGR5bmFtaWNhbGx5LFxcbmFzIGZvciBpbnN0YW5jZSBpbiB5b3VyIHJlbmRlciBtZXRob2QgdGhlbiB5b3UgbWF5IGJlIHJ1bm5pbmcgaW50byB0aGlzIGxpbWl0YXRpb24uXFxuXFxuXCIsMTc6XCJDU1NTdHlsZVNoZWV0IGNvdWxkIG5vdCBiZSBmb3VuZCBvbiBIVE1MU3R5bGVFbGVtZW50LlxcbkhhcyBzdHlsZWQtY29tcG9uZW50cycgc3R5bGUgdGFnIGJlZW4gdW5tb3VudGVkIG9yIGFsdGVyZWQgYnkgYW5vdGhlciBzY3JpcHQ/XFxuXCJ9Ont9O2Z1bmN0aW9uIEQoKXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aDw9MD92b2lkIDA6YXJndW1lbnRzWzBdLHQ9W10sbj0xLHI9YXJndW1lbnRzLmxlbmd0aDtuPHI7bis9MSl0LnB1c2gobjwwfHxhcmd1bWVudHMubGVuZ3RoPD1uP3ZvaWQgMDphcmd1bWVudHNbbl0pO3JldHVybiB0LmZvckVhY2goKGZ1bmN0aW9uKHQpe2U9ZS5yZXBsYWNlKC8lW2Etel0vLHQpfSkpLGV9ZnVuY3Rpb24gaihlKXtmb3IodmFyIHQ9YXJndW1lbnRzLmxlbmd0aCxuPW5ldyBBcnJheSh0PjE/dC0xOjApLHI9MTtyPHQ7cisrKW5bci0xXT1hcmd1bWVudHNbcl07dGhyb3dcInByb2R1Y3Rpb25cIj09PXByb2Nlc3MuZW52Lk5PREVfRU5WP25ldyBFcnJvcihcIkFuIGVycm9yIG9jY3VycmVkLiBTZWUgaHR0cHM6Ly9naXQuaW8vSlVJYUUjXCIrZStcIiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIisobi5sZW5ndGg+MD9cIiBBcmdzOiBcIituLmpvaW4oXCIsIFwiKTpcIlwiKSk6bmV3IEVycm9yKEQuYXBwbHkodm9pZCAwLFtSW2VdXS5jb25jYXQobikpLnRyaW0oKSl9dmFyIFQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe3RoaXMuZ3JvdXBTaXplcz1uZXcgVWludDMyQXJyYXkoNTEyKSx0aGlzLmxlbmd0aD01MTIsdGhpcy50YWc9ZX12YXIgdD1lLnByb3RvdHlwZTtyZXR1cm4gdC5pbmRleE9mR3JvdXA9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTAsbj0wO248ZTtuKyspdCs9dGhpcy5ncm91cFNpemVzW25dO3JldHVybiB0fSx0Lmluc2VydFJ1bGVzPWZ1bmN0aW9uKGUsdCl7aWYoZT49dGhpcy5ncm91cFNpemVzLmxlbmd0aCl7Zm9yKHZhciBuPXRoaXMuZ3JvdXBTaXplcyxyPW4ubGVuZ3RoLG89cjtlPj1vOykobzw8PTEpPDAmJmooMTYsXCJcIitlKTt0aGlzLmdyb3VwU2l6ZXM9bmV3IFVpbnQzMkFycmF5KG8pLHRoaXMuZ3JvdXBTaXplcy5zZXQobiksdGhpcy5sZW5ndGg9bztmb3IodmFyIHM9cjtzPG87cysrKXRoaXMuZ3JvdXBTaXplc1tzXT0wfWZvcih2YXIgaT10aGlzLmluZGV4T2ZHcm91cChlKzEpLGE9MCxjPXQubGVuZ3RoO2E8YzthKyspdGhpcy50YWcuaW5zZXJ0UnVsZShpLHRbYV0pJiYodGhpcy5ncm91cFNpemVzW2VdKyssaSsrKX0sdC5jbGVhckdyb3VwPWZ1bmN0aW9uKGUpe2lmKGU8dGhpcy5sZW5ndGgpe3ZhciB0PXRoaXMuZ3JvdXBTaXplc1tlXSxuPXRoaXMuaW5kZXhPZkdyb3VwKGUpLHI9bit0O3RoaXMuZ3JvdXBTaXplc1tlXT0wO2Zvcih2YXIgbz1uO288cjtvKyspdGhpcy50YWcuZGVsZXRlUnVsZShuKX19LHQuZ2V0R3JvdXA9ZnVuY3Rpb24oZSl7dmFyIHQ9XCJcIjtpZihlPj10aGlzLmxlbmd0aHx8MD09PXRoaXMuZ3JvdXBTaXplc1tlXSlyZXR1cm4gdDtmb3IodmFyIG49dGhpcy5ncm91cFNpemVzW2VdLHI9dGhpcy5pbmRleE9mR3JvdXAoZSksbz1yK24scz1yO3M8bztzKyspdCs9dGhpcy50YWcuZ2V0UnVsZShzKStcIi8qIXNjKi9cXG5cIjtyZXR1cm4gdH0sZX0oKSx4PW5ldyBNYXAsaz1uZXcgTWFwLFY9MSxCPWZ1bmN0aW9uKGUpe2lmKHguaGFzKGUpKXJldHVybiB4LmdldChlKTtmb3IoO2suaGFzKFYpOylWKys7dmFyIHQ9VisrO3JldHVyblwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJigoMHx0KTwwfHx0PjE8PDMwKSYmaigxNixcIlwiK3QpLHguc2V0KGUsdCksay5zZXQodCxlKSx0fSx6PWZ1bmN0aW9uKGUpe3JldHVybiBrLmdldChlKX0sTT1mdW5jdGlvbihlLHQpe3Q+PVYmJihWPXQrMSkseC5zZXQoZSx0KSxrLnNldCh0LGUpfSxHPVwic3R5bGVbXCIrQSsnXVtkYXRhLXN0eWxlZC12ZXJzaW9uPVwiNS4zLjVcIl0nLEw9bmV3IFJlZ0V4cChcIl5cIitBKydcXFxcLmcoXFxcXGQrKVxcXFxbaWQ9XCIoW1xcXFx3XFxcXGQtXSspXCJcXFxcXS4qP1wiKFteXCJdKiknKSxGPWZ1bmN0aW9uKGUsdCxuKXtmb3IodmFyIHIsbz1uLnNwbGl0KFwiLFwiKSxzPTAsaT1vLmxlbmd0aDtzPGk7cysrKShyPW9bc10pJiZlLnJlZ2lzdGVyTmFtZSh0LHIpfSxZPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPSh0LnRleHRDb250ZW50fHxcIlwiKS5zcGxpdChcIi8qIXNjKi9cXG5cIikscj1bXSxvPTAscz1uLmxlbmd0aDtvPHM7bysrKXt2YXIgaT1uW29dLnRyaW0oKTtpZihpKXt2YXIgYT1pLm1hdGNoKEwpO2lmKGEpe3ZhciBjPTB8cGFyc2VJbnQoYVsxXSwxMCksdT1hWzJdOzAhPT1jJiYoTSh1LGMpLEYoZSx1LGFbM10pLGUuZ2V0VGFnKCkuaW5zZXJ0UnVsZXMoYyxyKSksci5sZW5ndGg9MH1lbHNlIHIucHVzaChpKX19fSxxPWZ1bmN0aW9uKCl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmdm9pZCAwIT09d2luZG93Ll9fd2VicGFja19ub25jZV9fP3dpbmRvdy5fX3dlYnBhY2tfbm9uY2VfXzpudWxsfSxIPWZ1bmN0aW9uKGUpe3ZhciB0PWRvY3VtZW50LmhlYWQsbj1lfHx0LHI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpLG89ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWUuY2hpbGROb2RlcyxuPXQubGVuZ3RoO24+PTA7bi0tKXt2YXIgcj10W25dO2lmKHImJjE9PT1yLm5vZGVUeXBlJiZyLmhhc0F0dHJpYnV0ZShBKSlyZXR1cm4gcn19KG4pLHM9dm9pZCAwIT09bz9vLm5leHRTaWJsaW5nOm51bGw7ci5zZXRBdHRyaWJ1dGUoQSxcImFjdGl2ZVwiKSxyLnNldEF0dHJpYnV0ZShcImRhdGEtc3R5bGVkLXZlcnNpb25cIixcIjUuMy41XCIpO3ZhciBpPXEoKTtyZXR1cm4gaSYmci5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLGkpLG4uaW5zZXJ0QmVmb3JlKHIscykscn0sJD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7dmFyIHQ9dGhpcy5lbGVtZW50PUgoZSk7dC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKSksdGhpcy5zaGVldD1mdW5jdGlvbihlKXtpZihlLnNoZWV0KXJldHVybiBlLnNoZWV0O2Zvcih2YXIgdD1kb2N1bWVudC5zdHlsZVNoZWV0cyxuPTAscj10Lmxlbmd0aDtuPHI7bisrKXt2YXIgbz10W25dO2lmKG8ub3duZXJOb2RlPT09ZSlyZXR1cm4gb31qKDE3KX0odCksdGhpcy5sZW5ndGg9MH12YXIgdD1lLnByb3RvdHlwZTtyZXR1cm4gdC5pbnNlcnRSdWxlPWZ1bmN0aW9uKGUsdCl7dHJ5e3JldHVybiB0aGlzLnNoZWV0Lmluc2VydFJ1bGUodCxlKSx0aGlzLmxlbmd0aCsrLCEwfWNhdGNoKGUpe3JldHVybiExfX0sdC5kZWxldGVSdWxlPWZ1bmN0aW9uKGUpe3RoaXMuc2hlZXQuZGVsZXRlUnVsZShlKSx0aGlzLmxlbmd0aC0tfSx0LmdldFJ1bGU9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5zaGVldC5jc3NSdWxlc1tlXTtyZXR1cm4gdm9pZCAwIT09dCYmXCJzdHJpbmdcIj09dHlwZW9mIHQuY3NzVGV4dD90LmNzc1RleHQ6XCJcIn0sZX0oKSxXPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXt2YXIgdD10aGlzLmVsZW1lbnQ9SChlKTt0aGlzLm5vZGVzPXQuY2hpbGROb2Rlcyx0aGlzLmxlbmd0aD0wfXZhciB0PWUucHJvdG90eXBlO3JldHVybiB0Lmluc2VydFJ1bGU9ZnVuY3Rpb24oZSx0KXtpZihlPD10aGlzLmxlbmd0aCYmZT49MCl7dmFyIG49ZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodCkscj10aGlzLm5vZGVzW2VdO3JldHVybiB0aGlzLmVsZW1lbnQuaW5zZXJ0QmVmb3JlKG4scnx8bnVsbCksdGhpcy5sZW5ndGgrKywhMH1yZXR1cm4hMX0sdC5kZWxldGVSdWxlPWZ1bmN0aW9uKGUpe3RoaXMuZWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLm5vZGVzW2VdKSx0aGlzLmxlbmd0aC0tfSx0LmdldFJ1bGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGU8dGhpcy5sZW5ndGg/dGhpcy5ub2Rlc1tlXS50ZXh0Q29udGVudDpcIlwifSxlfSgpLFU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe3RoaXMucnVsZXM9W10sdGhpcy5sZW5ndGg9MH12YXIgdD1lLnByb3RvdHlwZTtyZXR1cm4gdC5pbnNlcnRSdWxlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU8PXRoaXMubGVuZ3RoJiYodGhpcy5ydWxlcy5zcGxpY2UoZSwwLHQpLHRoaXMubGVuZ3RoKyssITApfSx0LmRlbGV0ZVJ1bGU9ZnVuY3Rpb24oZSl7dGhpcy5ydWxlcy5zcGxpY2UoZSwxKSx0aGlzLmxlbmd0aC0tfSx0LmdldFJ1bGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGU8dGhpcy5sZW5ndGg/dGhpcy5ydWxlc1tlXTpcIlwifSxlfSgpLEo9SSxYPXtpc1NlcnZlcjohSSx1c2VDU1NPTUluamVjdGlvbjohUH0sWj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0LG4pe3ZvaWQgMD09PWUmJihlPUUpLHZvaWQgMD09PXQmJih0PXt9KSx0aGlzLm9wdGlvbnM9dih7fSxYLHt9LGUpLHRoaXMuZ3M9dCx0aGlzLm5hbWVzPW5ldyBNYXAobiksdGhpcy5zZXJ2ZXI9ISFlLmlzU2VydmVyLCF0aGlzLnNlcnZlciYmSSYmSiYmKEo9ITEsZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoRyksbj0wLHI9dC5sZW5ndGg7bjxyO24rKyl7dmFyIG89dFtuXTtvJiZcImFjdGl2ZVwiIT09by5nZXRBdHRyaWJ1dGUoQSkmJihZKGUsbyksby5wYXJlbnROb2RlJiZvLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobykpfX0odGhpcykpfWUucmVnaXN0ZXJJZD1mdW5jdGlvbihlKXtyZXR1cm4gQihlKX07dmFyIHQ9ZS5wcm90b3R5cGU7cmV0dXJuIHQucmVjb25zdHJ1Y3RXaXRoT3B0aW9ucz1mdW5jdGlvbih0LG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0hMCksbmV3IGUodih7fSx0aGlzLm9wdGlvbnMse30sdCksdGhpcy5ncyxuJiZ0aGlzLm5hbWVzfHx2b2lkIDApfSx0LmFsbG9jYXRlR1NJbnN0YW5jZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5nc1tlXT0odGhpcy5nc1tlXXx8MCkrMX0sdC5nZXRUYWc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50YWd8fCh0aGlzLnRhZz0obj0odD10aGlzLm9wdGlvbnMpLmlzU2VydmVyLHI9dC51c2VDU1NPTUluamVjdGlvbixvPXQudGFyZ2V0LGU9bj9uZXcgVShvKTpyP25ldyAkKG8pOm5ldyBXKG8pLG5ldyBUKGUpKSk7dmFyIGUsdCxuLHIsb30sdC5oYXNOYW1lRm9ySWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5uYW1lcy5oYXMoZSkmJnRoaXMubmFtZXMuZ2V0KGUpLmhhcyh0KX0sdC5yZWdpc3Rlck5hbWU9ZnVuY3Rpb24oZSx0KXtpZihCKGUpLHRoaXMubmFtZXMuaGFzKGUpKXRoaXMubmFtZXMuZ2V0KGUpLmFkZCh0KTtlbHNle3ZhciBuPW5ldyBTZXQ7bi5hZGQodCksdGhpcy5uYW1lcy5zZXQoZSxuKX19LHQuaW5zZXJ0UnVsZXM9ZnVuY3Rpb24oZSx0LG4pe3RoaXMucmVnaXN0ZXJOYW1lKGUsdCksdGhpcy5nZXRUYWcoKS5pbnNlcnRSdWxlcyhCKGUpLG4pfSx0LmNsZWFyTmFtZXM9ZnVuY3Rpb24oZSl7dGhpcy5uYW1lcy5oYXMoZSkmJnRoaXMubmFtZXMuZ2V0KGUpLmNsZWFyKCl9LHQuY2xlYXJSdWxlcz1mdW5jdGlvbihlKXt0aGlzLmdldFRhZygpLmNsZWFyR3JvdXAoQihlKSksdGhpcy5jbGVhck5hbWVzKGUpfSx0LmNsZWFyVGFnPWZ1bmN0aW9uKCl7dGhpcy50YWc9dm9pZCAwfSx0LnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1lLmdldFRhZygpLG49dC5sZW5ndGgscj1cIlwiLG89MDtvPG47bysrKXt2YXIgcz16KG8pO2lmKHZvaWQgMCE9PXMpe3ZhciBpPWUubmFtZXMuZ2V0KHMpLGE9dC5nZXRHcm91cChvKTtpZihpJiZhJiZpLnNpemUpe3ZhciBjPUErXCIuZ1wiK28rJ1tpZD1cIicrcysnXCJdJyx1PVwiXCI7dm9pZCAwIT09aSYmaS5mb3JFYWNoKChmdW5jdGlvbihlKXtlLmxlbmd0aD4wJiYodSs9ZStcIixcIil9KSkscis9XCJcIithK2MrJ3tjb250ZW50OlwiJyt1KydcIn0vKiFzYyovXFxuJ319fXJldHVybiByfSh0aGlzKX0sZX0oKSxLPS8oYSkoZCkvZ2ksUT1mdW5jdGlvbihlKXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShlKyhlPjI1PzM5Ojk3KSl9O2Z1bmN0aW9uIGVlKGUpe3ZhciB0LG49XCJcIjtmb3IodD1NYXRoLmFicyhlKTt0PjUyO3Q9dC81MnwwKW49USh0JTUyKStuO3JldHVybihRKHQlNTIpK24pLnJlcGxhY2UoSyxcIiQxLSQyXCIpfXZhciB0ZT1mdW5jdGlvbihlLHQpe2Zvcih2YXIgbj10Lmxlbmd0aDtuOyllPTMzKmVedC5jaGFyQ29kZUF0KC0tbik7cmV0dXJuIGV9LG5lPWZ1bmN0aW9uKGUpe3JldHVybiB0ZSg1MzgxLGUpfTtmdW5jdGlvbiByZShlKXtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoO3QrPTEpe3ZhciBuPWVbdF07aWYoYihuKSYmIU4obikpcmV0dXJuITF9cmV0dXJuITB9dmFyIG9lPW5lKFwiNS4zLjVcIiksc2U9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCxuKXt0aGlzLnJ1bGVzPWUsdGhpcy5zdGF0aWNSdWxlc0lkPVwiXCIsdGhpcy5pc1N0YXRpYz1cInByb2R1Y3Rpb25cIj09PXByb2Nlc3MuZW52Lk5PREVfRU5WJiYodm9pZCAwPT09bnx8bi5pc1N0YXRpYykmJnJlKGUpLHRoaXMuY29tcG9uZW50SWQ9dCx0aGlzLmJhc2VIYXNoPXRlKG9lLHQpLHRoaXMuYmFzZVN0eWxlPW4sWi5yZWdpc3RlcklkKHQpfXJldHVybiBlLnByb3RvdHlwZS5nZW5lcmF0ZUFuZEluamVjdFN0eWxlcz1mdW5jdGlvbihlLHQsbil7dmFyIHI9dGhpcy5jb21wb25lbnRJZCxvPVtdO2lmKHRoaXMuYmFzZVN0eWxlJiZvLnB1c2godGhpcy5iYXNlU3R5bGUuZ2VuZXJhdGVBbmRJbmplY3RTdHlsZXMoZSx0LG4pKSx0aGlzLmlzU3RhdGljJiYhbi5oYXNoKWlmKHRoaXMuc3RhdGljUnVsZXNJZCYmdC5oYXNOYW1lRm9ySWQocix0aGlzLnN0YXRpY1J1bGVzSWQpKW8ucHVzaCh0aGlzLnN0YXRpY1J1bGVzSWQpO2Vsc2V7dmFyIHM9TmUodGhpcy5ydWxlcyxlLHQsbikuam9pbihcIlwiKSxpPWVlKHRlKHRoaXMuYmFzZUhhc2gscyk+Pj4wKTtpZighdC5oYXNOYW1lRm9ySWQocixpKSl7dmFyIGE9bihzLFwiLlwiK2ksdm9pZCAwLHIpO3QuaW5zZXJ0UnVsZXMocixpLGEpfW8ucHVzaChpKSx0aGlzLnN0YXRpY1J1bGVzSWQ9aX1lbHNle2Zvcih2YXIgYz10aGlzLnJ1bGVzLmxlbmd0aCx1PXRlKHRoaXMuYmFzZUhhc2gsbi5oYXNoKSxsPVwiXCIsZD0wO2Q8YztkKyspe3ZhciBoPXRoaXMucnVsZXNbZF07aWYoXCJzdHJpbmdcIj09dHlwZW9mIGgpbCs9aCxcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiYodT10ZSh1LGgrZCkpO2Vsc2UgaWYoaCl7dmFyIHA9TmUoaCxlLHQsbiksZj1BcnJheS5pc0FycmF5KHApP3Auam9pbihcIlwiKTpwO3U9dGUodSxmK2QpLGwrPWZ9fWlmKGwpe3ZhciBtPWVlKHU+Pj4wKTtpZighdC5oYXNOYW1lRm9ySWQocixtKSl7dmFyIHk9bihsLFwiLlwiK20sdm9pZCAwLHIpO3QuaW5zZXJ0UnVsZXMocixtLHkpfW8ucHVzaChtKX19cmV0dXJuIG8uam9pbihcIiBcIil9LGV9KCksaWU9L15cXHMqXFwvXFwvLiokL2dtLGFlPVtcIjpcIixcIltcIixcIi5cIixcIiNcIl07ZnVuY3Rpb24gY2UoZSl7dmFyIHQsbixyLG8scz12b2lkIDA9PT1lP0U6ZSxpPXMub3B0aW9ucyxhPXZvaWQgMD09PWk/RTppLGM9cy5wbHVnaW5zLHU9dm9pZCAwPT09Yz93OmMsbD1uZXcgcChhKSxkPVtdLGg9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtpZih0KXRyeXtlKHQrXCJ9XCIpfWNhdGNoKGUpe319cmV0dXJuIGZ1bmN0aW9uKG4scixvLHMsaSxhLGMsdSxsLGQpe3N3aXRjaChuKXtjYXNlIDE6aWYoMD09PWwmJjY0PT09ci5jaGFyQ29kZUF0KDApKXJldHVybiBlKHIrXCI7XCIpLFwiXCI7YnJlYWs7Y2FzZSAyOmlmKDA9PT11KXJldHVybiByK1wiLyp8Ki9cIjticmVhaztjYXNlIDM6c3dpdGNoKHUpe2Nhc2UgMTAyOmNhc2UgMTEyOnJldHVybiBlKG9bMF0rciksXCJcIjtkZWZhdWx0OnJldHVybiByKygwPT09ZD9cIi8qfCovXCI6XCJcIil9Y2FzZS0yOnIuc3BsaXQoXCIvKnwqL31cIikuZm9yRWFjaCh0KX19fSgoZnVuY3Rpb24oZSl7ZC5wdXNoKGUpfSkpLGY9ZnVuY3Rpb24oZSxyLHMpe3JldHVybiAwPT09ciYmLTEhPT1hZS5pbmRleE9mKHNbbi5sZW5ndGhdKXx8cy5tYXRjaChvKT9lOlwiLlwiK3R9O2Z1bmN0aW9uIG0oZSxzLGksYSl7dm9pZCAwPT09YSYmKGE9XCImXCIpO3ZhciBjPWUucmVwbGFjZShpZSxcIlwiKSx1PXMmJmk/aStcIiBcIitzK1wiIHsgXCIrYytcIiB9XCI6YztyZXR1cm4gdD1hLG49cyxyPW5ldyBSZWdFeHAoXCJcXFxcXCIrbitcIlxcXFxiXCIsXCJnXCIpLG89bmV3IFJlZ0V4cChcIihcXFxcXCIrbitcIlxcXFxiKXsyLH1cIiksbChpfHwhcz9cIlwiOnMsdSl9cmV0dXJuIGwudXNlKFtdLmNvbmNhdCh1LFtmdW5jdGlvbihlLHQsbyl7Mj09PWUmJm8ubGVuZ3RoJiZvWzBdLmxhc3RJbmRleE9mKG4pPjAmJihvWzBdPW9bMF0ucmVwbGFjZShyLGYpKX0saCxmdW5jdGlvbihlKXtpZigtMj09PWUpe3ZhciB0PWQ7cmV0dXJuIGQ9W10sdH19XSkpLG0uaGFzaD11Lmxlbmd0aD91LnJlZHVjZSgoZnVuY3Rpb24oZSx0KXtyZXR1cm4gdC5uYW1lfHxqKDE1KSx0ZShlLHQubmFtZSl9KSw1MzgxKS50b1N0cmluZygpOlwiXCIsbX12YXIgdWU9ci5jcmVhdGVDb250ZXh0KCksbGU9dWUuQ29uc3VtZXIsZGU9ci5jcmVhdGVDb250ZXh0KCksaGU9KGRlLkNvbnN1bWVyLG5ldyBaKSxwZT1jZSgpO2Z1bmN0aW9uIGZlKCl7cmV0dXJuIHModWUpfHxoZX1mdW5jdGlvbiBtZSgpe3JldHVybiBzKGRlKXx8cGV9ZnVuY3Rpb24geWUoZSl7dmFyIHQ9byhlLnN0eWxpc1BsdWdpbnMpLG49dFswXSxzPXRbMV0sYz1mZSgpLHU9aSgoZnVuY3Rpb24oKXt2YXIgdD1jO3JldHVybiBlLnNoZWV0P3Q9ZS5zaGVldDplLnRhcmdldCYmKHQ9dC5yZWNvbnN0cnVjdFdpdGhPcHRpb25zKHt0YXJnZXQ6ZS50YXJnZXR9LCExKSksZS5kaXNhYmxlQ1NTT01JbmplY3Rpb24mJih0PXQucmVjb25zdHJ1Y3RXaXRoT3B0aW9ucyh7dXNlQ1NTT01JbmplY3Rpb246ITF9KSksdH0pLFtlLmRpc2FibGVDU1NPTUluamVjdGlvbixlLnNoZWV0LGUudGFyZ2V0XSksbD1pKChmdW5jdGlvbigpe3JldHVybiBjZSh7b3B0aW9uczp7cHJlZml4OiFlLmRpc2FibGVWZW5kb3JQcmVmaXhlc30scGx1Z2luczpufSl9KSxbZS5kaXNhYmxlVmVuZG9yUHJlZml4ZXMsbl0pO3JldHVybiBhKChmdW5jdGlvbigpe2gobixlLnN0eWxpc1BsdWdpbnMpfHxzKGUuc3R5bGlzUGx1Z2lucyl9KSxbZS5zdHlsaXNQbHVnaW5zXSksci5jcmVhdGVFbGVtZW50KHVlLlByb3ZpZGVyLHt2YWx1ZTp1fSxyLmNyZWF0ZUVsZW1lbnQoZGUuUHJvdmlkZXIse3ZhbHVlOmx9LFwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlY/ci5DaGlsZHJlbi5vbmx5KGUuY2hpbGRyZW4pOmUuY2hpbGRyZW4pKX12YXIgdmU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7dmFyIG49dGhpczt0aGlzLmluamVjdD1mdW5jdGlvbihlLHQpe3ZvaWQgMD09PXQmJih0PXBlKTt2YXIgcj1uLm5hbWUrdC5oYXNoO2UuaGFzTmFtZUZvcklkKG4uaWQscil8fGUuaW5zZXJ0UnVsZXMobi5pZCxyLHQobi5ydWxlcyxyLFwiQGtleWZyYW1lc1wiKSl9LHRoaXMudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gaigxMixTdHJpbmcobi5uYW1lKSl9LHRoaXMubmFtZT1lLHRoaXMuaWQ9XCJzYy1rZXlmcmFtZXMtXCIrZSx0aGlzLnJ1bGVzPXR9cmV0dXJuIGUucHJvdG90eXBlLmdldE5hbWU9ZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPXBlKSx0aGlzLm5hbWUrZS5oYXNofSxlfSgpLGdlPS8oW0EtWl0pLyxTZT0vKFtBLVpdKS9nLHdlPS9ebXMtLyxFZT1mdW5jdGlvbihlKXtyZXR1cm5cIi1cIitlLnRvTG93ZXJDYXNlKCl9O2Z1bmN0aW9uIGJlKGUpe3JldHVybiBnZS50ZXN0KGUpP2UucmVwbGFjZShTZSxFZSkucmVwbGFjZSh3ZSxcIi1tcy1cIik6ZX12YXIgX2U9ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWV8fCExPT09ZXx8XCJcIj09PWV9O2Z1bmN0aW9uIE5lKGUsbixyLG8pe2lmKEFycmF5LmlzQXJyYXkoZSkpe2Zvcih2YXIgcyxpPVtdLGE9MCxjPWUubGVuZ3RoO2E8YzthKz0xKVwiXCIhPT0ocz1OZShlW2FdLG4scixvKSkmJihBcnJheS5pc0FycmF5KHMpP2kucHVzaC5hcHBseShpLHMpOmkucHVzaChzKSk7cmV0dXJuIGl9aWYoX2UoZSkpcmV0dXJuXCJcIjtpZihOKGUpKXJldHVyblwiLlwiK2Uuc3R5bGVkQ29tcG9uZW50SWQ7aWYoYihlKSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YobD1lKXx8bC5wcm90b3R5cGUmJmwucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnR8fCFuKXJldHVybiBlO3ZhciB1PWUobik7cmV0dXJuXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmdCh1KSYmY29uc29sZS53YXJuKF8oZSkrXCIgaXMgbm90IGEgc3R5bGVkIGNvbXBvbmVudCBhbmQgY2Fubm90IGJlIHJlZmVycmVkIHRvIHZpYSBjb21wb25lbnQgc2VsZWN0b3IuIFNlZSBodHRwczovL3d3dy5zdHlsZWQtY29tcG9uZW50cy5jb20vZG9jcy9hZHZhbmNlZCNyZWZlcnJpbmctdG8tb3RoZXItY29tcG9uZW50cyBmb3IgbW9yZSBkZXRhaWxzLlwiKSxOZSh1LG4scixvKX12YXIgbDtyZXR1cm4gZSBpbnN0YW5jZW9mIHZlP3I/KGUuaW5qZWN0KHIsbyksZS5nZXROYW1lKG8pKTplOlMoZSk/ZnVuY3Rpb24gZSh0LG4pe3ZhciByLG8scz1bXTtmb3IodmFyIGkgaW4gdCl0Lmhhc093blByb3BlcnR5KGkpJiYhX2UodFtpXSkmJihBcnJheS5pc0FycmF5KHRbaV0pJiZ0W2ldLmlzQ3NzfHxiKHRbaV0pP3MucHVzaChiZShpKStcIjpcIix0W2ldLFwiO1wiKTpTKHRbaV0pP3MucHVzaC5hcHBseShzLGUodFtpXSxpKSk6cy5wdXNoKGJlKGkpK1wiOiBcIisocj1pLG51bGw9PShvPXRbaV0pfHxcImJvb2xlYW5cIj09dHlwZW9mIG98fFwiXCI9PT1vP1wiXCI6XCJudW1iZXJcIiE9dHlwZW9mIG98fDA9PT1vfHxyIGluIGY/U3RyaW5nKG8pLnRyaW0oKTpvK1wicHhcIikrXCI7XCIpKTtyZXR1cm4gbj9bbitcIiB7XCJdLmNvbmNhdChzLFtcIn1cIl0pOnN9KGUpOmUudG9TdHJpbmcoKX12YXIgQWU9ZnVuY3Rpb24oZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSkmJihlLmlzQ3NzPSEwKSxlfTtmdW5jdGlvbiBDZShlKXtmb3IodmFyIHQ9YXJndW1lbnRzLmxlbmd0aCxuPW5ldyBBcnJheSh0PjE/dC0xOjApLHI9MTtyPHQ7cisrKW5bci0xXT1hcmd1bWVudHNbcl07cmV0dXJuIGIoZSl8fFMoZSk/QWUoTmUoZyh3LFtlXS5jb25jYXQobikpKSk6MD09PW4ubGVuZ3RoJiYxPT09ZS5sZW5ndGgmJlwic3RyaW5nXCI9PXR5cGVvZiBlWzBdP2U6QWUoTmUoZyhlLG4pKSl9dmFyIEllPS9pbnZhbGlkIGhvb2sgY2FsbC9pLFBlPW5ldyBTZXQsT2U9ZnVuY3Rpb24oZSx0KXtpZihcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WKXt2YXIgbj1cIlRoZSBjb21wb25lbnQgXCIrZSsodD8nIHdpdGggdGhlIGlkIG9mIFwiJyt0KydcIic6XCJcIikrXCIgaGFzIGJlZW4gY3JlYXRlZCBkeW5hbWljYWxseS5cXG5Zb3UgbWF5IHNlZSB0aGlzIHdhcm5pbmcgYmVjYXVzZSB5b3UndmUgY2FsbGVkIHN0eWxlZCBpbnNpZGUgYW5vdGhlciBjb21wb25lbnQuXFxuVG8gcmVzb2x2ZSB0aGlzIG9ubHkgY3JlYXRlIG5ldyBTdHlsZWRDb21wb25lbnRzIG91dHNpZGUgb2YgYW55IHJlbmRlciBtZXRob2QgYW5kIGZ1bmN0aW9uIGNvbXBvbmVudC5cIixyPWNvbnNvbGUuZXJyb3I7dHJ5e3ZhciBvPSEwO2NvbnNvbGUuZXJyb3I9ZnVuY3Rpb24oZSl7aWYoSWUudGVzdChlKSlvPSExLFBlLmRlbGV0ZShuKTtlbHNle2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLHM9bmV3IEFycmF5KHQ+MT90LTE6MCksaT0xO2k8dDtpKyspc1tpLTFdPWFyZ3VtZW50c1tpXTtyLmFwcGx5KHZvaWQgMCxbZV0uY29uY2F0KHMpKX19LGMoKSxvJiYhUGUuaGFzKG4pJiYoY29uc29sZS53YXJuKG4pLFBlLmFkZChuKSl9Y2F0Y2goZSl7SWUudGVzdChlLm1lc3NhZ2UpJiZQZS5kZWxldGUobil9ZmluYWxseXtjb25zb2xlLmVycm9yPXJ9fX0sUmU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj1FKSxlLnRoZW1lIT09bi50aGVtZSYmZS50aGVtZXx8dHx8bi50aGVtZX0sRGU9L1shXCIjJCUmJygpKissLi86Ozw9Pj9AW1xcXFxcXF1eYHt8fX4tXSsvZyxqZT0vKF4tfC0kKS9nO2Z1bmN0aW9uIFRlKGUpe3JldHVybiBlLnJlcGxhY2UoRGUsXCItXCIpLnJlcGxhY2UoamUsXCJcIil9dmFyIHhlPWZ1bmN0aW9uKGUpe3JldHVybiBlZShuZShlKT4+PjApfTtmdW5jdGlvbiBrZShlKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZSYmKFwicHJvZHVjdGlvblwiPT09cHJvY2Vzcy5lbnYuTk9ERV9FTlZ8fGUuY2hhckF0KDApPT09ZS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSl9dmFyIFZlPWZ1bmN0aW9uKGUpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGV8fFwib2JqZWN0XCI9PXR5cGVvZiBlJiZudWxsIT09ZSYmIUFycmF5LmlzQXJyYXkoZSl9LEJlPWZ1bmN0aW9uKGUpe3JldHVyblwiX19wcm90b19fXCIhPT1lJiZcImNvbnN0cnVjdG9yXCIhPT1lJiZcInByb3RvdHlwZVwiIT09ZX07ZnVuY3Rpb24gemUoZSx0LG4pe3ZhciByPWVbbl07VmUodCkmJlZlKHIpP01lKHIsdCk6ZVtuXT10fWZ1bmN0aW9uIE1lKGUpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLG49bmV3IEFycmF5KHQ+MT90LTE6MCkscj0xO3I8dDtyKyspbltyLTFdPWFyZ3VtZW50c1tyXTtmb3IodmFyIG89MCxzPW47bzxzLmxlbmd0aDtvKyspe3ZhciBpPXNbb107aWYoVmUoaSkpZm9yKHZhciBhIGluIGkpQmUoYSkmJnplKGUsaVthXSxhKX1yZXR1cm4gZX12YXIgR2U9ci5jcmVhdGVDb250ZXh0KCksTGU9R2UuQ29uc3VtZXI7ZnVuY3Rpb24gRmUoZSl7dmFyIHQ9cyhHZSksbj1pKChmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlLHQpe2lmKCFlKXJldHVybiBqKDE0KTtpZihiKGUpKXt2YXIgbj1lKHQpO3JldHVyblwicHJvZHVjdGlvblwiPT09cHJvY2Vzcy5lbnYuTk9ERV9FTlZ8fG51bGwhPT1uJiYhQXJyYXkuaXNBcnJheShuKSYmXCJvYmplY3RcIj09dHlwZW9mIG4/bjpqKDcpfXJldHVybiBBcnJheS5pc0FycmF5KGUpfHxcIm9iamVjdFwiIT10eXBlb2YgZT9qKDgpOnQ/dih7fSx0LHt9LGUpOmV9KGUudGhlbWUsdCl9KSxbZS50aGVtZSx0XSk7cmV0dXJuIGUuY2hpbGRyZW4/ci5jcmVhdGVFbGVtZW50KEdlLlByb3ZpZGVyLHt2YWx1ZTpufSxlLmNoaWxkcmVuKTpudWxsfXZhciBZZT17fTtmdW5jdGlvbiBxZShlLHQsbil7dmFyIG89TihlKSxpPSFrZShlKSxhPXQuYXR0cnMsYz12b2lkIDA9PT1hP3c6YSxkPXQuY29tcG9uZW50SWQsaD12b2lkIDA9PT1kP2Z1bmN0aW9uKGUsdCl7dmFyIG49XCJzdHJpbmdcIiE9dHlwZW9mIGU/XCJzY1wiOlRlKGUpO1llW25dPShZZVtuXXx8MCkrMTt2YXIgcj1uK1wiLVwiK3hlKFwiNS4zLjVcIituK1llW25dKTtyZXR1cm4gdD90K1wiLVwiK3I6cn0odC5kaXNwbGF5TmFtZSx0LnBhcmVudENvbXBvbmVudElkKTpkLHA9dC5kaXNwbGF5TmFtZSxmPXZvaWQgMD09PXA/ZnVuY3Rpb24oZSl7cmV0dXJuIGtlKGUpP1wic3R5bGVkLlwiK2U6XCJTdHlsZWQoXCIrXyhlKStcIilcIn0oZSk6cCxnPXQuZGlzcGxheU5hbWUmJnQuY29tcG9uZW50SWQ/VGUodC5kaXNwbGF5TmFtZSkrXCItXCIrdC5jb21wb25lbnRJZDp0LmNvbXBvbmVudElkfHxoLFM9byYmZS5hdHRycz9BcnJheS5wcm90b3R5cGUuY29uY2F0KGUuYXR0cnMsYykuZmlsdGVyKEJvb2xlYW4pOmMsQT10LnNob3VsZEZvcndhcmRQcm9wO28mJmUuc2hvdWxkRm9yd2FyZFByb3AmJihBPXQuc2hvdWxkRm9yd2FyZFByb3A/ZnVuY3Rpb24obixyLG8pe3JldHVybiBlLnNob3VsZEZvcndhcmRQcm9wKG4scixvKSYmdC5zaG91bGRGb3J3YXJkUHJvcChuLHIsbyl9OmUuc2hvdWxkRm9yd2FyZFByb3ApO3ZhciBDLEk9bmV3IHNlKG4sZyxvP2UuY29tcG9uZW50U3R5bGU6dm9pZCAwKSxQPUkuaXNTdGF0aWMmJjA9PT1jLmxlbmd0aCxPPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBvPWUuYXR0cnMsaT1lLmNvbXBvbmVudFN0eWxlLGE9ZS5kZWZhdWx0UHJvcHMsYz1lLmZvbGRlZENvbXBvbmVudElkcyxkPWUuc2hvdWxkRm9yd2FyZFByb3AsaD1lLnN0eWxlZENvbXBvbmVudElkLHA9ZS50YXJnZXQ7XCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmbChoKTt2YXIgZj1mdW5jdGlvbihlLHQsbil7dm9pZCAwPT09ZSYmKGU9RSk7dmFyIHI9dih7fSx0LHt0aGVtZTplfSksbz17fTtyZXR1cm4gbi5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgdCxuLHMsaT1lO2Zvcih0IGluIGIoaSkmJihpPWkocikpLGkpclt0XT1vW3RdPVwiY2xhc3NOYW1lXCI9PT10PyhuPW9bdF0scz1pW3RdLG4mJnM/bitcIiBcIitzOm58fHMpOmlbdF19KSksW3Isb119KFJlKHQscyhHZSksYSl8fEUsdCxvKSx5PWZbMF0sZz1mWzFdLFM9ZnVuY3Rpb24oZSx0LG4scil7dmFyIG89ZmUoKSxzPW1lKCksaT10P2UuZ2VuZXJhdGVBbmRJbmplY3RTdHlsZXMoRSxvLHMpOmUuZ2VuZXJhdGVBbmRJbmplY3RTdHlsZXMobixvLHMpO3JldHVyblwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJmwoaSksXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmIXQmJnImJnIoaSksaX0oaSxyLHksXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOVj9lLndhcm5Ub29NYW55Q2xhc3Nlczp2b2lkIDApLHc9bixfPWcuJGFzfHx0LiRhc3x8Zy5hc3x8dC5hc3x8cCxOPWtlKF8pLEE9ZyE9PXQ/dih7fSx0LHt9LGcpOnQsQz17fTtmb3IodmFyIEkgaW4gQSlcIiRcIiE9PUlbMF0mJlwiYXNcIiE9PUkmJihcImZvcndhcmRlZEFzXCI9PT1JP0MuYXM9QVtJXTooZD9kKEksbSxfKTohTnx8bShJKSkmJihDW0ldPUFbSV0pKTtyZXR1cm4gdC5zdHlsZSYmZy5zdHlsZSE9PXQuc3R5bGUmJihDLnN0eWxlPXYoe30sdC5zdHlsZSx7fSxnLnN0eWxlKSksQy5jbGFzc05hbWU9QXJyYXkucHJvdG90eXBlLmNvbmNhdChjLGgsUyE9PWg/UzpudWxsLHQuY2xhc3NOYW1lLGcuY2xhc3NOYW1lKS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIiksQy5yZWY9dyx1KF8sQyl9KEMsZSx0LFApfTtyZXR1cm4gTy5kaXNwbGF5TmFtZT1mLChDPXIuZm9yd2FyZFJlZihPKSkuYXR0cnM9UyxDLmNvbXBvbmVudFN0eWxlPUksQy5kaXNwbGF5TmFtZT1mLEMuc2hvdWxkRm9yd2FyZFByb3A9QSxDLmZvbGRlZENvbXBvbmVudElkcz1vP0FycmF5LnByb3RvdHlwZS5jb25jYXQoZS5mb2xkZWRDb21wb25lbnRJZHMsZS5zdHlsZWRDb21wb25lbnRJZCk6dyxDLnN0eWxlZENvbXBvbmVudElkPWcsQy50YXJnZXQ9bz9lLnRhcmdldDplLEMud2l0aENvbXBvbmVudD1mdW5jdGlvbihlKXt2YXIgcj10LmNvbXBvbmVudElkLG89ZnVuY3Rpb24oZSx0KXtpZihudWxsPT1lKXJldHVybnt9O3ZhciBuLHIsbz17fSxzPU9iamVjdC5rZXlzKGUpO2ZvcihyPTA7cjxzLmxlbmd0aDtyKyspbj1zW3JdLHQuaW5kZXhPZihuKT49MHx8KG9bbl09ZVtuXSk7cmV0dXJuIG99KHQsW1wiY29tcG9uZW50SWRcIl0pLHM9ciYmcitcIi1cIisoa2UoZSk/ZTpUZShfKGUpKSk7cmV0dXJuIHFlKGUsdih7fSxvLHthdHRyczpTLGNvbXBvbmVudElkOnN9KSxuKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KEMsXCJkZWZhdWx0UHJvcHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2ZvbGRlZERlZmF1bHRQcm9wc30sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuX2ZvbGRlZERlZmF1bHRQcm9wcz1vP01lKHt9LGUuZGVmYXVsdFByb3BzLHQpOnR9fSksXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmKE9lKGYsZyksQy53YXJuVG9vTWFueUNsYXNzZXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj17fSxyPSExO3JldHVybiBmdW5jdGlvbihvKXtpZighciYmKG5bb109ITAsT2JqZWN0LmtleXMobikubGVuZ3RoPj0yMDApKXt2YXIgcz10Pycgd2l0aCB0aGUgaWQgb2YgXCInK3QrJ1wiJzpcIlwiO2NvbnNvbGUud2FybihcIk92ZXIgMjAwIGNsYXNzZXMgd2VyZSBnZW5lcmF0ZWQgZm9yIGNvbXBvbmVudCBcIitlK3MrXCIuXFxuQ29uc2lkZXIgdXNpbmcgdGhlIGF0dHJzIG1ldGhvZCwgdG9nZXRoZXIgd2l0aCBhIHN0eWxlIG9iamVjdCBmb3IgZnJlcXVlbnRseSBjaGFuZ2VkIHN0eWxlcy5cXG5FeGFtcGxlOlxcbiAgY29uc3QgQ29tcG9uZW50ID0gc3R5bGVkLmRpdi5hdHRycyhwcm9wcyA9PiAoe1xcbiAgICBzdHlsZToge1xcbiAgICAgIGJhY2tncm91bmQ6IHByb3BzLmJhY2tncm91bmQsXFxuICAgIH0sXFxuICB9KSlgd2lkdGg6IDEwMCU7YFxcblxcbiAgPENvbXBvbmVudCAvPlwiKSxyPSEwLG49e319fX0oZixnKSksQy50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiLlwiK0Muc3R5bGVkQ29tcG9uZW50SWR9LGkmJnkoQyxlLHthdHRyczohMCxjb21wb25lbnRTdHlsZTohMCxkaXNwbGF5TmFtZTohMCxmb2xkZWRDb21wb25lbnRJZHM6ITAsc2hvdWxkRm9yd2FyZFByb3A6ITAsc3R5bGVkQ29tcG9uZW50SWQ6ITAsdGFyZ2V0OiEwLHdpdGhDb21wb25lbnQ6ITB9KSxDfXZhciBIZT1mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24gZSh0LHIsbyl7aWYodm9pZCAwPT09byYmKG89RSksIW4ocikpcmV0dXJuIGooMSxTdHJpbmcocikpO3ZhciBzPWZ1bmN0aW9uKCl7cmV0dXJuIHQocixvLENlLmFwcGx5KHZvaWQgMCxhcmd1bWVudHMpKX07cmV0dXJuIHMud2l0aENvbmZpZz1mdW5jdGlvbihuKXtyZXR1cm4gZSh0LHIsdih7fSxvLHt9LG4pKX0scy5hdHRycz1mdW5jdGlvbihuKXtyZXR1cm4gZSh0LHIsdih7fSxvLHthdHRyczpBcnJheS5wcm90b3R5cGUuY29uY2F0KG8uYXR0cnMsbikuZmlsdGVyKEJvb2xlYW4pfSkpfSxzfShxZSxlKX07W1wiYVwiLFwiYWJiclwiLFwiYWRkcmVzc1wiLFwiYXJlYVwiLFwiYXJ0aWNsZVwiLFwiYXNpZGVcIixcImF1ZGlvXCIsXCJiXCIsXCJiYXNlXCIsXCJiZGlcIixcImJkb1wiLFwiYmlnXCIsXCJibG9ja3F1b3RlXCIsXCJib2R5XCIsXCJiclwiLFwiYnV0dG9uXCIsXCJjYW52YXNcIixcImNhcHRpb25cIixcImNpdGVcIixcImNvZGVcIixcImNvbFwiLFwiY29sZ3JvdXBcIixcImRhdGFcIixcImRhdGFsaXN0XCIsXCJkZFwiLFwiZGVsXCIsXCJkZXRhaWxzXCIsXCJkZm5cIixcImRpYWxvZ1wiLFwiZGl2XCIsXCJkbFwiLFwiZHRcIixcImVtXCIsXCJlbWJlZFwiLFwiZmllbGRzZXRcIixcImZpZ2NhcHRpb25cIixcImZpZ3VyZVwiLFwiZm9vdGVyXCIsXCJmb3JtXCIsXCJoMVwiLFwiaDJcIixcImgzXCIsXCJoNFwiLFwiaDVcIixcImg2XCIsXCJoZWFkXCIsXCJoZWFkZXJcIixcImhncm91cFwiLFwiaHJcIixcImh0bWxcIixcImlcIixcImlmcmFtZVwiLFwiaW1nXCIsXCJpbnB1dFwiLFwiaW5zXCIsXCJrYmRcIixcImtleWdlblwiLFwibGFiZWxcIixcImxlZ2VuZFwiLFwibGlcIixcImxpbmtcIixcIm1haW5cIixcIm1hcFwiLFwibWFya1wiLFwibWFycXVlZVwiLFwibWVudVwiLFwibWVudWl0ZW1cIixcIm1ldGFcIixcIm1ldGVyXCIsXCJuYXZcIixcIm5vc2NyaXB0XCIsXCJvYmplY3RcIixcIm9sXCIsXCJvcHRncm91cFwiLFwib3B0aW9uXCIsXCJvdXRwdXRcIixcInBcIixcInBhcmFtXCIsXCJwaWN0dXJlXCIsXCJwcmVcIixcInByb2dyZXNzXCIsXCJxXCIsXCJycFwiLFwicnRcIixcInJ1YnlcIixcInNcIixcInNhbXBcIixcInNjcmlwdFwiLFwic2VjdGlvblwiLFwic2VsZWN0XCIsXCJzbWFsbFwiLFwic291cmNlXCIsXCJzcGFuXCIsXCJzdHJvbmdcIixcInN0eWxlXCIsXCJzdWJcIixcInN1bW1hcnlcIixcInN1cFwiLFwidGFibGVcIixcInRib2R5XCIsXCJ0ZFwiLFwidGV4dGFyZWFcIixcInRmb290XCIsXCJ0aFwiLFwidGhlYWRcIixcInRpbWVcIixcInRpdGxlXCIsXCJ0clwiLFwidHJhY2tcIixcInVcIixcInVsXCIsXCJ2YXJcIixcInZpZGVvXCIsXCJ3YnJcIixcImNpcmNsZVwiLFwiY2xpcFBhdGhcIixcImRlZnNcIixcImVsbGlwc2VcIixcImZvcmVpZ25PYmplY3RcIixcImdcIixcImltYWdlXCIsXCJsaW5lXCIsXCJsaW5lYXJHcmFkaWVudFwiLFwibWFya2VyXCIsXCJtYXNrXCIsXCJwYXRoXCIsXCJwYXR0ZXJuXCIsXCJwb2x5Z29uXCIsXCJwb2x5bGluZVwiLFwicmFkaWFsR3JhZGllbnRcIixcInJlY3RcIixcInN0b3BcIixcInN2Z1wiLFwidGV4dFwiLFwidGV4dFBhdGhcIixcInRzcGFuXCJdLmZvckVhY2goKGZ1bmN0aW9uKGUpe0hlW2VdPUhlKGUpfSkpO3ZhciAkZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXt0aGlzLnJ1bGVzPWUsdGhpcy5jb21wb25lbnRJZD10LHRoaXMuaXNTdGF0aWM9cmUoZSksWi5yZWdpc3RlcklkKHRoaXMuY29tcG9uZW50SWQrMSl9dmFyIHQ9ZS5wcm90b3R5cGU7cmV0dXJuIHQuY3JlYXRlU3R5bGVzPWZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBvPXIoTmUodGhpcy5ydWxlcyx0LG4scikuam9pbihcIlwiKSxcIlwiKSxzPXRoaXMuY29tcG9uZW50SWQrZTtuLmluc2VydFJ1bGVzKHMscyxvKX0sdC5yZW1vdmVTdHlsZXM9ZnVuY3Rpb24oZSx0KXt0LmNsZWFyUnVsZXModGhpcy5jb21wb25lbnRJZCtlKX0sdC5yZW5kZXJTdHlsZXM9ZnVuY3Rpb24oZSx0LG4scil7ZT4yJiZaLnJlZ2lzdGVySWQodGhpcy5jb21wb25lbnRJZCtlKSx0aGlzLnJlbW92ZVN0eWxlcyhlLG4pLHRoaXMuY3JlYXRlU3R5bGVzKGUsdCxuLHIpfSxlfSgpO2Z1bmN0aW9uIFdlKGUpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLG49bmV3IEFycmF5KHQ+MT90LTE6MCksbz0xO288dDtvKyspbltvLTFdPWFyZ3VtZW50c1tvXTt2YXIgaT1DZS5hcHBseSh2b2lkIDAsW2VdLmNvbmNhdChuKSksYT1cInNjLWdsb2JhbC1cIit4ZShKU09OLnN0cmluZ2lmeShpKSksdT1uZXcgJGUoaSxhKTtmdW5jdGlvbiBsKGUpe3ZhciB0PWZlKCksbj1tZSgpLG89cyhHZSksbD1jKHQuYWxsb2NhdGVHU0luc3RhbmNlKGEpKS5jdXJyZW50O3JldHVyblwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJnIuQ2hpbGRyZW4uY291bnQoZS5jaGlsZHJlbikmJmNvbnNvbGUud2FybihcIlRoZSBnbG9iYWwgc3R5bGUgY29tcG9uZW50IFwiK2ErXCIgd2FzIGdpdmVuIGNoaWxkIEpTWC4gY3JlYXRlR2xvYmFsU3R5bGUgZG9lcyBub3QgcmVuZGVyIGNoaWxkcmVuLlwiKSxcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZpLnNvbWUoKGZ1bmN0aW9uKGUpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlJiYtMSE9PWUuaW5kZXhPZihcIkBpbXBvcnRcIil9KSkmJmNvbnNvbGUud2FybihcIlBsZWFzZSBkbyBub3QgdXNlIEBpbXBvcnQgQ1NTIHN5bnRheCBpbiBjcmVhdGVHbG9iYWxTdHlsZSBhdCB0aGlzIHRpbWUsIGFzIHRoZSBDU1NPTSBBUElzIHdlIHVzZSBpbiBwcm9kdWN0aW9uIGRvIG5vdCBoYW5kbGUgaXQgd2VsbC4gSW5zdGVhZCwgd2UgcmVjb21tZW5kIHVzaW5nIGEgbGlicmFyeSBzdWNoIGFzIHJlYWN0LWhlbG1ldCB0byBpbmplY3QgYSB0eXBpY2FsIDxsaW5rPiBtZXRhIHRhZyB0byB0aGUgc3R5bGVzaGVldCwgb3Igc2ltcGx5IGVtYmVkZGluZyBpdCBtYW51YWxseSBpbiB5b3VyIGluZGV4Lmh0bWwgPGhlYWQ+IHNlY3Rpb24gZm9yIGEgc2ltcGxlciBhcHAuXCIpLHQuc2VydmVyJiZoKGwsZSx0LG8sbiksZCgoZnVuY3Rpb24oKXtpZighdC5zZXJ2ZXIpcmV0dXJuIGgobCxlLHQsbyxuKSxmdW5jdGlvbigpe3JldHVybiB1LnJlbW92ZVN0eWxlcyhsLHQpfX0pLFtsLGUsdCxvLG5dKSxudWxsfWZ1bmN0aW9uIGgoZSx0LG4scixvKXtpZih1LmlzU3RhdGljKXUucmVuZGVyU3R5bGVzKGUsTyxuLG8pO2Vsc2V7dmFyIHM9dih7fSx0LHt0aGVtZTpSZSh0LHIsbC5kZWZhdWx0UHJvcHMpfSk7dS5yZW5kZXJTdHlsZXMoZSxzLG4sbyl9fXJldHVyblwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJk9lKGEpLHIubWVtbyhsKX1mdW5jdGlvbiBVZShlKXtcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbmF2aWdhdG9yJiZcIlJlYWN0TmF0aXZlXCI9PT1uYXZpZ2F0b3IucHJvZHVjdCYmY29uc29sZS53YXJuKFwiYGtleWZyYW1lc2AgY2Fubm90IGJlIHVzZWQgb24gUmVhY3ROYXRpdmUsIG9ubHkgb24gdGhlIHdlYi4gVG8gZG8gYW5pbWF0aW9uIGluIFJlYWN0TmF0aXZlIHBsZWFzZSB1c2UgQW5pbWF0ZWQuXCIpO2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLG49bmV3IEFycmF5KHQ+MT90LTE6MCkscj0xO3I8dDtyKyspbltyLTFdPWFyZ3VtZW50c1tyXTt2YXIgbz1DZS5hcHBseSh2b2lkIDAsW2VdLmNvbmNhdChuKSkuam9pbihcIlwiKSxzPXhlKG8pO3JldHVybiBuZXcgdmUocyxvKX12YXIgSmU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7dmFyIGU9dGhpczt0aGlzLl9lbWl0U2hlZXRDU1M9ZnVuY3Rpb24oKXt2YXIgdD1lLmluc3RhbmNlLnRvU3RyaW5nKCk7aWYoIXQpcmV0dXJuXCJcIjt2YXIgbj1xKCk7cmV0dXJuXCI8c3R5bGUgXCIrW24mJidub25jZT1cIicrbisnXCInLEErJz1cInRydWVcIicsJ2RhdGEtc3R5bGVkLXZlcnNpb249XCI1LjMuNVwiJ10uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpK1wiPlwiK3QrXCI8L3N0eWxlPlwifSx0aGlzLmdldFN0eWxlVGFncz1mdW5jdGlvbigpe3JldHVybiBlLnNlYWxlZD9qKDIpOmUuX2VtaXRTaGVldENTUygpfSx0aGlzLmdldFN0eWxlRWxlbWVudD1mdW5jdGlvbigpe3ZhciB0O2lmKGUuc2VhbGVkKXJldHVybiBqKDIpO3ZhciBuPSgodD17fSlbQV09XCJcIix0W1wiZGF0YS1zdHlsZWQtdmVyc2lvblwiXT1cIjUuMy41XCIsdC5kYW5nZXJvdXNseVNldElubmVySFRNTD17X19odG1sOmUuaW5zdGFuY2UudG9TdHJpbmcoKX0sdCksbz1xKCk7cmV0dXJuIG8mJihuLm5vbmNlPW8pLFtyLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiLHYoe30sbix7a2V5Olwic2MtMC0wXCJ9KSldfSx0aGlzLnNlYWw9ZnVuY3Rpb24oKXtlLnNlYWxlZD0hMH0sdGhpcy5pbnN0YW5jZT1uZXcgWih7aXNTZXJ2ZXI6ITB9KSx0aGlzLnNlYWxlZD0hMX12YXIgdD1lLnByb3RvdHlwZTtyZXR1cm4gdC5jb2xsZWN0U3R5bGVzPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnNlYWxlZD9qKDIpOnIuY3JlYXRlRWxlbWVudCh5ZSx7c2hlZXQ6dGhpcy5pbnN0YW5jZX0sZSl9LHQuaW50ZXJsZWF2ZVdpdGhOb2RlU3RyZWFtPWZ1bmN0aW9uKGUpe3JldHVybiBqKDMpfSxlfSgpLFhlPWZ1bmN0aW9uKGUpe3ZhciB0PXIuZm9yd2FyZFJlZigoZnVuY3Rpb24odCxuKXt2YXIgbz1zKEdlKSxpPWUuZGVmYXVsdFByb3BzLGE9UmUodCxvLGkpO3JldHVyblwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJnZvaWQgMD09PWEmJmNvbnNvbGUud2FybignW3dpdGhUaGVtZV0gWW91IGFyZSBub3QgdXNpbmcgYSBUaGVtZVByb3ZpZGVyIG5vciBwYXNzaW5nIGEgdGhlbWUgcHJvcCBvciBhIHRoZW1lIGluIGRlZmF1bHRQcm9wcyBpbiBjb21wb25lbnQgY2xhc3MgXCInK18oZSkrJ1wiJyksci5jcmVhdGVFbGVtZW50KGUsdih7fSx0LHt0aGVtZTphLHJlZjpufSkpfSkpO3JldHVybiB5KHQsZSksdC5kaXNwbGF5TmFtZT1cIldpdGhUaGVtZShcIitfKGUpK1wiKVwiLHR9LFplPWZ1bmN0aW9uKCl7cmV0dXJuIHMoR2UpfSxLZT17U3R5bGVTaGVldDpaLG1hc3RlclNoZWV0OmhlfTtcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbmF2aWdhdG9yJiZcIlJlYWN0TmF0aXZlXCI9PT1uYXZpZ2F0b3IucHJvZHVjdCYmY29uc29sZS53YXJuKFwiSXQgbG9va3MgbGlrZSB5b3UndmUgaW1wb3J0ZWQgJ3N0eWxlZC1jb21wb25lbnRzJyBvbiBSZWFjdCBOYXRpdmUuXFxuUGVyaGFwcyB5b3UncmUgbG9va2luZyB0byBpbXBvcnQgJ3N0eWxlZC1jb21wb25lbnRzL25hdGl2ZSc/XFxuUmVhZCBtb3JlIGFib3V0IHRoaXMgYXQgaHR0cHM6Ly93d3cuc3R5bGVkLWNvbXBvbmVudHMuY29tL2RvY3MvYmFzaWNzI3JlYWN0LW5hdGl2ZVwiKSxcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZcInRlc3RcIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiYod2luZG93W1wiX19zdHlsZWQtY29tcG9uZW50cy1pbml0X19cIl09d2luZG93W1wiX19zdHlsZWQtY29tcG9uZW50cy1pbml0X19cIl18fDAsMT09PXdpbmRvd1tcIl9fc3R5bGVkLWNvbXBvbmVudHMtaW5pdF9fXCJdJiZjb25zb2xlLndhcm4oXCJJdCBsb29rcyBsaWtlIHRoZXJlIGFyZSBzZXZlcmFsIGluc3RhbmNlcyBvZiAnc3R5bGVkLWNvbXBvbmVudHMnIGluaXRpYWxpemVkIGluIHRoaXMgYXBwbGljYXRpb24uIFRoaXMgbWF5IGNhdXNlIGR5bmFtaWMgc3R5bGVzIHRvIG5vdCByZW5kZXIgcHJvcGVybHksIGVycm9ycyBkdXJpbmcgdGhlIHJlaHlkcmF0aW9uIHByb2Nlc3MsIGEgbWlzc2luZyB0aGVtZSBwcm9wLCBhbmQgbWFrZXMgeW91ciBhcHBsaWNhdGlvbiBiaWdnZXIgd2l0aG91dCBnb29kIHJlYXNvbi5cXG5cXG5TZWUgaHR0cHM6Ly9zLWMuc2gvMkJBWHplZCBmb3IgbW9yZSBpbmZvLlwiKSx3aW5kb3dbXCJfX3N0eWxlZC1jb21wb25lbnRzLWluaXRfX1wiXSs9MSk7ZXhwb3J0IGRlZmF1bHQgSGU7ZXhwb3J0e0plIGFzIFNlcnZlclN0eWxlU2hlZXQsbGUgYXMgU3R5bGVTaGVldENvbnN1bWVyLHVlIGFzIFN0eWxlU2hlZXRDb250ZXh0LHllIGFzIFN0eWxlU2hlZXRNYW5hZ2VyLExlIGFzIFRoZW1lQ29uc3VtZXIsR2UgYXMgVGhlbWVDb250ZXh0LEZlIGFzIFRoZW1lUHJvdmlkZXIsS2UgYXMgX19QUklWQVRFX18sV2UgYXMgY3JlYXRlR2xvYmFsU3R5bGUsQ2UgYXMgY3NzLE4gYXMgaXNTdHlsZWRDb21wb25lbnQsVWUgYXMga2V5ZnJhbWVzLFplIGFzIHVzZVRoZW1lLEMgYXMgdmVyc2lvbixYZSBhcyB3aXRoVGhlbWV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3R5bGVkLWNvbXBvbmVudHMuYnJvd3Nlci5lc20uanMubWFwXG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4IGFzIF9qc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmV4cG9ydCBjb25zdCBERUZBVUxUX0JSRUFLUE9JTlRTID0gWyd4eGwnLCAneGwnLCAnbGcnLCAnbWQnLCAnc20nLCAneHMnXTtcbmNvbnN0IFRoZW1lQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgcHJlZml4ZXM6IHt9LFxuICBicmVha3BvaW50czogREVGQVVMVF9CUkVBS1BPSU5UU1xufSk7XG5jb25zdCB7XG4gIENvbnN1bWVyLFxuICBQcm92aWRlclxufSA9IFRoZW1lQ29udGV4dDtcblxuZnVuY3Rpb24gVGhlbWVQcm92aWRlcih7XG4gIHByZWZpeGVzID0ge30sXG4gIGJyZWFrcG9pbnRzID0gREVGQVVMVF9CUkVBS1BPSU5UUyxcbiAgZGlyLFxuICBjaGlsZHJlblxufSkge1xuICBjb25zdCBjb250ZXh0VmFsdWUgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgcHJlZml4ZXM6IHsgLi4ucHJlZml4ZXNcbiAgICB9LFxuICAgIGJyZWFrcG9pbnRzLFxuICAgIGRpclxuICB9KSwgW3ByZWZpeGVzLCBicmVha3BvaW50cywgZGlyXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovX2pzeChQcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0VmFsdWUsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQm9vdHN0cmFwUHJlZml4KHByZWZpeCwgZGVmYXVsdFByZWZpeCkge1xuICBjb25zdCB7XG4gICAgcHJlZml4ZXNcbiAgfSA9IHVzZUNvbnRleHQoVGhlbWVDb250ZXh0KTtcbiAgcmV0dXJuIHByZWZpeCB8fCBwcmVmaXhlc1tkZWZhdWx0UHJlZml4XSB8fCBkZWZhdWx0UHJlZml4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZUJvb3RzdHJhcEJyZWFrcG9pbnRzKCkge1xuICBjb25zdCB7XG4gICAgYnJlYWtwb2ludHNcbiAgfSA9IHVzZUNvbnRleHQoVGhlbWVDb250ZXh0KTtcbiAgcmV0dXJuIGJyZWFrcG9pbnRzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZUlzUlRMKCkge1xuICBjb25zdCB7XG4gICAgZGlyXG4gIH0gPSB1c2VDb250ZXh0KFRoZW1lQ29udGV4dCk7XG4gIHJldHVybiBkaXIgPT09ICdydGwnO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVCb290c3RyYXBDb21wb25lbnQoQ29tcG9uZW50LCBvcHRzKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpIG9wdHMgPSB7XG4gICAgcHJlZml4OiBvcHRzXG4gIH07XG4gIGNvbnN0IGlzQ2xhc3N5ID0gQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ7IC8vIElmIGl0J3MgYSBmdW5jdGlvbmFsIGNvbXBvbmVudCBtYWtlIHN1cmUgd2UgZG9uJ3QgYnJlYWsgaXQgd2l0aCBhIHJlZlxuXG4gIGNvbnN0IHtcbiAgICBwcmVmaXgsXG4gICAgZm9yd2FyZFJlZkFzID0gaXNDbGFzc3kgPyAncmVmJyA6ICdpbm5lclJlZidcbiAgfSA9IG9wdHM7XG4gIGNvbnN0IFdyYXBwZWQgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigoeyAuLi5wcm9wc1xuICB9LCByZWYpID0+IHtcbiAgICBwcm9wc1tmb3J3YXJkUmVmQXNdID0gcmVmO1xuICAgIGNvbnN0IGJzUHJlZml4ID0gdXNlQm9vdHN0cmFwUHJlZml4KHByb3BzLmJzUHJlZml4LCBwcmVmaXgpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovX2pzeChDb21wb25lbnQsIHsgLi4ucHJvcHMsXG4gICAgICBic1ByZWZpeDogYnNQcmVmaXhcbiAgICB9KTtcbiAgfSk7XG4gIFdyYXBwZWQuZGlzcGxheU5hbWUgPSBgQm9vdHN0cmFwKCR7Q29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lfSlgO1xuICByZXR1cm4gV3JhcHBlZDtcbn1cblxuZXhwb3J0IHsgY3JlYXRlQm9vdHN0cmFwQ29tcG9uZW50LCBDb25zdW1lciBhcyBUaGVtZUNvbnN1bWVyIH07XG5leHBvcnQgZGVmYXVsdCBUaGVtZVByb3ZpZGVyOyIsImltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlQm9vdHN0cmFwUHJlZml4IH0gZnJvbSAnLi9UaGVtZVByb3ZpZGVyJztcbmltcG9ydCB7IGpzeCBhcyBfanN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGZsdWlkOiBmYWxzZVxufTtcbmNvbnN0IENvbnRhaW5lciA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKCh7XG4gIGJzUHJlZml4LFxuICBmbHVpZCxcbiAgLy8gTmVlZCB0byBkZWZpbmUgdGhlIGRlZmF1bHQgXCJhc1wiIGR1cmluZyBwcm9wIGRlc3RydWN0dXJpbmcgdG8gYmUgY29tcGF0aWJsZSB3aXRoIHN0eWxlZC1jb21wb25lbnRzIGdpdGh1Yi5jb20vcmVhY3QtYm9vdHN0cmFwL3JlYWN0LWJvb3RzdHJhcC9pc3N1ZXMvMzU5NVxuICBhczogQ29tcG9uZW50ID0gJ2RpdicsXG4gIGNsYXNzTmFtZSxcbiAgLi4ucHJvcHNcbn0sIHJlZikgPT4ge1xuICBjb25zdCBwcmVmaXggPSB1c2VCb290c3RyYXBQcmVmaXgoYnNQcmVmaXgsICdjb250YWluZXInKTtcbiAgY29uc3Qgc3VmZml4ID0gdHlwZW9mIGZsdWlkID09PSAnc3RyaW5nJyA/IGAtJHtmbHVpZH1gIDogJy1mbHVpZCc7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovX2pzeChDb21wb25lbnQsIHtcbiAgICByZWY6IHJlZixcbiAgICAuLi5wcm9wcyxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMoY2xhc3NOYW1lLCBmbHVpZCA/IGAke3ByZWZpeH0ke3N1ZmZpeH1gIDogcHJlZml4KVxuICB9KTtcbn0pO1xuQ29udGFpbmVyLmRpc3BsYXlOYW1lID0gJ0NvbnRhaW5lcic7XG5Db250YWluZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuZXhwb3J0IGRlZmF1bHQgQ29udGFpbmVyOyIsImltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlQm9vdHN0cmFwUHJlZml4LCB1c2VCb290c3RyYXBCcmVha3BvaW50cyB9IGZyb20gJy4vVGhlbWVQcm92aWRlcic7XG5pbXBvcnQgeyBqc3ggYXMgX2pzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuY29uc3QgUm93ID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHtcbiAgYnNQcmVmaXgsXG4gIGNsYXNzTmFtZSxcbiAgLy8gTmVlZCB0byBkZWZpbmUgdGhlIGRlZmF1bHQgXCJhc1wiIGR1cmluZyBwcm9wIGRlc3RydWN0dXJpbmcgdG8gYmUgY29tcGF0aWJsZSB3aXRoIHN0eWxlZC1jb21wb25lbnRzIGdpdGh1Yi5jb20vcmVhY3QtYm9vdHN0cmFwL3JlYWN0LWJvb3RzdHJhcC9pc3N1ZXMvMzU5NVxuICBhczogQ29tcG9uZW50ID0gJ2RpdicsXG4gIC4uLnByb3BzXG59LCByZWYpID0+IHtcbiAgY29uc3QgZGVjb3JhdGVkQnNQcmVmaXggPSB1c2VCb290c3RyYXBQcmVmaXgoYnNQcmVmaXgsICdyb3cnKTtcbiAgY29uc3QgYnJlYWtwb2ludHMgPSB1c2VCb290c3RyYXBCcmVha3BvaW50cygpO1xuICBjb25zdCBzaXplUHJlZml4ID0gYCR7ZGVjb3JhdGVkQnNQcmVmaXh9LWNvbHNgO1xuICBjb25zdCBjbGFzc2VzID0gW107XG4gIGJyZWFrcG9pbnRzLmZvckVhY2goYnJrUG9pbnQgPT4ge1xuICAgIGNvbnN0IHByb3BWYWx1ZSA9IHByb3BzW2Jya1BvaW50XTtcbiAgICBkZWxldGUgcHJvcHNbYnJrUG9pbnRdO1xuICAgIGxldCBjb2xzO1xuXG4gICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAoe1xuICAgICAgICBjb2xzXG4gICAgICB9ID0gcHJvcFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29scyA9IHByb3BWYWx1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBpbmZpeCA9IGJya1BvaW50ICE9PSAneHMnID8gYC0ke2Jya1BvaW50fWAgOiAnJztcbiAgICBpZiAoY29scyAhPSBudWxsKSBjbGFzc2VzLnB1c2goYCR7c2l6ZVByZWZpeH0ke2luZml4fS0ke2NvbHN9YCk7XG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL19qc3goQ29tcG9uZW50LCB7XG4gICAgcmVmOiByZWYsXG4gICAgLi4ucHJvcHMsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzKGNsYXNzTmFtZSwgZGVjb3JhdGVkQnNQcmVmaXgsIC4uLmNsYXNzZXMpXG4gIH0pO1xufSk7XG5Sb3cuZGlzcGxheU5hbWUgPSAnUm93JztcbmV4cG9ydCBkZWZhdWx0IFJvdzsiLCJpbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUJvb3RzdHJhcFByZWZpeCwgdXNlQm9vdHN0cmFwQnJlYWtwb2ludHMgfSBmcm9tICcuL1RoZW1lUHJvdmlkZXInO1xuaW1wb3J0IHsganN4IGFzIF9qc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmV4cG9ydCBmdW5jdGlvbiB1c2VDb2woe1xuICBhcyxcbiAgYnNQcmVmaXgsXG4gIGNsYXNzTmFtZSxcbiAgLi4ucHJvcHNcbn0pIHtcbiAgYnNQcmVmaXggPSB1c2VCb290c3RyYXBQcmVmaXgoYnNQcmVmaXgsICdjb2wnKTtcbiAgY29uc3QgYnJlYWtwb2ludHMgPSB1c2VCb290c3RyYXBCcmVha3BvaW50cygpO1xuICBjb25zdCBzcGFucyA9IFtdO1xuICBjb25zdCBjbGFzc2VzID0gW107XG4gIGJyZWFrcG9pbnRzLmZvckVhY2goYnJrUG9pbnQgPT4ge1xuICAgIGNvbnN0IHByb3BWYWx1ZSA9IHByb3BzW2Jya1BvaW50XTtcbiAgICBkZWxldGUgcHJvcHNbYnJrUG9pbnRdO1xuICAgIGxldCBzcGFuO1xuICAgIGxldCBvZmZzZXQ7XG4gICAgbGV0IG9yZGVyO1xuXG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICdvYmplY3QnICYmIHByb3BWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAoe1xuICAgICAgICBzcGFuLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIG9yZGVyXG4gICAgICB9ID0gcHJvcFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3BhbiA9IHByb3BWYWx1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBpbmZpeCA9IGJya1BvaW50ICE9PSAneHMnID8gYC0ke2Jya1BvaW50fWAgOiAnJztcbiAgICBpZiAoc3Bhbikgc3BhbnMucHVzaChzcGFuID09PSB0cnVlID8gYCR7YnNQcmVmaXh9JHtpbmZpeH1gIDogYCR7YnNQcmVmaXh9JHtpbmZpeH0tJHtzcGFufWApO1xuICAgIGlmIChvcmRlciAhPSBudWxsKSBjbGFzc2VzLnB1c2goYG9yZGVyJHtpbmZpeH0tJHtvcmRlcn1gKTtcbiAgICBpZiAob2Zmc2V0ICE9IG51bGwpIGNsYXNzZXMucHVzaChgb2Zmc2V0JHtpbmZpeH0tJHtvZmZzZXR9YCk7XG4gIH0pO1xuICByZXR1cm4gW3sgLi4ucHJvcHMsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzKGNsYXNzTmFtZSwgLi4uc3BhbnMsIC4uLmNsYXNzZXMpXG4gIH0sIHtcbiAgICBhcyxcbiAgICBic1ByZWZpeCxcbiAgICBzcGFuc1xuICB9XTtcbn1cbmNvbnN0IENvbCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKCAvLyBOZWVkIHRvIGRlZmluZSB0aGUgZGVmYXVsdCBcImFzXCIgZHVyaW5nIHByb3AgZGVzdHJ1Y3R1cmluZyB0byBiZSBjb21wYXRpYmxlIHdpdGggc3R5bGVkLWNvbXBvbmVudHMgZ2l0aHViLmNvbS9yZWFjdC1ib290c3RyYXAvcmVhY3QtYm9vdHN0cmFwL2lzc3Vlcy8zNTk1XG4ocHJvcHMsIHJlZikgPT4ge1xuICBjb25zdCBbe1xuICAgIGNsYXNzTmFtZSxcbiAgICAuLi5jb2xQcm9wc1xuICB9LCB7XG4gICAgYXM6IENvbXBvbmVudCA9ICdkaXYnLFxuICAgIGJzUHJlZml4LFxuICAgIHNwYW5zXG4gIH1dID0gdXNlQ29sKHByb3BzKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fanN4KENvbXBvbmVudCwgeyAuLi5jb2xQcm9wcyxcbiAgICByZWY6IHJlZixcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMoY2xhc3NOYW1lLCAhc3BhbnMubGVuZ3RoICYmIGJzUHJlZml4KVxuICB9KTtcbn0pO1xuQ29sLmRpc3BsYXlOYW1lID0gJ0NvbCc7XG5leHBvcnQgZGVmYXVsdCBDb2w7IiwiZXhwb3J0IGNvbnN0IGRhcmsgPSAnIzIyMic7XHJcbmV4cG9ydCBjb25zdCBkYXJrQmx1ZSA9ICcjMzM5JztcclxuZXhwb3J0IGNvbnN0IGxpZ2h0Qmx1ZSA9ICcjNzdkJztcclxuXHJcbmV4cG9ydCBjb25zdCBib3JkZXJSYWRpdXMgPSAnN3B4JztcclxuZXhwb3J0IGNvbnN0IGRpYWxEaW1lbnNpb25zID0gJzEyMHB4JztcclxuXHJcbmV4cG9ydCBjb25zdCBkaWFsQmFzZURpbWVuc2lvbnNQeCA9IDk1O1xyXG5cclxuZXhwb3J0IGNvbnN0IERJQUxfVFlQRVMgPSB7XHJcbiAgU0NBTEFSOiAnU0NBTEFSJyxcclxuICBDT09SRFM6ICdDT09SRFMnLFxyXG4gIEFOR0xFOiAnQU5HTEUnLFxyXG4gIFZFQ1RPUjogJ1ZFQ1RPUicsXHJcbn07XHJcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBzdHlsZWQgZnJvbSAnc3R5bGVkLWNvbXBvbmVudHMnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5cclxuaW1wb3J0IENvbnRhaW5lciBmcm9tICdyZWFjdC1ib290c3RyYXAvQ29udGFpbmVyJztcclxuaW1wb3J0IFJvdyBmcm9tICdyZWFjdC1ib290c3RyYXAvUm93JztcclxuaW1wb3J0IENvbCBmcm9tICdyZWFjdC1ib290c3RyYXAvQ29sJztcclxuXHJcbmltcG9ydCAqIGFzIHVpQ29uc3RhbnRzIGZyb20gJy4uL2NvbnN0YW50cy91aUNvbnN0YW50cyc7XHJcblxyXG5jb25zdCBTdHlsZWRDb250YWluZXIgPSBzdHlsZWQoQ29udGFpbmVyKWBcclxuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xyXG5gO1xyXG5cclxuY29uc3QgQ29udGVudENvbnRhaW5lciA9IHN0eWxlZC5kaXZgXHJcbiAgZGlzcGxheTogZmxleDtcclxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcclxuYDtcclxuXHJcbmNvbnN0IFRvcENvbnRhaW5lciA9IHN0eWxlZC5kaXZgXHJcbiAgYmFja2dyb3VuZC1jb2xvcjogJHt1aUNvbnN0YW50cy5kYXJrQmx1ZX07XHJcbiAgd2lkdGg6IDYwMHB4O1xyXG4gIGhlaWdodDogNjAwcHg7XHJcblxyXG4gIEBtZWRpYSBvbmx5IHNjcmVlbiBhbmQgKG1heC13aWR0aDogNjAwcHgpIHtcclxuICAgIHdpZHRoOiAxMDB2dztcclxuICAgIGhlaWdodDogMTAwdnc7XHJcbiAgfVxyXG5gO1xyXG5cclxuY29uc3QgRGVmYXVsdFNpbXVsYXRpb25WaWV3ID0gc3R5bGVkLmRpdmBcclxuICBjb2xvcjogI2ZmZjtcclxuYDtcclxuXHJcbmNvbnN0IERlZmF1bHRDb250ZW50VmlldyA9IHN0eWxlZC5kaXZgICBcclxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZGRkO1xyXG4gIGNvbG9yOiAjMjIyO1xyXG4gIHdpZHRoOiA4MDBweDtcclxuICBcclxuICBAbWVkaWEgb25seSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDgwMHB4KSB7XHJcbiAgICB3aWR0aDogMTAwdnc7XHJcbiAgfVxyXG5gO1xyXG5cclxuY29uc3QgRGVmYXVsdFNpbXVsYXRpb25WaWV3Q29tcG9uZW50ID0gKHsgLi4ucHJvcHMgfSkgPT4ge1xyXG4gIHJldHVybiAoXHJcbiAgICA8RGVmYXVsdFNpbXVsYXRpb25WaWV3PlNpbXVsYWF0aW88L0RlZmF1bHRTaW11bGF0aW9uVmlldz5cclxuICApO1xyXG59O1xyXG5cclxuY29uc3QgRGVmYXVsdENvbnRlbnRWaWV3Q29tcG9uZW50ID0gKHsgLi4ucHJvcHMgfSkgPT4ge1xyXG4gIHJldHVybiAoXHJcbiAgICA8RGVmYXVsdENvbnRlbnRWaWV3PlNpc8OkbHTDtjwvRGVmYXVsdENvbnRlbnRWaWV3PlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgRGFzaGJvYXJkVGVtcGxhdGUgPSAoe1xyXG4gIFNpbXVsYXRpb25WaWV3LFxyXG4gIENvbnRlbnRWaWV3LFxyXG4gIC4uLnByb3BzXHJcbn0pID0+IHtcclxuICByZXR1cm4gKFxyXG4gICAgPFN0eWxlZENvbnRhaW5lcj5cclxuICAgICAgPFJvdz5cclxuICAgICAgICA8Q29sPlxyXG4gICAgICAgICAgPENvbnRlbnRDb250YWluZXI+XHJcbiAgICAgICAgICAgIDxUb3BDb250YWluZXI+XHJcbiAgICAgICAgICAgICAgPFNpbXVsYXRpb25WaWV3IC8+XHJcbiAgICAgICAgICAgIDwvVG9wQ29udGFpbmVyPlxyXG4gICAgICAgICAgPC9Db250ZW50Q29udGFpbmVyPlxyXG4gICAgICAgIDwvQ29sPlxyXG4gICAgICA8L1Jvdz5cclxuICAgICAgPFJvdz5cclxuICAgICAgICA8Q29sPlxyXG4gICAgICAgICAgPENvbnRlbnRDb250YWluZXI+XHJcbiAgICAgICAgICAgIDxDb250ZW50VmlldyAvPlxyXG4gICAgICAgICAgPC9Db250ZW50Q29udGFpbmVyPlxyXG4gICAgICAgIDwvQ29sPlxyXG4gICAgICA8L1Jvdz5cclxuICAgICAgPFJvdz5cclxuICAgICAgICA8Q29sPlxyXG4gICAgICAgICAgPGRpdiBpZD1cImRlYnVnVmlld1wiIC8+XHJcbiAgICAgICAgPC9Db2w+XHJcbiAgICAgIDwvUm93PlxyXG4gICAgPC9TdHlsZWRDb250YWluZXI+XHJcbiAgKTtcclxufTtcclxuXHJcbkRhc2hib2FyZFRlbXBsYXRlLmRlZmF1bHRQcm9wcyA9IHtcclxuICBTaW11bGF0aW9uVmlldzogRGVmYXVsdFNpbXVsYXRpb25WaWV3Q29tcG9uZW50LFxyXG4gIENvbnRlbnRWaWV3OiBEZWZhdWx0Q29udGVudFZpZXdDb21wb25lbnQsXHJcbn07XHJcblxyXG5EYXNoYm9hcmRUZW1wbGF0ZS5wcm9wVHlwZXMgPSB7XHJcbiAgU2ltdWxhdGlvblZpZXc6IFByb3BUeXBlcy5lbGVtZW50VHlwZSxcclxuICBDb250ZW50VmlldzogUHJvcFR5cGVzLmVsZW1lbnRUeXBlLFxyXG59O1xyXG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59IiwiaW1wb3J0IHNldFByb3RvdHlwZU9mIGZyb20gXCIuL3NldFByb3RvdHlwZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn0iLCIvKipcclxuICogQSBjb2xsZWN0aW9uIG9mIHNoaW1zIHRoYXQgcHJvdmlkZSBtaW5pbWFsIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIEVTNiBjb2xsZWN0aW9ucy5cclxuICpcclxuICogVGhlc2UgaW1wbGVtZW50YXRpb25zIGFyZSBub3QgbWVhbnQgdG8gYmUgdXNlZCBvdXRzaWRlIG9mIHRoZSBSZXNpemVPYnNlcnZlclxyXG4gKiBtb2R1bGVzIGFzIHRoZXkgY292ZXIgb25seSBhIGxpbWl0ZWQgcmFuZ2Ugb2YgdXNlIGNhc2VzLlxyXG4gKi9cclxuLyogZXNsaW50LWRpc2FibGUgcmVxdWlyZS1qc2RvYywgdmFsaWQtanNkb2MgKi9cclxudmFyIE1hcFNoaW0gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hcDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBpbmRleCBpbiBwcm92aWRlZCBhcnJheSB0aGF0IG1hdGNoZXMgdGhlIHNwZWNpZmllZCBrZXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheTxBcnJheT59IGFyclxyXG4gICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldEluZGV4KGFyciwga2V5KSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IC0xO1xyXG4gICAgICAgIGFyci5zb21lKGZ1bmN0aW9uIChlbnRyeSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgaWYgKGVudHJ5WzBdID09PSBrZXkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX19lbnRyaWVzX18gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzXzEucHJvdG90eXBlLCBcInNpemVcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZW50cmllc19fLmxlbmd0aDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XHJcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuX19lbnRyaWVzX19baW5kZXhdO1xyXG4gICAgICAgICAgICByZXR1cm4gZW50cnkgJiYgZW50cnlbMV07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleCh0aGlzLl9fZW50cmllc19fLCBrZXkpO1xyXG4gICAgICAgICAgICBpZiAofmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZW50cmllc19fW2luZGV4XVsxXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfXy5wdXNoKFtrZXksIHZhbHVlXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICB2YXIgZW50cmllcyA9IHRoaXMuX19lbnRyaWVzX187XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4KGVudHJpZXMsIGtleSk7XHJcbiAgICAgICAgICAgIGlmICh+aW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGVudHJpZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIX5nZXRJbmRleCh0aGlzLl9fZW50cmllc19fLCBrZXkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX19lbnRyaWVzX18uc3BsaWNlKDApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgICAgICAgKiBAcGFyYW0geyp9IFtjdHg9bnVsbF1cclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjdHgpIHtcclxuICAgICAgICAgICAgaWYgKGN0eCA9PT0gdm9pZCAwKSB7IGN0eCA9IG51bGw7IH1cclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX19lbnRyaWVzX187IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKGN0eCwgZW50cnlbMV0sIGVudHJ5WzBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGNsYXNzXzE7XHJcbiAgICB9KCkpO1xyXG59KSgpO1xuXG4vKipcclxuICogRGV0ZWN0cyB3aGV0aGVyIHdpbmRvdyBhbmQgZG9jdW1lbnQgb2JqZWN0cyBhcmUgYXZhaWxhYmxlIGluIGN1cnJlbnQgZW52aXJvbm1lbnQuXHJcbiAqL1xyXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgPT09IGRvY3VtZW50O1xuXG4vLyBSZXR1cm5zIGdsb2JhbCBvYmplY3Qgb2YgYSBjdXJyZW50IGVudmlyb25tZW50LlxyXG52YXIgZ2xvYmFsJDEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbC5NYXRoID09PSBNYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09PSBNYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT09IE1hdGgpIHtcclxuICAgICAgICByZXR1cm4gd2luZG93O1xyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXHJcbiAgICByZXR1cm4gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcclxufSkoKTtcblxuLyoqXHJcbiAqIEEgc2hpbSBmb3IgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSB3aGljaCBmYWxscyBiYWNrIHRvIHRoZSBzZXRUaW1lb3V0IGlmXHJcbiAqIGZpcnN0IG9uZSBpcyBub3Qgc3VwcG9ydGVkLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXF1ZXN0cycgaWRlbnRpZmllci5cclxuICovXHJcbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIC8vIEl0J3MgcmVxdWlyZWQgdG8gdXNlIGEgYm91bmRlZCBmdW5jdGlvbiBiZWNhdXNlIElFIHNvbWV0aW1lcyB0aHJvd3NcclxuICAgICAgICAvLyBhbiBcIkludmFsaWQgY2FsbGluZyBvYmplY3RcIiBlcnJvciBpZiByQUYgaXMgaW52b2tlZCB3aXRob3V0IHRoZSBnbG9iYWxcclxuICAgICAgICAvLyBvYmplY3Qgb24gdGhlIGxlZnQgaGFuZCBzaWRlLlxyXG4gICAgICAgIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZChnbG9iYWwkMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbGxiYWNrKERhdGUubm93KCkpOyB9LCAxMDAwIC8gNjApOyB9O1xyXG59KSgpO1xuXG4vLyBEZWZpbmVzIG1pbmltdW0gdGltZW91dCBiZWZvcmUgYWRkaW5nIGEgdHJhaWxpbmcgY2FsbC5cclxudmFyIHRyYWlsaW5nVGltZW91dCA9IDI7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgd3JhcHBlciBmdW5jdGlvbiB3aGljaCBlbnN1cmVzIHRoYXQgcHJvdmlkZWQgY2FsbGJhY2sgd2lsbCBiZVxyXG4gKiBpbnZva2VkIG9ubHkgb25jZSBkdXJpbmcgdGhlIHNwZWNpZmllZCBkZWxheSBwZXJpb2QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gYmUgaW52b2tlZCBhZnRlciB0aGUgZGVsYXkgcGVyaW9kLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgLSBEZWxheSBhZnRlciB3aGljaCB0byBpbnZva2UgY2FsbGJhY2suXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cclxuICovXHJcbmZ1bmN0aW9uIHRocm90dGxlIChjYWxsYmFjaywgZGVsYXkpIHtcclxuICAgIHZhciBsZWFkaW5nQ2FsbCA9IGZhbHNlLCB0cmFpbGluZ0NhbGwgPSBmYWxzZSwgbGFzdENhbGxUaW1lID0gMDtcclxuICAgIC8qKlxyXG4gICAgICogSW52b2tlcyB0aGUgb3JpZ2luYWwgY2FsbGJhY2sgZnVuY3Rpb24gYW5kIHNjaGVkdWxlcyBuZXcgaW52b2NhdGlvbiBpZlxyXG4gICAgICogdGhlIFwicHJveHlcIiB3YXMgY2FsbGVkIGR1cmluZyBjdXJyZW50IHJlcXVlc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJlc29sdmVQZW5kaW5nKCkge1xyXG4gICAgICAgIGlmIChsZWFkaW5nQ2FsbCkge1xyXG4gICAgICAgICAgICBsZWFkaW5nQ2FsbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHJhaWxpbmdDYWxsKSB7XHJcbiAgICAgICAgICAgIHByb3h5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjayBpbnZva2VkIGFmdGVyIHRoZSBzcGVjaWZpZWQgZGVsYXkuIEl0IHdpbGwgZnVydGhlciBwb3N0cG9uZVxyXG4gICAgICogaW52b2NhdGlvbiBvZiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gZGVsZWdhdGluZyBpdCB0byB0aGVcclxuICAgICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdGltZW91dENhbGxiYWNrKCkge1xyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxKHJlc29sdmVQZW5kaW5nKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2NoZWR1bGVzIGludm9jYXRpb24gb2YgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBwcm94eSgpIHtcclxuICAgICAgICB2YXIgdGltZVN0YW1wID0gRGF0ZS5ub3coKTtcclxuICAgICAgICBpZiAobGVhZGluZ0NhbGwpIHtcclxuICAgICAgICAgICAgLy8gUmVqZWN0IGltbWVkaWF0ZWx5IGZvbGxvd2luZyBjYWxscy5cclxuICAgICAgICAgICAgaWYgKHRpbWVTdGFtcCAtIGxhc3RDYWxsVGltZSA8IHRyYWlsaW5nVGltZW91dCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIG5ldyBjYWxsIHRvIGJlIGluIGludm9rZWQgd2hlbiB0aGUgcGVuZGluZyBvbmUgaXMgcmVzb2x2ZWQuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGZvciBcInRyYW5zaXRpb25zXCIgd2hpY2ggbmV2ZXIgYWN0dWFsbHkgc3RhcnRcclxuICAgICAgICAgICAgLy8gaW1tZWRpYXRlbHkgc28gdGhlcmUgaXMgYSBjaGFuY2UgdGhhdCB3ZSBtaWdodCBtaXNzIG9uZSBpZiBjaGFuZ2VcclxuICAgICAgICAgICAgLy8gaGFwcGVucyBhbWlkcyB0aGUgcGVuZGluZyBpbnZvY2F0aW9uLlxyXG4gICAgICAgICAgICB0cmFpbGluZ0NhbGwgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGVhZGluZ0NhbGwgPSB0cnVlO1xyXG4gICAgICAgICAgICB0cmFpbGluZ0NhbGwgPSBmYWxzZTtcclxuICAgICAgICAgICAgc2V0VGltZW91dCh0aW1lb3V0Q2FsbGJhY2ssIGRlbGF5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGFzdENhbGxUaW1lID0gdGltZVN0YW1wO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb3h5O1xyXG59XG5cbi8vIE1pbmltdW0gZGVsYXkgYmVmb3JlIGludm9raW5nIHRoZSB1cGRhdGUgb2Ygb2JzZXJ2ZXJzLlxyXG52YXIgUkVGUkVTSF9ERUxBWSA9IDIwO1xyXG4vLyBBIGxpc3Qgb2Ygc3Vic3RyaW5ncyBvZiBDU1MgcHJvcGVydGllcyB1c2VkIHRvIGZpbmQgdHJhbnNpdGlvbiBldmVudHMgdGhhdFxyXG4vLyBtaWdodCBhZmZlY3QgZGltZW5zaW9ucyBvZiBvYnNlcnZlZCBlbGVtZW50cy5cclxudmFyIHRyYW5zaXRpb25LZXlzID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ3NpemUnLCAnd2VpZ2h0J107XHJcbi8vIENoZWNrIGlmIE11dGF0aW9uT2JzZXJ2ZXIgaXMgYXZhaWxhYmxlLlxyXG52YXIgbXV0YXRpb25PYnNlcnZlclN1cHBvcnRlZCA9IHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJztcclxuLyoqXHJcbiAqIFNpbmdsZXRvbiBjb250cm9sbGVyIGNsYXNzIHdoaWNoIGhhbmRsZXMgdXBkYXRlcyBvZiBSZXNpemVPYnNlcnZlciBpbnN0YW5jZXMuXHJcbiAqL1xyXG52YXIgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgRE9NIGxpc3RlbmVycyBoYXZlIGJlZW4gYWRkZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvbm5lY3RlZF8gPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZWxscyB0aGF0IGNvbnRyb2xsZXIgaGFzIHN1YnNjcmliZWQgZm9yIE11dGF0aW9uIEV2ZW50cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8gPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBLZWVwcyByZWZlcmVuY2UgdG8gdGhlIGluc3RhbmNlIG9mIE11dGF0aW9uT2JzZXJ2ZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7TXV0YXRpb25PYnNlcnZlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXyA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBsaXN0IG9mIGNvbm5lY3RlZCBvYnNlcnZlcnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7QXJyYXk8UmVzaXplT2JzZXJ2ZXJTUEk+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzXyA9IFtdO1xyXG4gICAgICAgIHRoaXMub25UcmFuc2l0aW9uRW5kXyA9IHRoaXMub25UcmFuc2l0aW9uRW5kXy5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMucmVmcmVzaCA9IHRocm90dGxlKHRoaXMucmVmcmVzaC5iaW5kKHRoaXMpLCBSRUZSRVNIX0RFTEFZKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBvYnNlcnZlciB0byBvYnNlcnZlcnMgbGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyU1BJfSBvYnNlcnZlciAtIE9ic2VydmVyIHRvIGJlIGFkZGVkLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUuYWRkT2JzZXJ2ZXIgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICBpZiAoIX50aGlzLm9ic2VydmVyc18uaW5kZXhPZihvYnNlcnZlcikpIHtcclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnNfLnB1c2gob2JzZXJ2ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBZGQgbGlzdGVuZXJzIGlmIHRoZXkgaGF2ZW4ndCBiZWVuIGFkZGVkIHlldC5cclxuICAgICAgICBpZiAoIXRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBvYnNlcnZlciBmcm9tIG9ic2VydmVycyBsaXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJTUEl9IG9ic2VydmVyIC0gT2JzZXJ2ZXIgdG8gYmUgcmVtb3ZlZC5cclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLnJlbW92ZU9ic2VydmVyID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzXztcclxuICAgICAgICB2YXIgaW5kZXggPSBvYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlcik7XHJcbiAgICAgICAgLy8gUmVtb3ZlIG9ic2VydmVyIGlmIGl0J3MgcHJlc2VudCBpbiByZWdpc3RyeS5cclxuICAgICAgICBpZiAofmluZGV4KSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW1vdmUgbGlzdGVuZXJzIGlmIGNvbnRyb2xsZXIgaGFzIG5vIGNvbm5lY3RlZCBvYnNlcnZlcnMuXHJcbiAgICAgICAgaWYgKCFvYnNlcnZlcnMubGVuZ3RoICYmIHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSW52b2tlcyB0aGUgdXBkYXRlIG9mIG9ic2VydmVycy4gSXQgd2lsbCBjb250aW51ZSBydW5uaW5nIHVwZGF0ZXMgaW5zb2ZhclxyXG4gICAgICogaXQgZGV0ZWN0cyBjaGFuZ2VzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNoYW5nZXNEZXRlY3RlZCA9IHRoaXMudXBkYXRlT2JzZXJ2ZXJzXygpO1xyXG4gICAgICAgIC8vIENvbnRpbnVlIHJ1bm5pbmcgdXBkYXRlcyBpZiBjaGFuZ2VzIGhhdmUgYmVlbiBkZXRlY3RlZCBhcyB0aGVyZSBtaWdodFxyXG4gICAgICAgIC8vIGJlIGZ1dHVyZSBvbmVzIGNhdXNlZCBieSBDU1MgdHJhbnNpdGlvbnMuXHJcbiAgICAgICAgaWYgKGNoYW5nZXNEZXRlY3RlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIGV2ZXJ5IG9ic2VydmVyIGZyb20gb2JzZXJ2ZXJzIGxpc3QgYW5kIG5vdGlmaWVzIHRoZW0gb2YgcXVldWVkXHJcbiAgICAgKiBlbnRyaWVzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBcInRydWVcIiBpZiBhbnkgb2JzZXJ2ZXIgaGFzIGRldGVjdGVkIGNoYW5nZXMgaW5cclxuICAgICAqICAgICAgZGltZW5zaW9ucyBvZiBpdCdzIGVsZW1lbnRzLlxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZU9ic2VydmVyc18gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gQ29sbGVjdCBvYnNlcnZlcnMgdGhhdCBoYXZlIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgICAgdmFyIGFjdGl2ZU9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzXy5maWx0ZXIoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5nYXRoZXJBY3RpdmUoKSwgb2JzZXJ2ZXIuaGFzQWN0aXZlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gRGVsaXZlciBub3RpZmljYXRpb25zIGluIGEgc2VwYXJhdGUgY3ljbGUgaW4gb3JkZXIgdG8gYXZvaWQgYW55XHJcbiAgICAgICAgLy8gY29sbGlzaW9ucyBiZXR3ZWVuIG9ic2VydmVycywgZS5nLiB3aGVuIG11bHRpcGxlIGluc3RhbmNlcyBvZlxyXG4gICAgICAgIC8vIFJlc2l6ZU9ic2VydmVyIGFyZSB0cmFja2luZyB0aGUgc2FtZSBlbGVtZW50IGFuZCB0aGUgY2FsbGJhY2sgb2Ygb25lXHJcbiAgICAgICAgLy8gb2YgdGhlbSBjaGFuZ2VzIGNvbnRlbnQgZGltZW5zaW9ucyBvZiB0aGUgb2JzZXJ2ZWQgdGFyZ2V0LiBTb21ldGltZXNcclxuICAgICAgICAvLyB0aGlzIG1heSByZXN1bHQgaW4gbm90aWZpY2F0aW9ucyBiZWluZyBibG9ja2VkIGZvciB0aGUgcmVzdCBvZiBvYnNlcnZlcnMuXHJcbiAgICAgICAgYWN0aXZlT2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gKG9ic2VydmVyKSB7IHJldHVybiBvYnNlcnZlci5icm9hZGNhc3RBY3RpdmUoKTsgfSk7XHJcbiAgICAgICAgcmV0dXJuIGFjdGl2ZU9ic2VydmVycy5sZW5ndGggPiAwO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgRE9NIGxpc3RlbmVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUuY29ubmVjdF8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBydW5uaW5nIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQgb3IgaWYgbGlzdGVuZXJzXHJcbiAgICAgICAgLy8gaGF2ZSBiZWVuIGFscmVhZHkgYWRkZWQuXHJcbiAgICAgICAgaWYgKCFpc0Jyb3dzZXIgfHwgdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU3Vic2NyaXB0aW9uIHRvIHRoZSBcIlRyYW5zaXRpb25lbmRcIiBldmVudCBpcyB1c2VkIGFzIGEgd29ya2Fyb3VuZCBmb3JcclxuICAgICAgICAvLyBkZWxheWVkIHRyYW5zaXRpb25zLiBUaGlzIHdheSBpdCdzIHBvc3NpYmxlIHRvIGNhcHR1cmUgYXQgbGVhc3QgdGhlXHJcbiAgICAgICAgLy8gZmluYWwgc3RhdGUgb2YgYW4gZWxlbWVudC5cclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy5vblRyYW5zaXRpb25FbmRfKTtcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICBpZiAobXV0YXRpb25PYnNlcnZlclN1cHBvcnRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXyA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfLm9ic2VydmUoZG9jdW1lbnQsIHtcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgc3VidHJlZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTVN1YnRyZWVNb2RpZmllZCcsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbm5lY3RlZF8gPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBET00gbGlzdGVuZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5kaXNjb25uZWN0XyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHJ1bm5pbmcgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudCBvciBpZiBsaXN0ZW5lcnNcclxuICAgICAgICAvLyBoYXZlIGJlZW4gYWxyZWFkeSByZW1vdmVkLlxyXG4gICAgICAgIGlmICghaXNCcm93c2VyIHx8ICF0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy5vblRyYW5zaXRpb25FbmRfKTtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICBpZiAodGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8pIHtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8uZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXykge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01TdWJ0cmVlTW9kaWZpZWQnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogXCJUcmFuc2l0aW9uZW5kXCIgZXZlbnQgaGFuZGxlci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtUcmFuc2l0aW9uRXZlbnR9IGV2ZW50XHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5vblRyYW5zaXRpb25FbmRfID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX2EucHJvcGVydHlOYW1lLCBwcm9wZXJ0eU5hbWUgPSBfYiA9PT0gdm9pZCAwID8gJycgOiBfYjtcclxuICAgICAgICAvLyBEZXRlY3Qgd2hldGhlciB0cmFuc2l0aW9uIG1heSBhZmZlY3QgZGltZW5zaW9ucyBvZiBhbiBlbGVtZW50LlxyXG4gICAgICAgIHZhciBpc1JlZmxvd1Byb3BlcnR5ID0gdHJhbnNpdGlvbktleXMuc29tZShmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIX5wcm9wZXJ0eU5hbWUuaW5kZXhPZihrZXkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChpc1JlZmxvd1Byb3BlcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgaW5zdGFuY2Ugb2YgdGhlIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmluc3RhbmNlXykge1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlXyA9IG5ldyBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VfO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSG9sZHMgcmVmZXJlbmNlIHRvIHRoZSBjb250cm9sbGVyJ3MgaW5zdGFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGUge1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlcn1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmluc3RhbmNlXyA9IG51bGw7XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyO1xyXG59KCkpO1xuXG4vKipcclxuICogRGVmaW5lcyBub24td3JpdGFibGUvZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHRoZSBwcm92aWRlZCB0YXJnZXQgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IC0gT2JqZWN0IGZvciB3aGljaCB0byBkZWZpbmUgcHJvcGVydGllcy5cclxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gUHJvcGVydGllcyB0byBiZSBkZWZpbmVkLlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUYXJnZXQgb2JqZWN0LlxyXG4gKi9cclxudmFyIGRlZmluZUNvbmZpZ3VyYWJsZSA9IChmdW5jdGlvbiAodGFyZ2V0LCBwcm9wcykge1xyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKHByb3BzKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIga2V5ID0gX2FbX2ldO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xyXG4gICAgICAgICAgICB2YWx1ZTogcHJvcHNba2V5XSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59KTtcblxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGdsb2JhbCBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcclxuICogQHJldHVybnMge09iamVjdH1cclxuICovXHJcbnZhciBnZXRXaW5kb3dPZiA9IChmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAvLyBBc3N1bWUgdGhhdCB0aGUgZWxlbWVudCBpcyBhbiBpbnN0YW5jZSBvZiBOb2RlLCB3aGljaCBtZWFucyB0aGF0IGl0XHJcbiAgICAvLyBoYXMgdGhlIFwib3duZXJEb2N1bWVudFwiIHByb3BlcnR5IGZyb20gd2hpY2ggd2UgY2FuIHJldHJpZXZlIGFcclxuICAgIC8vIGNvcnJlc3BvbmRpbmcgZ2xvYmFsIG9iamVjdC5cclxuICAgIHZhciBvd25lckdsb2JhbCA9IHRhcmdldCAmJiB0YXJnZXQub3duZXJEb2N1bWVudCAmJiB0YXJnZXQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcclxuICAgIC8vIFJldHVybiB0aGUgbG9jYWwgZ2xvYmFsIG9iamVjdCBpZiBpdCdzIG5vdCBwb3NzaWJsZSBleHRyYWN0IG9uZSBmcm9tXHJcbiAgICAvLyBwcm92aWRlZCBlbGVtZW50LlxyXG4gICAgcmV0dXJuIG93bmVyR2xvYmFsIHx8IGdsb2JhbCQxO1xyXG59KTtcblxuLy8gUGxhY2Vob2xkZXIgb2YgYW4gZW1wdHkgY29udGVudCByZWN0YW5nbGUuXHJcbnZhciBlbXB0eVJlY3QgPSBjcmVhdGVSZWN0SW5pdCgwLCAwLCAwLCAwKTtcclxuLyoqXHJcbiAqIENvbnZlcnRzIHByb3ZpZGVkIHN0cmluZyB0byBhIG51bWJlci5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuZnVuY3Rpb24gdG9GbG9hdCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpIHx8IDA7XHJcbn1cclxuLyoqXHJcbiAqIEV4dHJhY3RzIGJvcmRlcnMgc2l6ZSBmcm9tIHByb3ZpZGVkIHN0eWxlcy5cclxuICpcclxuICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBzdHlsZXNcclxuICogQHBhcmFtIHsuLi5zdHJpbmd9IHBvc2l0aW9ucyAtIEJvcmRlcnMgcG9zaXRpb25zICh0b3AsIHJpZ2h0LCAuLi4pXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRCb3JkZXJzU2l6ZShzdHlsZXMpIHtcclxuICAgIHZhciBwb3NpdGlvbnMgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgcG9zaXRpb25zW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBvc2l0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKHNpemUsIHBvc2l0aW9uKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVzWydib3JkZXItJyArIHBvc2l0aW9uICsgJy13aWR0aCddO1xyXG4gICAgICAgIHJldHVybiBzaXplICsgdG9GbG9hdCh2YWx1ZSk7XHJcbiAgICB9LCAwKTtcclxufVxyXG4vKipcclxuICogRXh0cmFjdHMgcGFkZGluZ3Mgc2l6ZXMgZnJvbSBwcm92aWRlZCBzdHlsZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IFBhZGRpbmdzIGJveC5cclxuICovXHJcbmZ1bmN0aW9uIGdldFBhZGRpbmdzKHN0eWxlcykge1xyXG4gICAgdmFyIHBvc2l0aW9ucyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J107XHJcbiAgICB2YXIgcGFkZGluZ3MgPSB7fTtcclxuICAgIGZvciAodmFyIF9pID0gMCwgcG9zaXRpb25zXzEgPSBwb3NpdGlvbnM7IF9pIDwgcG9zaXRpb25zXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gcG9zaXRpb25zXzFbX2ldO1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHN0eWxlc1sncGFkZGluZy0nICsgcG9zaXRpb25dO1xyXG4gICAgICAgIHBhZGRpbmdzW3Bvc2l0aW9uXSA9IHRvRmxvYXQodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhZGRpbmdzO1xyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHByb3ZpZGVkIFNWRyBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NWR0dyYXBoaWNzRWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCBjb250ZW50IHJlY3RhbmdsZSBvZiB3aGljaCBuZWVkc1xyXG4gKiAgICAgIHRvIGJlIGNhbGN1bGF0ZWQuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICovXHJcbmZ1bmN0aW9uIGdldFNWR0NvbnRlbnRSZWN0KHRhcmdldCkge1xyXG4gICAgdmFyIGJib3ggPSB0YXJnZXQuZ2V0QkJveCgpO1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlY3RJbml0KDAsIDAsIGJib3gud2lkdGgsIGJib3guaGVpZ2h0KTtcclxufVxyXG4vKipcclxuICogQ2FsY3VsYXRlcyBjb250ZW50IHJlY3RhbmdsZSBvZiBwcm92aWRlZCBIVE1MRWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCBmb3Igd2hpY2ggdG8gY2FsY3VsYXRlIHRoZSBjb250ZW50IHJlY3RhbmdsZS5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0SFRNTEVsZW1lbnRDb250ZW50UmVjdCh0YXJnZXQpIHtcclxuICAgIC8vIENsaWVudCB3aWR0aCAmIGhlaWdodCBwcm9wZXJ0aWVzIGNhbid0IGJlXHJcbiAgICAvLyB1c2VkIGV4Y2x1c2l2ZWx5IGFzIHRoZXkgcHJvdmlkZSByb3VuZGVkIHZhbHVlcy5cclxuICAgIHZhciBjbGllbnRXaWR0aCA9IHRhcmdldC5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0ID0gdGFyZ2V0LmNsaWVudEhlaWdodDtcclxuICAgIC8vIEJ5IHRoaXMgY29uZGl0aW9uIHdlIGNhbiBjYXRjaCBhbGwgbm9uLXJlcGxhY2VkIGlubGluZSwgaGlkZGVuIGFuZFxyXG4gICAgLy8gZGV0YWNoZWQgZWxlbWVudHMuIFRob3VnaCBlbGVtZW50cyB3aXRoIHdpZHRoICYgaGVpZ2h0IHByb3BlcnRpZXMgbGVzc1xyXG4gICAgLy8gdGhhbiAwLjUgd2lsbCBiZSBkaXNjYXJkZWQgYXMgd2VsbC5cclxuICAgIC8vXHJcbiAgICAvLyBXaXRob3V0IGl0IHdlIHdvdWxkIG5lZWQgdG8gaW1wbGVtZW50IHNlcGFyYXRlIG1ldGhvZHMgZm9yIGVhY2ggb2ZcclxuICAgIC8vIHRob3NlIGNhc2VzIGFuZCBpdCdzIG5vdCBwb3NzaWJsZSB0byBwZXJmb3JtIGEgcHJlY2lzZSBhbmQgcGVyZm9ybWFuY2VcclxuICAgIC8vIGVmZmVjdGl2ZSB0ZXN0IGZvciBoaWRkZW4gZWxlbWVudHMuIEUuZy4gZXZlbiBqUXVlcnkncyAnOnZpc2libGUnIGZpbHRlclxyXG4gICAgLy8gZ2l2ZXMgd3JvbmcgcmVzdWx0cyBmb3IgZWxlbWVudHMgd2l0aCB3aWR0aCAmIGhlaWdodCBsZXNzIHRoYW4gMC41LlxyXG4gICAgaWYgKCFjbGllbnRXaWR0aCAmJiAhY2xpZW50SGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIGVtcHR5UmVjdDtcclxuICAgIH1cclxuICAgIHZhciBzdHlsZXMgPSBnZXRXaW5kb3dPZih0YXJnZXQpLmdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcclxuICAgIHZhciBwYWRkaW5ncyA9IGdldFBhZGRpbmdzKHN0eWxlcyk7XHJcbiAgICB2YXIgaG9yaXpQYWQgPSBwYWRkaW5ncy5sZWZ0ICsgcGFkZGluZ3MucmlnaHQ7XHJcbiAgICB2YXIgdmVydFBhZCA9IHBhZGRpbmdzLnRvcCArIHBhZGRpbmdzLmJvdHRvbTtcclxuICAgIC8vIENvbXB1dGVkIHN0eWxlcyBvZiB3aWR0aCAmIGhlaWdodCBhcmUgYmVpbmcgdXNlZCBiZWNhdXNlIHRoZXkgYXJlIHRoZVxyXG4gICAgLy8gb25seSBkaW1lbnNpb25zIGF2YWlsYWJsZSB0byBKUyB0aGF0IGNvbnRhaW4gbm9uLXJvdW5kZWQgdmFsdWVzLiBJdCBjb3VsZFxyXG4gICAgLy8gYmUgcG9zc2libGUgdG8gdXRpbGl6ZSB0aGUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlmIG9ubHkgaXQncyBkYXRhIHdhc24ndFxyXG4gICAgLy8gYWZmZWN0ZWQgYnkgQ1NTIHRyYW5zZm9ybWF0aW9ucyBsZXQgYWxvbmUgcGFkZGluZ3MsIGJvcmRlcnMgYW5kIHNjcm9sbCBiYXJzLlxyXG4gICAgdmFyIHdpZHRoID0gdG9GbG9hdChzdHlsZXMud2lkdGgpLCBoZWlnaHQgPSB0b0Zsb2F0KHN0eWxlcy5oZWlnaHQpO1xyXG4gICAgLy8gV2lkdGggJiBoZWlnaHQgaW5jbHVkZSBwYWRkaW5ncyBhbmQgYm9yZGVycyB3aGVuIHRoZSAnYm9yZGVyLWJveCcgYm94XHJcbiAgICAvLyBtb2RlbCBpcyBhcHBsaWVkIChleGNlcHQgZm9yIElFKS5cclxuICAgIGlmIChzdHlsZXMuYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCcpIHtcclxuICAgICAgICAvLyBGb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgcmVxdWlyZWQgdG8gaGFuZGxlIEludGVybmV0IEV4cGxvcmVyIHdoaWNoXHJcbiAgICAgICAgLy8gZG9lc24ndCBpbmNsdWRlIHBhZGRpbmdzIGFuZCBib3JkZXJzIHRvIGNvbXB1dGVkIENTUyBkaW1lbnNpb25zLlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gV2UgY2FuIHNheSB0aGF0IGlmIENTUyBkaW1lbnNpb25zICsgcGFkZGluZ3MgYXJlIGVxdWFsIHRvIHRoZSBcImNsaWVudFwiXHJcbiAgICAgICAgLy8gcHJvcGVydGllcyB0aGVuIGl0J3MgZWl0aGVyIElFLCBhbmQgdGh1cyB3ZSBkb24ndCBuZWVkIHRvIHN1YnRyYWN0XHJcbiAgICAgICAgLy8gYW55dGhpbmcsIG9yIGFuIGVsZW1lbnQgbWVyZWx5IGRvZXNuJ3QgaGF2ZSBwYWRkaW5ncy9ib3JkZXJzIHN0eWxlcy5cclxuICAgICAgICBpZiAoTWF0aC5yb3VuZCh3aWR0aCArIGhvcml6UGFkKSAhPT0gY2xpZW50V2lkdGgpIHtcclxuICAgICAgICAgICAgd2lkdGggLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAnbGVmdCcsICdyaWdodCcpICsgaG9yaXpQYWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChNYXRoLnJvdW5kKGhlaWdodCArIHZlcnRQYWQpICE9PSBjbGllbnRIZWlnaHQpIHtcclxuICAgICAgICAgICAgaGVpZ2h0IC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3RvcCcsICdib3R0b20nKSArIHZlcnRQYWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gRm9sbG93aW5nIHN0ZXBzIGNhbid0IGJlIGFwcGxpZWQgdG8gdGhlIGRvY3VtZW50J3Mgcm9vdCBlbGVtZW50IGFzIGl0c1xyXG4gICAgLy8gY2xpZW50W1dpZHRoL0hlaWdodF0gcHJvcGVydGllcyByZXByZXNlbnQgdmlld3BvcnQgYXJlYSBvZiB0aGUgd2luZG93LlxyXG4gICAgLy8gQmVzaWRlcywgaXQncyBhcyB3ZWxsIG5vdCBuZWNlc3NhcnkgYXMgdGhlIDxodG1sPiBpdHNlbGYgbmVpdGhlciBoYXNcclxuICAgIC8vIHJlbmRlcmVkIHNjcm9sbCBiYXJzIG5vciBpdCBjYW4gYmUgY2xpcHBlZC5cclxuICAgIGlmICghaXNEb2N1bWVudEVsZW1lbnQodGFyZ2V0KSkge1xyXG4gICAgICAgIC8vIEluIHNvbWUgYnJvd3NlcnMgKG9ubHkgaW4gRmlyZWZveCwgYWN0dWFsbHkpIENTUyB3aWR0aCAmIGhlaWdodFxyXG4gICAgICAgIC8vIGluY2x1ZGUgc2Nyb2xsIGJhcnMgc2l6ZSB3aGljaCBjYW4gYmUgcmVtb3ZlZCBhdCB0aGlzIHN0ZXAgYXMgc2Nyb2xsXHJcbiAgICAgICAgLy8gYmFycyBhcmUgdGhlIG9ubHkgZGlmZmVyZW5jZSBiZXR3ZWVuIHJvdW5kZWQgZGltZW5zaW9ucyArIHBhZGRpbmdzXHJcbiAgICAgICAgLy8gYW5kIFwiY2xpZW50XCIgcHJvcGVydGllcywgdGhvdWdoIHRoYXQgaXMgbm90IGFsd2F5cyB0cnVlIGluIENocm9tZS5cclxuICAgICAgICB2YXIgdmVydFNjcm9sbGJhciA9IE1hdGgucm91bmQod2lkdGggKyBob3JpelBhZCkgLSBjbGllbnRXaWR0aDtcclxuICAgICAgICB2YXIgaG9yaXpTY3JvbGxiYXIgPSBNYXRoLnJvdW5kKGhlaWdodCArIHZlcnRQYWQpIC0gY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgIC8vIENocm9tZSBoYXMgYSByYXRoZXIgd2VpcmQgcm91bmRpbmcgb2YgXCJjbGllbnRcIiBwcm9wZXJ0aWVzLlxyXG4gICAgICAgIC8vIEUuZy4gZm9yIGFuIGVsZW1lbnQgd2l0aCBjb250ZW50IHdpZHRoIG9mIDMxNC4ycHggaXQgc29tZXRpbWVzIGdpdmVzXHJcbiAgICAgICAgLy8gdGhlIGNsaWVudCB3aWR0aCBvZiAzMTVweCBhbmQgZm9yIHRoZSB3aWR0aCBvZiAzMTQuN3B4IGl0IG1heSBnaXZlXHJcbiAgICAgICAgLy8gMzE0cHguIEFuZCBpdCBkb2Vzbid0IGhhcHBlbiBhbGwgdGhlIHRpbWUuIFNvIGp1c3QgaWdub3JlIHRoaXMgZGVsdGFcclxuICAgICAgICAvLyBhcyBhIG5vbi1yZWxldmFudC5cclxuICAgICAgICBpZiAoTWF0aC5hYnModmVydFNjcm9sbGJhcikgIT09IDEpIHtcclxuICAgICAgICAgICAgd2lkdGggLT0gdmVydFNjcm9sbGJhcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKE1hdGguYWJzKGhvcml6U2Nyb2xsYmFyKSAhPT0gMSkge1xyXG4gICAgICAgICAgICBoZWlnaHQgLT0gaG9yaXpTY3JvbGxiYXI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNyZWF0ZVJlY3RJbml0KHBhZGRpbmdzLmxlZnQsIHBhZGRpbmdzLnRvcCwgd2lkdGgsIGhlaWdodCk7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIHByb3ZpZGVkIGVsZW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIFNWR0dyYXBoaWNzRWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIGJlIGNoZWNrZWQuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxudmFyIGlzU1ZHR3JhcGhpY3NFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIFNvbWUgYnJvd3NlcnMsIG5hbWVseSBJRSBhbmQgRWRnZSwgZG9uJ3QgaGF2ZSB0aGUgU1ZHR3JhcGhpY3NFbGVtZW50XHJcbiAgICAvLyBpbnRlcmZhY2UuXHJcbiAgICBpZiAodHlwZW9mIFNWR0dyYXBoaWNzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5TVkdHcmFwaGljc0VsZW1lbnQ7IH07XHJcbiAgICB9XHJcbiAgICAvLyBJZiBpdCdzIHNvLCB0aGVuIGNoZWNrIHRoYXQgZWxlbWVudCBpcyBhdCBsZWFzdCBhbiBpbnN0YW5jZSBvZiB0aGVcclxuICAgIC8vIFNWR0VsZW1lbnQgYW5kIHRoYXQgaXQgaGFzIHRoZSBcImdldEJCb3hcIiBtZXRob2QuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0cmEtcGFyZW5zXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gKHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuU1ZHRWxlbWVudCAmJlxyXG4gICAgICAgIHR5cGVvZiB0YXJnZXQuZ2V0QkJveCA9PT0gJ2Z1bmN0aW9uJyk7IH07XHJcbn0pKCk7XHJcbi8qKlxyXG4gKiBDaGVja3Mgd2hldGhlciBwcm92aWRlZCBlbGVtZW50IGlzIGEgZG9jdW1lbnQgZWxlbWVudCAoPGh0bWw+KS5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIGJlIGNoZWNrZWQuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gaXNEb2N1bWVudEVsZW1lbnQodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gdGFyZ2V0ID09PSBnZXRXaW5kb3dPZih0YXJnZXQpLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxufVxyXG4vKipcclxuICogQ2FsY3VsYXRlcyBhbiBhcHByb3ByaWF0ZSBjb250ZW50IHJlY3RhbmdsZSBmb3IgcHJvdmlkZWQgaHRtbCBvciBzdmcgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHdoaWNoIG5lZWRzIHRvIGJlIGNhbGN1bGF0ZWQuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICovXHJcbmZ1bmN0aW9uIGdldENvbnRlbnRSZWN0KHRhcmdldCkge1xyXG4gICAgaWYgKCFpc0Jyb3dzZXIpIHtcclxuICAgICAgICByZXR1cm4gZW1wdHlSZWN0O1xyXG4gICAgfVxyXG4gICAgaWYgKGlzU1ZHR3JhcGhpY3NFbGVtZW50KHRhcmdldCkpIHtcclxuICAgICAgICByZXR1cm4gZ2V0U1ZHQ29udGVudFJlY3QodGFyZ2V0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBnZXRIVE1MRWxlbWVudENvbnRlbnRSZWN0KHRhcmdldCk7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgcmVjdGFuZ2xlIHdpdGggYW4gaW50ZXJmYWNlIG9mIHRoZSBET01SZWN0UmVhZE9ubHkuXHJcbiAqIFNwZWM6IGh0dHBzOi8vZHJhZnRzLmZ4dGYub3JnL2dlb21ldHJ5LyNkb21yZWN0cmVhZG9ubHlcclxuICpcclxuICogQHBhcmFtIHtET01SZWN0SW5pdH0gcmVjdEluaXQgLSBPYmplY3Qgd2l0aCByZWN0YW5nbGUncyB4L3kgY29vcmRpbmF0ZXMgYW5kIGRpbWVuc2lvbnMuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0UmVhZE9ubHl9XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVSZWFkT25seVJlY3QoX2EpIHtcclxuICAgIHZhciB4ID0gX2EueCwgeSA9IF9hLnksIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcclxuICAgIC8vIElmIERPTVJlY3RSZWFkT25seSBpcyBhdmFpbGFibGUgdXNlIGl0IGFzIGEgcHJvdG90eXBlIGZvciB0aGUgcmVjdGFuZ2xlLlxyXG4gICAgdmFyIENvbnN0ciA9IHR5cGVvZiBET01SZWN0UmVhZE9ubHkgIT09ICd1bmRlZmluZWQnID8gRE9NUmVjdFJlYWRPbmx5IDogT2JqZWN0O1xyXG4gICAgdmFyIHJlY3QgPSBPYmplY3QuY3JlYXRlKENvbnN0ci5wcm90b3R5cGUpO1xyXG4gICAgLy8gUmVjdGFuZ2xlJ3MgcHJvcGVydGllcyBhcmUgbm90IHdyaXRhYmxlIGFuZCBub24tZW51bWVyYWJsZS5cclxuICAgIGRlZmluZUNvbmZpZ3VyYWJsZShyZWN0LCB7XHJcbiAgICAgICAgeDogeCwgeTogeSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICB0b3A6IHksXHJcbiAgICAgICAgcmlnaHQ6IHggKyB3aWR0aCxcclxuICAgICAgICBib3R0b206IGhlaWdodCArIHksXHJcbiAgICAgICAgbGVmdDogeFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVjdDtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBET01SZWN0SW5pdCBvYmplY3QgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGRpbWVuc2lvbnMgYW5kIHRoZSB4L3kgY29vcmRpbmF0ZXMuXHJcbiAqIFNwZWM6IGh0dHBzOi8vZHJhZnRzLmZ4dGYub3JnL2dlb21ldHJ5LyNkaWN0ZGVmLWRvbXJlY3Rpbml0XHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gWCBjb29yZGluYXRlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0geSAtIFkgY29vcmRpbmF0ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gUmVjdGFuZ2xlJ3Mgd2lkdGguXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBSZWN0YW5nbGUncyBoZWlnaHQuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVJlY3RJbml0KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIHJldHVybiB7IHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcclxufVxuXG4vKipcclxuICogQ2xhc3MgdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgY29tcHV0YXRpb25zIG9mIHRoZSBjb250ZW50IHJlY3RhbmdsZSBvZlxyXG4gKiBwcm92aWRlZCBET00gZWxlbWVudCBhbmQgZm9yIGtlZXBpbmcgdHJhY2sgb2YgaXQncyBjaGFuZ2VzLlxyXG4gKi9cclxudmFyIFJlc2l6ZU9ic2VydmF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBvYnNlcnZlZC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0KSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnJvYWRjYXN0ZWQgd2lkdGggb2YgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0V2lkdGggPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJyb2FkY2FzdGVkIGhlaWdodCBvZiBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RIZWlnaHQgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgbGFzdCBvYnNlcnZlZCBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtET01SZWN0SW5pdH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvbnRlbnRSZWN0XyA9IGNyZWF0ZVJlY3RJbml0KDAsIDAsIDAsIDApO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIGNvbnRlbnQgcmVjdGFuZ2xlIGFuZCB0ZWxscyB3aGV0aGVyIGl0J3Mgd2lkdGggb3IgaGVpZ2h0IHByb3BlcnRpZXNcclxuICAgICAqIGhhdmUgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBicm9hZGNhc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmF0aW9uLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IGdldENvbnRlbnRSZWN0KHRoaXMudGFyZ2V0KTtcclxuICAgICAgICB0aGlzLmNvbnRlbnRSZWN0XyA9IHJlY3Q7XHJcbiAgICAgICAgcmV0dXJuIChyZWN0LndpZHRoICE9PSB0aGlzLmJyb2FkY2FzdFdpZHRoIHx8XHJcbiAgICAgICAgICAgIHJlY3QuaGVpZ2h0ICE9PSB0aGlzLmJyb2FkY2FzdEhlaWdodCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzICdicm9hZGNhc3RXaWR0aCcgYW5kICdicm9hZGNhc3RIZWlnaHQnIHByb3BlcnRpZXMgd2l0aCBhIGRhdGFcclxuICAgICAqIGZyb20gdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydGllcyBvZiB0aGUgbGFzdCBvYnNlcnZlZCBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9IExhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmF0aW9uLnByb3RvdHlwZS5icm9hZGNhc3RSZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5jb250ZW50UmVjdF87XHJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RXaWR0aCA9IHJlY3Qud2lkdGg7XHJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RIZWlnaHQgPSByZWN0LmhlaWdodDtcclxuICAgICAgICByZXR1cm4gcmVjdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2YXRpb247XHJcbn0oKSk7XG5cbnZhciBSZXNpemVPYnNlcnZlckVudHJ5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyRW50cnkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRoYXQgaXMgYmVpbmcgb2JzZXJ2ZWQuXHJcbiAgICAgKiBAcGFyYW0ge0RPTVJlY3RJbml0fSByZWN0SW5pdCAtIERhdGEgb2YgdGhlIGVsZW1lbnQncyBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXJFbnRyeSh0YXJnZXQsIHJlY3RJbml0KSB7XHJcbiAgICAgICAgdmFyIGNvbnRlbnRSZWN0ID0gY3JlYXRlUmVhZE9ubHlSZWN0KHJlY3RJbml0KTtcclxuICAgICAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmljYXRpb24gZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIG5vdCB3cml0YWJsZVxyXG4gICAgICAgIC8vIGFuZCBhcmUgYWxzbyBub3QgZW51bWVyYWJsZSBpbiB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gUHJvcGVydHkgYWNjZXNzb3JzIGFyZSBub3QgYmVpbmcgdXNlZCBhcyB0aGV5J2QgcmVxdWlyZSB0byBkZWZpbmUgYVxyXG4gICAgICAgIC8vIHByaXZhdGUgV2Vha01hcCBzdG9yYWdlIHdoaWNoIG1heSBjYXVzZSBtZW1vcnkgbGVha3MgaW4gYnJvd3NlcnMgdGhhdFxyXG4gICAgICAgIC8vIGRvbid0IHN1cHBvcnQgdGhpcyB0eXBlIG9mIGNvbGxlY3Rpb25zLlxyXG4gICAgICAgIGRlZmluZUNvbmZpZ3VyYWJsZSh0aGlzLCB7IHRhcmdldDogdGFyZ2V0LCBjb250ZW50UmVjdDogY29udGVudFJlY3QgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJFbnRyeTtcclxufSgpKTtcblxudmFyIFJlc2l6ZU9ic2VydmVyU1BJID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJDYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGludm9rZWRcclxuICAgICAqICAgICAgd2hlbiBvbmUgb2YgdGhlIG9ic2VydmVkIGVsZW1lbnRzIGNoYW5nZXMgaXQncyBjb250ZW50IGRpbWVuc2lvbnMuXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlcn0gY29udHJvbGxlciAtIENvbnRyb2xsZXIgaW5zdGFuY2Ugd2hpY2hcclxuICAgICAqICAgICAgaXMgcmVzcG9uc2libGUgZm9yIHRoZSB1cGRhdGVzIG9mIG9ic2VydmVyLlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlcn0gY2FsbGJhY2tDdHggLSBSZWZlcmVuY2UgdG8gdGhlIHB1YmxpY1xyXG4gICAgICogICAgICBSZXNpemVPYnNlcnZlciBpbnN0YW5jZSB3aGljaCB3aWxsIGJlIHBhc3NlZCB0byBjYWxsYmFjayBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXJTUEkoY2FsbGJhY2ssIGNvbnRyb2xsZXIsIGNhbGxiYWNrQ3R4KSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29sbGVjdGlvbiBvZiByZXNpemUgb2JzZXJ2YXRpb25zIHRoYXQgaGF2ZSBkZXRlY3RlZCBjaGFuZ2VzIGluIGRpbWVuc2lvbnNcclxuICAgICAgICAgKiBvZiBlbGVtZW50cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtBcnJheTxSZXNpemVPYnNlcnZhdGlvbj59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVnaXN0cnkgb2YgdGhlIFJlc2l6ZU9ic2VydmF0aW9uIGluc3RhbmNlcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtNYXA8RWxlbWVudCwgUmVzaXplT2JzZXJ2YXRpb24+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YXRpb25zXyA9IG5ldyBNYXBTaGltKCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgY2FsbGJhY2sgcHJvdmlkZWQgYXMgcGFyYW1ldGVyIDEgaXMgbm90IGEgZnVuY3Rpb24uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tfID0gY2FsbGJhY2s7XHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyXyA9IGNvbnRyb2xsZXI7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja0N0eF8gPSBjYWxsYmFja0N0eDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIG9ic2VydmluZyBwcm92aWRlZCBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBvYnNlcnZlZC5cclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIHRoZSBFbGVtZW50IGludGVyZmFjZS5cclxuICAgICAgICBpZiAodHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnIHx8ICEoRWxlbWVudCBpbnN0YW5jZW9mIE9iamVjdCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLkVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlIFwiRWxlbWVudFwiLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb2JzZXJ2YXRpb25zID0gdGhpcy5vYnNlcnZhdGlvbnNfO1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgZWxlbWVudCBpcyBhbHJlYWR5IGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgIGlmIChvYnNlcnZhdGlvbnMuaGFzKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYnNlcnZhdGlvbnMuc2V0KHRhcmdldCwgbmV3IFJlc2l6ZU9ic2VydmF0aW9uKHRhcmdldCkpO1xyXG4gICAgICAgIHRoaXMuY29udHJvbGxlcl8uYWRkT2JzZXJ2ZXIodGhpcyk7XHJcbiAgICAgICAgLy8gRm9yY2UgdGhlIHVwZGF0ZSBvZiBvYnNlcnZhdGlvbnMuXHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyXy5yZWZyZXNoKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyBvYnNlcnZpbmcgcHJvdmlkZWQgZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gc3RvcCBvYnNlcnZpbmcuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLnVub2JzZXJ2ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIHRoZSBFbGVtZW50IGludGVyZmFjZS5cclxuICAgICAgICBpZiAodHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnIHx8ICEoRWxlbWVudCBpbnN0YW5jZW9mIE9iamVjdCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLkVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlIFwiRWxlbWVudFwiLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb2JzZXJ2YXRpb25zID0gdGhpcy5vYnNlcnZhdGlvbnNfO1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgZWxlbWVudCBpcyBub3QgYmVpbmcgb2JzZXJ2ZWQuXHJcbiAgICAgICAgaWYgKCFvYnNlcnZhdGlvbnMuaGFzKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYnNlcnZhdGlvbnMuZGVsZXRlKHRhcmdldCk7XHJcbiAgICAgICAgaWYgKCFvYnNlcnZhdGlvbnMuc2l6ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLnJlbW92ZU9ic2VydmVyKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIG9ic2VydmluZyBhbGwgZWxlbWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2xlYXJBY3RpdmUoKTtcclxuICAgICAgICB0aGlzLm9ic2VydmF0aW9uc18uY2xlYXIoKTtcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLnJlbW92ZU9ic2VydmVyKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29sbGVjdHMgb2JzZXJ2YXRpb24gaW5zdGFuY2VzIHRoZSBhc3NvY2lhdGVkIGVsZW1lbnQgb2Ygd2hpY2ggaGFzIGNoYW5nZWRcclxuICAgICAqIGl0J3MgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5nYXRoZXJBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZhdGlvbnNfLmZvckVhY2goZnVuY3Rpb24gKG9ic2VydmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChvYnNlcnZhdGlvbi5pc0FjdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLnB1c2gob2JzZXJ2YXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2VzIGluaXRpYWwgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBhIGxpc3Qgb2YgUmVzaXplT2JzZXJ2ZXJFbnRyeVxyXG4gICAgICogaW5zdGFuY2VzIGNvbGxlY3RlZCBmcm9tIGFjdGl2ZSByZXNpemUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuYnJvYWRjYXN0QWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgb2JzZXJ2ZXIgZG9lc24ndCBoYXZlIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgICAgaWYgKCF0aGlzLmhhc0FjdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuY2FsbGJhY2tDdHhfO1xyXG4gICAgICAgIC8vIENyZWF0ZSBSZXNpemVPYnNlcnZlckVudHJ5IGluc3RhbmNlIGZvciBldmVyeSBhY3RpdmUgb2JzZXJ2YXRpb24uXHJcbiAgICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18ubWFwKGZ1bmN0aW9uIChvYnNlcnZhdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc2l6ZU9ic2VydmVyRW50cnkob2JzZXJ2YXRpb24udGFyZ2V0LCBvYnNlcnZhdGlvbi5icm9hZGNhc3RSZWN0KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tfLmNhbGwoY3R4LCBlbnRyaWVzLCBjdHgpO1xyXG4gICAgICAgIHRoaXMuY2xlYXJBY3RpdmUoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyB0aGUgY29sbGVjdGlvbiBvZiBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuY2xlYXJBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLnNwbGljZSgwKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHdoZXRoZXIgb2JzZXJ2ZXIgaGFzIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5oYXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5sZW5ndGggPiAwO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlclNQSTtcclxufSgpKTtcblxuLy8gUmVnaXN0cnkgb2YgaW50ZXJuYWwgb2JzZXJ2ZXJzLiBJZiBXZWFrTWFwIGlzIG5vdCBhdmFpbGFibGUgdXNlIGN1cnJlbnQgc2hpbVxyXG4vLyBmb3IgdGhlIE1hcCBjb2xsZWN0aW9uIGFzIGl0IGhhcyBhbGwgcmVxdWlyZWQgbWV0aG9kcyBhbmQgYmVjYXVzZSBXZWFrTWFwXHJcbi8vIGNhbid0IGJlIGZ1bGx5IHBvbHlmaWxsZWQgYW55d2F5LlxyXG52YXIgb2JzZXJ2ZXJzID0gdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnID8gbmV3IFdlYWtNYXAoKSA6IG5ldyBNYXBTaGltKCk7XHJcbi8qKlxyXG4gKiBSZXNpemVPYnNlcnZlciBBUEkuIEVuY2Fwc3VsYXRlcyB0aGUgUmVzaXplT2JzZXJ2ZXIgU1BJIGltcGxlbWVudGF0aW9uXHJcbiAqIGV4cG9zaW5nIG9ubHkgdGhvc2UgbWV0aG9kcyBhbmQgcHJvcGVydGllcyB0aGF0IGFyZSBkZWZpbmVkIGluIHRoZSBzcGVjLlxyXG4gKi9cclxudmFyIFJlc2l6ZU9ic2VydmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJDYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayB0aGF0IGlzIGludm9rZWQgd2hlblxyXG4gICAgICogICAgICBkaW1lbnNpb25zIG9mIHRoZSBvYnNlcnZlZCBlbGVtZW50cyBjaGFuZ2UuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlc2l6ZU9ic2VydmVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb250cm9sbGVyID0gUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgdmFyIG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyU1BJKGNhbGxiYWNrLCBjb250cm9sbGVyLCB0aGlzKTtcclxuICAgICAgICBvYnNlcnZlcnMuc2V0KHRoaXMsIG9ic2VydmVyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlcjtcclxufSgpKTtcclxuLy8gRXhwb3NlIHB1YmxpYyBtZXRob2RzIG9mIFJlc2l6ZU9ic2VydmVyLlxyXG5bXHJcbiAgICAnb2JzZXJ2ZScsXHJcbiAgICAndW5vYnNlcnZlJyxcclxuICAgICdkaXNjb25uZWN0J1xyXG5dLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xyXG4gICAgUmVzaXplT2JzZXJ2ZXIucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAoX2EgPSBvYnNlcnZlcnMuZ2V0KHRoaXMpKVttZXRob2RdLmFwcGx5KF9hLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxufSk7XG5cbnZhciBpbmRleCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBFeHBvcnQgZXhpc3RpbmcgaW1wbGVtZW50YXRpb24gaWYgYXZhaWxhYmxlLlxyXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwkMS5SZXNpemVPYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gZ2xvYmFsJDEuUmVzaXplT2JzZXJ2ZXI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXI7XHJcbn0pKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGluZGV4O1xuIiwiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UnO1xuaW1wb3J0IF9pbmhlcml0c0xvb3NlIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzTG9vc2UnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZXNpemVPYnNlcnZlciBmcm9tICdyZXNpemUtb2JzZXJ2ZXItcG9seWZpbGwnO1xuXG52YXIgdHlwZXMgPSBbJ2NsaWVudCcsICdvZmZzZXQnLCAnc2Nyb2xsJywgJ2JvdW5kcycsICdtYXJnaW4nXTtcbmZ1bmN0aW9uIGdldFR5cGVzKHByb3BzKSB7XG4gIHZhciBhbGxvd2VkVHlwZXMgPSBbXTtcbiAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIGlmIChwcm9wc1t0eXBlXSkge1xuICAgICAgYWxsb3dlZFR5cGVzLnB1c2godHlwZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGFsbG93ZWRUeXBlcztcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGVudFJlY3Qobm9kZSwgdHlwZXMpIHtcbiAgdmFyIGNhbGN1bGF0aW9ucyA9IHt9O1xuXG4gIGlmICh0eXBlcy5pbmRleE9mKCdjbGllbnQnKSA+IC0xKSB7XG4gICAgY2FsY3VsYXRpb25zLmNsaWVudCA9IHtcbiAgICAgIHRvcDogbm9kZS5jbGllbnRUb3AsXG4gICAgICBsZWZ0OiBub2RlLmNsaWVudExlZnQsXG4gICAgICB3aWR0aDogbm9kZS5jbGllbnRXaWR0aCxcbiAgICAgIGhlaWdodDogbm9kZS5jbGllbnRIZWlnaHRcbiAgICB9O1xuICB9XG5cbiAgaWYgKHR5cGVzLmluZGV4T2YoJ29mZnNldCcpID4gLTEpIHtcbiAgICBjYWxjdWxhdGlvbnMub2Zmc2V0ID0ge1xuICAgICAgdG9wOiBub2RlLm9mZnNldFRvcCxcbiAgICAgIGxlZnQ6IG5vZGUub2Zmc2V0TGVmdCxcbiAgICAgIHdpZHRoOiBub2RlLm9mZnNldFdpZHRoLFxuICAgICAgaGVpZ2h0OiBub2RlLm9mZnNldEhlaWdodFxuICAgIH07XG4gIH1cblxuICBpZiAodHlwZXMuaW5kZXhPZignc2Nyb2xsJykgPiAtMSkge1xuICAgIGNhbGN1bGF0aW9ucy5zY3JvbGwgPSB7XG4gICAgICB0b3A6IG5vZGUuc2Nyb2xsVG9wLFxuICAgICAgbGVmdDogbm9kZS5zY3JvbGxMZWZ0LFxuICAgICAgd2lkdGg6IG5vZGUuc2Nyb2xsV2lkdGgsXG4gICAgICBoZWlnaHQ6IG5vZGUuc2Nyb2xsSGVpZ2h0XG4gICAgfTtcbiAgfVxuXG4gIGlmICh0eXBlcy5pbmRleE9mKCdib3VuZHMnKSA+IC0xKSB7XG4gICAgdmFyIHJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNhbGN1bGF0aW9ucy5ib3VuZHMgPSB7XG4gICAgICB0b3A6IHJlY3QudG9wLFxuICAgICAgcmlnaHQ6IHJlY3QucmlnaHQsXG4gICAgICBib3R0b206IHJlY3QuYm90dG9tLFxuICAgICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gICAgfTtcbiAgfVxuXG4gIGlmICh0eXBlcy5pbmRleE9mKCdtYXJnaW4nKSA+IC0xKSB7XG4gICAgdmFyIHN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgY2FsY3VsYXRpb25zLm1hcmdpbiA9IHtcbiAgICAgIHRvcDogc3R5bGVzID8gcGFyc2VJbnQoc3R5bGVzLm1hcmdpblRvcCkgOiAwLFxuICAgICAgcmlnaHQ6IHN0eWxlcyA/IHBhcnNlSW50KHN0eWxlcy5tYXJnaW5SaWdodCkgOiAwLFxuICAgICAgYm90dG9tOiBzdHlsZXMgPyBwYXJzZUludChzdHlsZXMubWFyZ2luQm90dG9tKSA6IDAsXG4gICAgICBsZWZ0OiBzdHlsZXMgPyBwYXJzZUludChzdHlsZXMubWFyZ2luTGVmdCkgOiAwXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBjYWxjdWxhdGlvbnM7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZ2xvYmFsIHdpbmRvdyBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHByb3ZpZGVkIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvd09mKHRhcmdldCkge1xuICAvLyBBc3N1bWUgdGhhdCB0aGUgZWxlbWVudCBpcyBhbiBpbnN0YW5jZSBvZiBOb2RlLCB3aGljaCBtZWFucyB0aGF0IGl0XG4gIC8vIGhhcyB0aGUgXCJvd25lckRvY3VtZW50XCIgcHJvcGVydHkgZnJvbSB3aGljaCB3ZSBjYW4gcmV0cmlldmUgYVxuICAvLyBjb3JyZXNwb25kaW5nIGdsb2JhbCBvYmplY3QuXG4gIHZhciBvd25lckdsb2JhbCA9IHRhcmdldCAmJiB0YXJnZXQub3duZXJEb2N1bWVudCAmJiB0YXJnZXQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldzsgLy8gUmV0dXJuIHRoZSBsb2NhbCB3aW5kb3cgb2JqZWN0IGlmIGl0J3Mgbm90IHBvc3NpYmxlIGV4dHJhY3Qgb25lIGZyb21cbiAgLy8gcHJvdmlkZWQgZWxlbWVudC5cblxuICByZXR1cm4gb3duZXJHbG9iYWwgfHwgd2luZG93O1xufVxuXG5mdW5jdGlvbiB3aXRoQ29udGVudFJlY3QodHlwZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChXcmFwcGVkQ29tcG9uZW50KSB7XG4gICAgdmFyIF9jbGFzcywgX3RlbXA7XG5cbiAgICByZXR1cm4gX3RlbXAgPSBfY2xhc3MgPVxuICAgIC8qI19fUFVSRV9fKi9cbiAgICBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICAgICAgX2luaGVyaXRzTG9vc2UoV2l0aENvbnRlbnRSZWN0LCBfQ29tcG9uZW50KTtcblxuICAgICAgZnVuY3Rpb24gV2l0aENvbnRlbnRSZWN0KCkge1xuICAgICAgICB2YXIgX3RoaXM7XG5cbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzID0gX0NvbXBvbmVudC5jYWxsLmFwcGx5KF9Db21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgIGNvbnRlbnRSZWN0OiB7XG4gICAgICAgICAgICBlbnRyeToge30sXG4gICAgICAgICAgICBjbGllbnQ6IHt9LFxuICAgICAgICAgICAgb2Zmc2V0OiB7fSxcbiAgICAgICAgICAgIHNjcm9sbDoge30sXG4gICAgICAgICAgICBib3VuZHM6IHt9LFxuICAgICAgICAgICAgbWFyZ2luOiB7fVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuX2FuaW1hdGlvbkZyYW1lSUQgPSBudWxsO1xuICAgICAgICBfdGhpcy5fcmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICBfdGhpcy5fbm9kZSA9IG51bGw7XG4gICAgICAgIF90aGlzLl93aW5kb3cgPSBudWxsO1xuXG4gICAgICAgIF90aGlzLm1lYXN1cmUgPSBmdW5jdGlvbiAoZW50cmllcykge1xuICAgICAgICAgIHZhciBjb250ZW50UmVjdCA9IGdldENvbnRlbnRSZWN0KF90aGlzLl9ub2RlLCB0eXBlcyB8fCBnZXRUeXBlcyhfdGhpcy5wcm9wcykpO1xuXG4gICAgICAgICAgaWYgKGVudHJpZXMpIHtcbiAgICAgICAgICAgIGNvbnRlbnRSZWN0LmVudHJ5ID0gZW50cmllc1swXS5jb250ZW50UmVjdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpcy5fYW5pbWF0aW9uRnJhbWVJRCA9IF90aGlzLl93aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fcmVzaXplT2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGNvbnRlbnRSZWN0OiBjb250ZW50UmVjdFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIF90aGlzLnByb3BzLm9uUmVzaXplID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25SZXNpemUoY29udGVudFJlY3QpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMuX2hhbmRsZVJlZiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgaWYgKF90aGlzLl9yZXNpemVPYnNlcnZlciAhPT0gbnVsbCAmJiBfdGhpcy5fbm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgX3RoaXMuX3Jlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZShfdGhpcy5fbm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMuX25vZGUgPSBub2RlO1xuICAgICAgICAgIF90aGlzLl93aW5kb3cgPSBnZXRXaW5kb3dPZihfdGhpcy5fbm9kZSk7XG4gICAgICAgICAgdmFyIGlubmVyUmVmID0gX3RoaXMucHJvcHMuaW5uZXJSZWY7XG5cbiAgICAgICAgICBpZiAoaW5uZXJSZWYpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5uZXJSZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgaW5uZXJSZWYoX3RoaXMuX25vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5uZXJSZWYuY3VycmVudCA9IF90aGlzLl9ub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfdGhpcy5fcmVzaXplT2JzZXJ2ZXIgIT09IG51bGwgJiYgX3RoaXMuX25vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIF90aGlzLl9yZXNpemVPYnNlcnZlci5vYnNlcnZlKF90aGlzLl9ub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3Byb3RvID0gV2l0aENvbnRlbnRSZWN0LnByb3RvdHlwZTtcblxuICAgICAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyID0gdGhpcy5fd2luZG93ICE9PSBudWxsICYmIHRoaXMuX3dpbmRvdy5SZXNpemVPYnNlcnZlciA/IG5ldyB0aGlzLl93aW5kb3cuUmVzaXplT2JzZXJ2ZXIodGhpcy5tZWFzdXJlKSA6IG5ldyBSZXNpemVPYnNlcnZlcih0aGlzLm1lYXN1cmUpO1xuXG4gICAgICAgIGlmICh0aGlzLl9ub2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5fcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9ub2RlKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcm9wcy5vblJlc2l6ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblJlc2l6ZShnZXRDb250ZW50UmVjdCh0aGlzLl9ub2RlLCB0eXBlcyB8fCBnZXRUeXBlcyh0aGlzLnByb3BzKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLl93aW5kb3cgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLl93aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fYW5pbWF0aW9uRnJhbWVJRCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fcmVzaXplT2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLl9yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cbiAgICAgICAgICB0aGlzLl9yZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBpbm5lclJlZiA9IF90aGlzJHByb3BzLmlubmVyUmVmLFxuICAgICAgICAgICAgb25SZXNpemUgPSBfdGhpcyRwcm9wcy5vblJlc2l6ZSxcbiAgICAgICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMsIFtcImlubmVyUmVmXCIsIFwib25SZXNpemVcIl0pO1xuXG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFdyYXBwZWRDb21wb25lbnQsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgICAgIG1lYXN1cmVSZWY6IHRoaXMuX2hhbmRsZVJlZixcbiAgICAgICAgICBtZWFzdXJlOiB0aGlzLm1lYXN1cmUsXG4gICAgICAgICAgY29udGVudFJlY3Q6IHRoaXMuc3RhdGUuY29udGVudFJlY3RcbiAgICAgICAgfSkpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIFdpdGhDb250ZW50UmVjdDtcbiAgICB9KENvbXBvbmVudCksIF9jbGFzcy5wcm9wVHlwZXMgPSB7XG4gICAgICBjbGllbnQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgb2Zmc2V0OiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgIHNjcm9sbDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICBib3VuZHM6IFByb3BUeXBlcy5ib29sLFxuICAgICAgbWFyZ2luOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgIGlubmVyUmVmOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuZnVuY10pLFxuICAgICAgb25SZXNpemU6IFByb3BUeXBlcy5mdW5jXG4gICAgfSwgX3RlbXA7XG4gIH07XG59XG5cbnZhciBNZWFzdXJlID0gd2l0aENvbnRlbnRSZWN0KCkoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIG1lYXN1cmUgPSBfcmVmLm1lYXN1cmUsXG4gICAgICBtZWFzdXJlUmVmID0gX3JlZi5tZWFzdXJlUmVmLFxuICAgICAgY29udGVudFJlY3QgPSBfcmVmLmNvbnRlbnRSZWN0LFxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICByZXR1cm4gY2hpbGRyZW4oe1xuICAgIG1lYXN1cmU6IG1lYXN1cmUsXG4gICAgbWVhc3VyZVJlZjogbWVhc3VyZVJlZixcbiAgICBjb250ZW50UmVjdDogY29udGVudFJlY3RcbiAgfSk7XG59KTtcbk1lYXN1cmUuZGlzcGxheU5hbWUgPSAnTWVhc3VyZSc7XG5NZWFzdXJlLnByb3BUeXBlcy5jaGlsZHJlbiA9IFByb3BUeXBlcy5mdW5jO1xuXG5leHBvcnQgZGVmYXVsdCBNZWFzdXJlO1xuZXhwb3J0IHsgd2l0aENvbnRlbnRSZWN0IH07XG4iLCJ2YXIgUElfT1ZFUl8xODAgPSBNYXRoLlBJIC8gMTgwO1xuZnVuY3Rpb24gZGV0ZWN0QnJvd3NlcigpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICh7fS50b1N0cmluZy5jYWxsKHdpbmRvdykgPT09ICdbb2JqZWN0IFdpbmRvd10nIHx8XG4gICAgICAgICAgICB7fS50b1N0cmluZy5jYWxsKHdpbmRvdykgPT09ICdbb2JqZWN0IGdsb2JhbF0nKSk7XG59XG5leHBvcnQgY29uc3QgZ2xvYiA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnXG4gICAgPyBnbG9iYWxcbiAgICA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gd2luZG93XG4gICAgICAgIDogdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBzZWxmXG4gICAgICAgICAgICA6IHt9O1xuZXhwb3J0IGNvbnN0IEtvbnZhID0ge1xuICAgIF9nbG9iYWw6IGdsb2IsXG4gICAgdmVyc2lvbjogJzguMy45JyxcbiAgICBpc0Jyb3dzZXI6IGRldGVjdEJyb3dzZXIoKSxcbiAgICBpc1VubWluaWZpZWQ6IC9wYXJhbS8udGVzdChmdW5jdGlvbiAocGFyYW0pIHsgfS50b1N0cmluZygpKSxcbiAgICBkYmxDbGlja1dpbmRvdzogNDAwLFxuICAgIGdldEFuZ2xlKGFuZ2xlKSB7XG4gICAgICAgIHJldHVybiBLb252YS5hbmdsZURlZyA/IGFuZ2xlICogUElfT1ZFUl8xODAgOiBhbmdsZTtcbiAgICB9LFxuICAgIGVuYWJsZVRyYWNlOiBmYWxzZSxcbiAgICBwb2ludGVyRXZlbnRzRW5hYmxlZDogdHJ1ZSxcbiAgICBhdXRvRHJhd0VuYWJsZWQ6IHRydWUsXG4gICAgaGl0T25EcmFnRW5hYmxlZDogZmFsc2UsXG4gICAgY2FwdHVyZVBvaW50ZXJFdmVudHNFbmFibGVkOiBmYWxzZSxcbiAgICBfbW91c2VMaXN0ZW5DbGljazogZmFsc2UsXG4gICAgX3RvdWNoTGlzdGVuQ2xpY2s6IGZhbHNlLFxuICAgIF9wb2ludGVyTGlzdGVuQ2xpY2s6IGZhbHNlLFxuICAgIF9tb3VzZUluRGJsQ2xpY2tXaW5kb3c6IGZhbHNlLFxuICAgIF90b3VjaEluRGJsQ2xpY2tXaW5kb3c6IGZhbHNlLFxuICAgIF9wb2ludGVySW5EYmxDbGlja1dpbmRvdzogZmFsc2UsXG4gICAgX21vdXNlRGJsQ2xpY2tQb2ludGVySWQ6IG51bGwsXG4gICAgX3RvdWNoRGJsQ2xpY2tQb2ludGVySWQ6IG51bGwsXG4gICAgX3BvaW50ZXJEYmxDbGlja1BvaW50ZXJJZDogbnVsbCxcbiAgICBwaXhlbFJhdGlvOiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8pIHx8IDEsXG4gICAgZHJhZ0Rpc3RhbmNlOiAzLFxuICAgIGFuZ2xlRGVnOiB0cnVlLFxuICAgIHNob3dXYXJuaW5nczogdHJ1ZSxcbiAgICBkcmFnQnV0dG9uczogWzAsIDFdLFxuICAgIGlzRHJhZ2dpbmcoKSB7XG4gICAgICAgIHJldHVybiBLb252YVsnREQnXS5pc0RyYWdnaW5nO1xuICAgIH0sXG4gICAgaXNEcmFnUmVhZHkoKSB7XG4gICAgICAgIHJldHVybiAhIUtvbnZhWydERCddLm5vZGU7XG4gICAgfSxcbiAgICBkb2N1bWVudDogZ2xvYi5kb2N1bWVudCxcbiAgICBfaW5qZWN0R2xvYmFsKEtvbnZhKSB7XG4gICAgICAgIGdsb2IuS29udmEgPSBLb252YTtcbiAgICB9LFxufTtcbmV4cG9ydCBjb25zdCBfcmVnaXN0ZXJOb2RlID0gKE5vZGVDbGFzcykgPT4ge1xuICAgIEtvbnZhW05vZGVDbGFzcy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lKCldID0gTm9kZUNsYXNzO1xufTtcbktvbnZhLl9pbmplY3RHbG9iYWwoS29udmEpO1xuIiwiaW1wb3J0IHsgS29udmEgfSBmcm9tICcuL0dsb2JhbC5qcyc7XG5leHBvcnQgY2xhc3MgVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3RvcihtID0gWzEsIDAsIDAsIDEsIDAsIDBdKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tID0gKG0gJiYgbS5zbGljZSgpKSB8fCBbMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLm1bMF0gPSAxO1xuICAgICAgICB0aGlzLm1bMV0gPSAwO1xuICAgICAgICB0aGlzLm1bMl0gPSAwO1xuICAgICAgICB0aGlzLm1bM10gPSAxO1xuICAgICAgICB0aGlzLm1bNF0gPSAwO1xuICAgICAgICB0aGlzLm1bNV0gPSAwO1xuICAgIH1cbiAgICBjb3B5KCkge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zZm9ybSh0aGlzLm0pO1xuICAgIH1cbiAgICBjb3B5SW50byh0cikge1xuICAgICAgICB0ci5tWzBdID0gdGhpcy5tWzBdO1xuICAgICAgICB0ci5tWzFdID0gdGhpcy5tWzFdO1xuICAgICAgICB0ci5tWzJdID0gdGhpcy5tWzJdO1xuICAgICAgICB0ci5tWzNdID0gdGhpcy5tWzNdO1xuICAgICAgICB0ci5tWzRdID0gdGhpcy5tWzRdO1xuICAgICAgICB0ci5tWzVdID0gdGhpcy5tWzVdO1xuICAgIH1cbiAgICBwb2ludChwb2ludCkge1xuICAgICAgICB2YXIgbSA9IHRoaXMubTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IG1bMF0gKiBwb2ludC54ICsgbVsyXSAqIHBvaW50LnkgKyBtWzRdLFxuICAgICAgICAgICAgeTogbVsxXSAqIHBvaW50LnggKyBtWzNdICogcG9pbnQueSArIG1bNV0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgICAgIHRoaXMubVs0XSArPSB0aGlzLm1bMF0gKiB4ICsgdGhpcy5tWzJdICogeTtcbiAgICAgICAgdGhpcy5tWzVdICs9IHRoaXMubVsxXSAqIHggKyB0aGlzLm1bM10gKiB5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2NhbGUoc3gsIHN5KSB7XG4gICAgICAgIHRoaXMubVswXSAqPSBzeDtcbiAgICAgICAgdGhpcy5tWzFdICo9IHN4O1xuICAgICAgICB0aGlzLm1bMl0gKj0gc3k7XG4gICAgICAgIHRoaXMubVszXSAqPSBzeTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJvdGF0ZShyYWQpIHtcbiAgICAgICAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgICAgICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gICAgICAgIHZhciBtMTEgPSB0aGlzLm1bMF0gKiBjICsgdGhpcy5tWzJdICogcztcbiAgICAgICAgdmFyIG0xMiA9IHRoaXMubVsxXSAqIGMgKyB0aGlzLm1bM10gKiBzO1xuICAgICAgICB2YXIgbTIxID0gdGhpcy5tWzBdICogLXMgKyB0aGlzLm1bMl0gKiBjO1xuICAgICAgICB2YXIgbTIyID0gdGhpcy5tWzFdICogLXMgKyB0aGlzLm1bM10gKiBjO1xuICAgICAgICB0aGlzLm1bMF0gPSBtMTE7XG4gICAgICAgIHRoaXMubVsxXSA9IG0xMjtcbiAgICAgICAgdGhpcy5tWzJdID0gbTIxO1xuICAgICAgICB0aGlzLm1bM10gPSBtMjI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRUcmFuc2xhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHRoaXMubVs0XSxcbiAgICAgICAgICAgIHk6IHRoaXMubVs1XSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc2tldyhzeCwgc3kpIHtcbiAgICAgICAgdmFyIG0xMSA9IHRoaXMubVswXSArIHRoaXMubVsyXSAqIHN5O1xuICAgICAgICB2YXIgbTEyID0gdGhpcy5tWzFdICsgdGhpcy5tWzNdICogc3k7XG4gICAgICAgIHZhciBtMjEgPSB0aGlzLm1bMl0gKyB0aGlzLm1bMF0gKiBzeDtcbiAgICAgICAgdmFyIG0yMiA9IHRoaXMubVszXSArIHRoaXMubVsxXSAqIHN4O1xuICAgICAgICB0aGlzLm1bMF0gPSBtMTE7XG4gICAgICAgIHRoaXMubVsxXSA9IG0xMjtcbiAgICAgICAgdGhpcy5tWzJdID0gbTIxO1xuICAgICAgICB0aGlzLm1bM10gPSBtMjI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBtdWx0aXBseShtYXRyaXgpIHtcbiAgICAgICAgdmFyIG0xMSA9IHRoaXMubVswXSAqIG1hdHJpeC5tWzBdICsgdGhpcy5tWzJdICogbWF0cml4Lm1bMV07XG4gICAgICAgIHZhciBtMTIgPSB0aGlzLm1bMV0gKiBtYXRyaXgubVswXSArIHRoaXMubVszXSAqIG1hdHJpeC5tWzFdO1xuICAgICAgICB2YXIgbTIxID0gdGhpcy5tWzBdICogbWF0cml4Lm1bMl0gKyB0aGlzLm1bMl0gKiBtYXRyaXgubVszXTtcbiAgICAgICAgdmFyIG0yMiA9IHRoaXMubVsxXSAqIG1hdHJpeC5tWzJdICsgdGhpcy5tWzNdICogbWF0cml4Lm1bM107XG4gICAgICAgIHZhciBkeCA9IHRoaXMubVswXSAqIG1hdHJpeC5tWzRdICsgdGhpcy5tWzJdICogbWF0cml4Lm1bNV0gKyB0aGlzLm1bNF07XG4gICAgICAgIHZhciBkeSA9IHRoaXMubVsxXSAqIG1hdHJpeC5tWzRdICsgdGhpcy5tWzNdICogbWF0cml4Lm1bNV0gKyB0aGlzLm1bNV07XG4gICAgICAgIHRoaXMubVswXSA9IG0xMTtcbiAgICAgICAgdGhpcy5tWzFdID0gbTEyO1xuICAgICAgICB0aGlzLm1bMl0gPSBtMjE7XG4gICAgICAgIHRoaXMubVszXSA9IG0yMjtcbiAgICAgICAgdGhpcy5tWzRdID0gZHg7XG4gICAgICAgIHRoaXMubVs1XSA9IGR5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaW52ZXJ0KCkge1xuICAgICAgICB2YXIgZCA9IDEgLyAodGhpcy5tWzBdICogdGhpcy5tWzNdIC0gdGhpcy5tWzFdICogdGhpcy5tWzJdKTtcbiAgICAgICAgdmFyIG0wID0gdGhpcy5tWzNdICogZDtcbiAgICAgICAgdmFyIG0xID0gLXRoaXMubVsxXSAqIGQ7XG4gICAgICAgIHZhciBtMiA9IC10aGlzLm1bMl0gKiBkO1xuICAgICAgICB2YXIgbTMgPSB0aGlzLm1bMF0gKiBkO1xuICAgICAgICB2YXIgbTQgPSBkICogKHRoaXMubVsyXSAqIHRoaXMubVs1XSAtIHRoaXMubVszXSAqIHRoaXMubVs0XSk7XG4gICAgICAgIHZhciBtNSA9IGQgKiAodGhpcy5tWzFdICogdGhpcy5tWzRdIC0gdGhpcy5tWzBdICogdGhpcy5tWzVdKTtcbiAgICAgICAgdGhpcy5tWzBdID0gbTA7XG4gICAgICAgIHRoaXMubVsxXSA9IG0xO1xuICAgICAgICB0aGlzLm1bMl0gPSBtMjtcbiAgICAgICAgdGhpcy5tWzNdID0gbTM7XG4gICAgICAgIHRoaXMubVs0XSA9IG00O1xuICAgICAgICB0aGlzLm1bNV0gPSBtNTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldE1hdHJpeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubTtcbiAgICB9XG4gICAgZGVjb21wb3NlKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMubVswXTtcbiAgICAgICAgdmFyIGIgPSB0aGlzLm1bMV07XG4gICAgICAgIHZhciBjID0gdGhpcy5tWzJdO1xuICAgICAgICB2YXIgZCA9IHRoaXMubVszXTtcbiAgICAgICAgdmFyIGUgPSB0aGlzLm1bNF07XG4gICAgICAgIHZhciBmID0gdGhpcy5tWzVdO1xuICAgICAgICB2YXIgZGVsdGEgPSBhICogZCAtIGIgKiBjO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgeDogZSxcbiAgICAgICAgICAgIHk6IGYsXG4gICAgICAgICAgICByb3RhdGlvbjogMCxcbiAgICAgICAgICAgIHNjYWxlWDogMCxcbiAgICAgICAgICAgIHNjYWxlWTogMCxcbiAgICAgICAgICAgIHNrZXdYOiAwLFxuICAgICAgICAgICAgc2tld1k6IDAsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChhICE9IDAgfHwgYiAhPSAwKSB7XG4gICAgICAgICAgICB2YXIgciA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgICAgICAgICAgIHJlc3VsdC5yb3RhdGlvbiA9IGIgPiAwID8gTWF0aC5hY29zKGEgLyByKSA6IC1NYXRoLmFjb3MoYSAvIHIpO1xuICAgICAgICAgICAgcmVzdWx0LnNjYWxlWCA9IHI7XG4gICAgICAgICAgICByZXN1bHQuc2NhbGVZID0gZGVsdGEgLyByO1xuICAgICAgICAgICAgcmVzdWx0LnNrZXdYID0gKGEgKiBjICsgYiAqIGQpIC8gZGVsdGE7XG4gICAgICAgICAgICByZXN1bHQuc2tld1kgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgIT0gMCB8fCBkICE9IDApIHtcbiAgICAgICAgICAgIHZhciBzID0gTWF0aC5zcXJ0KGMgKiBjICsgZCAqIGQpO1xuICAgICAgICAgICAgcmVzdWx0LnJvdGF0aW9uID1cbiAgICAgICAgICAgICAgICBNYXRoLlBJIC8gMiAtIChkID4gMCA/IE1hdGguYWNvcygtYyAvIHMpIDogLU1hdGguYWNvcyhjIC8gcykpO1xuICAgICAgICAgICAgcmVzdWx0LnNjYWxlWCA9IGRlbHRhIC8gcztcbiAgICAgICAgICAgIHJlc3VsdC5zY2FsZVkgPSBzO1xuICAgICAgICAgICAgcmVzdWx0LnNrZXdYID0gMDtcbiAgICAgICAgICAgIHJlc3VsdC5za2V3WSA9IChhICogYyArIGIgKiBkKSAvIGRlbHRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5yb3RhdGlvbiA9IFV0aWwuX2dldFJvdGF0aW9uKHJlc3VsdC5yb3RhdGlvbik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxudmFyIE9CSkVDVF9BUlJBWSA9ICdbb2JqZWN0IEFycmF5XScsIE9CSkVDVF9OVU1CRVIgPSAnW29iamVjdCBOdW1iZXJdJywgT0JKRUNUX1NUUklORyA9ICdbb2JqZWN0IFN0cmluZ10nLCBPQkpFQ1RfQk9PTEVBTiA9ICdbb2JqZWN0IEJvb2xlYW5dJywgUElfT1ZFUl9ERUcxODAgPSBNYXRoLlBJIC8gMTgwLCBERUcxODBfT1ZFUl9QSSA9IDE4MCAvIE1hdGguUEksIEhBU0ggPSAnIycsIEVNUFRZX1NUUklORyA9ICcnLCBaRVJPID0gJzAnLCBLT05WQV9XQVJOSU5HID0gJ0tvbnZhIHdhcm5pbmc6ICcsIEtPTlZBX0VSUk9SID0gJ0tvbnZhIGVycm9yOiAnLCBSR0JfUEFSRU4gPSAncmdiKCcsIENPTE9SUyA9IHtcbiAgICBhbGljZWJsdWU6IFsyNDAsIDI0OCwgMjU1XSxcbiAgICBhbnRpcXVld2hpdGU6IFsyNTAsIDIzNSwgMjE1XSxcbiAgICBhcXVhOiBbMCwgMjU1LCAyNTVdLFxuICAgIGFxdWFtYXJpbmU6IFsxMjcsIDI1NSwgMjEyXSxcbiAgICBhenVyZTogWzI0MCwgMjU1LCAyNTVdLFxuICAgIGJlaWdlOiBbMjQ1LCAyNDUsIDIyMF0sXG4gICAgYmlzcXVlOiBbMjU1LCAyMjgsIDE5Nl0sXG4gICAgYmxhY2s6IFswLCAwLCAwXSxcbiAgICBibGFuY2hlZGFsbW9uZDogWzI1NSwgMjM1LCAyMDVdLFxuICAgIGJsdWU6IFswLCAwLCAyNTVdLFxuICAgIGJsdWV2aW9sZXQ6IFsxMzgsIDQzLCAyMjZdLFxuICAgIGJyb3duOiBbMTY1LCA0MiwgNDJdLFxuICAgIGJ1cmx5d29vZDogWzIyMiwgMTg0LCAxMzVdLFxuICAgIGNhZGV0Ymx1ZTogWzk1LCAxNTgsIDE2MF0sXG4gICAgY2hhcnRyZXVzZTogWzEyNywgMjU1LCAwXSxcbiAgICBjaG9jb2xhdGU6IFsyMTAsIDEwNSwgMzBdLFxuICAgIGNvcmFsOiBbMjU1LCAxMjcsIDgwXSxcbiAgICBjb3JuZmxvd2VyYmx1ZTogWzEwMCwgMTQ5LCAyMzddLFxuICAgIGNvcm5zaWxrOiBbMjU1LCAyNDgsIDIyMF0sXG4gICAgY3JpbXNvbjogWzIyMCwgMjAsIDYwXSxcbiAgICBjeWFuOiBbMCwgMjU1LCAyNTVdLFxuICAgIGRhcmtibHVlOiBbMCwgMCwgMTM5XSxcbiAgICBkYXJrY3lhbjogWzAsIDEzOSwgMTM5XSxcbiAgICBkYXJrZ29sZGVucm9kOiBbMTg0LCAxMzIsIDExXSxcbiAgICBkYXJrZ3JheTogWzE2OSwgMTY5LCAxNjldLFxuICAgIGRhcmtncmVlbjogWzAsIDEwMCwgMF0sXG4gICAgZGFya2dyZXk6IFsxNjksIDE2OSwgMTY5XSxcbiAgICBkYXJra2hha2k6IFsxODksIDE4MywgMTA3XSxcbiAgICBkYXJrbWFnZW50YTogWzEzOSwgMCwgMTM5XSxcbiAgICBkYXJrb2xpdmVncmVlbjogWzg1LCAxMDcsIDQ3XSxcbiAgICBkYXJrb3JhbmdlOiBbMjU1LCAxNDAsIDBdLFxuICAgIGRhcmtvcmNoaWQ6IFsxNTMsIDUwLCAyMDRdLFxuICAgIGRhcmtyZWQ6IFsxMzksIDAsIDBdLFxuICAgIGRhcmtzYWxtb246IFsyMzMsIDE1MCwgMTIyXSxcbiAgICBkYXJrc2VhZ3JlZW46IFsxNDMsIDE4OCwgMTQzXSxcbiAgICBkYXJrc2xhdGVibHVlOiBbNzIsIDYxLCAxMzldLFxuICAgIGRhcmtzbGF0ZWdyYXk6IFs0NywgNzksIDc5XSxcbiAgICBkYXJrc2xhdGVncmV5OiBbNDcsIDc5LCA3OV0sXG4gICAgZGFya3R1cnF1b2lzZTogWzAsIDIwNiwgMjA5XSxcbiAgICBkYXJrdmlvbGV0OiBbMTQ4LCAwLCAyMTFdLFxuICAgIGRlZXBwaW5rOiBbMjU1LCAyMCwgMTQ3XSxcbiAgICBkZWVwc2t5Ymx1ZTogWzAsIDE5MSwgMjU1XSxcbiAgICBkaW1ncmF5OiBbMTA1LCAxMDUsIDEwNV0sXG4gICAgZGltZ3JleTogWzEwNSwgMTA1LCAxMDVdLFxuICAgIGRvZGdlcmJsdWU6IFszMCwgMTQ0LCAyNTVdLFxuICAgIGZpcmVicmljazogWzE3OCwgMzQsIDM0XSxcbiAgICBmbG9yYWx3aGl0ZTogWzI1NSwgMjU1LCAyNDBdLFxuICAgIGZvcmVzdGdyZWVuOiBbMzQsIDEzOSwgMzRdLFxuICAgIGZ1Y2hzaWE6IFsyNTUsIDAsIDI1NV0sXG4gICAgZ2FpbnNib3JvOiBbMjIwLCAyMjAsIDIyMF0sXG4gICAgZ2hvc3R3aGl0ZTogWzI0OCwgMjQ4LCAyNTVdLFxuICAgIGdvbGQ6IFsyNTUsIDIxNSwgMF0sXG4gICAgZ29sZGVucm9kOiBbMjE4LCAxNjUsIDMyXSxcbiAgICBncmF5OiBbMTI4LCAxMjgsIDEyOF0sXG4gICAgZ3JlZW46IFswLCAxMjgsIDBdLFxuICAgIGdyZWVueWVsbG93OiBbMTczLCAyNTUsIDQ3XSxcbiAgICBncmV5OiBbMTI4LCAxMjgsIDEyOF0sXG4gICAgaG9uZXlkZXc6IFsyNDAsIDI1NSwgMjQwXSxcbiAgICBob3RwaW5rOiBbMjU1LCAxMDUsIDE4MF0sXG4gICAgaW5kaWFucmVkOiBbMjA1LCA5MiwgOTJdLFxuICAgIGluZGlnbzogWzc1LCAwLCAxMzBdLFxuICAgIGl2b3J5OiBbMjU1LCAyNTUsIDI0MF0sXG4gICAga2hha2k6IFsyNDAsIDIzMCwgMTQwXSxcbiAgICBsYXZlbmRlcjogWzIzMCwgMjMwLCAyNTBdLFxuICAgIGxhdmVuZGVyYmx1c2g6IFsyNTUsIDI0MCwgMjQ1XSxcbiAgICBsYXduZ3JlZW46IFsxMjQsIDI1MiwgMF0sXG4gICAgbGVtb25jaGlmZm9uOiBbMjU1LCAyNTAsIDIwNV0sXG4gICAgbGlnaHRibHVlOiBbMTczLCAyMTYsIDIzMF0sXG4gICAgbGlnaHRjb3JhbDogWzI0MCwgMTI4LCAxMjhdLFxuICAgIGxpZ2h0Y3lhbjogWzIyNCwgMjU1LCAyNTVdLFxuICAgIGxpZ2h0Z29sZGVucm9keWVsbG93OiBbMjUwLCAyNTAsIDIxMF0sXG4gICAgbGlnaHRncmF5OiBbMjExLCAyMTEsIDIxMV0sXG4gICAgbGlnaHRncmVlbjogWzE0NCwgMjM4LCAxNDRdLFxuICAgIGxpZ2h0Z3JleTogWzIxMSwgMjExLCAyMTFdLFxuICAgIGxpZ2h0cGluazogWzI1NSwgMTgyLCAxOTNdLFxuICAgIGxpZ2h0c2FsbW9uOiBbMjU1LCAxNjAsIDEyMl0sXG4gICAgbGlnaHRzZWFncmVlbjogWzMyLCAxNzgsIDE3MF0sXG4gICAgbGlnaHRza3libHVlOiBbMTM1LCAyMDYsIDI1MF0sXG4gICAgbGlnaHRzbGF0ZWdyYXk6IFsxMTksIDEzNiwgMTUzXSxcbiAgICBsaWdodHNsYXRlZ3JleTogWzExOSwgMTM2LCAxNTNdLFxuICAgIGxpZ2h0c3RlZWxibHVlOiBbMTc2LCAxOTYsIDIyMl0sXG4gICAgbGlnaHR5ZWxsb3c6IFsyNTUsIDI1NSwgMjI0XSxcbiAgICBsaW1lOiBbMCwgMjU1LCAwXSxcbiAgICBsaW1lZ3JlZW46IFs1MCwgMjA1LCA1MF0sXG4gICAgbGluZW46IFsyNTAsIDI0MCwgMjMwXSxcbiAgICBtYWdlbnRhOiBbMjU1LCAwLCAyNTVdLFxuICAgIG1hcm9vbjogWzEyOCwgMCwgMF0sXG4gICAgbWVkaXVtYXF1YW1hcmluZTogWzEwMiwgMjA1LCAxNzBdLFxuICAgIG1lZGl1bWJsdWU6IFswLCAwLCAyMDVdLFxuICAgIG1lZGl1bW9yY2hpZDogWzE4NiwgODUsIDIxMV0sXG4gICAgbWVkaXVtcHVycGxlOiBbMTQ3LCAxMTIsIDIxOV0sXG4gICAgbWVkaXVtc2VhZ3JlZW46IFs2MCwgMTc5LCAxMTNdLFxuICAgIG1lZGl1bXNsYXRlYmx1ZTogWzEyMywgMTA0LCAyMzhdLFxuICAgIG1lZGl1bXNwcmluZ2dyZWVuOiBbMCwgMjUwLCAxNTRdLFxuICAgIG1lZGl1bXR1cnF1b2lzZTogWzcyLCAyMDksIDIwNF0sXG4gICAgbWVkaXVtdmlvbGV0cmVkOiBbMTk5LCAyMSwgMTMzXSxcbiAgICBtaWRuaWdodGJsdWU6IFsyNSwgMjUsIDExMl0sXG4gICAgbWludGNyZWFtOiBbMjQ1LCAyNTUsIDI1MF0sXG4gICAgbWlzdHlyb3NlOiBbMjU1LCAyMjgsIDIyNV0sXG4gICAgbW9jY2FzaW46IFsyNTUsIDIyOCwgMTgxXSxcbiAgICBuYXZham93aGl0ZTogWzI1NSwgMjIyLCAxNzNdLFxuICAgIG5hdnk6IFswLCAwLCAxMjhdLFxuICAgIG9sZGxhY2U6IFsyNTMsIDI0NSwgMjMwXSxcbiAgICBvbGl2ZTogWzEyOCwgMTI4LCAwXSxcbiAgICBvbGl2ZWRyYWI6IFsxMDcsIDE0MiwgMzVdLFxuICAgIG9yYW5nZTogWzI1NSwgMTY1LCAwXSxcbiAgICBvcmFuZ2VyZWQ6IFsyNTUsIDY5LCAwXSxcbiAgICBvcmNoaWQ6IFsyMTgsIDExMiwgMjE0XSxcbiAgICBwYWxlZ29sZGVucm9kOiBbMjM4LCAyMzIsIDE3MF0sXG4gICAgcGFsZWdyZWVuOiBbMTUyLCAyNTEsIDE1Ml0sXG4gICAgcGFsZXR1cnF1b2lzZTogWzE3NSwgMjM4LCAyMzhdLFxuICAgIHBhbGV2aW9sZXRyZWQ6IFsyMTksIDExMiwgMTQ3XSxcbiAgICBwYXBheWF3aGlwOiBbMjU1LCAyMzksIDIxM10sXG4gICAgcGVhY2hwdWZmOiBbMjU1LCAyMTgsIDE4NV0sXG4gICAgcGVydTogWzIwNSwgMTMzLCA2M10sXG4gICAgcGluazogWzI1NSwgMTkyLCAyMDNdLFxuICAgIHBsdW06IFsyMjEsIDE2MCwgMjAzXSxcbiAgICBwb3dkZXJibHVlOiBbMTc2LCAyMjQsIDIzMF0sXG4gICAgcHVycGxlOiBbMTI4LCAwLCAxMjhdLFxuICAgIHJlYmVjY2FwdXJwbGU6IFsxMDIsIDUxLCAxNTNdLFxuICAgIHJlZDogWzI1NSwgMCwgMF0sXG4gICAgcm9zeWJyb3duOiBbMTg4LCAxNDMsIDE0M10sXG4gICAgcm95YWxibHVlOiBbNjUsIDEwNSwgMjI1XSxcbiAgICBzYWRkbGVicm93bjogWzEzOSwgNjksIDE5XSxcbiAgICBzYWxtb246IFsyNTAsIDEyOCwgMTE0XSxcbiAgICBzYW5keWJyb3duOiBbMjQ0LCAxNjQsIDk2XSxcbiAgICBzZWFncmVlbjogWzQ2LCAxMzksIDg3XSxcbiAgICBzZWFzaGVsbDogWzI1NSwgMjQ1LCAyMzhdLFxuICAgIHNpZW5uYTogWzE2MCwgODIsIDQ1XSxcbiAgICBzaWx2ZXI6IFsxOTIsIDE5MiwgMTkyXSxcbiAgICBza3libHVlOiBbMTM1LCAyMDYsIDIzNV0sXG4gICAgc2xhdGVibHVlOiBbMTA2LCA5MCwgMjA1XSxcbiAgICBzbGF0ZWdyYXk6IFsxMTksIDEyOCwgMTQ0XSxcbiAgICBzbGF0ZWdyZXk6IFsxMTksIDEyOCwgMTQ0XSxcbiAgICBzbm93OiBbMjU1LCAyNTUsIDI1MF0sXG4gICAgc3ByaW5nZ3JlZW46IFswLCAyNTUsIDEyN10sXG4gICAgc3RlZWxibHVlOiBbNzAsIDEzMCwgMTgwXSxcbiAgICB0YW46IFsyMTAsIDE4MCwgMTQwXSxcbiAgICB0ZWFsOiBbMCwgMTI4LCAxMjhdLFxuICAgIHRoaXN0bGU6IFsyMTYsIDE5MSwgMjE2XSxcbiAgICB0cmFuc3BhcmVudDogWzI1NSwgMjU1LCAyNTUsIDBdLFxuICAgIHRvbWF0bzogWzI1NSwgOTksIDcxXSxcbiAgICB0dXJxdW9pc2U6IFs2NCwgMjI0LCAyMDhdLFxuICAgIHZpb2xldDogWzIzOCwgMTMwLCAyMzhdLFxuICAgIHdoZWF0OiBbMjQ1LCAyMjIsIDE3OV0sXG4gICAgd2hpdGU6IFsyNTUsIDI1NSwgMjU1XSxcbiAgICB3aGl0ZXNtb2tlOiBbMjQ1LCAyNDUsIDI0NV0sXG4gICAgeWVsbG93OiBbMjU1LCAyNTUsIDBdLFxuICAgIHllbGxvd2dyZWVuOiBbMTU0LCAyMDUsIDVdLFxufSwgUkdCX1JFR0VYID0gL3JnYlxcKChcXGR7MSwzfSksKFxcZHsxLDN9KSwoXFxkezEsM30pXFwpLywgYW5pbVF1ZXVlID0gW107XG5jb25zdCByZXEgPSAodHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB8fFxuICAgIGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZiwgNjApO1xuICAgIH07XG5leHBvcnQgY29uc3QgVXRpbCA9IHtcbiAgICBfaXNFbGVtZW50KG9iaikge1xuICAgICAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PSAxKTtcbiAgICB9LFxuICAgIF9pc0Z1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gISEob2JqICYmIG9iai5jb25zdHJ1Y3RvciAmJiBvYmouY2FsbCAmJiBvYmouYXBwbHkpO1xuICAgIH0sXG4gICAgX2lzUGxhaW5PYmplY3Qob2JqKSB7XG4gICAgICAgIHJldHVybiAhIW9iaiAmJiBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdDtcbiAgICB9LFxuICAgIF9pc0FycmF5KG9iaikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IE9CSkVDVF9BUlJBWTtcbiAgICB9LFxuICAgIF9pc051bWJlcihvYmopIHtcbiAgICAgICAgcmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gT0JKRUNUX05VTUJFUiAmJlxuICAgICAgICAgICAgIWlzTmFOKG9iaikgJiZcbiAgICAgICAgICAgIGlzRmluaXRlKG9iaikpO1xuICAgIH0sXG4gICAgX2lzU3RyaW5nKG9iaikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IE9CSkVDVF9TVFJJTkc7XG4gICAgfSxcbiAgICBfaXNCb29sZWFuKG9iaikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IE9CSkVDVF9CT09MRUFOO1xuICAgIH0sXG4gICAgaXNPYmplY3QodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgaW5zdGFuY2VvZiBPYmplY3Q7XG4gICAgfSxcbiAgICBpc1ZhbGlkU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlyc3RDaGFyID0gc2VsZWN0b3JbMF07XG4gICAgICAgIHJldHVybiAoZmlyc3RDaGFyID09PSAnIycgfHxcbiAgICAgICAgICAgIGZpcnN0Q2hhciA9PT0gJy4nIHx8XG4gICAgICAgICAgICBmaXJzdENoYXIgPT09IGZpcnN0Q2hhci50b1VwcGVyQ2FzZSgpKTtcbiAgICB9LFxuICAgIF9zaWduKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtYmVyID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlcXVlc3RBbmltRnJhbWUoY2FsbGJhY2spIHtcbiAgICAgICAgYW5pbVF1ZXVlLnB1c2goY2FsbGJhY2spO1xuICAgICAgICBpZiAoYW5pbVF1ZXVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmVxKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBxdWV1ZSA9IGFuaW1RdWV1ZTtcbiAgICAgICAgICAgICAgICBhbmltUXVldWUgPSBbXTtcbiAgICAgICAgICAgICAgICBxdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZUNhbnZhc0VsZW1lbnQoKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNhbnZhcy5zdHlsZSA9IGNhbnZhcy5zdHlsZSB8fCB7fTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfSxcbiAgICBjcmVhdGVJbWFnZUVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICB9LFxuICAgIF9pc0luRG9jdW1lbnQoZWwpIHtcbiAgICAgICAgd2hpbGUgKChlbCA9IGVsLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoZWwgPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBfdXJsVG9JbWFnZSh1cmwsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpbWFnZU9iaiA9IFV0aWwuY3JlYXRlSW1hZ2VFbGVtZW50KCk7XG4gICAgICAgIGltYWdlT2JqLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGltYWdlT2JqKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW1hZ2VPYmouc3JjID0gdXJsO1xuICAgIH0sXG4gICAgX3JnYlRvSGV4KHIsIGcsIGIpIHtcbiAgICAgICAgcmV0dXJuICgoMSA8PCAyNCkgKyAociA8PCAxNikgKyAoZyA8PCA4KSArIGIpLnRvU3RyaW5nKDE2KS5zbGljZSgxKTtcbiAgICB9LFxuICAgIF9oZXhUb1JnYihoZXgpIHtcbiAgICAgICAgaGV4ID0gaGV4LnJlcGxhY2UoSEFTSCwgRU1QVFlfU1RSSU5HKTtcbiAgICAgICAgdmFyIGJpZ2ludCA9IHBhcnNlSW50KGhleCwgMTYpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcjogKGJpZ2ludCA+PiAxNikgJiAyNTUsXG4gICAgICAgICAgICBnOiAoYmlnaW50ID4+IDgpICYgMjU1LFxuICAgICAgICAgICAgYjogYmlnaW50ICYgMjU1LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZ2V0UmFuZG9tQ29sb3IoKSB7XG4gICAgICAgIHZhciByYW5kQ29sb3IgPSAoKE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZikgPDwgMCkudG9TdHJpbmcoMTYpO1xuICAgICAgICB3aGlsZSAocmFuZENvbG9yLmxlbmd0aCA8IDYpIHtcbiAgICAgICAgICAgIHJhbmRDb2xvciA9IFpFUk8gKyByYW5kQ29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEhBU0ggKyByYW5kQ29sb3I7XG4gICAgfSxcbiAgICBnZXRSR0IoY29sb3IpIHtcbiAgICAgICAgdmFyIHJnYjtcbiAgICAgICAgaWYgKGNvbG9yIGluIENPTE9SUykge1xuICAgICAgICAgICAgcmdiID0gQ09MT1JTW2NvbG9yXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcjogcmdiWzBdLFxuICAgICAgICAgICAgICAgIGc6IHJnYlsxXSxcbiAgICAgICAgICAgICAgICBiOiByZ2JbMl0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbG9yWzBdID09PSBIQVNIKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGV4VG9SZ2IoY29sb3Iuc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2xvci5zdWJzdHIoMCwgNCkgPT09IFJHQl9QQVJFTikge1xuICAgICAgICAgICAgcmdiID0gUkdCX1JFR0VYLmV4ZWMoY29sb3IucmVwbGFjZSgvIC9nLCAnJykpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByOiBwYXJzZUludChyZ2JbMV0sIDEwKSxcbiAgICAgICAgICAgICAgICBnOiBwYXJzZUludChyZ2JbMl0sIDEwKSxcbiAgICAgICAgICAgICAgICBiOiBwYXJzZUludChyZ2JbM10sIDEwKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHI6IDAsXG4gICAgICAgICAgICAgICAgZzogMCxcbiAgICAgICAgICAgICAgICBiOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29sb3JUb1JHQkEoc3RyKSB7XG4gICAgICAgIHN0ciA9IHN0ciB8fCAnYmxhY2snO1xuICAgICAgICByZXR1cm4gKFV0aWwuX25hbWVkQ29sb3JUb1JCQShzdHIpIHx8XG4gICAgICAgICAgICBVdGlsLl9oZXgzQ29sb3JUb1JHQkEoc3RyKSB8fFxuICAgICAgICAgICAgVXRpbC5faGV4NkNvbG9yVG9SR0JBKHN0cikgfHxcbiAgICAgICAgICAgIFV0aWwuX3JnYkNvbG9yVG9SR0JBKHN0cikgfHxcbiAgICAgICAgICAgIFV0aWwuX3JnYmFDb2xvclRvUkdCQShzdHIpIHx8XG4gICAgICAgICAgICBVdGlsLl9oc2xDb2xvclRvUkdCQShzdHIpKTtcbiAgICB9LFxuICAgIF9uYW1lZENvbG9yVG9SQkEoc3RyKSB7XG4gICAgICAgIHZhciBjID0gQ09MT1JTW3N0ci50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgaWYgKCFjKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcjogY1swXSxcbiAgICAgICAgICAgIGc6IGNbMV0sXG4gICAgICAgICAgICBiOiBjWzJdLFxuICAgICAgICAgICAgYTogMSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIF9yZ2JDb2xvclRvUkdCQShzdHIpIHtcbiAgICAgICAgaWYgKHN0ci5pbmRleE9mKCdyZ2IoJykgPT09IDApIHtcbiAgICAgICAgICAgIHN0ciA9IHN0ci5tYXRjaCgvcmdiXFwoKFteKV0rKVxcKS8pWzFdO1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KC8gKiwgKi8pLm1hcChOdW1iZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByOiBwYXJ0c1swXSxcbiAgICAgICAgICAgICAgICBnOiBwYXJ0c1sxXSxcbiAgICAgICAgICAgICAgICBiOiBwYXJ0c1syXSxcbiAgICAgICAgICAgICAgICBhOiAxLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX3JnYmFDb2xvclRvUkdCQShzdHIpIHtcbiAgICAgICAgaWYgKHN0ci5pbmRleE9mKCdyZ2JhKCcpID09PSAwKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIubWF0Y2goL3JnYmFcXCgoW14pXSspXFwpLylbMV07XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoLyAqLCAqLykubWFwKChuLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChuLnNsaWNlKC0xKSA9PT0gJyUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCA9PT0gMyA/IHBhcnNlSW50KG4pIC8gMTAwIDogKHBhcnNlSW50KG4pIC8gMTAwKSAqIDI1NTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcihuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByOiBwYXJ0c1swXSxcbiAgICAgICAgICAgICAgICBnOiBwYXJ0c1sxXSxcbiAgICAgICAgICAgICAgICBiOiBwYXJ0c1syXSxcbiAgICAgICAgICAgICAgICBhOiBwYXJ0c1szXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9oZXg2Q29sb3JUb1JHQkEoc3RyKSB7XG4gICAgICAgIGlmIChzdHJbMF0gPT09ICcjJyAmJiBzdHIubGVuZ3RoID09PSA3KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHI6IHBhcnNlSW50KHN0ci5zbGljZSgxLCAzKSwgMTYpLFxuICAgICAgICAgICAgICAgIGc6IHBhcnNlSW50KHN0ci5zbGljZSgzLCA1KSwgMTYpLFxuICAgICAgICAgICAgICAgIGI6IHBhcnNlSW50KHN0ci5zbGljZSg1LCA3KSwgMTYpLFxuICAgICAgICAgICAgICAgIGE6IDEsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfaGV4M0NvbG9yVG9SR0JBKHN0cikge1xuICAgICAgICBpZiAoc3RyWzBdID09PSAnIycgJiYgc3RyLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByOiBwYXJzZUludChzdHJbMV0gKyBzdHJbMV0sIDE2KSxcbiAgICAgICAgICAgICAgICBnOiBwYXJzZUludChzdHJbMl0gKyBzdHJbMl0sIDE2KSxcbiAgICAgICAgICAgICAgICBiOiBwYXJzZUludChzdHJbM10gKyBzdHJbM10sIDE2KSxcbiAgICAgICAgICAgICAgICBhOiAxLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX2hzbENvbG9yVG9SR0JBKHN0cikge1xuICAgICAgICBpZiAoL2hzbFxcKChcXGQrKSxcXHMqKFtcXGQuXSspJSxcXHMqKFtcXGQuXSspJVxcKS9nLnRlc3Qoc3RyKSkge1xuICAgICAgICAgICAgY29uc3QgW18sIC4uLmhzbF0gPSAvaHNsXFwoKFxcZCspLFxccyooW1xcZC5dKyklLFxccyooW1xcZC5dKyklXFwpL2cuZXhlYyhzdHIpO1xuICAgICAgICAgICAgY29uc3QgaCA9IE51bWJlcihoc2xbMF0pIC8gMzYwO1xuICAgICAgICAgICAgY29uc3QgcyA9IE51bWJlcihoc2xbMV0pIC8gMTAwO1xuICAgICAgICAgICAgY29uc3QgbCA9IE51bWJlcihoc2xbMl0pIC8gMTAwO1xuICAgICAgICAgICAgbGV0IHQyO1xuICAgICAgICAgICAgbGV0IHQzO1xuICAgICAgICAgICAgbGV0IHZhbDtcbiAgICAgICAgICAgIGlmIChzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gbCAqIDI1NTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByOiBNYXRoLnJvdW5kKHZhbCksXG4gICAgICAgICAgICAgICAgICAgIGc6IE1hdGgucm91bmQodmFsKSxcbiAgICAgICAgICAgICAgICAgICAgYjogTWF0aC5yb3VuZCh2YWwpLFxuICAgICAgICAgICAgICAgICAgICBhOiAxLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobCA8IDAuNSkge1xuICAgICAgICAgICAgICAgIHQyID0gbCAqICgxICsgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0MiA9IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0MSA9IDIgKiBsIC0gdDI7XG4gICAgICAgICAgICBjb25zdCByZ2IgPSBbMCwgMCwgMF07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgIHQzID0gaCArICgxIC8gMykgKiAtKGkgLSAxKTtcbiAgICAgICAgICAgICAgICBpZiAodDMgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHQzKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0MyA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdDMtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKDYgKiB0MyA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdDEgKyAodDIgLSB0MSkgKiA2ICogdDM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKDIgKiB0MyA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKDMgKiB0MyA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdDEgKyAodDIgLSB0MSkgKiAoMiAvIDMgLSB0MykgKiA2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJnYltpXSA9IHZhbCAqIDI1NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcjogTWF0aC5yb3VuZChyZ2JbMF0pLFxuICAgICAgICAgICAgICAgIGc6IE1hdGgucm91bmQocmdiWzFdKSxcbiAgICAgICAgICAgICAgICBiOiBNYXRoLnJvdW5kKHJnYlsyXSksXG4gICAgICAgICAgICAgICAgYTogMSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGhhdmVJbnRlcnNlY3Rpb24ocjEsIHIyKSB7XG4gICAgICAgIHJldHVybiAhKHIyLnggPiByMS54ICsgcjEud2lkdGggfHxcbiAgICAgICAgICAgIHIyLnggKyByMi53aWR0aCA8IHIxLnggfHxcbiAgICAgICAgICAgIHIyLnkgPiByMS55ICsgcjEuaGVpZ2h0IHx8XG4gICAgICAgICAgICByMi55ICsgcjIuaGVpZ2h0IDwgcjEueSk7XG4gICAgfSxcbiAgICBjbG9uZU9iamVjdChvYmopIHtcbiAgICAgICAgdmFyIHJldE9iaiA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNQbGFpbk9iamVjdChvYmpba2V5XSkpIHtcbiAgICAgICAgICAgICAgICByZXRPYmpba2V5XSA9IHRoaXMuY2xvbmVPYmplY3Qob2JqW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5faXNBcnJheShvYmpba2V5XSkpIHtcbiAgICAgICAgICAgICAgICByZXRPYmpba2V5XSA9IHRoaXMuY2xvbmVBcnJheShvYmpba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXRPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXRPYmo7XG4gICAgfSxcbiAgICBjbG9uZUFycmF5KGFycikge1xuICAgICAgICByZXR1cm4gYXJyLnNsaWNlKDApO1xuICAgIH0sXG4gICAgZGVnVG9SYWQoZGVnKSB7XG4gICAgICAgIHJldHVybiBkZWcgKiBQSV9PVkVSX0RFRzE4MDtcbiAgICB9LFxuICAgIHJhZFRvRGVnKHJhZCkge1xuICAgICAgICByZXR1cm4gcmFkICogREVHMTgwX09WRVJfUEk7XG4gICAgfSxcbiAgICBfZGVnVG9SYWQoZGVnKSB7XG4gICAgICAgIFV0aWwud2FybignVXRpbC5fZGVnVG9SYWQgaXMgcmVtb3ZlZC4gUGxlYXNlIHVzZSBwdWJsaWMgVXRpbC5kZWdUb1JhZCBpbnN0ZWFkLicpO1xuICAgICAgICByZXR1cm4gVXRpbC5kZWdUb1JhZChkZWcpO1xuICAgIH0sXG4gICAgX3JhZFRvRGVnKHJhZCkge1xuICAgICAgICBVdGlsLndhcm4oJ1V0aWwuX3JhZFRvRGVnIGlzIHJlbW92ZWQuIFBsZWFzZSB1c2UgcHVibGljIFV0aWwucmFkVG9EZWcgaW5zdGVhZC4nKTtcbiAgICAgICAgcmV0dXJuIFV0aWwucmFkVG9EZWcocmFkKTtcbiAgICB9LFxuICAgIF9nZXRSb3RhdGlvbihyYWRpYW5zKSB7XG4gICAgICAgIHJldHVybiBLb252YS5hbmdsZURlZyA/IFV0aWwucmFkVG9EZWcocmFkaWFucykgOiByYWRpYW5zO1xuICAgIH0sXG4gICAgX2NhcGl0YWxpemUoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG4gICAgfSxcbiAgICB0aHJvdyhzdHIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKEtPTlZBX0VSUk9SICsgc3RyKTtcbiAgICB9LFxuICAgIGVycm9yKHN0cikge1xuICAgICAgICBjb25zb2xlLmVycm9yKEtPTlZBX0VSUk9SICsgc3RyKTtcbiAgICB9LFxuICAgIHdhcm4oc3RyKSB7XG4gICAgICAgIGlmICghS29udmEuc2hvd1dhcm5pbmdzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS53YXJuKEtPTlZBX1dBUk5JTkcgKyBzdHIpO1xuICAgIH0sXG4gICAgZWFjaChvYmosIGZ1bmMpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgZnVuYyhrZXksIG9ialtrZXldKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX2luUmFuZ2UodmFsLCBsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gbGVmdCA8PSB2YWwgJiYgdmFsIDwgcmlnaHQ7XG4gICAgfSxcbiAgICBfZ2V0UHJvamVjdGlvblRvU2VnbWVudCh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAgIHZhciB4LCB5LCBkaXN0O1xuICAgICAgICB2YXIgcGQyID0gKHgxIC0geDIpICogKHgxIC0geDIpICsgKHkxIC0geTIpICogKHkxIC0geTIpO1xuICAgICAgICBpZiAocGQyID09IDApIHtcbiAgICAgICAgICAgIHggPSB4MTtcbiAgICAgICAgICAgIHkgPSB5MTtcbiAgICAgICAgICAgIGRpc3QgPSAoeDMgLSB4MikgKiAoeDMgLSB4MikgKyAoeTMgLSB5MikgKiAoeTMgLSB5Mik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdSA9ICgoeDMgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTMgLSB5MSkgKiAoeTIgLSB5MSkpIC8gcGQyO1xuICAgICAgICAgICAgaWYgKHUgPCAwKSB7XG4gICAgICAgICAgICAgICAgeCA9IHgxO1xuICAgICAgICAgICAgICAgIHkgPSB5MTtcbiAgICAgICAgICAgICAgICBkaXN0ID0gKHgxIC0geDMpICogKHgxIC0geDMpICsgKHkxIC0geTMpICogKHkxIC0geTMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodSA+IDEuMCkge1xuICAgICAgICAgICAgICAgIHggPSB4MjtcbiAgICAgICAgICAgICAgICB5ID0geTI7XG4gICAgICAgICAgICAgICAgZGlzdCA9ICh4MiAtIHgzKSAqICh4MiAtIHgzKSArICh5MiAtIHkzKSAqICh5MiAtIHkzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHggPSB4MSArIHUgKiAoeDIgLSB4MSk7XG4gICAgICAgICAgICAgICAgeSA9IHkxICsgdSAqICh5MiAtIHkxKTtcbiAgICAgICAgICAgICAgICBkaXN0ID0gKHggLSB4MykgKiAoeCAtIHgzKSArICh5IC0geTMpICogKHkgLSB5Myk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt4LCB5LCBkaXN0XTtcbiAgICB9LFxuICAgIF9nZXRQcm9qZWN0aW9uVG9MaW5lKHB0LCBsaW5lLCBpc0Nsb3NlZCkge1xuICAgICAgICB2YXIgcGMgPSBVdGlsLmNsb25lT2JqZWN0KHB0KTtcbiAgICAgICAgdmFyIGRpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICBsaW5lLmZvckVhY2goZnVuY3Rpb24gKHAxLCBpKSB7XG4gICAgICAgICAgICBpZiAoIWlzQ2xvc2VkICYmIGkgPT09IGxpbmUubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwMiA9IGxpbmVbKGkgKyAxKSAlIGxpbmUubGVuZ3RoXTtcbiAgICAgICAgICAgIHZhciBwcm9qID0gVXRpbC5fZ2V0UHJvamVjdGlvblRvU2VnbWVudChwMS54LCBwMS55LCBwMi54LCBwMi55LCBwdC54LCBwdC55KTtcbiAgICAgICAgICAgIHZhciBweCA9IHByb2pbMF0sIHB5ID0gcHJvalsxXSwgcGRpc3QgPSBwcm9qWzJdO1xuICAgICAgICAgICAgaWYgKHBkaXN0IDwgZGlzdCkge1xuICAgICAgICAgICAgICAgIHBjLnggPSBweDtcbiAgICAgICAgICAgICAgICBwYy55ID0gcHk7XG4gICAgICAgICAgICAgICAgZGlzdCA9IHBkaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBjO1xuICAgIH0sXG4gICAgX3ByZXBhcmVBcnJheUZvclR3ZWVuKHN0YXJ0QXJyYXksIGVuZEFycmF5LCBpc0Nsb3NlZCkge1xuICAgICAgICB2YXIgbiwgc3RhcnQgPSBbXSwgZW5kID0gW107XG4gICAgICAgIGlmIChzdGFydEFycmF5Lmxlbmd0aCA+IGVuZEFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHRlbXAgPSBlbmRBcnJheTtcbiAgICAgICAgICAgIGVuZEFycmF5ID0gc3RhcnRBcnJheTtcbiAgICAgICAgICAgIHN0YXJ0QXJyYXkgPSB0ZW1wO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobiA9IDA7IG4gPCBzdGFydEFycmF5Lmxlbmd0aDsgbiArPSAyKSB7XG4gICAgICAgICAgICBzdGFydC5wdXNoKHtcbiAgICAgICAgICAgICAgICB4OiBzdGFydEFycmF5W25dLFxuICAgICAgICAgICAgICAgIHk6IHN0YXJ0QXJyYXlbbiArIDFdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChuID0gMDsgbiA8IGVuZEFycmF5Lmxlbmd0aDsgbiArPSAyKSB7XG4gICAgICAgICAgICBlbmQucHVzaCh7XG4gICAgICAgICAgICAgICAgeDogZW5kQXJyYXlbbl0sXG4gICAgICAgICAgICAgICAgeTogZW5kQXJyYXlbbiArIDFdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld1N0YXJ0ID0gW107XG4gICAgICAgIGVuZC5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgdmFyIHByID0gVXRpbC5fZ2V0UHJvamVjdGlvblRvTGluZShwb2ludCwgc3RhcnQsIGlzQ2xvc2VkKTtcbiAgICAgICAgICAgIG5ld1N0YXJ0LnB1c2gocHIueCk7XG4gICAgICAgICAgICBuZXdTdGFydC5wdXNoKHByLnkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld1N0YXJ0O1xuICAgIH0sXG4gICAgX3ByZXBhcmVUb1N0cmluZ2lmeShvYmopIHtcbiAgICAgICAgdmFyIGRlc2M7XG4gICAgICAgIG9iai52aXNpdGVkQnlDaXJjdWxhclJlZmVyZW5jZVJlbW92YWwgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoIShvYmouaGFzT3duUHJvcGVydHkoa2V5KSAmJiBvYmpba2V5XSAmJiB0eXBlb2Ygb2JqW2tleV0gPT0gJ29iamVjdCcpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gICAgICAgICAgICBpZiAob2JqW2tleV0udmlzaXRlZEJ5Q2lyY3VsYXJSZWZlcmVuY2VSZW1vdmFsIHx8XG4gICAgICAgICAgICAgICAgVXRpbC5faXNFbGVtZW50KG9ialtrZXldKSkge1xuICAgICAgICAgICAgICAgIGlmIChkZXNjLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChVdGlsLl9wcmVwYXJlVG9TdHJpbmdpZnkob2JqW2tleV0pID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlc2MuY29uZmlndXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgb2JqLnZpc2l0ZWRCeUNpcmN1bGFyUmVmZXJlbmNlUmVtb3ZhbDtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIF9hc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0sXG4gICAgX2dldEZpcnN0UG9pbnRlcklkKGV2dCkge1xuICAgICAgICBpZiAoIWV2dC50b3VjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZ0LnBvaW50ZXJJZCB8fCA5OTk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZXZ0LmNoYW5nZWRUb3VjaGVzWzBdLmlkZW50aWZpZXI7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbiIsImltcG9ydCB7IEtvbnZhIH0gZnJvbSAnLi9HbG9iYWwuanMnO1xuaW1wb3J0IHsgVXRpbCB9IGZyb20gJy4vVXRpbC5qcyc7XG5mdW5jdGlvbiBfZm9ybWF0VmFsdWUodmFsKSB7XG4gICAgaWYgKFV0aWwuX2lzU3RyaW5nKHZhbCkpIHtcbiAgICAgICAgcmV0dXJuICdcIicgKyB2YWwgKyAnXCInO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IE51bWJlcl0nKSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGlmIChVdGlsLl9pc0Jvb2xlYW4odmFsKSkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCk7XG59XG5leHBvcnQgZnVuY3Rpb24gUkdCQ29tcG9uZW50KHZhbCkge1xuICAgIGlmICh2YWwgPiAyNTUpIHtcbiAgICAgICAgcmV0dXJuIDI1NTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsIDwgMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhbHBoYUNvbXBvbmVudCh2YWwpIHtcbiAgICBpZiAodmFsID4gMSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsIDwgMC4wMDAxKSB7XG4gICAgICAgIHJldHVybiAwLjAwMDE7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TnVtYmVyVmFsaWRhdG9yKCkge1xuICAgIGlmIChLb252YS5pc1VubWluaWZpZWQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIGF0dHIpIHtcbiAgICAgICAgICAgIGlmICghVXRpbC5faXNOdW1iZXIodmFsKSkge1xuICAgICAgICAgICAgICAgIFV0aWwud2FybihfZm9ybWF0VmFsdWUodmFsKSArXG4gICAgICAgICAgICAgICAgICAgICcgaXMgYSBub3QgdmFsaWQgdmFsdWUgZm9yIFwiJyArXG4gICAgICAgICAgICAgICAgICAgIGF0dHIgK1xuICAgICAgICAgICAgICAgICAgICAnXCIgYXR0cmlidXRlLiBUaGUgdmFsdWUgc2hvdWxkIGJlIGEgbnVtYmVyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TnVtYmVyT3JBcnJheU9mTnVtYmVyc1ZhbGlkYXRvcihub09mRWxlbWVudHMpIHtcbiAgICBpZiAoS29udmEuaXNVbm1pbmlmaWVkKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsLCBhdHRyKSB7XG4gICAgICAgICAgICBsZXQgaXNOdW1iZXIgPSBVdGlsLl9pc051bWJlcih2YWwpO1xuICAgICAgICAgICAgbGV0IGlzVmFsaWRBcnJheSA9IFV0aWwuX2lzQXJyYXkodmFsKSAmJiB2YWwubGVuZ3RoID09IG5vT2ZFbGVtZW50cztcbiAgICAgICAgICAgIGlmICghaXNOdW1iZXIgJiYgIWlzVmFsaWRBcnJheSkge1xuICAgICAgICAgICAgICAgIFV0aWwud2FybihfZm9ybWF0VmFsdWUodmFsKSArXG4gICAgICAgICAgICAgICAgICAgICcgaXMgYSBub3QgdmFsaWQgdmFsdWUgZm9yIFwiJyArXG4gICAgICAgICAgICAgICAgICAgIGF0dHIgK1xuICAgICAgICAgICAgICAgICAgICAnXCIgYXR0cmlidXRlLiBUaGUgdmFsdWUgc2hvdWxkIGJlIGEgbnVtYmVyIG9yIEFycmF5PG51bWJlcj4oJyArXG4gICAgICAgICAgICAgICAgICAgIG5vT2ZFbGVtZW50cyArXG4gICAgICAgICAgICAgICAgICAgICcpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXROdW1iZXJPckF1dG9WYWxpZGF0b3IoKSB7XG4gICAgaWYgKEtvbnZhLmlzVW5taW5pZmllZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgYXR0cikge1xuICAgICAgICAgICAgdmFyIGlzTnVtYmVyID0gVXRpbC5faXNOdW1iZXIodmFsKTtcbiAgICAgICAgICAgIHZhciBpc0F1dG8gPSB2YWwgPT09ICdhdXRvJztcbiAgICAgICAgICAgIGlmICghKGlzTnVtYmVyIHx8IGlzQXV0bykpIHtcbiAgICAgICAgICAgICAgICBVdGlsLndhcm4oX2Zvcm1hdFZhbHVlKHZhbCkgK1xuICAgICAgICAgICAgICAgICAgICAnIGlzIGEgbm90IHZhbGlkIHZhbHVlIGZvciBcIicgK1xuICAgICAgICAgICAgICAgICAgICBhdHRyICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiIGF0dHJpYnV0ZS4gVGhlIHZhbHVlIHNob3VsZCBiZSBhIG51bWJlciBvciBcImF1dG9cIi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0cmluZ1ZhbGlkYXRvcigpIHtcbiAgICBpZiAoS29udmEuaXNVbm1pbmlmaWVkKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsLCBhdHRyKSB7XG4gICAgICAgICAgICBpZiAoIVV0aWwuX2lzU3RyaW5nKHZhbCkpIHtcbiAgICAgICAgICAgICAgICBVdGlsLndhcm4oX2Zvcm1hdFZhbHVlKHZhbCkgK1xuICAgICAgICAgICAgICAgICAgICAnIGlzIGEgbm90IHZhbGlkIHZhbHVlIGZvciBcIicgK1xuICAgICAgICAgICAgICAgICAgICBhdHRyICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiIGF0dHJpYnV0ZS4gVGhlIHZhbHVlIHNob3VsZCBiZSBhIHN0cmluZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0cmluZ09yR3JhZGllbnRWYWxpZGF0b3IoKSB7XG4gICAgaWYgKEtvbnZhLmlzVW5taW5pZmllZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgYXR0cikge1xuICAgICAgICAgICAgY29uc3QgaXNTdHJpbmcgPSBVdGlsLl9pc1N0cmluZyh2YWwpO1xuICAgICAgICAgICAgY29uc3QgaXNHcmFkaWVudCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBDYW52YXNHcmFkaWVudF0nIHx8XG4gICAgICAgICAgICAgICAgKHZhbCAmJiB2YWwuYWRkQ29sb3JTdG9wKTtcbiAgICAgICAgICAgIGlmICghKGlzU3RyaW5nIHx8IGlzR3JhZGllbnQpKSB7XG4gICAgICAgICAgICAgICAgVXRpbC53YXJuKF9mb3JtYXRWYWx1ZSh2YWwpICtcbiAgICAgICAgICAgICAgICAgICAgJyBpcyBhIG5vdCB2YWxpZCB2YWx1ZSBmb3IgXCInICtcbiAgICAgICAgICAgICAgICAgICAgYXR0ciArXG4gICAgICAgICAgICAgICAgICAgICdcIiBhdHRyaWJ1dGUuIFRoZSB2YWx1ZSBzaG91bGQgYmUgYSBzdHJpbmcgb3IgYSBuYXRpdmUgZ3JhZGllbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRGdW5jdGlvblZhbGlkYXRvcigpIHtcbiAgICBpZiAoS29udmEuaXNVbm1pbmlmaWVkKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsLCBhdHRyKSB7XG4gICAgICAgICAgICBpZiAoIVV0aWwuX2lzRnVuY3Rpb24odmFsKSkge1xuICAgICAgICAgICAgICAgIFV0aWwud2FybihfZm9ybWF0VmFsdWUodmFsKSArXG4gICAgICAgICAgICAgICAgICAgICcgaXMgYSBub3QgdmFsaWQgdmFsdWUgZm9yIFwiJyArXG4gICAgICAgICAgICAgICAgICAgIGF0dHIgK1xuICAgICAgICAgICAgICAgICAgICAnXCIgYXR0cmlidXRlLiBUaGUgdmFsdWUgc2hvdWxkIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXROdW1iZXJBcnJheVZhbGlkYXRvcigpIHtcbiAgICBpZiAoS29udmEuaXNVbm1pbmlmaWVkKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsLCBhdHRyKSB7XG4gICAgICAgICAgICBpZiAoIVV0aWwuX2lzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgICAgIFV0aWwud2FybihfZm9ybWF0VmFsdWUodmFsKSArXG4gICAgICAgICAgICAgICAgICAgICcgaXMgYSBub3QgdmFsaWQgdmFsdWUgZm9yIFwiJyArXG4gICAgICAgICAgICAgICAgICAgIGF0dHIgK1xuICAgICAgICAgICAgICAgICAgICAnXCIgYXR0cmlidXRlLiBUaGUgdmFsdWUgc2hvdWxkIGJlIGEgYXJyYXkgb2YgbnVtYmVycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghVXRpbC5faXNOdW1iZXIoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFV0aWwud2FybignXCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCIgYXR0cmlidXRlIGhhcyBub24gbnVtZXJpYyBlbGVtZW50ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcuIE1ha2Ugc3VyZSB0aGF0IGFsbCBlbGVtZW50cyBhcmUgbnVtYmVycy4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Qm9vbGVhblZhbGlkYXRvcigpIHtcbiAgICBpZiAoS29udmEuaXNVbm1pbmlmaWVkKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsLCBhdHRyKSB7XG4gICAgICAgICAgICB2YXIgaXNCb29sID0gdmFsID09PSB0cnVlIHx8IHZhbCA9PT0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIWlzQm9vbCkge1xuICAgICAgICAgICAgICAgIFV0aWwud2FybihfZm9ybWF0VmFsdWUodmFsKSArXG4gICAgICAgICAgICAgICAgICAgICcgaXMgYSBub3QgdmFsaWQgdmFsdWUgZm9yIFwiJyArXG4gICAgICAgICAgICAgICAgICAgIGF0dHIgK1xuICAgICAgICAgICAgICAgICAgICAnXCIgYXR0cmlidXRlLiBUaGUgdmFsdWUgc2hvdWxkIGJlIGEgYm9vbGVhbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbXBvbmVudFZhbGlkYXRvcihjb21wb25lbnRzKSB7XG4gICAgaWYgKEtvbnZhLmlzVW5taW5pZmllZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgYXR0cikge1xuICAgICAgICAgICAgaWYgKCFVdGlsLmlzT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICAgICAgICBVdGlsLndhcm4oX2Zvcm1hdFZhbHVlKHZhbCkgK1xuICAgICAgICAgICAgICAgICAgICAnIGlzIGEgbm90IHZhbGlkIHZhbHVlIGZvciBcIicgK1xuICAgICAgICAgICAgICAgICAgICBhdHRyICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiIGF0dHJpYnV0ZS4gVGhlIHZhbHVlIHNob3VsZCBiZSBhbiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzICcgK1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgVXRpbCB9IGZyb20gJy4vVXRpbC5qcyc7XG5pbXBvcnQgeyBnZXRDb21wb25lbnRWYWxpZGF0b3IgfSBmcm9tICcuL1ZhbGlkYXRvcnMuanMnO1xudmFyIEdFVCA9ICdnZXQnLCBTRVQgPSAnc2V0JztcbmV4cG9ydCBjb25zdCBGYWN0b3J5ID0ge1xuICAgIGFkZEdldHRlclNldHRlcihjb25zdHJ1Y3RvciwgYXR0ciwgZGVmLCB2YWxpZGF0b3IsIGFmdGVyKSB7XG4gICAgICAgIEZhY3RvcnkuYWRkR2V0dGVyKGNvbnN0cnVjdG9yLCBhdHRyLCBkZWYpO1xuICAgICAgICBGYWN0b3J5LmFkZFNldHRlcihjb25zdHJ1Y3RvciwgYXR0ciwgdmFsaWRhdG9yLCBhZnRlcik7XG4gICAgICAgIEZhY3RvcnkuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihjb25zdHJ1Y3RvciwgYXR0cik7XG4gICAgfSxcbiAgICBhZGRHZXR0ZXIoY29uc3RydWN0b3IsIGF0dHIsIGRlZikge1xuICAgICAgICB2YXIgbWV0aG9kID0gR0VUICsgVXRpbC5fY2FwaXRhbGl6ZShhdHRyKTtcbiAgICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZF0gPVxuICAgICAgICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZF0gfHxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLmF0dHJzW2F0dHJdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsID09PSB1bmRlZmluZWQgPyBkZWYgOiB2YWw7XG4gICAgICAgICAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZFNldHRlcihjb25zdHJ1Y3RvciwgYXR0ciwgdmFsaWRhdG9yLCBhZnRlcikge1xuICAgICAgICB2YXIgbWV0aG9kID0gU0VUICsgVXRpbC5fY2FwaXRhbGl6ZShhdHRyKTtcbiAgICAgICAgaWYgKCFjb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kXSkge1xuICAgICAgICAgICAgRmFjdG9yeS5vdmVyV3JpdGVTZXR0ZXIoY29uc3RydWN0b3IsIGF0dHIsIHZhbGlkYXRvciwgYWZ0ZXIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBvdmVyV3JpdGVTZXR0ZXIoY29uc3RydWN0b3IsIGF0dHIsIHZhbGlkYXRvciwgYWZ0ZXIpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IFNFVCArIFV0aWwuX2NhcGl0YWxpemUoYXR0cik7XG4gICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRvciAmJiB2YWwgIT09IHVuZGVmaW5lZCAmJiB2YWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSB2YWxpZGF0b3IuY2FsbCh0aGlzLCB2YWwsIGF0dHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2V0QXR0cihhdHRyLCB2YWwpO1xuICAgICAgICAgICAgaWYgKGFmdGVyKSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihjb25zdHJ1Y3RvciwgYXR0ciwgY29tcG9uZW50cywgdmFsaWRhdG9yLCBhZnRlcikge1xuICAgICAgICB2YXIgbGVuID0gY29tcG9uZW50cy5sZW5ndGgsIGNhcGl0YWxpemUgPSBVdGlsLl9jYXBpdGFsaXplLCBnZXR0ZXIgPSBHRVQgKyBjYXBpdGFsaXplKGF0dHIpLCBzZXR0ZXIgPSBTRVQgKyBjYXBpdGFsaXplKGF0dHIpLCBuLCBjb21wb25lbnQ7XG4gICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZVtnZXR0ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJldCA9IHt9O1xuICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50c1tuXTtcbiAgICAgICAgICAgICAgICByZXRbY29tcG9uZW50XSA9IHRoaXMuZ2V0QXR0cihhdHRyICsgY2FwaXRhbGl6ZShjb21wb25lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBiYXNpY1ZhbGlkYXRvciA9IGdldENvbXBvbmVudFZhbGlkYXRvcihjb21wb25lbnRzKTtcbiAgICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlW3NldHRlcl0gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB2YXIgb2xkVmFsID0gdGhpcy5hdHRyc1thdHRyXSwga2V5O1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgICAgICAgICAgIHZhbCA9IHZhbGlkYXRvci5jYWxsKHRoaXMsIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmFzaWNWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgICAgICBiYXNpY1ZhbGlkYXRvci5jYWxsKHRoaXMsIHZhbCwgYXR0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGtleSBpbiB2YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRBdHRyKGF0dHIgKyBjYXBpdGFsaXplKGtleSksIHZhbFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2ZpcmVDaGFuZ2VFdmVudChhdHRyLCBvbGRWYWwsIHZhbCk7XG4gICAgICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICBhZnRlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIEZhY3RvcnkuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihjb25zdHJ1Y3RvciwgYXR0cik7XG4gICAgfSxcbiAgICBhZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKGNvbnN0cnVjdG9yLCBhdHRyKSB7XG4gICAgICAgIHZhciBjYXBpdGFsaXplZEF0dHIgPSBVdGlsLl9jYXBpdGFsaXplKGF0dHIpLCBzZXR0ZXIgPSBTRVQgKyBjYXBpdGFsaXplZEF0dHIsIGdldHRlciA9IEdFVCArIGNhcGl0YWxpemVkQXR0cjtcbiAgICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlW2F0dHJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzW3NldHRlcl0oYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzW2dldHRlcl0oKTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZERlcHJlY2F0ZWRHZXR0ZXJTZXR0ZXIoY29uc3RydWN0b3IsIGF0dHIsIGRlZiwgdmFsaWRhdG9yKSB7XG4gICAgICAgIFV0aWwuZXJyb3IoJ0FkZGluZyBkZXByZWNhdGVkICcgKyBhdHRyKTtcbiAgICAgICAgdmFyIG1ldGhvZCA9IEdFVCArIFV0aWwuX2NhcGl0YWxpemUoYXR0cik7XG4gICAgICAgIHZhciBtZXNzYWdlID0gYXR0ciArXG4gICAgICAgICAgICAnIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBzb29uLiBMb29rIGF0IEtvbnZhIGNoYW5nZSBsb2cgZm9yIG1vcmUgaW5mb3JtYXRpb24uJztcbiAgICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBVdGlsLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMuYXR0cnNbYXR0cl07XG4gICAgICAgICAgICByZXR1cm4gdmFsID09PSB1bmRlZmluZWQgPyBkZWYgOiB2YWw7XG4gICAgICAgIH07XG4gICAgICAgIEZhY3RvcnkuYWRkU2V0dGVyKGNvbnN0cnVjdG9yLCBhdHRyLCB2YWxpZGF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFV0aWwuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBGYWN0b3J5LmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoY29uc3RydWN0b3IsIGF0dHIpO1xuICAgIH0sXG4gICAgYmFja0NvbXBhdChjb25zdHJ1Y3RvciwgbWV0aG9kcykge1xuICAgICAgICBVdGlsLmVhY2gobWV0aG9kcywgZnVuY3Rpb24gKG9sZE1ldGhvZE5hbWUsIG5ld01ldGhvZE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGVbbmV3TWV0aG9kTmFtZV07XG4gICAgICAgICAgICB2YXIgb2xkR2V0dGVyID0gR0VUICsgVXRpbC5fY2FwaXRhbGl6ZShvbGRNZXRob2ROYW1lKTtcbiAgICAgICAgICAgIHZhciBvbGRTZXR0ZXIgPSBTRVQgKyBVdGlsLl9jYXBpdGFsaXplKG9sZE1ldGhvZE5hbWUpO1xuICAgICAgICAgICAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBVdGlsLmVycm9yKCdcIicgK1xuICAgICAgICAgICAgICAgICAgICBvbGRNZXRob2ROYW1lICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiIG1ldGhvZCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgc29vbi4gVXNlIFwiXCInICtcbiAgICAgICAgICAgICAgICAgICAgbmV3TWV0aG9kTmFtZSArXG4gICAgICAgICAgICAgICAgICAgICdcIiBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlW29sZE1ldGhvZE5hbWVdID0gZGVwcmVjYXRlZDtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZVtvbGRHZXR0ZXJdID0gZGVwcmVjYXRlZDtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZVtvbGRTZXR0ZXJdID0gZGVwcmVjYXRlZDtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBhZnRlclNldEZpbHRlcigpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICB9LFxufTtcbiIsImltcG9ydCB7IFV0aWwgfSBmcm9tICcuL1V0aWwuanMnO1xuaW1wb3J0IHsgS29udmEgfSBmcm9tICcuL0dsb2JhbC5qcyc7XG5mdW5jdGlvbiBzaW1wbGlmeUFycmF5KGFycikge1xuICAgIHZhciByZXRBcnIgPSBbXSwgbGVuID0gYXJyLmxlbmd0aCwgdXRpbCA9IFV0aWwsIG4sIHZhbDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgdmFsID0gYXJyW25dO1xuICAgICAgICBpZiAodXRpbC5faXNOdW1iZXIodmFsKSkge1xuICAgICAgICAgICAgdmFsID0gTWF0aC5yb3VuZCh2YWwgKiAxMDAwKSAvIDEwMDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXV0aWwuX2lzU3RyaW5nKHZhbCkpIHtcbiAgICAgICAgICAgIHZhbCA9IHZhbCArICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldEFyci5wdXNoKHZhbCk7XG4gICAgfVxuICAgIHJldHVybiByZXRBcnI7XG59XG52YXIgQ09NTUEgPSAnLCcsIE9QRU5fUEFSRU4gPSAnKCcsIENMT1NFX1BBUkVOID0gJyknLCBPUEVOX1BBUkVOX0JSQUNLRVQgPSAnKFsnLCBDTE9TRV9CUkFDS0VUX1BBUkVOID0gJ10pJywgU0VNSUNPTE9OID0gJzsnLCBET1VCTEVfUEFSRU4gPSAnKCknLCBFUVVBTFMgPSAnPScsIENPTlRFWFRfTUVUSE9EUyA9IFtcbiAgICAnYXJjJyxcbiAgICAnYXJjVG8nLFxuICAgICdiZWdpblBhdGgnLFxuICAgICdiZXppZXJDdXJ2ZVRvJyxcbiAgICAnY2xlYXJSZWN0JyxcbiAgICAnY2xpcCcsXG4gICAgJ2Nsb3NlUGF0aCcsXG4gICAgJ2NyZWF0ZUxpbmVhckdyYWRpZW50JyxcbiAgICAnY3JlYXRlUGF0dGVybicsXG4gICAgJ2NyZWF0ZVJhZGlhbEdyYWRpZW50JyxcbiAgICAnZHJhd0ltYWdlJyxcbiAgICAnZWxsaXBzZScsXG4gICAgJ2ZpbGwnLFxuICAgICdmaWxsVGV4dCcsXG4gICAgJ2dldEltYWdlRGF0YScsXG4gICAgJ2NyZWF0ZUltYWdlRGF0YScsXG4gICAgJ2xpbmVUbycsXG4gICAgJ21vdmVUbycsXG4gICAgJ3B1dEltYWdlRGF0YScsXG4gICAgJ3F1YWRyYXRpY0N1cnZlVG8nLFxuICAgICdyZWN0JyxcbiAgICAncmVzdG9yZScsXG4gICAgJ3JvdGF0ZScsXG4gICAgJ3NhdmUnLFxuICAgICdzY2FsZScsXG4gICAgJ3NldExpbmVEYXNoJyxcbiAgICAnc2V0VHJhbnNmb3JtJyxcbiAgICAnc3Ryb2tlJyxcbiAgICAnc3Ryb2tlVGV4dCcsXG4gICAgJ3RyYW5zZm9ybScsXG4gICAgJ3RyYW5zbGF0ZScsXG5dO1xudmFyIENPTlRFWFRfUFJPUEVSVElFUyA9IFtcbiAgICAnZmlsbFN0eWxlJyxcbiAgICAnc3Ryb2tlU3R5bGUnLFxuICAgICdzaGFkb3dDb2xvcicsXG4gICAgJ3NoYWRvd0JsdXInLFxuICAgICdzaGFkb3dPZmZzZXRYJyxcbiAgICAnc2hhZG93T2Zmc2V0WScsXG4gICAgJ2xpbmVDYXAnLFxuICAgICdsaW5lRGFzaE9mZnNldCcsXG4gICAgJ2xpbmVKb2luJyxcbiAgICAnbGluZVdpZHRoJyxcbiAgICAnbWl0ZXJMaW1pdCcsXG4gICAgJ2ZvbnQnLFxuICAgICd0ZXh0QWxpZ24nLFxuICAgICd0ZXh0QmFzZWxpbmUnLFxuICAgICdnbG9iYWxBbHBoYScsXG4gICAgJ2dsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbicsXG4gICAgJ2ltYWdlU21vb3RoaW5nRW5hYmxlZCcsXG5dO1xuY29uc3QgdHJhY2VBcnJNYXggPSAxMDA7XG5leHBvcnQgY2xhc3MgQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY2FudmFzLl9jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgaWYgKEtvbnZhLmVuYWJsZVRyYWNlKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlQXJyID0gW107XG4gICAgICAgICAgICB0aGlzLl9lbmFibGVUcmFjZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbGxTaGFwZShzaGFwZSkge1xuICAgICAgICBpZiAoc2hhcGUuZmlsbEVuYWJsZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fZmlsbChzaGFwZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ZpbGwoc2hhcGUpIHtcbiAgICB9XG4gICAgc3Ryb2tlU2hhcGUoc2hhcGUpIHtcbiAgICAgICAgaWYgKHNoYXBlLmhhc1N0cm9rZSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9zdHJva2Uoc2hhcGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9zdHJva2Uoc2hhcGUpIHtcbiAgICB9XG4gICAgZmlsbFN0cm9rZVNoYXBlKHNoYXBlKSB7XG4gICAgICAgIGlmIChzaGFwZS5hdHRycy5maWxsQWZ0ZXJTdHJva2VFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0cm9rZVNoYXBlKHNoYXBlKTtcbiAgICAgICAgICAgIHRoaXMuZmlsbFNoYXBlKHNoYXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmlsbFNoYXBlKHNoYXBlKTtcbiAgICAgICAgICAgIHRoaXMuc3Ryb2tlU2hhcGUoc2hhcGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFRyYWNlKHJlbGF4ZWQsIHJvdW5kZWQpIHtcbiAgICAgICAgdmFyIHRyYWNlQXJyID0gdGhpcy50cmFjZUFyciwgbGVuID0gdHJhY2VBcnIubGVuZ3RoLCBzdHIgPSAnJywgbiwgdHJhY2UsIG1ldGhvZCwgYXJncztcbiAgICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICB0cmFjZSA9IHRyYWNlQXJyW25dO1xuICAgICAgICAgICAgbWV0aG9kID0gdHJhY2UubWV0aG9kO1xuICAgICAgICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGFyZ3MgPSB0cmFjZS5hcmdzO1xuICAgICAgICAgICAgICAgIHN0ciArPSBtZXRob2Q7XG4gICAgICAgICAgICAgICAgaWYgKHJlbGF4ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyICs9IERPVUJMRV9QQVJFTjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChVdGlsLl9pc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gT1BFTl9QQVJFTl9CUkFDS0VUICsgYXJncy5qb2luKENPTU1BKSArIENMT1NFX0JSQUNLRVRfUEFSRU47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocm91bmRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzLm1hcCgoYSkgPT4gdHlwZW9mIGEgPT09ICdudW1iZXInID8gTWF0aC5mbG9vcihhKSA6IGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IE9QRU5fUEFSRU4gKyBhcmdzLmpvaW4oQ09NTUEpICsgQ0xPU0VfUEFSRU47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gdHJhY2UucHJvcGVydHk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWxheGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSBFUVVBTFMgKyB0cmFjZS52YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyICs9IFNFTUlDT0xPTjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBjbGVhclRyYWNlKCkge1xuICAgICAgICB0aGlzLnRyYWNlQXJyID0gW107XG4gICAgfVxuICAgIF90cmFjZShzdHIpIHtcbiAgICAgICAgdmFyIHRyYWNlQXJyID0gdGhpcy50cmFjZUFyciwgbGVuO1xuICAgICAgICB0cmFjZUFyci5wdXNoKHN0cik7XG4gICAgICAgIGxlbiA9IHRyYWNlQXJyLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA+PSB0cmFjZUFyck1heCkge1xuICAgICAgICAgICAgdHJhY2VBcnIuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdmFyIHBpeGVsUmF0aW8gPSB0aGlzLmdldENhbnZhcygpLmdldFBpeGVsUmF0aW8oKTtcbiAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oMSAqIHBpeGVsUmF0aW8sIDAsIDAsIDEgKiBwaXhlbFJhdGlvLCAwLCAwKTtcbiAgICB9XG4gICAgZ2V0Q2FudmFzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXM7XG4gICAgfVxuICAgIGNsZWFyKGJvdW5kcykge1xuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5nZXRDYW52YXMoKTtcbiAgICAgICAgaWYgKGJvdW5kcykge1xuICAgICAgICAgICAgdGhpcy5jbGVhclJlY3QoYm91bmRzLnggfHwgMCwgYm91bmRzLnkgfHwgMCwgYm91bmRzLndpZHRoIHx8IDAsIGJvdW5kcy5oZWlnaHQgfHwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyUmVjdCgwLCAwLCBjYW52YXMuZ2V0V2lkdGgoKSAvIGNhbnZhcy5waXhlbFJhdGlvLCBjYW52YXMuZ2V0SGVpZ2h0KCkgLyBjYW52YXMucGl4ZWxSYXRpbyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2FwcGx5TGluZUNhcChzaGFwZSkge1xuICAgICAgICB2YXIgbGluZUNhcCA9IHNoYXBlLmdldExpbmVDYXAoKTtcbiAgICAgICAgaWYgKGxpbmVDYXApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cignbGluZUNhcCcsIGxpbmVDYXApO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9hcHBseU9wYWNpdHkoc2hhcGUpIHtcbiAgICAgICAgdmFyIGFic09wYWNpdHkgPSBzaGFwZS5nZXRBYnNvbHV0ZU9wYWNpdHkoKTtcbiAgICAgICAgaWYgKGFic09wYWNpdHkgIT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cignZ2xvYmFsQWxwaGEnLCBhYnNPcGFjaXR5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfYXBwbHlMaW5lSm9pbihzaGFwZSkge1xuICAgICAgICB2YXIgbGluZUpvaW4gPSBzaGFwZS5hdHRycy5saW5lSm9pbjtcbiAgICAgICAgaWYgKGxpbmVKb2luKSB7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ2xpbmVKb2luJywgbGluZUpvaW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEF0dHIoYXR0ciwgdmFsKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHRbYXR0cl0gPSB2YWw7XG4gICAgfVxuICAgIGFyYyhhMCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuYXJjKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpO1xuICAgIH1cbiAgICBhcmNUbyhhMCwgYTEsIGEyLCBhMywgYTQpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5hcmNUbyhhMCwgYTEsIGEyLCBhMywgYTQpO1xuICAgIH1cbiAgICBiZWdpblBhdGgoKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgfVxuICAgIGJlemllckN1cnZlVG8oYTAsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICAgICAgICB0aGlzLl9jb250ZXh0LmJlemllckN1cnZlVG8oYTAsIGExLCBhMiwgYTMsIGE0LCBhNSk7XG4gICAgfVxuICAgIGNsZWFyUmVjdChhMCwgYTEsIGEyLCBhMykge1xuICAgICAgICB0aGlzLl9jb250ZXh0LmNsZWFyUmVjdChhMCwgYTEsIGEyLCBhMyk7XG4gICAgfVxuICAgIGNsaXAoKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xpcCgpO1xuICAgIH1cbiAgICBjbG9zZVBhdGgoKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfVxuICAgIGNyZWF0ZUltYWdlRGF0YShhMCwgYTEpIHtcbiAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICAgIGlmIChhLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKGEwLCBhMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmNyZWF0ZUltYWdlRGF0YShhMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlTGluZWFyR3JhZGllbnQoYTAsIGExLCBhMiwgYTMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoYTAsIGExLCBhMiwgYTMpO1xuICAgIH1cbiAgICBjcmVhdGVQYXR0ZXJuKGEwLCBhMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5jcmVhdGVQYXR0ZXJuKGEwLCBhMSk7XG4gICAgfVxuICAgIGNyZWF0ZVJhZGlhbEdyYWRpZW50KGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuY3JlYXRlUmFkaWFsR3JhZGllbnQoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSk7XG4gICAgfVxuICAgIGRyYXdJbWFnZShhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4KSB7XG4gICAgICAgIHZhciBhID0gYXJndW1lbnRzLCBfY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICAgIGlmIChhLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgX2NvbnRleHQuZHJhd0ltYWdlKGEwLCBhMSwgYTIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEubGVuZ3RoID09PSA1KSB7XG4gICAgICAgICAgICBfY29udGV4dC5kcmF3SW1hZ2UoYTAsIGExLCBhMiwgYTMsIGE0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmxlbmd0aCA9PT0gOSkge1xuICAgICAgICAgICAgX2NvbnRleHQuZHJhd0ltYWdlKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsbGlwc2UoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3KSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuZWxsaXBzZShhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcpO1xuICAgIH1cbiAgICBpc1BvaW50SW5QYXRoKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuaXNQb2ludEluUGF0aCh4LCB5KTtcbiAgICB9XG4gICAgZmlsbChwYXRoMmQpIHtcbiAgICAgICAgaWYgKHBhdGgyZCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5maWxsKHBhdGgyZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmZpbGwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaWxsUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICAgIHN0cm9rZVJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLl9jb250ZXh0LnN0cm9rZVJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICAgIGZpbGxUZXh0KHRleHQsIHgsIHksIG1heFdpZHRoKSB7XG4gICAgICAgIGlmIChtYXhXaWR0aCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5maWxsVGV4dCh0ZXh0LCB4LCB5LCBtYXhXaWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmZpbGxUZXh0KHRleHQsIHgsIHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lYXN1cmVUZXh0KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQubWVhc3VyZVRleHQodGV4dCk7XG4gICAgfVxuICAgIGdldEltYWdlRGF0YShhMCwgYTEsIGEyLCBhMykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5nZXRJbWFnZURhdGEoYTAsIGExLCBhMiwgYTMpO1xuICAgIH1cbiAgICBsaW5lVG8oYTAsIGExKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKGEwLCBhMSk7XG4gICAgfVxuICAgIG1vdmVUbyhhMCwgYTEpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oYTAsIGExKTtcbiAgICB9XG4gICAgcmVjdChhMCwgYTEsIGEyLCBhMykge1xuICAgICAgICB0aGlzLl9jb250ZXh0LnJlY3QoYTAsIGExLCBhMiwgYTMpO1xuICAgIH1cbiAgICBwdXRJbWFnZURhdGEoYTAsIGExLCBhMikge1xuICAgICAgICB0aGlzLl9jb250ZXh0LnB1dEltYWdlRGF0YShhMCwgYTEsIGEyKTtcbiAgICB9XG4gICAgcXVhZHJhdGljQ3VydmVUbyhhMCwgYTEsIGEyLCBhMykge1xuICAgICAgICB0aGlzLl9jb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oYTAsIGExLCBhMiwgYTMpO1xuICAgIH1cbiAgICByZXN0b3JlKCkge1xuICAgICAgICB0aGlzLl9jb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgcm90YXRlKGEwKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQucm90YXRlKGEwKTtcbiAgICB9XG4gICAgc2F2ZSgpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5zYXZlKCk7XG4gICAgfVxuICAgIHNjYWxlKGEwLCBhMSkge1xuICAgICAgICB0aGlzLl9jb250ZXh0LnNjYWxlKGEwLCBhMSk7XG4gICAgfVxuICAgIHNldExpbmVEYXNoKGEwKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb250ZXh0LnNldExpbmVEYXNoKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNldExpbmVEYXNoKGEwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgnbW96RGFzaCcgaW4gdGhpcy5fY29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dFsnbW96RGFzaCddID0gYTA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ3dlYmtpdExpbmVEYXNoJyBpbiB0aGlzLl9jb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0Wyd3ZWJraXRMaW5lRGFzaCddID0gYTA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TGluZURhc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmdldExpbmVEYXNoKCk7XG4gICAgfVxuICAgIHNldFRyYW5zZm9ybShhMCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuc2V0VHJhbnNmb3JtKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpO1xuICAgIH1cbiAgICBzdHJva2UocGF0aDJkKSB7XG4gICAgICAgIGlmIChwYXRoMmQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc3Ryb2tlKHBhdGgyZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0cm9rZVRleHQoYTAsIGExLCBhMiwgYTMpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5zdHJva2VUZXh0KGEwLCBhMSwgYTIsIGEzKTtcbiAgICB9XG4gICAgdHJhbnNmb3JtKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dC50cmFuc2Zvcm0oYTAsIGExLCBhMiwgYTMsIGE0LCBhNSk7XG4gICAgfVxuICAgIHRyYW5zbGF0ZShhMCwgYTEpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dC50cmFuc2xhdGUoYTAsIGExKTtcbiAgICB9XG4gICAgX2VuYWJsZVRyYWNlKCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXMsIGxlbiA9IENPTlRFWFRfTUVUSE9EUy5sZW5ndGgsIG9yaWdTZXR0ZXIgPSB0aGlzLnNldEF0dHIsIG4sIGFyZ3M7XG4gICAgICAgIHZhciBmdW5jID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBvcmlnTWV0aG9kID0gdGhhdFttZXRob2ROYW1lXSwgcmV0O1xuICAgICAgICAgICAgdGhhdFttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBhcmdzID0gc2ltcGxpZnlBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcbiAgICAgICAgICAgICAgICByZXQgPSBvcmlnTWV0aG9kLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgdGhhdC5fdHJhY2Uoe1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgZnVuYyhDT05URVhUX01FVEhPRFNbbl0pO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuc2V0QXR0ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9yaWdTZXR0ZXIuYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBwcm9wID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdmFyIHZhbCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnc2hhZG93T2Zmc2V0WCcgfHxcbiAgICAgICAgICAgICAgICBwcm9wID09PSAnc2hhZG93T2Zmc2V0WScgfHxcbiAgICAgICAgICAgICAgICBwcm9wID09PSAnc2hhZG93Qmx1cicpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSB2YWwgLyB0aGlzLmNhbnZhcy5nZXRQaXhlbFJhdGlvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGF0Ll90cmFjZSh7XG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IHByb3AsXG4gICAgICAgICAgICAgICAgdmFsOiB2YWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2FwcGx5R2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uKG5vZGUpIHtcbiAgICAgICAgY29uc3Qgb3AgPSBub2RlLmF0dHJzLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICAgICAgdmFyIGRlZiA9ICFvcCB8fCBvcCA9PT0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgaWYgKCFkZWYpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cignZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uJywgb3ApO1xuICAgICAgICB9XG4gICAgfVxufVxuQ09OVEVYVF9QUk9QRVJUSUVTLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udGV4dC5wcm90b3R5cGUsIHByb3AsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHRbcHJvcF07XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHRbcHJvcF0gPSB2YWw7XG4gICAgICAgIH0sXG4gICAgfSk7XG59KTtcbmV4cG9ydCBjbGFzcyBTY2VuZUNvbnRleHQgZXh0ZW5kcyBDb250ZXh0IHtcbiAgICBfZmlsbENvbG9yKHNoYXBlKSB7XG4gICAgICAgIHZhciBmaWxsID0gc2hhcGUuZmlsbCgpO1xuICAgICAgICB0aGlzLnNldEF0dHIoJ2ZpbGxTdHlsZScsIGZpbGwpO1xuICAgICAgICBzaGFwZS5fZmlsbEZ1bmModGhpcyk7XG4gICAgfVxuICAgIF9maWxsUGF0dGVybihzaGFwZSkge1xuICAgICAgICB0aGlzLnNldEF0dHIoJ2ZpbGxTdHlsZScsIHNoYXBlLl9nZXRGaWxsUGF0dGVybigpKTtcbiAgICAgICAgc2hhcGUuX2ZpbGxGdW5jKHRoaXMpO1xuICAgIH1cbiAgICBfZmlsbExpbmVhckdyYWRpZW50KHNoYXBlKSB7XG4gICAgICAgIHZhciBncmQgPSBzaGFwZS5fZ2V0TGluZWFyR3JhZGllbnQoKTtcbiAgICAgICAgaWYgKGdyZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdmaWxsU3R5bGUnLCBncmQpO1xuICAgICAgICAgICAgc2hhcGUuX2ZpbGxGdW5jKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9maWxsUmFkaWFsR3JhZGllbnQoc2hhcGUpIHtcbiAgICAgICAgdmFyIGdyZCA9IHNoYXBlLl9nZXRSYWRpYWxHcmFkaWVudCgpO1xuICAgICAgICBpZiAoZ3JkKSB7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ2ZpbGxTdHlsZScsIGdyZCk7XG4gICAgICAgICAgICBzaGFwZS5fZmlsbEZ1bmModGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ZpbGwoc2hhcGUpIHtcbiAgICAgICAgdmFyIGhhc0NvbG9yID0gc2hhcGUuZmlsbCgpLCBmaWxsUHJpb3JpdHkgPSBzaGFwZS5nZXRGaWxsUHJpb3JpdHkoKTtcbiAgICAgICAgaWYgKGhhc0NvbG9yICYmIGZpbGxQcmlvcml0eSA9PT0gJ2NvbG9yJykge1xuICAgICAgICAgICAgdGhpcy5fZmlsbENvbG9yKHNoYXBlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGFzUGF0dGVybiA9IHNoYXBlLmdldEZpbGxQYXR0ZXJuSW1hZ2UoKTtcbiAgICAgICAgaWYgKGhhc1BhdHRlcm4gJiYgZmlsbFByaW9yaXR5ID09PSAncGF0dGVybicpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbGxQYXR0ZXJuKHNoYXBlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGFzTGluZWFyR3JhZGllbnQgPSBzaGFwZS5nZXRGaWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzKCk7XG4gICAgICAgIGlmIChoYXNMaW5lYXJHcmFkaWVudCAmJiBmaWxsUHJpb3JpdHkgPT09ICdsaW5lYXItZ3JhZGllbnQnKSB7XG4gICAgICAgICAgICB0aGlzLl9maWxsTGluZWFyR3JhZGllbnQoc2hhcGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoYXNSYWRpYWxHcmFkaWVudCA9IHNoYXBlLmdldEZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHMoKTtcbiAgICAgICAgaWYgKGhhc1JhZGlhbEdyYWRpZW50ICYmIGZpbGxQcmlvcml0eSA9PT0gJ3JhZGlhbC1ncmFkaWVudCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbGxSYWRpYWxHcmFkaWVudChzaGFwZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0NvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9maWxsQ29sb3Ioc2hhcGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhc1BhdHRlcm4pIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbGxQYXR0ZXJuKHNoYXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYXNMaW5lYXJHcmFkaWVudCkge1xuICAgICAgICAgICAgdGhpcy5fZmlsbExpbmVhckdyYWRpZW50KHNoYXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYXNSYWRpYWxHcmFkaWVudCkge1xuICAgICAgICAgICAgdGhpcy5fZmlsbFJhZGlhbEdyYWRpZW50KHNoYXBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc3Ryb2tlTGluZWFyR3JhZGllbnQoc2hhcGUpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gc2hhcGUuZ2V0U3Ryb2tlTGluZWFyR3JhZGllbnRTdGFydFBvaW50KCksIGVuZCA9IHNoYXBlLmdldFN0cm9rZUxpbmVhckdyYWRpZW50RW5kUG9pbnQoKSwgY29sb3JTdG9wcyA9IHNoYXBlLmdldFN0cm9rZUxpbmVhckdyYWRpZW50Q29sb3JTdG9wcygpLCBncmQgPSB0aGlzLmNyZWF0ZUxpbmVhckdyYWRpZW50KHN0YXJ0LngsIHN0YXJ0LnksIGVuZC54LCBlbmQueSk7XG4gICAgICAgIGlmIChjb2xvclN0b3BzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGNvbG9yU3RvcHMubGVuZ3RoOyBuICs9IDIpIHtcbiAgICAgICAgICAgICAgICBncmQuYWRkQ29sb3JTdG9wKGNvbG9yU3RvcHNbbl0sIGNvbG9yU3RvcHNbbiArIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cignc3Ryb2tlU3R5bGUnLCBncmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9zdHJva2Uoc2hhcGUpIHtcbiAgICAgICAgdmFyIGRhc2ggPSBzaGFwZS5kYXNoKCksIHN0cm9rZVNjYWxlRW5hYmxlZCA9IHNoYXBlLmdldFN0cm9rZVNjYWxlRW5hYmxlZCgpO1xuICAgICAgICBpZiAoc2hhcGUuaGFzU3Ryb2tlKCkpIHtcbiAgICAgICAgICAgIGlmICghc3Ryb2tlU2NhbGVFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICAgICAgICAgICAgdmFyIHBpeGVsUmF0aW8gPSB0aGlzLmdldENhbnZhcygpLmdldFBpeGVsUmF0aW8oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybShwaXhlbFJhdGlvLCAwLCAwLCBwaXhlbFJhdGlvLCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FwcGx5TGluZUNhcChzaGFwZSk7XG4gICAgICAgICAgICBpZiAoZGFzaCAmJiBzaGFwZS5kYXNoRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRMaW5lRGFzaChkYXNoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHIoJ2xpbmVEYXNoT2Zmc2V0Jywgc2hhcGUuZGFzaE9mZnNldCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cignbGluZVdpZHRoJywgc2hhcGUuc3Ryb2tlV2lkdGgoKSk7XG4gICAgICAgICAgICBpZiAoIXNoYXBlLmdldFNoYWRvd0ZvclN0cm9rZUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cignc2hhZG93Q29sb3InLCAncmdiYSgwLDAsMCwwKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhhc0xpbmVhckdyYWRpZW50ID0gc2hhcGUuZ2V0U3Ryb2tlTGluZWFyR3JhZGllbnRDb2xvclN0b3BzKCk7XG4gICAgICAgICAgICBpZiAoaGFzTGluZWFyR3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHJva2VMaW5lYXJHcmFkaWVudChzaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3N0cm9rZVN0eWxlJywgc2hhcGUuc3Ryb2tlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2hhcGUuX3N0cm9rZUZ1bmModGhpcyk7XG4gICAgICAgICAgICBpZiAoIXN0cm9rZVNjYWxlRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9hcHBseVNoYWRvdyhzaGFwZSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdmFyIGNvbG9yID0gKF9hID0gc2hhcGUuZ2V0U2hhZG93UkdCQSgpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnYmxhY2snLCBibHVyID0gKF9iID0gc2hhcGUuZ2V0U2hhZG93Qmx1cigpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiA1LCBvZmZzZXQgPSAoX2MgPSBzaGFwZS5nZXRTaGFkb3dPZmZzZXQoKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgIH0sIHNjYWxlID0gc2hhcGUuZ2V0QWJzb2x1dGVTY2FsZSgpLCByYXRpbyA9IHRoaXMuY2FudmFzLmdldFBpeGVsUmF0aW8oKSwgc2NhbGVYID0gc2NhbGUueCAqIHJhdGlvLCBzY2FsZVkgPSBzY2FsZS55ICogcmF0aW87XG4gICAgICAgIHRoaXMuc2V0QXR0cignc2hhZG93Q29sb3InLCBjb2xvcik7XG4gICAgICAgIHRoaXMuc2V0QXR0cignc2hhZG93Qmx1cicsIGJsdXIgKiBNYXRoLm1pbihNYXRoLmFicyhzY2FsZVgpLCBNYXRoLmFicyhzY2FsZVkpKSk7XG4gICAgICAgIHRoaXMuc2V0QXR0cignc2hhZG93T2Zmc2V0WCcsIG9mZnNldC54ICogc2NhbGVYKTtcbiAgICAgICAgdGhpcy5zZXRBdHRyKCdzaGFkb3dPZmZzZXRZJywgb2Zmc2V0LnkgKiBzY2FsZVkpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBIaXRDb250ZXh0IGV4dGVuZHMgQ29udGV4dCB7XG4gICAgX2ZpbGwoc2hhcGUpIHtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICAgIHRoaXMuc2V0QXR0cignZmlsbFN0eWxlJywgc2hhcGUuY29sb3JLZXkpO1xuICAgICAgICBzaGFwZS5fZmlsbEZ1bmNIaXQodGhpcyk7XG4gICAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIH1cbiAgICBzdHJva2VTaGFwZShzaGFwZSkge1xuICAgICAgICBpZiAoc2hhcGUuaGFzSGl0U3Ryb2tlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0cm9rZShzaGFwZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3N0cm9rZShzaGFwZSkge1xuICAgICAgICBpZiAoc2hhcGUuaGFzSGl0U3Ryb2tlKCkpIHtcbiAgICAgICAgICAgIHZhciBzdHJva2VTY2FsZUVuYWJsZWQgPSBzaGFwZS5nZXRTdHJva2VTY2FsZUVuYWJsZWQoKTtcbiAgICAgICAgICAgIGlmICghc3Ryb2tlU2NhbGVFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICAgICAgICAgICAgdmFyIHBpeGVsUmF0aW8gPSB0aGlzLmdldENhbnZhcygpLmdldFBpeGVsUmF0aW8oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybShwaXhlbFJhdGlvLCAwLCAwLCBwaXhlbFJhdGlvLCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FwcGx5TGluZUNhcChzaGFwZSk7XG4gICAgICAgICAgICB2YXIgaGl0U3Ryb2tlV2lkdGggPSBzaGFwZS5oaXRTdHJva2VXaWR0aCgpO1xuICAgICAgICAgICAgdmFyIHN0cm9rZVdpZHRoID0gaGl0U3Ryb2tlV2lkdGggPT09ICdhdXRvJyA/IHNoYXBlLnN0cm9rZVdpZHRoKCkgOiBoaXRTdHJva2VXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cignbGluZVdpZHRoJywgc3Ryb2tlV2lkdGgpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdzdHJva2VTdHlsZScsIHNoYXBlLmNvbG9yS2V5KTtcbiAgICAgICAgICAgIHNoYXBlLl9zdHJva2VGdW5jSGl0KHRoaXMpO1xuICAgICAgICAgICAgaWYgKCFzdHJva2VTY2FsZUVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IFV0aWwgfSBmcm9tICcuL1V0aWwuanMnO1xuaW1wb3J0IHsgU2NlbmVDb250ZXh0LCBIaXRDb250ZXh0IH0gZnJvbSAnLi9Db250ZXh0LmpzJztcbmltcG9ydCB7IEtvbnZhIH0gZnJvbSAnLi9HbG9iYWwuanMnO1xuaW1wb3J0IHsgRmFjdG9yeSB9IGZyb20gJy4vRmFjdG9yeS5qcyc7XG5pbXBvcnQgeyBnZXROdW1iZXJWYWxpZGF0b3IgfSBmcm9tICcuL1ZhbGlkYXRvcnMuanMnO1xudmFyIF9waXhlbFJhdGlvO1xuZnVuY3Rpb24gZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgICBpZiAoX3BpeGVsUmF0aW8pIHtcbiAgICAgICAgcmV0dXJuIF9waXhlbFJhdGlvO1xuICAgIH1cbiAgICB2YXIgY2FudmFzID0gVXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBfcGl4ZWxSYXRpbyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZXZpY2VQaXhlbFJhdGlvID0gS29udmEuX2dsb2JhbC5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsIGJhY2tpbmdTdG9yZVJhdGlvID0gY29udGV4dC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICBjb250ZXh0Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgIGNvbnRleHQubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICBjb250ZXh0Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICBjb250ZXh0LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgIDE7XG4gICAgICAgIHJldHVybiBkZXZpY2VQaXhlbFJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG4gICAgfSkoKTtcbiAgICByZXR1cm4gX3BpeGVsUmF0aW87XG59XG5leHBvcnQgY2xhc3MgQ2FudmFzIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5waXhlbFJhdGlvID0gMTtcbiAgICAgICAgdGhpcy53aWR0aCA9IDA7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5pc0NhY2hlID0gZmFsc2U7XG4gICAgICAgIHZhciBjb25mID0gY29uZmlnIHx8IHt9O1xuICAgICAgICB2YXIgcGl4ZWxSYXRpbyA9IGNvbmYucGl4ZWxSYXRpbyB8fCBLb252YS5waXhlbFJhdGlvIHx8IGdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICAgICAgdGhpcy5waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcbiAgICAgICAgdGhpcy5fY2FudmFzID0gVXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5wYWRkaW5nID0gJzAnO1xuICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUubWFyZ2luID0gJzAnO1xuICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUuYm9yZGVyID0gJzAnO1xuICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUuYmFja2dyb3VuZCA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS50b3AgPSAnMCc7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgIH1cbiAgICBnZXRDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0O1xuICAgIH1cbiAgICBnZXRQaXhlbFJhdGlvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5waXhlbFJhdGlvO1xuICAgIH1cbiAgICBzZXRQaXhlbFJhdGlvKHBpeGVsUmF0aW8pIHtcbiAgICAgICAgdmFyIHByZXZpb3VzUmF0aW8gPSB0aGlzLnBpeGVsUmF0aW87XG4gICAgICAgIHRoaXMucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gICAgICAgIHRoaXMuc2V0U2l6ZSh0aGlzLmdldFdpZHRoKCkgLyBwcmV2aW91c1JhdGlvLCB0aGlzLmdldEhlaWdodCgpIC8gcHJldmlvdXNSYXRpbyk7XG4gICAgfVxuICAgIHNldFdpZHRoKHdpZHRoKSB7XG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLl9jYW52YXMud2lkdGggPSB3aWR0aCAqIHRoaXMucGl4ZWxSYXRpbztcbiAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICB2YXIgcGl4ZWxSYXRpbyA9IHRoaXMucGl4ZWxSYXRpbywgX2NvbnRleHQgPSB0aGlzLmdldENvbnRleHQoKS5fY29udGV4dDtcbiAgICAgICAgX2NvbnRleHQuc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gICAgfVxuICAgIHNldEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogdGhpcy5waXhlbFJhdGlvO1xuICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgdmFyIHBpeGVsUmF0aW8gPSB0aGlzLnBpeGVsUmF0aW8sIF9jb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KCkuX2NvbnRleHQ7XG4gICAgICAgIF9jb250ZXh0LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuICAgIH1cbiAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gICAgfVxuICAgIGdldEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xuICAgIH1cbiAgICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5zZXRXaWR0aCh3aWR0aCB8fCAwKTtcbiAgICAgICAgdGhpcy5zZXRIZWlnaHQoaGVpZ2h0IHx8IDApO1xuICAgIH1cbiAgICB0b0RhdGFVUkwobWltZVR5cGUsIHF1YWxpdHkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYW52YXMudG9EYXRhVVJMKG1pbWVUeXBlLCBxdWFsaXR5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIFV0aWwuZXJyb3IoJ1VuYWJsZSB0byBnZXQgZGF0YSBVUkwuICcgK1xuICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSArXG4gICAgICAgICAgICAgICAgICAgICcgRm9yIG1vcmUgaW5mbyByZWFkIGh0dHBzOi8va29udmFqcy5vcmcvZG9jcy9wb3N0cy9UYWludGVkX0NhbnZhcy5odG1sLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKENhbnZhcywgJ3BpeGVsUmF0aW8nLCB1bmRlZmluZWQsIGdldE51bWJlclZhbGlkYXRvcigpKTtcbmV4cG9ydCBjbGFzcyBTY2VuZUNhbnZhcyBleHRlbmRzIENhbnZhcyB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbmV3IFNjZW5lQ29udGV4dCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRTaXplKGNvbmZpZy53aWR0aCwgY29uZmlnLmhlaWdodCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEhpdENhbnZhcyBleHRlbmRzIENhbnZhcyB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcbiAgICAgICAgdGhpcy5oaXRDYW52YXMgPSB0cnVlO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBuZXcgSGl0Q29udGV4dCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRTaXplKGNvbmZpZy53aWR0aCwgY29uZmlnLmhlaWdodCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgS29udmEgfSBmcm9tICcuL0dsb2JhbC5qcyc7XG5pbXBvcnQgeyBVdGlsIH0gZnJvbSAnLi9VdGlsLmpzJztcbmV4cG9ydCBjb25zdCBERCA9IHtcbiAgICBnZXQgaXNEcmFnZ2luZygpIHtcbiAgICAgICAgdmFyIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgREQuX2RyYWdFbGVtZW50cy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoZWxlbS5kcmFnU3RhdHVzID09PSAnZHJhZ2dpbmcnKSB7XG4gICAgICAgICAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmxhZztcbiAgICB9LFxuICAgIGp1c3REcmFnZ2VkOiBmYWxzZSxcbiAgICBnZXQgbm9kZSgpIHtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIERELl9kcmFnRWxlbWVudHMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgICAgICAgbm9kZSA9IGVsZW0ubm9kZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG4gICAgX2RyYWdFbGVtZW50czogbmV3IE1hcCgpLFxuICAgIF9kcmFnKGV2dCkge1xuICAgICAgICBjb25zdCBub2Rlc1RvRmlyZUV2ZW50cyA9IFtdO1xuICAgICAgICBERC5fZHJhZ0VsZW1lbnRzLmZvckVhY2goKGVsZW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBub2RlIH0gPSBlbGVtO1xuICAgICAgICAgICAgY29uc3Qgc3RhZ2UgPSBub2RlLmdldFN0YWdlKCk7XG4gICAgICAgICAgICBzdGFnZS5zZXRQb2ludGVyc1Bvc2l0aW9ucyhldnQpO1xuICAgICAgICAgICAgaWYgKGVsZW0ucG9pbnRlcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBlbGVtLnBvaW50ZXJJZCA9IFV0aWwuX2dldEZpcnN0UG9pbnRlcklkKGV2dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwb3MgPSBzdGFnZS5fY2hhbmdlZFBvaW50ZXJQb3NpdGlvbnMuZmluZCgocG9zKSA9PiBwb3MuaWQgPT09IGVsZW0ucG9pbnRlcklkKTtcbiAgICAgICAgICAgIGlmICghcG9zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsZW0uZHJhZ1N0YXR1cyAhPT0gJ2RyYWdnaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciBkcmFnRGlzdGFuY2UgPSBub2RlLmRyYWdEaXN0YW5jZSgpO1xuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGgubWF4KE1hdGguYWJzKHBvcy54IC0gZWxlbS5zdGFydFBvaW50ZXJQb3MueCksIE1hdGguYWJzKHBvcy55IC0gZWxlbS5zdGFydFBvaW50ZXJQb3MueSkpO1xuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IGRyYWdEaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUuc3RhcnREcmFnKHsgZXZ0IH0pO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZS5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuX3NldERyYWdQb3NpdGlvbihldnQsIGVsZW0pO1xuICAgICAgICAgICAgbm9kZXNUb0ZpcmVFdmVudHMucHVzaChub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG5vZGVzVG9GaXJlRXZlbnRzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgIG5vZGUuZmlyZSgnZHJhZ21vdmUnLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2RyYWdtb3ZlJyxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IG5vZGUsXG4gICAgICAgICAgICAgICAgZXZ0OiBldnQsXG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfZW5kRHJhZ0JlZm9yZShldnQpIHtcbiAgICAgICAgREQuX2RyYWdFbGVtZW50cy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG5vZGUgfSA9IGVsZW07XG4gICAgICAgICAgICBjb25zdCBzdGFnZSA9IG5vZGUuZ2V0U3RhZ2UoKTtcbiAgICAgICAgICAgIGlmIChldnQpIHtcbiAgICAgICAgICAgICAgICBzdGFnZS5zZXRQb2ludGVyc1Bvc2l0aW9ucyhldnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcG9zID0gc3RhZ2UuX2NoYW5nZWRQb2ludGVyUG9zaXRpb25zLmZpbmQoKHBvcykgPT4gcG9zLmlkID09PSBlbGVtLnBvaW50ZXJJZCk7XG4gICAgICAgICAgICBpZiAoIXBvcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbGVtLmRyYWdTdGF0dXMgPT09ICdkcmFnZ2luZycgfHwgZWxlbS5kcmFnU3RhdHVzID09PSAnc3RvcHBlZCcpIHtcbiAgICAgICAgICAgICAgICBERC5qdXN0RHJhZ2dlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgS29udmEuX21vdXNlTGlzdGVuQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBLb252YS5fdG91Y2hMaXN0ZW5DbGljayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIEtvbnZhLl9wb2ludGVyTGlzdGVuQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbGVtLmRyYWdTdGF0dXMgPSAnc3RvcHBlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkcmF3Tm9kZSA9IGVsZW0ubm9kZS5nZXRMYXllcigpIHx8XG4gICAgICAgICAgICAgICAgKGVsZW0ubm9kZSBpbnN0YW5jZW9mIEtvbnZhWydTdGFnZSddICYmIGVsZW0ubm9kZSk7XG4gICAgICAgICAgICBpZiAoZHJhd05vZGUpIHtcbiAgICAgICAgICAgICAgICBkcmF3Tm9kZS5iYXRjaERyYXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfZW5kRHJhZ0FmdGVyKGV2dCkge1xuICAgICAgICBERC5fZHJhZ0VsZW1lbnRzLmZvckVhY2goKGVsZW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVsZW0uZHJhZ1N0YXR1cyA9PT0gJ3N0b3BwZWQnKSB7XG4gICAgICAgICAgICAgICAgZWxlbS5ub2RlLmZpcmUoJ2RyYWdlbmQnLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkcmFnZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBlbGVtLm5vZGUsXG4gICAgICAgICAgICAgICAgICAgIGV2dDogZXZ0LFxuICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsZW0uZHJhZ1N0YXR1cyAhPT0gJ2RyYWdnaW5nJykge1xuICAgICAgICAgICAgICAgIERELl9kcmFnRWxlbWVudHMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG59O1xuaWYgKEtvbnZhLmlzQnJvd3Nlcikge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgREQuX2VuZERyYWdCZWZvcmUsIHRydWUpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIERELl9lbmREcmFnQmVmb3JlLCB0cnVlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgREQuX2RyYWcpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBERC5fZHJhZyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBERC5fZW5kRHJhZ0FmdGVyLCBmYWxzZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgREQuX2VuZERyYWdBZnRlciwgZmFsc2UpO1xufVxuIiwiaW1wb3J0IHsgVXRpbCwgVHJhbnNmb3JtIH0gZnJvbSAnLi9VdGlsLmpzJztcbmltcG9ydCB7IEZhY3RvcnkgfSBmcm9tICcuL0ZhY3RvcnkuanMnO1xuaW1wb3J0IHsgU2NlbmVDYW52YXMsIEhpdENhbnZhcyB9IGZyb20gJy4vQ2FudmFzLmpzJztcbmltcG9ydCB7IEtvbnZhIH0gZnJvbSAnLi9HbG9iYWwuanMnO1xuaW1wb3J0IHsgREQgfSBmcm9tICcuL0RyYWdBbmREcm9wLmpzJztcbmltcG9ydCB7IGdldE51bWJlclZhbGlkYXRvciwgZ2V0U3RyaW5nVmFsaWRhdG9yLCBnZXRCb29sZWFuVmFsaWRhdG9yLCB9IGZyb20gJy4vVmFsaWRhdG9ycy5qcyc7XG52YXIgQUJTT0xVVEVfT1BBQ0lUWSA9ICdhYnNvbHV0ZU9wYWNpdHknLCBBTExfTElTVEVORVJTID0gJ2FsbEV2ZW50TGlzdGVuZXJzJywgQUJTT0xVVEVfVFJBTlNGT1JNID0gJ2Fic29sdXRlVHJhbnNmb3JtJywgQUJTT0xVVEVfU0NBTEUgPSAnYWJzb2x1dGVTY2FsZScsIENBTlZBUyA9ICdjYW52YXMnLCBDSEFOR0UgPSAnQ2hhbmdlJywgQ0hJTERSRU4gPSAnY2hpbGRyZW4nLCBLT05WQSA9ICdrb252YScsIExJU1RFTklORyA9ICdsaXN0ZW5pbmcnLCBNT1VTRUVOVEVSID0gJ21vdXNlZW50ZXInLCBNT1VTRUxFQVZFID0gJ21vdXNlbGVhdmUnLCBOQU1FID0gJ25hbWUnLCBTRVQgPSAnc2V0JywgU0hBUEUgPSAnU2hhcGUnLCBTUEFDRSA9ICcgJywgU1RBR0UgPSAnc3RhZ2UnLCBUUkFOU0ZPUk0gPSAndHJhbnNmb3JtJywgVVBQRVJfU1RBR0UgPSAnU3RhZ2UnLCBWSVNJQkxFID0gJ3Zpc2libGUnLCBUUkFOU0ZPUk1fQ0hBTkdFX1NUUiA9IFtcbiAgICAneENoYW5nZS5rb252YScsXG4gICAgJ3lDaGFuZ2Uua29udmEnLFxuICAgICdzY2FsZVhDaGFuZ2Uua29udmEnLFxuICAgICdzY2FsZVlDaGFuZ2Uua29udmEnLFxuICAgICdza2V3WENoYW5nZS5rb252YScsXG4gICAgJ3NrZXdZQ2hhbmdlLmtvbnZhJyxcbiAgICAncm90YXRpb25DaGFuZ2Uua29udmEnLFxuICAgICdvZmZzZXRYQ2hhbmdlLmtvbnZhJyxcbiAgICAnb2Zmc2V0WUNoYW5nZS5rb252YScsXG4gICAgJ3RyYW5zZm9ybXNFbmFibGVkQ2hhbmdlLmtvbnZhJyxcbl0uam9pbihTUEFDRSk7XG5sZXQgaWRDb3VudGVyID0gMTtcbmV4cG9ydCBjbGFzcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5faWQgPSBpZENvdW50ZXIrKztcbiAgICAgICAgdGhpcy5ldmVudExpc3RlbmVycyA9IHt9O1xuICAgICAgICB0aGlzLmF0dHJzID0ge307XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9hbGxFdmVudExpc3RlbmVycyA9IG51bGw7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2F0dGFjaGVkRGVwc0xpc3RlbmVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fbGFzdFBvcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2JhdGNoaW5nVHJhbnNmb3JtQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX25lZWRDbGVhclRyYW5zZm9ybUNhY2hlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2ZpbHRlclVwVG9EYXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzVW5kZXJDYWNoZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kcmFnRXZlbnRJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3Nob3VsZEZpcmVDaGFuZ2VFdmVudHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZXRBdHRycyhjb25maWcpO1xuICAgICAgICB0aGlzLl9zaG91bGRGaXJlQ2hhbmdlRXZlbnRzID0gdHJ1ZTtcbiAgICB9XG4gICAgaGFzQ2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX2NsZWFyQ2FjaGUoYXR0cikge1xuICAgICAgICBpZiAoKGF0dHIgPT09IFRSQU5TRk9STSB8fCBhdHRyID09PSBBQlNPTFVURV9UUkFOU0ZPUk0pICYmXG4gICAgICAgICAgICB0aGlzLl9jYWNoZS5nZXQoYXR0cikpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlLmdldChhdHRyKS5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXR0cikge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGUuZGVsZXRlKGF0dHIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGUuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZ2V0Q2FjaGUoYXR0ciwgcHJpdmF0ZUdldHRlcikge1xuICAgICAgICB2YXIgY2FjaGUgPSB0aGlzLl9jYWNoZS5nZXQoYXR0cik7XG4gICAgICAgIHZhciBpc1RyYW5zZm9ybSA9IGF0dHIgPT09IFRSQU5TRk9STSB8fCBhdHRyID09PSBBQlNPTFVURV9UUkFOU0ZPUk07XG4gICAgICAgIHZhciBpbnZhbGlkID0gY2FjaGUgPT09IHVuZGVmaW5lZCB8fCAoaXNUcmFuc2Zvcm0gJiYgY2FjaGUuZGlydHkgPT09IHRydWUpO1xuICAgICAgICBpZiAoaW52YWxpZCkge1xuICAgICAgICAgICAgY2FjaGUgPSBwcml2YXRlR2V0dGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZS5zZXQoYXR0ciwgY2FjaGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZTtcbiAgICB9XG4gICAgX2NhbGN1bGF0ZShuYW1lLCBkZXBzLCBnZXR0ZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hdHRhY2hlZERlcHNMaXN0ZW5lcnMuZ2V0KG5hbWUpKSB7XG4gICAgICAgICAgICBjb25zdCBkZXBzU3RyaW5nID0gZGVwcy5tYXAoKGRlcCkgPT4gZGVwICsgJ0NoYW5nZS5rb252YScpLmpvaW4oU1BBQ0UpO1xuICAgICAgICAgICAgdGhpcy5vbihkZXBzU3RyaW5nLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJDYWNoZShuYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fYXR0YWNoZWREZXBzTGlzdGVuZXJzLnNldChuYW1lLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUobmFtZSwgZ2V0dGVyKTtcbiAgICB9XG4gICAgX2dldENhbnZhc0NhY2hlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGUuZ2V0KENBTlZBUyk7XG4gICAgfVxuICAgIF9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoYXR0cikge1xuICAgICAgICB0aGlzLl9jbGVhckNhY2hlKGF0dHIpO1xuICAgICAgICBpZiAoYXR0ciA9PT0gQUJTT0xVVEVfVFJBTlNGT1JNKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2Fic29sdXRlVHJhbnNmb3JtQ2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJDYWNoZSgpIHtcbiAgICAgICAgdGhpcy5fY2FjaGUuZGVsZXRlKENBTlZBUyk7XG4gICAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZSgpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0RHJhdygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY2FjaGUoY29uZmlnKSB7XG4gICAgICAgIHZhciBjb25mID0gY29uZmlnIHx8IHt9O1xuICAgICAgICB2YXIgcmVjdCA9IHt9O1xuICAgICAgICBpZiAoY29uZi54ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGNvbmYueSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBjb25mLndpZHRoID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGNvbmYuaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlY3QgPSB0aGlzLmdldENsaWVudFJlY3Qoe1xuICAgICAgICAgICAgICAgIHNraXBUcmFuc2Zvcm06IHRydWUsXG4gICAgICAgICAgICAgICAgcmVsYXRpdmVUbzogdGhpcy5nZXRQYXJlbnQoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aWR0aCA9IE1hdGguY2VpbChjb25mLndpZHRoIHx8IHJlY3Qud2lkdGgpLCBoZWlnaHQgPSBNYXRoLmNlaWwoY29uZi5oZWlnaHQgfHwgcmVjdC5oZWlnaHQpLCBwaXhlbFJhdGlvID0gY29uZi5waXhlbFJhdGlvLCB4ID0gY29uZi54ID09PSB1bmRlZmluZWQgPyBNYXRoLmZsb29yKHJlY3QueCkgOiBjb25mLngsIHkgPSBjb25mLnkgPT09IHVuZGVmaW5lZCA/IE1hdGguZmxvb3IocmVjdC55KSA6IGNvbmYueSwgb2Zmc2V0ID0gY29uZi5vZmZzZXQgfHwgMCwgZHJhd0JvcmRlciA9IGNvbmYuZHJhd0JvcmRlciB8fCBmYWxzZSwgaGl0Q2FudmFzUGl4ZWxSYXRpbyA9IGNvbmYuaGl0Q2FudmFzUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgICAgICAgIFV0aWwuZXJyb3IoJ0NhbiBub3QgY2FjaGUgdGhlIG5vZGUuIFdpZHRoIG9yIGhlaWdodCBvZiB0aGUgbm9kZSBlcXVhbHMgMC4gQ2FjaGluZyBpcyBza2lwcGVkLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdpZHRoICs9IG9mZnNldCAqIDIgKyAxO1xuICAgICAgICBoZWlnaHQgKz0gb2Zmc2V0ICogMiArIDE7XG4gICAgICAgIHggLT0gb2Zmc2V0O1xuICAgICAgICB5IC09IG9mZnNldDtcbiAgICAgICAgdmFyIGNhY2hlZFNjZW5lQ2FudmFzID0gbmV3IFNjZW5lQ2FudmFzKHtcbiAgICAgICAgICAgIHBpeGVsUmF0aW86IHBpeGVsUmF0aW8sXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgfSksIGNhY2hlZEZpbHRlckNhbnZhcyA9IG5ldyBTY2VuZUNhbnZhcyh7XG4gICAgICAgICAgICBwaXhlbFJhdGlvOiBwaXhlbFJhdGlvLFxuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIH0pLCBjYWNoZWRIaXRDYW52YXMgPSBuZXcgSGl0Q2FudmFzKHtcbiAgICAgICAgICAgIHBpeGVsUmF0aW86IGhpdENhbnZhc1BpeGVsUmF0aW8sXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgfSksIHNjZW5lQ29udGV4dCA9IGNhY2hlZFNjZW5lQ2FudmFzLmdldENvbnRleHQoKSwgaGl0Q29udGV4dCA9IGNhY2hlZEhpdENhbnZhcy5nZXRDb250ZXh0KCk7XG4gICAgICAgIGNhY2hlZEhpdENhbnZhcy5pc0NhY2hlID0gdHJ1ZTtcbiAgICAgICAgY2FjaGVkU2NlbmVDYW52YXMuaXNDYWNoZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2NhY2hlLmRlbGV0ZShDQU5WQVMpO1xuICAgICAgICB0aGlzLl9maWx0ZXJVcFRvRGF0ZSA9IGZhbHNlO1xuICAgICAgICBpZiAoY29uZi5pbWFnZVNtb290aGluZ0VuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjYWNoZWRTY2VuZUNhbnZhcy5nZXRDb250ZXh0KCkuX2NvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICBjYWNoZWRGaWx0ZXJDYW52YXMuZ2V0Q29udGV4dCgpLl9jb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHNjZW5lQ29udGV4dC5zYXZlKCk7XG4gICAgICAgIGhpdENvbnRleHQuc2F2ZSgpO1xuICAgICAgICBzY2VuZUNvbnRleHQudHJhbnNsYXRlKC14LCAteSk7XG4gICAgICAgIGhpdENvbnRleHQudHJhbnNsYXRlKC14LCAteSk7XG4gICAgICAgIHRoaXMuX2lzVW5kZXJDYWNoZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShBQlNPTFVURV9PUEFDSVRZKTtcbiAgICAgICAgdGhpcy5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKEFCU09MVVRFX1NDQUxFKTtcbiAgICAgICAgdGhpcy5kcmF3U2NlbmUoY2FjaGVkU2NlbmVDYW52YXMsIHRoaXMpO1xuICAgICAgICB0aGlzLmRyYXdIaXQoY2FjaGVkSGl0Q2FudmFzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5faXNVbmRlckNhY2hlID0gZmFsc2U7XG4gICAgICAgIHNjZW5lQ29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIGhpdENvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICBpZiAoZHJhd0JvcmRlcikge1xuICAgICAgICAgICAgc2NlbmVDb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgIHNjZW5lQ29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIHNjZW5lQ29udGV4dC5yZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgc2NlbmVDb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgc2NlbmVDb250ZXh0LnNldEF0dHIoJ3N0cm9rZVN0eWxlJywgJ3JlZCcpO1xuICAgICAgICAgICAgc2NlbmVDb250ZXh0LnNldEF0dHIoJ2xpbmVXaWR0aCcsIDUpO1xuICAgICAgICAgICAgc2NlbmVDb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgICAgc2NlbmVDb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYWNoZS5zZXQoQ0FOVkFTLCB7XG4gICAgICAgICAgICBzY2VuZTogY2FjaGVkU2NlbmVDYW52YXMsXG4gICAgICAgICAgICBmaWx0ZXI6IGNhY2hlZEZpbHRlckNhbnZhcyxcbiAgICAgICAgICAgIGhpdDogY2FjaGVkSGl0Q2FudmFzLFxuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0RHJhdygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaXNDYWNoZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZS5oYXMoQ0FOVkFTKTtcbiAgICB9XG4gICAgZ2V0Q2xpZW50UmVjdChjb25maWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhYnN0cmFjdCBcImdldENsaWVudFJlY3RcIiBtZXRob2QgY2FsbCcpO1xuICAgIH1cbiAgICBfdHJhbnNmb3JtZWRSZWN0KHJlY3QsIHRvcCkge1xuICAgICAgICB2YXIgcG9pbnRzID0gW1xuICAgICAgICAgICAgeyB4OiByZWN0LngsIHk6IHJlY3QueSB9LFxuICAgICAgICAgICAgeyB4OiByZWN0LnggKyByZWN0LndpZHRoLCB5OiByZWN0LnkgfSxcbiAgICAgICAgICAgIHsgeDogcmVjdC54ICsgcmVjdC53aWR0aCwgeTogcmVjdC55ICsgcmVjdC5oZWlnaHQgfSxcbiAgICAgICAgICAgIHsgeDogcmVjdC54LCB5OiByZWN0LnkgKyByZWN0LmhlaWdodCB9LFxuICAgICAgICBdO1xuICAgICAgICB2YXIgbWluWCwgbWluWSwgbWF4WCwgbWF4WTtcbiAgICAgICAgdmFyIHRyYW5zID0gdGhpcy5nZXRBYnNvbHV0ZVRyYW5zZm9ybSh0b3ApO1xuICAgICAgICBwb2ludHMuZm9yRWFjaChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZCA9IHRyYW5zLnBvaW50KHBvaW50KTtcbiAgICAgICAgICAgIGlmIChtaW5YID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtaW5YID0gbWF4WCA9IHRyYW5zZm9ybWVkLng7XG4gICAgICAgICAgICAgICAgbWluWSA9IG1heFkgPSB0cmFuc2Zvcm1lZC55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHRyYW5zZm9ybWVkLngpO1xuICAgICAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHRyYW5zZm9ybWVkLnkpO1xuICAgICAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHRyYW5zZm9ybWVkLngpO1xuICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHRyYW5zZm9ybWVkLnkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IG1pblgsXG4gICAgICAgICAgICB5OiBtaW5ZLFxuICAgICAgICAgICAgd2lkdGg6IG1heFggLSBtaW5YLFxuICAgICAgICAgICAgaGVpZ2h0OiBtYXhZIC0gbWluWSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2RyYXdDYWNoZWRTY2VuZUNhbnZhcyhjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0Ll9hcHBseU9wYWNpdHkodGhpcyk7XG4gICAgICAgIGNvbnRleHQuX2FwcGx5R2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uKHRoaXMpO1xuICAgICAgICBjb25zdCBjYW52YXNDYWNoZSA9IHRoaXMuX2dldENhbnZhc0NhY2hlKCk7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKGNhbnZhc0NhY2hlLngsIGNhbnZhc0NhY2hlLnkpO1xuICAgICAgICB2YXIgY2FjaGVDYW52YXMgPSB0aGlzLl9nZXRDYWNoZWRTY2VuZUNhbnZhcygpO1xuICAgICAgICB2YXIgcmF0aW8gPSBjYWNoZUNhbnZhcy5waXhlbFJhdGlvO1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShjYWNoZUNhbnZhcy5fY2FudmFzLCAwLCAwLCBjYWNoZUNhbnZhcy53aWR0aCAvIHJhdGlvLCBjYWNoZUNhbnZhcy5oZWlnaHQgLyByYXRpbyk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cbiAgICBfZHJhd0NhY2hlZEhpdENhbnZhcyhjb250ZXh0KSB7XG4gICAgICAgIHZhciBjYW52YXNDYWNoZSA9IHRoaXMuX2dldENhbnZhc0NhY2hlKCksIGhpdENhbnZhcyA9IGNhbnZhc0NhY2hlLmhpdDtcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKGNhbnZhc0NhY2hlLngsIGNhbnZhc0NhY2hlLnkpO1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShoaXRDYW52YXMuX2NhbnZhcywgMCwgMCwgaGl0Q2FudmFzLndpZHRoIC8gaGl0Q2FudmFzLnBpeGVsUmF0aW8sIGhpdENhbnZhcy5oZWlnaHQgLyBoaXRDYW52YXMucGl4ZWxSYXRpbyk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cbiAgICBfZ2V0Q2FjaGVkU2NlbmVDYW52YXMoKSB7XG4gICAgICAgIHZhciBmaWx0ZXJzID0gdGhpcy5maWx0ZXJzKCksIGNhY2hlZENhbnZhcyA9IHRoaXMuX2dldENhbnZhc0NhY2hlKCksIHNjZW5lQ2FudmFzID0gY2FjaGVkQ2FudmFzLnNjZW5lLCBmaWx0ZXJDYW52YXMgPSBjYWNoZWRDYW52YXMuZmlsdGVyLCBmaWx0ZXJDb250ZXh0ID0gZmlsdGVyQ2FudmFzLmdldENvbnRleHQoKSwgbGVuLCBpbWFnZURhdGEsIG4sIGZpbHRlcjtcbiAgICAgICAgaWYgKGZpbHRlcnMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZmlsdGVyVXBUb0RhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmF0aW8gPSBzY2VuZUNhbnZhcy5waXhlbFJhdGlvO1xuICAgICAgICAgICAgICAgIGZpbHRlckNhbnZhcy5zZXRTaXplKHNjZW5lQ2FudmFzLndpZHRoIC8gc2NlbmVDYW52YXMucGl4ZWxSYXRpbywgc2NlbmVDYW52YXMuaGVpZ2h0IC8gc2NlbmVDYW52YXMucGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gZmlsdGVycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlckNvbnRleHQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyQ29udGV4dC5kcmF3SW1hZ2Uoc2NlbmVDYW52YXMuX2NhbnZhcywgMCwgMCwgc2NlbmVDYW52YXMuZ2V0V2lkdGgoKSAvIHJhdGlvLCBzY2VuZUNhbnZhcy5nZXRIZWlnaHQoKSAvIHJhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhID0gZmlsdGVyQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgZmlsdGVyQ2FudmFzLmdldFdpZHRoKCksIGZpbHRlckNhbnZhcy5nZXRIZWlnaHQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0gZmlsdGVyc1tuXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmlsdGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVXRpbC5lcnJvcignRmlsdGVyIHNob3VsZCBiZSB0eXBlIG9mIGZ1bmN0aW9uLCBidXQgZ290ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZmlsdGVyICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBpbnN0ZWFkLiBQbGVhc2UgY2hlY2sgY29ycmVjdCBmaWx0ZXJzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIuY2FsbCh0aGlzLCBpbWFnZURhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyQ29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBVdGlsLmVycm9yKCdVbmFibGUgdG8gYXBwbHkgZmlsdGVyLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUubWVzc2FnZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnIFRoaXMgcG9zdCBteSBoZWxwIHlvdSBodHRwczovL2tvbnZhanMub3JnL2RvY3MvcG9zdHMvVGFpbnRlZF9DYW52YXMuaHRtbC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlckNhbnZhcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NlbmVDYW52YXM7XG4gICAgfVxuICAgIG9uKGV2dFN0ciwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLl9jYWNoZSAmJiB0aGlzLl9jYWNoZS5kZWxldGUoQUxMX0xJU1RFTkVSUyk7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnRzID0gZXZ0U3RyLnNwbGl0KFNQQUNFKSwgbGVuID0gZXZlbnRzLmxlbmd0aCwgbiwgZXZlbnQsIHBhcnRzLCBiYXNlRXZlbnQsIG5hbWU7XG4gICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgZXZlbnQgPSBldmVudHNbbl07XG4gICAgICAgICAgICBwYXJ0cyA9IGV2ZW50LnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBiYXNlRXZlbnQgPSBwYXJ0c1swXTtcbiAgICAgICAgICAgIG5hbWUgPSBwYXJ0c1sxXSB8fCAnJztcbiAgICAgICAgICAgIGlmICghdGhpcy5ldmVudExpc3RlbmVyc1tiYXNlRXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudExpc3RlbmVyc1tiYXNlRXZlbnRdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzW2Jhc2VFdmVudF0ucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9mZihldnRTdHIsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBldmVudHMgPSAoZXZ0U3RyIHx8ICcnKS5zcGxpdChTUEFDRSksIGxlbiA9IGV2ZW50cy5sZW5ndGgsIG4sIHQsIGV2ZW50LCBwYXJ0cywgYmFzZUV2ZW50LCBuYW1lO1xuICAgICAgICB0aGlzLl9jYWNoZSAmJiB0aGlzLl9jYWNoZS5kZWxldGUoQUxMX0xJU1RFTkVSUyk7XG4gICAgICAgIGlmICghZXZ0U3RyKSB7XG4gICAgICAgICAgICBmb3IgKHQgaW4gdGhpcy5ldmVudExpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIHRoaXMuX29mZih0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgIGV2ZW50ID0gZXZlbnRzW25dO1xuICAgICAgICAgICAgcGFydHMgPSBldmVudC5zcGxpdCgnLicpO1xuICAgICAgICAgICAgYmFzZUV2ZW50ID0gcGFydHNbMF07XG4gICAgICAgICAgICBuYW1lID0gcGFydHNbMV07XG4gICAgICAgICAgICBpZiAoYmFzZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRMaXN0ZW5lcnNbYmFzZUV2ZW50XSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vZmYoYmFzZUV2ZW50LCBuYW1lLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh0IGluIHRoaXMuZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2ZmKHQsIG5hbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpc3BhdGNoRXZlbnQoZXZ0KSB7XG4gICAgICAgIHZhciBlID0ge1xuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgdHlwZTogZXZ0LnR5cGUsXG4gICAgICAgICAgICBldnQ6IGV2dCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5maXJlKGV2dC50eXBlLCBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLm9uKHR5cGUsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBldnQuZXZ0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUpIHtcbiAgICAgICAgdGhpcy5vZmYodHlwZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBfZGVsZWdhdGUoZXZlbnQsIHNlbGVjdG9yLCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciBzdG9wTm9kZSA9IHRoaXM7XG4gICAgICAgIHRoaXMub24oZXZlbnQsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRzID0gZXZ0LnRhcmdldC5maW5kQW5jZXN0b3JzKHNlbGVjdG9yLCB0cnVlLCBzdG9wTm9kZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBldnQgPSBVdGlsLmNsb25lT2JqZWN0KGV2dCk7XG4gICAgICAgICAgICAgICAgZXZ0LmN1cnJlbnRUYXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuY2FsbCh0YXJnZXRzW2ldLCBldnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlKCkge1xuICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcERyYWcoKTtcbiAgICAgICAgfVxuICAgICAgICBERC5fZHJhZ0VsZW1lbnRzLmRlbGV0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgX2NsZWFyQ2FjaGVzKCkge1xuICAgICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoQUJTT0xVVEVfVFJBTlNGT1JNKTtcbiAgICAgICAgdGhpcy5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKEFCU09MVVRFX09QQUNJVFkpO1xuICAgICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoQUJTT0xVVEVfU0NBTEUpO1xuICAgICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoU1RBR0UpO1xuICAgICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoVklTSUJMRSk7XG4gICAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShMSVNURU5JTkcpO1xuICAgIH1cbiAgICBfcmVtb3ZlKCkge1xuICAgICAgICB0aGlzLl9jbGVhckNhY2hlcygpO1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UodGhpcy5pbmRleCwgMSk7XG4gICAgICAgICAgICBwYXJlbnQuX3NldENoaWxkcmVuSW5kaWNlcygpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRBdHRyKGF0dHIpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9ICdnZXQnICsgVXRpbC5fY2FwaXRhbGl6ZShhdHRyKTtcbiAgICAgICAgaWYgKFV0aWwuX2lzRnVuY3Rpb24odGhpc1ttZXRob2RdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbbWV0aG9kXSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJzW2F0dHJdO1xuICAgIH1cbiAgICBnZXRBbmNlc3RvcnMoKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpLCBhbmNlc3RvcnMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgYW5jZXN0b3JzLnB1c2gocGFyZW50KTtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYW5jZXN0b3JzO1xuICAgIH1cbiAgICBnZXRBdHRycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cnMgfHwge307XG4gICAgfVxuICAgIHNldEF0dHJzKGNvbmZpZykge1xuICAgICAgICB0aGlzLl9iYXRjaFRyYW5zZm9ybUNoYW5nZXMoKCkgPT4ge1xuICAgICAgICAgICAgdmFyIGtleSwgbWV0aG9kO1xuICAgICAgICAgICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoa2V5IGluIGNvbmZpZykge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IENISUxEUkVOKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXRob2QgPSBTRVQgKyBVdGlsLl9jYXBpdGFsaXplKGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKFV0aWwuX2lzRnVuY3Rpb24odGhpc1ttZXRob2RdKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW21ldGhvZF0oY29uZmlnW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0QXR0cihrZXksIGNvbmZpZ1trZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaXNMaXN0ZW5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZShMSVNURU5JTkcsIHRoaXMuX2lzTGlzdGVuaW5nKTtcbiAgICB9XG4gICAgX2lzTGlzdGVuaW5nKHJlbGF0aXZlVG8pIHtcbiAgICAgICAgY29uc3QgbGlzdGVuaW5nID0gdGhpcy5saXN0ZW5pbmcoKTtcbiAgICAgICAgaWYgKCFsaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudCAhPT0gcmVsYXRpdmVUbyAmJiB0aGlzICE9PSByZWxhdGl2ZVRvKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50Ll9pc0xpc3RlbmluZyhyZWxhdGl2ZVRvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzVmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKFZJU0lCTEUsIHRoaXMuX2lzVmlzaWJsZSk7XG4gICAgfVxuICAgIF9pc1Zpc2libGUocmVsYXRpdmVUbykge1xuICAgICAgICBjb25zdCB2aXNpYmxlID0gdGhpcy52aXNpYmxlKCk7XG4gICAgICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50ICE9PSByZWxhdGl2ZVRvICYmIHRoaXMgIT09IHJlbGF0aXZlVG8pIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQuX2lzVmlzaWJsZShyZWxhdGl2ZVRvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNob3VsZERyYXdIaXQodG9wLCBza2lwRHJhZ0NoZWNrID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVmlzaWJsZSh0b3ApICYmIHRoaXMuX2lzTGlzdGVuaW5nKHRvcCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpO1xuICAgICAgICB2YXIgbGF5ZXJVbmRlckRyYWcgPSBmYWxzZTtcbiAgICAgICAgREQuX2RyYWdFbGVtZW50cy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoZWxlbS5kcmFnU3RhdHVzICE9PSAnZHJhZ2dpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWxlbS5ub2RlLm5vZGVUeXBlID09PSAnU3RhZ2UnKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJVbmRlckRyYWcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWxlbS5ub2RlLmdldExheWVyKCkgPT09IGxheWVyKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJVbmRlckRyYWcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGRyYWdTa2lwID0gIXNraXBEcmFnQ2hlY2sgJiYgIUtvbnZhLmhpdE9uRHJhZ0VuYWJsZWQgJiYgbGF5ZXJVbmRlckRyYWc7XG4gICAgICAgIHJldHVybiB0aGlzLmlzTGlzdGVuaW5nKCkgJiYgdGhpcy5pc1Zpc2libGUoKSAmJiAhZHJhZ1NraXA7XG4gICAgfVxuICAgIHNob3coKSB7XG4gICAgICAgIHRoaXMudmlzaWJsZSh0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGhpZGUoKSB7XG4gICAgICAgIHRoaXMudmlzaWJsZShmYWxzZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRaSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4IHx8IDA7XG4gICAgfVxuICAgIGdldEFic29sdXRlWkluZGV4KCkge1xuICAgICAgICB2YXIgZGVwdGggPSB0aGlzLmdldERlcHRoKCksIHRoYXQgPSB0aGlzLCBpbmRleCA9IDAsIG5vZGVzLCBsZW4sIG4sIGNoaWxkO1xuICAgICAgICBmdW5jdGlvbiBhZGRDaGlsZHJlbihjaGlsZHJlbikge1xuICAgICAgICAgICAgbm9kZXMgPSBbXTtcbiAgICAgICAgICAgIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5bbl07XG4gICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgIT09IFNIQVBFKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzID0gbm9kZXMuY29uY2F0KGNoaWxkLmdldENoaWxkcmVuKCkuc2xpY2UoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5faWQgPT09IHRoYXQuX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIG4gPSBsZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDAgJiYgbm9kZXNbMF0uZ2V0RGVwdGgoKSA8PSBkZXB0aCkge1xuICAgICAgICAgICAgICAgIGFkZENoaWxkcmVuKG5vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhhdC5ub2RlVHlwZSAhPT0gVVBQRVJfU1RBR0UpIHtcbiAgICAgICAgICAgIGFkZENoaWxkcmVuKHRoYXQuZ2V0U3RhZ2UoKS5nZXRDaGlsZHJlbigpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGdldERlcHRoKCkge1xuICAgICAgICB2YXIgZGVwdGggPSAwLCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlcHRoO1xuICAgIH1cbiAgICBfYmF0Y2hUcmFuc2Zvcm1DaGFuZ2VzKGZ1bmMpIHtcbiAgICAgICAgdGhpcy5fYmF0Y2hpbmdUcmFuc2Zvcm1DaGFuZ2UgPSB0cnVlO1xuICAgICAgICBmdW5jKCk7XG4gICAgICAgIHRoaXMuX2JhdGNoaW5nVHJhbnNmb3JtQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9uZWVkQ2xlYXJUcmFuc2Zvcm1DYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJDYWNoZShUUkFOU0ZPUk0pO1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKEFCU09MVVRFX1RSQU5TRk9STSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbmVlZENsZWFyVHJhbnNmb3JtQ2FjaGUgPSBmYWxzZTtcbiAgICB9XG4gICAgc2V0UG9zaXRpb24ocG9zKSB7XG4gICAgICAgIHRoaXMuX2JhdGNoVHJhbnNmb3JtQ2hhbmdlcygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLngocG9zLngpO1xuICAgICAgICAgICAgdGhpcy55KHBvcy55KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRQb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHRoaXMueCgpLFxuICAgICAgICAgICAgeTogdGhpcy55KCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFJlbGF0aXZlUG9pbnRlclBvc2l0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuZ2V0U3RhZ2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0U3RhZ2UoKS5nZXRQb2ludGVyUG9zaXRpb24oKTtcbiAgICAgICAgaWYgKCFwb3MpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLmdldEFic29sdXRlVHJhbnNmb3JtKCkuY29weSgpO1xuICAgICAgICB0cmFuc2Zvcm0uaW52ZXJ0KCk7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm0ucG9pbnQocG9zKTtcbiAgICB9XG4gICAgZ2V0QWJzb2x1dGVQb3NpdGlvbih0b3ApIHtcbiAgICAgICAgbGV0IGhhdmVDYWNoZWRQYXJlbnQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgICBpZiAocGFyZW50LmlzQ2FjaGVkKCkpIHtcbiAgICAgICAgICAgICAgICBoYXZlQ2FjaGVkUGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhdmVDYWNoZWRQYXJlbnQgJiYgIXRvcCkge1xuICAgICAgICAgICAgdG9wID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWJzb2x1dGVNYXRyaXggPSB0aGlzLmdldEFic29sdXRlVHJhbnNmb3JtKHRvcCkuZ2V0TWF0cml4KCksIGFic29sdXRlVHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybSgpLCBvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuICAgICAgICBhYnNvbHV0ZVRyYW5zZm9ybS5tID0gYWJzb2x1dGVNYXRyaXguc2xpY2UoKTtcbiAgICAgICAgYWJzb2x1dGVUcmFuc2Zvcm0udHJhbnNsYXRlKG9mZnNldC54LCBvZmZzZXQueSk7XG4gICAgICAgIHJldHVybiBhYnNvbHV0ZVRyYW5zZm9ybS5nZXRUcmFuc2xhdGlvbigpO1xuICAgIH1cbiAgICBzZXRBYnNvbHV0ZVBvc2l0aW9uKHBvcykge1xuICAgICAgICB2YXIgb3JpZ1RyYW5zID0gdGhpcy5fY2xlYXJUcmFuc2Zvcm0oKTtcbiAgICAgICAgdGhpcy5hdHRycy54ID0gb3JpZ1RyYW5zLng7XG4gICAgICAgIHRoaXMuYXR0cnMueSA9IG9yaWdUcmFucy55O1xuICAgICAgICBkZWxldGUgb3JpZ1RyYW5zLng7XG4gICAgICAgIGRlbGV0ZSBvcmlnVHJhbnMueTtcbiAgICAgICAgdGhpcy5fY2xlYXJDYWNoZShUUkFOU0ZPUk0pO1xuICAgICAgICB2YXIgaXQgPSB0aGlzLl9nZXRBYnNvbHV0ZVRyYW5zZm9ybSgpLmNvcHkoKTtcbiAgICAgICAgaXQuaW52ZXJ0KCk7XG4gICAgICAgIGl0LnRyYW5zbGF0ZShwb3MueCwgcG9zLnkpO1xuICAgICAgICBwb3MgPSB7XG4gICAgICAgICAgICB4OiB0aGlzLmF0dHJzLnggKyBpdC5nZXRUcmFuc2xhdGlvbigpLngsXG4gICAgICAgICAgICB5OiB0aGlzLmF0dHJzLnkgKyBpdC5nZXRUcmFuc2xhdGlvbigpLnksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NldFRyYW5zZm9ybShvcmlnVHJhbnMpO1xuICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHsgeDogcG9zLngsIHk6IHBvcy55IH0pO1xuICAgICAgICB0aGlzLl9jbGVhckNhY2hlKFRSQU5TRk9STSk7XG4gICAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShBQlNPTFVURV9UUkFOU0ZPUk0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgX3NldFRyYW5zZm9ybSh0cmFucykge1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGtleSBpbiB0cmFucykge1xuICAgICAgICAgICAgdGhpcy5hdHRyc1trZXldID0gdHJhbnNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY2xlYXJUcmFuc2Zvcm0oKSB7XG4gICAgICAgIHZhciB0cmFucyA9IHtcbiAgICAgICAgICAgIHg6IHRoaXMueCgpLFxuICAgICAgICAgICAgeTogdGhpcy55KCksXG4gICAgICAgICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbigpLFxuICAgICAgICAgICAgc2NhbGVYOiB0aGlzLnNjYWxlWCgpLFxuICAgICAgICAgICAgc2NhbGVZOiB0aGlzLnNjYWxlWSgpLFxuICAgICAgICAgICAgb2Zmc2V0WDogdGhpcy5vZmZzZXRYKCksXG4gICAgICAgICAgICBvZmZzZXRZOiB0aGlzLm9mZnNldFkoKSxcbiAgICAgICAgICAgIHNrZXdYOiB0aGlzLnNrZXdYKCksXG4gICAgICAgICAgICBza2V3WTogdGhpcy5za2V3WSgpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmF0dHJzLnggPSAwO1xuICAgICAgICB0aGlzLmF0dHJzLnkgPSAwO1xuICAgICAgICB0aGlzLmF0dHJzLnJvdGF0aW9uID0gMDtcbiAgICAgICAgdGhpcy5hdHRycy5zY2FsZVggPSAxO1xuICAgICAgICB0aGlzLmF0dHJzLnNjYWxlWSA9IDE7XG4gICAgICAgIHRoaXMuYXR0cnMub2Zmc2V0WCA9IDA7XG4gICAgICAgIHRoaXMuYXR0cnMub2Zmc2V0WSA9IDA7XG4gICAgICAgIHRoaXMuYXR0cnMuc2tld1ggPSAwO1xuICAgICAgICB0aGlzLmF0dHJzLnNrZXdZID0gMDtcbiAgICAgICAgcmV0dXJuIHRyYW5zO1xuICAgIH1cbiAgICBtb3ZlKGNoYW5nZSkge1xuICAgICAgICB2YXIgY2hhbmdlWCA9IGNoYW5nZS54LCBjaGFuZ2VZID0gY2hhbmdlLnksIHggPSB0aGlzLngoKSwgeSA9IHRoaXMueSgpO1xuICAgICAgICBpZiAoY2hhbmdlWCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB4ICs9IGNoYW5nZVg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZVkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgeSArPSBjaGFuZ2VZO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0UG9zaXRpb24oeyB4OiB4LCB5OiB5IH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgX2VhY2hBbmNlc3RvclJldmVyc2UoZnVuYywgdG9wKSB7XG4gICAgICAgIHZhciBmYW1pbHkgPSBbXSwgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKSwgbGVuLCBuO1xuICAgICAgICBpZiAodG9wICYmIHRvcC5faWQgPT09IHRoaXMuX2lkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZmFtaWx5LnVuc2hpZnQodGhpcyk7XG4gICAgICAgIHdoaWxlIChwYXJlbnQgJiYgKCF0b3AgfHwgcGFyZW50Ll9pZCAhPT0gdG9wLl9pZCkpIHtcbiAgICAgICAgICAgIGZhbWlseS51bnNoaWZ0KHBhcmVudCk7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGxlbiA9IGZhbWlseS5sZW5ndGg7XG4gICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgZnVuYyhmYW1pbHlbbl0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJvdGF0ZSh0aGV0YSkge1xuICAgICAgICB0aGlzLnJvdGF0aW9uKHRoaXMucm90YXRpb24oKSArIHRoZXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG1vdmVUb1RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgVXRpbC53YXJuKCdOb2RlIGhhcyBubyBwYXJlbnQuIG1vdmVUb1RvcCBmdW5jdGlvbiBpcyBpZ25vcmVkLicpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXgsIGxlbiA9IHRoaXMucGFyZW50LmdldENoaWxkcmVuKCkubGVuZ3RoO1xuICAgICAgICBpZiAoaW5kZXggPCBsZW4gLSAxKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4ucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50Ll9zZXRDaGlsZHJlbkluZGljZXMoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbW92ZVVwKCkge1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICBVdGlsLndhcm4oJ05vZGUgaGFzIG5vIHBhcmVudC4gbW92ZVVwIGZ1bmN0aW9uIGlzIGlnbm9yZWQuJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleCwgbGVuID0gdGhpcy5wYXJlbnQuZ2V0Q2hpbGRyZW4oKS5sZW5ndGg7XG4gICAgICAgIGlmIChpbmRleCA8IGxlbiAtIDEpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXggKyAxLCAwLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50Ll9zZXRDaGlsZHJlbkluZGljZXMoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbW92ZURvd24oKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIFV0aWwud2FybignTm9kZSBoYXMgbm8gcGFyZW50LiBtb3ZlRG93biBmdW5jdGlvbiBpcyBpZ25vcmVkLicpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXggLSAxLCAwLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50Ll9zZXRDaGlsZHJlbkluZGljZXMoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbW92ZVRvQm90dG9tKCkge1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICBVdGlsLndhcm4oJ05vZGUgaGFzIG5vIHBhcmVudC4gbW92ZVRvQm90dG9tIGZ1bmN0aW9uIGlzIGlnbm9yZWQuJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnVuc2hpZnQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5fc2V0Q2hpbGRyZW5JbmRpY2VzKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNldFpJbmRleCh6SW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgVXRpbC53YXJuKCdOb2RlIGhhcyBubyBwYXJlbnQuIHpJbmRleCBwYXJhbWV0ZXIgaXMgaWdub3JlZC4nKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh6SW5kZXggPCAwIHx8IHpJbmRleCA+PSB0aGlzLnBhcmVudC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIFV0aWwud2FybignVW5leHBlY3RlZCB2YWx1ZSAnICtcbiAgICAgICAgICAgICAgICB6SW5kZXggK1xuICAgICAgICAgICAgICAgICcgZm9yIHpJbmRleCBwcm9wZXJ0eS4gekluZGV4IGlzIGp1c3QgaW5kZXggb2YgYSBub2RlIGluIGNoaWxkcmVuIG9mIGl0cyBwYXJlbnQuIEV4cGVjdGVkIHZhbHVlIGlzIGZyb20gMCB0byAnICtcbiAgICAgICAgICAgICAgICAodGhpcy5wYXJlbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMSkgK1xuICAgICAgICAgICAgICAgICcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKHpJbmRleCwgMCwgdGhpcyk7XG4gICAgICAgIHRoaXMucGFyZW50Ll9zZXRDaGlsZHJlbkluZGljZXMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldEFic29sdXRlT3BhY2l0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKEFCU09MVVRFX09QQUNJVFksIHRoaXMuX2dldEFic29sdXRlT3BhY2l0eSk7XG4gICAgfVxuICAgIF9nZXRBYnNvbHV0ZU9wYWNpdHkoKSB7XG4gICAgICAgIHZhciBhYnNPcGFjaXR5ID0gdGhpcy5vcGFjaXR5KCk7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgICAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzVW5kZXJDYWNoZSkge1xuICAgICAgICAgICAgYWJzT3BhY2l0eSAqPSBwYXJlbnQuZ2V0QWJzb2x1dGVPcGFjaXR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFic09wYWNpdHk7XG4gICAgfVxuICAgIG1vdmVUbyhuZXdDb250YWluZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0UGFyZW50KCkgIT09IG5ld0NvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlKCk7XG4gICAgICAgICAgICBuZXdDb250YWluZXIuYWRkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b09iamVjdCgpIHtcbiAgICAgICAgdmFyIG9iaiA9IHt9LCBhdHRycyA9IHRoaXMuZ2V0QXR0cnMoKSwga2V5LCB2YWwsIGdldHRlciwgZGVmYXVsdFZhbHVlLCBub25QbGFpbk9iamVjdDtcbiAgICAgICAgb2JqLmF0dHJzID0ge307XG4gICAgICAgIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgICB2YWwgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgbm9uUGxhaW5PYmplY3QgPVxuICAgICAgICAgICAgICAgIFV0aWwuaXNPYmplY3QodmFsKSAmJiAhVXRpbC5faXNQbGFpbk9iamVjdCh2YWwpICYmICFVdGlsLl9pc0FycmF5KHZhbCk7XG4gICAgICAgICAgICBpZiAobm9uUGxhaW5PYmplY3QpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldHRlciA9IHR5cGVvZiB0aGlzW2tleV0gPT09ICdmdW5jdGlvbicgJiYgdGhpc1trZXldO1xuICAgICAgICAgICAgZGVsZXRlIGF0dHJzW2tleV07XG4gICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbCh0aGlzKSA6IG51bGw7XG4gICAgICAgICAgICBhdHRyc1trZXldID0gdmFsO1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRWYWx1ZSAhPT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgb2JqLmF0dHJzW2tleV0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb2JqLmNsYXNzTmFtZSA9IHRoaXMuZ2V0Q2xhc3NOYW1lKCk7XG4gICAgICAgIHJldHVybiBVdGlsLl9wcmVwYXJlVG9TdHJpbmdpZnkob2JqKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b09iamVjdCgpKTtcbiAgICB9XG4gICAgZ2V0UGFyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XG4gICAgfVxuICAgIGZpbmRBbmNlc3RvcnMoc2VsZWN0b3IsIGluY2x1ZGVTZWxmLCBzdG9wTm9kZSkge1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIGlmIChpbmNsdWRlU2VsZiAmJiB0aGlzLl9pc01hdGNoKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgcmVzLnB1c2godGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFuY2VzdG9yID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICAgICAgaWYgKGFuY2VzdG9yID09PSBzdG9wTm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYW5jZXN0b3IuX2lzTWF0Y2goc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaXNBbmNlc3Rvck9mKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmaW5kQW5jZXN0b3Ioc2VsZWN0b3IsIGluY2x1ZGVTZWxmLCBzdG9wTm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kQW5jZXN0b3JzKHNlbGVjdG9yLCBpbmNsdWRlU2VsZiwgc3RvcE5vZGUpWzBdO1xuICAgIH1cbiAgICBfaXNNYXRjaChzZWxlY3Rvcikge1xuICAgICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWxlY3RvckFyciA9IHNlbGVjdG9yLnJlcGxhY2UoLyAvZywgJycpLnNwbGl0KCcsJyksIGxlbiA9IHNlbGVjdG9yQXJyLmxlbmd0aCwgbiwgc2VsO1xuICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgIHNlbCA9IHNlbGVjdG9yQXJyW25dO1xuICAgICAgICAgICAgaWYgKCFVdGlsLmlzVmFsaWRTZWxlY3RvcihzZWwpKSB7XG4gICAgICAgICAgICAgICAgVXRpbC53YXJuKCdTZWxlY3RvciBcIicgK1xuICAgICAgICAgICAgICAgICAgICBzZWwgK1xuICAgICAgICAgICAgICAgICAgICAnXCIgaXMgaW52YWxpZC4gQWxsb3dlZCBzZWxlY3RvcnMgZXhhbXBsZXMgYXJlIFwiI2Zvb1wiLCBcIi5iYXJcIiBvciBcIkdyb3VwXCIuJyk7XG4gICAgICAgICAgICAgICAgVXRpbC53YXJuKCdJZiB5b3UgaGF2ZSBhIGN1c3RvbSBzaGFwZSB3aXRoIHN1Y2ggY2xhc3NOYW1lLCBwbGVhc2UgY2hhbmdlIGl0IHRvIHN0YXJ0IHdpdGggdXBwZXIgbGV0dGVyIGxpa2UgXCJUcmlhbmdsZVwiLicpO1xuICAgICAgICAgICAgICAgIFV0aWwud2FybignS29udmEgaXMgYXdlc29tZSwgcmlnaHQ/Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWQoKSA9PT0gc2VsLnNsaWNlKDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbC5jaGFyQXQoMCkgPT09ICcuJykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc05hbWUoc2VsLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNsYXNzTmFtZSA9PT0gc2VsIHx8IHRoaXMubm9kZVR5cGUgPT09IHNlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0TGF5ZXIoKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgICAgICByZXR1cm4gcGFyZW50ID8gcGFyZW50LmdldExheWVyKCkgOiBudWxsO1xuICAgIH1cbiAgICBnZXRTdGFnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKFNUQUdFLCB0aGlzLl9nZXRTdGFnZSk7XG4gICAgfVxuICAgIF9nZXRTdGFnZSgpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQuZ2V0U3RhZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmlyZShldmVudFR5cGUsIGV2dCA9IHt9LCBidWJibGUpIHtcbiAgICAgICAgZXZ0LnRhcmdldCA9IGV2dC50YXJnZXQgfHwgdGhpcztcbiAgICAgICAgaWYgKGJ1YmJsZSkge1xuICAgICAgICAgICAgdGhpcy5fZmlyZUFuZEJ1YmJsZShldmVudFR5cGUsIGV2dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9maXJlKGV2ZW50VHlwZSwgZXZ0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0QWJzb2x1dGVUcmFuc2Zvcm0odG9wKSB7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRBYnNvbHV0ZVRyYW5zZm9ybSh0b3ApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKEFCU09MVVRFX1RSQU5TRk9STSwgdGhpcy5fZ2V0QWJzb2x1dGVUcmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9nZXRBYnNvbHV0ZVRyYW5zZm9ybSh0b3ApIHtcbiAgICAgICAgdmFyIGF0O1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgICBhdCA9IG5ldyBUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIHRoaXMuX2VhY2hBbmNlc3RvclJldmVyc2UoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3Jtc0VuYWJsZWQgPSBub2RlLnRyYW5zZm9ybXNFbmFibGVkKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybXNFbmFibGVkID09PSAnYWxsJykge1xuICAgICAgICAgICAgICAgICAgICBhdC5tdWx0aXBseShub2RlLmdldFRyYW5zZm9ybSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHJhbnNmb3Jtc0VuYWJsZWQgPT09ICdwb3NpdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgYXQudHJhbnNsYXRlKG5vZGUueCgpIC0gbm9kZS5vZmZzZXRYKCksIG5vZGUueSgpIC0gbm9kZS5vZmZzZXRZKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRvcCk7XG4gICAgICAgICAgICByZXR1cm4gYXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhdCA9IHRoaXMuX2NhY2hlLmdldChBQlNPTFVURV9UUkFOU0ZPUk0pIHx8IG5ldyBUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmdldEFic29sdXRlVHJhbnNmb3JtKCkuY29weUludG8oYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXQucmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1zRW5hYmxlZCA9IHRoaXMudHJhbnNmb3Jtc0VuYWJsZWQoKTtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1zRW5hYmxlZCA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICAgICAgICBhdC5tdWx0aXBseSh0aGlzLmdldFRyYW5zZm9ybSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRyYW5zZm9ybXNFbmFibGVkID09PSAncG9zaXRpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMuYXR0cnMueCB8fCAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLmF0dHJzLnkgfHwgMDtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXRYID0gdGhpcy5hdHRycy5vZmZzZXRYIHx8IDA7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IHRoaXMuYXR0cnMub2Zmc2V0WSB8fCAwO1xuICAgICAgICAgICAgICAgIGF0LnRyYW5zbGF0ZSh4IC0gb2Zmc2V0WCwgeSAtIG9mZnNldFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXQuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBhdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRBYnNvbHV0ZVNjYWxlKHRvcCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudC5faXNVbmRlckNhY2hlKSB7XG4gICAgICAgICAgICAgICAgdG9wID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRoaXMuZ2V0QWJzb2x1dGVUcmFuc2Zvcm0odG9wKTtcbiAgICAgICAgY29uc3QgYXR0cnMgPSB0cmFuc2Zvcm0uZGVjb21wb3NlKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBhdHRycy5zY2FsZVgsXG4gICAgICAgICAgICB5OiBhdHRycy5zY2FsZVksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldEFic29sdXRlUm90YXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFic29sdXRlVHJhbnNmb3JtKCkuZGVjb21wb3NlKCkucm90YXRpb247XG4gICAgfVxuICAgIGdldFRyYW5zZm9ybSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKFRSQU5TRk9STSwgdGhpcy5fZ2V0VHJhbnNmb3JtKTtcbiAgICB9XG4gICAgX2dldFRyYW5zZm9ybSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIG0gPSB0aGlzLl9jYWNoZS5nZXQoVFJBTlNGT1JNKSB8fCBuZXcgVHJhbnNmb3JtKCk7XG4gICAgICAgIG0ucmVzZXQoKTtcbiAgICAgICAgdmFyIHggPSB0aGlzLngoKSwgeSA9IHRoaXMueSgpLCByb3RhdGlvbiA9IEtvbnZhLmdldEFuZ2xlKHRoaXMucm90YXRpb24oKSksIHNjYWxlWCA9IChfYSA9IHRoaXMuYXR0cnMuc2NhbGVYKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxLCBzY2FsZVkgPSAoX2IgPSB0aGlzLmF0dHJzLnNjYWxlWSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMSwgc2tld1ggPSB0aGlzLmF0dHJzLnNrZXdYIHx8IDAsIHNrZXdZID0gdGhpcy5hdHRycy5za2V3WSB8fCAwLCBvZmZzZXRYID0gdGhpcy5hdHRycy5vZmZzZXRYIHx8IDAsIG9mZnNldFkgPSB0aGlzLmF0dHJzLm9mZnNldFkgfHwgMDtcbiAgICAgICAgaWYgKHggIT09IDAgfHwgeSAhPT0gMCkge1xuICAgICAgICAgICAgbS50cmFuc2xhdGUoeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICBtLnJvdGF0ZShyb3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNrZXdYICE9PSAwIHx8IHNrZXdZICE9PSAwKSB7XG4gICAgICAgICAgICBtLnNrZXcoc2tld1gsIHNrZXdZKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NhbGVYICE9PSAxIHx8IHNjYWxlWSAhPT0gMSkge1xuICAgICAgICAgICAgbS5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldFggIT09IDAgfHwgb2Zmc2V0WSAhPT0gMCkge1xuICAgICAgICAgICAgbS50cmFuc2xhdGUoLTEgKiBvZmZzZXRYLCAtMSAqIG9mZnNldFkpO1xuICAgICAgICB9XG4gICAgICAgIG0uZGlydHkgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuICAgIGNsb25lKG9iaikge1xuICAgICAgICB2YXIgYXR0cnMgPSBVdGlsLmNsb25lT2JqZWN0KHRoaXMuYXR0cnMpLCBrZXksIGFsbExpc3RlbmVycywgbGVuLCBuLCBsaXN0ZW5lcjtcbiAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBhdHRyc1trZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihhdHRycyk7XG4gICAgICAgIGZvciAoa2V5IGluIHRoaXMuZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGFsbExpc3RlbmVycyA9IHRoaXMuZXZlbnRMaXN0ZW5lcnNba2V5XTtcbiAgICAgICAgICAgIGxlbiA9IGFsbExpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGFsbExpc3RlbmVyc1tuXTtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIubmFtZS5pbmRleE9mKEtPTlZBKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLmV2ZW50TGlzdGVuZXJzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZXZlbnRMaXN0ZW5lcnNba2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZXZlbnRMaXN0ZW5lcnNba2V5XS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIF90b0tvbnZhQ2FudmFzKGNvbmZpZykge1xuICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgICAgIHZhciBib3ggPSB0aGlzLmdldENsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpLCB4ID0gY29uZmlnLnggIT09IHVuZGVmaW5lZCA/IGNvbmZpZy54IDogTWF0aC5mbG9vcihib3gueCksIHkgPSBjb25maWcueSAhPT0gdW5kZWZpbmVkID8gY29uZmlnLnkgOiBNYXRoLmZsb29yKGJveC55KSwgcGl4ZWxSYXRpbyA9IGNvbmZpZy5waXhlbFJhdGlvIHx8IDEsIGNhbnZhcyA9IG5ldyBTY2VuZUNhbnZhcyh7XG4gICAgICAgICAgICB3aWR0aDogY29uZmlnLndpZHRoIHx8IE1hdGguY2VpbChib3gud2lkdGgpIHx8IChzdGFnZSA/IHN0YWdlLndpZHRoKCkgOiAwKSxcbiAgICAgICAgICAgIGhlaWdodDogY29uZmlnLmhlaWdodCB8fFxuICAgICAgICAgICAgICAgIE1hdGguY2VpbChib3guaGVpZ2h0KSB8fFxuICAgICAgICAgICAgICAgIChzdGFnZSA/IHN0YWdlLmhlaWdodCgpIDogMCksXG4gICAgICAgICAgICBwaXhlbFJhdGlvOiBwaXhlbFJhdGlvLFxuICAgICAgICB9KSwgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCk7XG4gICAgICAgIGlmIChjb25maWcuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udGV4dC5fY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgaWYgKHggfHwgeSkge1xuICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoLTEgKiB4LCAtMSAqIHkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhd1NjZW5lKGNhbnZhcyk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgIH1cbiAgICB0b0NhbnZhcyhjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvS29udmFDYW52YXMoY29uZmlnKS5fY2FudmFzO1xuICAgIH1cbiAgICB0b0RhdGFVUkwoY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgdmFyIG1pbWVUeXBlID0gY29uZmlnLm1pbWVUeXBlIHx8IG51bGwsIHF1YWxpdHkgPSBjb25maWcucXVhbGl0eSB8fCBudWxsO1xuICAgICAgICB2YXIgdXJsID0gdGhpcy5fdG9Lb252YUNhbnZhcyhjb25maWcpLnRvRGF0YVVSTChtaW1lVHlwZSwgcXVhbGl0eSk7XG4gICAgICAgIGlmIChjb25maWcuY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNvbmZpZy5jYWxsYmFjayh1cmwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIHRvSW1hZ2UoY29uZmlnKSB7XG4gICAgICAgIGlmICghY29uZmlnIHx8ICFjb25maWcuY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRocm93ICdjYWxsYmFjayByZXF1aXJlZCBmb3IgdG9JbWFnZSBtZXRob2QgY29uZmlnIGFyZ3VtZW50JztcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FsbGJhY2sgPSBjb25maWcuY2FsbGJhY2s7XG4gICAgICAgIGRlbGV0ZSBjb25maWcuY2FsbGJhY2s7XG4gICAgICAgIFV0aWwuX3VybFRvSW1hZ2UodGhpcy50b0RhdGFVUkwoY29uZmlnKSwgZnVuY3Rpb24gKGltZykge1xuICAgICAgICAgICAgY2FsbGJhY2soaW1nKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldFNpemUoc2l6ZSkge1xuICAgICAgICB0aGlzLndpZHRoKHNpemUud2lkdGgpO1xuICAgICAgICB0aGlzLmhlaWdodChzaXplLmhlaWdodCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRTaXplKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgoKSxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0Q2xhc3NOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGFzc05hbWUgfHwgdGhpcy5ub2RlVHlwZTtcbiAgICB9XG4gICAgZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZVR5cGU7XG4gICAgfVxuICAgIGdldERyYWdEaXN0YW5jZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXR0cnMuZHJhZ0Rpc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dHJzLmRyYWdEaXN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldERyYWdEaXN0YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEtvbnZhLmRyYWdEaXN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfb2ZmKHR5cGUsIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBldnRMaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzW3R5cGVdLCBpLCBldnROYW1lLCBoYW5kbGVyO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZ0TGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBldnROYW1lID0gZXZ0TGlzdGVuZXJzW2ldLm5hbWU7XG4gICAgICAgICAgICBoYW5kbGVyID0gZXZ0TGlzdGVuZXJzW2ldLmhhbmRsZXI7XG4gICAgICAgICAgICBpZiAoKGV2dE5hbWUgIT09ICdrb252YScgfHwgbmFtZSA9PT0gJ2tvbnZhJykgJiZcbiAgICAgICAgICAgICAgICAoIW5hbWUgfHwgZXZ0TmFtZSA9PT0gbmFtZSkgJiZcbiAgICAgICAgICAgICAgICAoIWNhbGxiYWNrIHx8IGNhbGxiYWNrID09PSBoYW5kbGVyKSkge1xuICAgICAgICAgICAgICAgIGV2dExpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGV2dExpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZXZlbnRMaXN0ZW5lcnNbdHlwZV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ZpcmVDaGFuZ2VFdmVudChhdHRyLCBvbGRWYWwsIG5ld1ZhbCkge1xuICAgICAgICB0aGlzLl9maXJlKGF0dHIgKyBDSEFOR0UsIHtcbiAgICAgICAgICAgIG9sZFZhbDogb2xkVmFsLFxuICAgICAgICAgICAgbmV3VmFsOiBuZXdWYWwsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhZGROYW1lKG5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc05hbWUobmFtZSkpIHtcbiAgICAgICAgICAgIHZhciBvbGROYW1lID0gdGhpcy5uYW1lKCk7XG4gICAgICAgICAgICB2YXIgbmV3TmFtZSA9IG9sZE5hbWUgPyBvbGROYW1lICsgJyAnICsgbmFtZSA6IG5hbWU7XG4gICAgICAgICAgICB0aGlzLm5hbWUobmV3TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGhhc05hbWUobmFtZSkge1xuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmdWxsTmFtZSA9IHRoaXMubmFtZSgpO1xuICAgICAgICBpZiAoIWZ1bGxOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWVzID0gKGZ1bGxOYW1lIHx8ICcnKS5zcGxpdCgvXFxzL2cpO1xuICAgICAgICByZXR1cm4gbmFtZXMuaW5kZXhPZihuYW1lKSAhPT0gLTE7XG4gICAgfVxuICAgIHJlbW92ZU5hbWUobmFtZSkge1xuICAgICAgICB2YXIgbmFtZXMgPSAodGhpcy5uYW1lKCkgfHwgJycpLnNwbGl0KC9cXHMvZyk7XG4gICAgICAgIHZhciBpbmRleCA9IG5hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIG5hbWVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLm5hbWUobmFtZXMuam9pbignICcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0QXR0cihhdHRyLCB2YWwpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSB0aGlzW1NFVCArIFV0aWwuX2NhcGl0YWxpemUoYXR0cildO1xuICAgICAgICBpZiAoVXRpbC5faXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICAgICAgZnVuYy5jYWxsKHRoaXMsIHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRBdHRyKGF0dHIsIHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIF9yZXF1ZXN0RHJhdygpIHtcbiAgICAgICAgaWYgKEtvbnZhLmF1dG9EcmF3RW5hYmxlZCkge1xuICAgICAgICAgICAgY29uc3QgZHJhd05vZGUgPSB0aGlzLmdldExheWVyKCkgfHwgdGhpcy5nZXRTdGFnZSgpO1xuICAgICAgICAgICAgZHJhd05vZGUgPT09IG51bGwgfHwgZHJhd05vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRyYXdOb2RlLmJhdGNoRHJhdygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9zZXRBdHRyKGtleSwgdmFsKSB7XG4gICAgICAgIHZhciBvbGRWYWwgPSB0aGlzLmF0dHJzW2tleV07XG4gICAgICAgIGlmIChvbGRWYWwgPT09IHZhbCAmJiAhVXRpbC5pc09iamVjdCh2YWwpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkIHx8IHZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYXR0cnNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXR0cnNba2V5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc2hvdWxkRmlyZUNoYW5nZUV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5fZmlyZUNoYW5nZUV2ZW50KGtleSwgb2xkVmFsLCB2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlcXVlc3REcmF3KCk7XG4gICAgfVxuICAgIF9zZXRDb21wb25lbnRBdHRyKGtleSwgY29tcG9uZW50LCB2YWwpIHtcbiAgICAgICAgdmFyIG9sZFZhbDtcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvbGRWYWwgPSB0aGlzLmF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAoIW9sZFZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0cnNba2V5XSA9IHRoaXMuZ2V0QXR0cihrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hdHRyc1trZXldW2NvbXBvbmVudF0gPSB2YWw7XG4gICAgICAgICAgICB0aGlzLl9maXJlQ2hhbmdlRXZlbnQoa2V5LCBvbGRWYWwsIHZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ZpcmVBbmRCdWJibGUoZXZlbnRUeXBlLCBldnQsIGNvbXBhcmVTaGFwZSkge1xuICAgICAgICBpZiAoZXZ0ICYmIHRoaXMubm9kZVR5cGUgPT09IFNIQVBFKSB7XG4gICAgICAgICAgICBldnQudGFyZ2V0ID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hvdWxkU3RvcCA9IChldmVudFR5cGUgPT09IE1PVVNFRU5URVIgfHwgZXZlbnRUeXBlID09PSBNT1VTRUxFQVZFKSAmJlxuICAgICAgICAgICAgKChjb21wYXJlU2hhcGUgJiZcbiAgICAgICAgICAgICAgICAodGhpcyA9PT0gY29tcGFyZVNoYXBlIHx8XG4gICAgICAgICAgICAgICAgICAgICh0aGlzLmlzQW5jZXN0b3JPZiAmJiB0aGlzLmlzQW5jZXN0b3JPZihjb21wYXJlU2hhcGUpKSkpIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMubm9kZVR5cGUgPT09ICdTdGFnZScgJiYgIWNvbXBhcmVTaGFwZSkpO1xuICAgICAgICBpZiAoIXNob3VsZFN0b3ApIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmUoZXZlbnRUeXBlLCBldnQpO1xuICAgICAgICAgICAgdmFyIHN0b3BCdWJibGUgPSAoZXZlbnRUeXBlID09PSBNT1VTRUVOVEVSIHx8IGV2ZW50VHlwZSA9PT0gTU9VU0VMRUFWRSkgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlU2hhcGUgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlU2hhcGUuaXNBbmNlc3Rvck9mICYmXG4gICAgICAgICAgICAgICAgY29tcGFyZVNoYXBlLmlzQW5jZXN0b3JPZih0aGlzKSAmJlxuICAgICAgICAgICAgICAgICFjb21wYXJlU2hhcGUuaXNBbmNlc3Rvck9mKHRoaXMucGFyZW50KTtcbiAgICAgICAgICAgIGlmICgoKGV2dCAmJiAhZXZ0LmNhbmNlbEJ1YmJsZSkgfHwgIWV2dCkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCAmJlxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmlzTGlzdGVuaW5nKCkgJiZcbiAgICAgICAgICAgICAgICAhc3RvcEJ1YmJsZSkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlU2hhcGUgJiYgY29tcGFyZVNoYXBlLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maXJlQW5kQnViYmxlLmNhbGwodGhpcy5wYXJlbnQsIGV2ZW50VHlwZSwgZXZ0LCBjb21wYXJlU2hhcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlyZUFuZEJ1YmJsZS5jYWxsKHRoaXMucGFyZW50LCBldmVudFR5cGUsIGV2dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9nZXRQcm90b0xpc3RlbmVycyhldmVudFR5cGUpIHtcbiAgICAgICAgbGV0IGxpc3RlbmVycyA9IHRoaXMuX2NhY2hlLmdldChBTExfTElTVEVORVJTKTtcbiAgICAgICAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGxpc3RlbmVycyA9IHt9O1xuICAgICAgICAgICAgbGV0IG9iaiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKTtcbiAgICAgICAgICAgIHdoaWxlIChvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9iai5ldmVudExpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGV2ZW50IGluIG9iai5ldmVudExpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdFdmVudHMgPSBvYmouZXZlbnRMaXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRFdmVudHMgPSBsaXN0ZW5lcnNbZXZlbnRdIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbZXZlbnRdID0gbmV3RXZlbnRzLmNvbmNhdChvbGRFdmVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmogPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NhY2hlLnNldChBTExfTElTVEVORVJTLCBsaXN0ZW5lcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgICB9XG4gICAgX2ZpcmUoZXZlbnRUeXBlLCBldnQpIHtcbiAgICAgICAgZXZ0ID0gZXZ0IHx8IHt9O1xuICAgICAgICBldnQuY3VycmVudFRhcmdldCA9IHRoaXM7XG4gICAgICAgIGV2dC50eXBlID0gZXZlbnRUeXBlO1xuICAgICAgICBjb25zdCB0b3BMaXN0ZW5lcnMgPSB0aGlzLl9nZXRQcm90b0xpc3RlbmVycyhldmVudFR5cGUpO1xuICAgICAgICBpZiAodG9wTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvcExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRvcExpc3RlbmVyc1tpXS5oYW5kbGVyLmNhbGwodGhpcywgZXZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWxmTGlzdGVuZXJzID0gdGhpcy5ldmVudExpc3RlbmVyc1tldmVudFR5cGVdO1xuICAgICAgICBpZiAoc2VsZkxpc3RlbmVycykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2VsZkxpc3RlbmVyc1tpXS5oYW5kbGVyLmNhbGwodGhpcywgZXZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkcmF3KCkge1xuICAgICAgICB0aGlzLmRyYXdTY2VuZSgpO1xuICAgICAgICB0aGlzLmRyYXdIaXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIF9jcmVhdGVEcmFnRWxlbWVudChldnQpIHtcbiAgICAgICAgdmFyIHBvaW50ZXJJZCA9IGV2dCA/IGV2dC5wb2ludGVySWQgOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKTtcbiAgICAgICAgdmFyIGFwID0gdGhpcy5nZXRBYnNvbHV0ZVBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBwb3MgPSBzdGFnZS5fZ2V0UG9pbnRlckJ5SWQocG9pbnRlcklkKSB8fFxuICAgICAgICAgICAgc3RhZ2UuX2NoYW5nZWRQb2ludGVyUG9zaXRpb25zWzBdIHx8XG4gICAgICAgICAgICBhcDtcbiAgICAgICAgREQuX2RyYWdFbGVtZW50cy5zZXQodGhpcy5faWQsIHtcbiAgICAgICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgICAgICBzdGFydFBvaW50ZXJQb3M6IHBvcyxcbiAgICAgICAgICAgIG9mZnNldDoge1xuICAgICAgICAgICAgICAgIHg6IHBvcy54IC0gYXAueCxcbiAgICAgICAgICAgICAgICB5OiBwb3MueSAtIGFwLnksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHJhZ1N0YXR1czogJ3JlYWR5JyxcbiAgICAgICAgICAgIHBvaW50ZXJJZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXJ0RHJhZyhldnQsIGJ1YmJsZUV2ZW50ID0gdHJ1ZSkge1xuICAgICAgICBpZiAoIURELl9kcmFnRWxlbWVudHMuaGFzKHRoaXMuX2lkKSkge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlRHJhZ0VsZW1lbnQoZXZ0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGVtID0gREQuX2RyYWdFbGVtZW50cy5nZXQodGhpcy5faWQpO1xuICAgICAgICBlbGVtLmRyYWdTdGF0dXMgPSAnZHJhZ2dpbmcnO1xuICAgICAgICB0aGlzLmZpcmUoJ2RyYWdzdGFydCcsIHtcbiAgICAgICAgICAgIHR5cGU6ICdkcmFnc3RhcnQnLFxuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgZXZ0OiBldnQgJiYgZXZ0LmV2dCxcbiAgICAgICAgfSwgYnViYmxlRXZlbnQpO1xuICAgIH1cbiAgICBfc2V0RHJhZ1Bvc2l0aW9uKGV2dCwgZWxlbSkge1xuICAgICAgICBjb25zdCBwb3MgPSB0aGlzLmdldFN0YWdlKCkuX2dldFBvaW50ZXJCeUlkKGVsZW0ucG9pbnRlcklkKTtcbiAgICAgICAgaWYgKCFwb3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3Tm9kZVBvcyA9IHtcbiAgICAgICAgICAgIHg6IHBvcy54IC0gZWxlbS5vZmZzZXQueCxcbiAgICAgICAgICAgIHk6IHBvcy55IC0gZWxlbS5vZmZzZXQueSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRiZiA9IHRoaXMuZHJhZ0JvdW5kRnVuYygpO1xuICAgICAgICBpZiAoZGJmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kZWQgPSBkYmYuY2FsbCh0aGlzLCBuZXdOb2RlUG9zLCBldnQpO1xuICAgICAgICAgICAgaWYgKCFib3VuZGVkKSB7XG4gICAgICAgICAgICAgICAgVXRpbC53YXJuKCdkcmFnQm91bmRGdW5jIGRpZCBub3QgcmV0dXJuIGFueSB2YWx1ZS4gVGhhdCBpcyB1bmV4cGVjdGVkIGJlaGF2aW9yLiBZb3UgbXVzdCByZXR1cm4gbmV3IGFic29sdXRlIHBvc2l0aW9uIGZyb20gZHJhZ0JvdW5kRnVuYy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld05vZGVQb3MgPSBib3VuZGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fbGFzdFBvcyB8fFxuICAgICAgICAgICAgdGhpcy5fbGFzdFBvcy54ICE9PSBuZXdOb2RlUG9zLnggfHxcbiAgICAgICAgICAgIHRoaXMuX2xhc3RQb3MueSAhPT0gbmV3Tm9kZVBvcy55KSB7XG4gICAgICAgICAgICB0aGlzLnNldEFic29sdXRlUG9zaXRpb24obmV3Tm9kZVBvcyk7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0RHJhdygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xhc3RQb3MgPSBuZXdOb2RlUG9zO1xuICAgIH1cbiAgICBzdG9wRHJhZyhldnQpIHtcbiAgICAgICAgY29uc3QgZWxlbSA9IERELl9kcmFnRWxlbWVudHMuZ2V0KHRoaXMuX2lkKTtcbiAgICAgICAgaWYgKGVsZW0pIHtcbiAgICAgICAgICAgIGVsZW0uZHJhZ1N0YXR1cyA9ICdzdG9wcGVkJztcbiAgICAgICAgfVxuICAgICAgICBERC5fZW5kRHJhZ0JlZm9yZShldnQpO1xuICAgICAgICBERC5fZW5kRHJhZ0FmdGVyKGV2dCk7XG4gICAgfVxuICAgIHNldERyYWdnYWJsZShkcmFnZ2FibGUpIHtcbiAgICAgICAgdGhpcy5fc2V0QXR0cignZHJhZ2dhYmxlJywgZHJhZ2dhYmxlKTtcbiAgICAgICAgdGhpcy5fZHJhZ0NoYW5nZSgpO1xuICAgIH1cbiAgICBpc0RyYWdnaW5nKCkge1xuICAgICAgICBjb25zdCBlbGVtID0gREQuX2RyYWdFbGVtZW50cy5nZXQodGhpcy5faWQpO1xuICAgICAgICByZXR1cm4gZWxlbSA/IGVsZW0uZHJhZ1N0YXR1cyA9PT0gJ2RyYWdnaW5nJyA6IGZhbHNlO1xuICAgIH1cbiAgICBfbGlzdGVuRHJhZygpIHtcbiAgICAgICAgdGhpcy5fZHJhZ0NsZWFudXAoKTtcbiAgICAgICAgdGhpcy5vbignbW91c2Vkb3duLmtvbnZhIHRvdWNoc3RhcnQua29udmEnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICB2YXIgc2hvdWxkQ2hlY2tCdXR0b24gPSBldnQuZXZ0WydidXR0b24nXSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdmFyIGNhbkRyYWcgPSAhc2hvdWxkQ2hlY2tCdXR0b24gfHwgS29udmEuZHJhZ0J1dHRvbnMuaW5kZXhPZihldnQuZXZ0WydidXR0b24nXSkgPj0gMDtcbiAgICAgICAgICAgIGlmICghY2FuRHJhZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoYXNEcmFnZ2luZ0NoaWxkID0gZmFsc2U7XG4gICAgICAgICAgICBERC5fZHJhZ0VsZW1lbnRzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0FuY2VzdG9yT2YoZWxlbS5ub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNEcmFnZ2luZ0NoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghaGFzRHJhZ2dpbmdDaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZURyYWdFbGVtZW50KGV2dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZHJhZ0NoYW5nZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXR0cnMuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5EcmFnKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kcmFnQ2xlYW51cCgpO1xuICAgICAgICAgICAgdmFyIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpO1xuICAgICAgICAgICAgaWYgKCFzdGFnZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRyYWdFbGVtZW50ID0gREQuX2RyYWdFbGVtZW50cy5nZXQodGhpcy5faWQpO1xuICAgICAgICAgICAgY29uc3QgaXNEcmFnZ2luZyA9IGRyYWdFbGVtZW50ICYmIGRyYWdFbGVtZW50LmRyYWdTdGF0dXMgPT09ICdkcmFnZ2luZyc7XG4gICAgICAgICAgICBjb25zdCBpc1JlYWR5ID0gZHJhZ0VsZW1lbnQgJiYgZHJhZ0VsZW1lbnQuZHJhZ1N0YXR1cyA9PT0gJ3JlYWR5JztcbiAgICAgICAgICAgIGlmIChpc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wRHJhZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWFkeSkge1xuICAgICAgICAgICAgICAgIERELl9kcmFnRWxlbWVudHMuZGVsZXRlKHRoaXMuX2lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfZHJhZ0NsZWFudXAoKSB7XG4gICAgICAgIHRoaXMub2ZmKCdtb3VzZWRvd24ua29udmEnKTtcbiAgICAgICAgdGhpcy5vZmYoJ3RvdWNoc3RhcnQua29udmEnKTtcbiAgICB9XG4gICAgaXNDbGllbnRSZWN0T25TY3JlZW4obWFyZ2luID0geyB4OiAwLCB5OiAwIH0pIHtcbiAgICAgICAgY29uc3Qgc3RhZ2UgPSB0aGlzLmdldFN0YWdlKCk7XG4gICAgICAgIGlmICghc3RhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY3JlZW5SZWN0ID0ge1xuICAgICAgICAgICAgeDogLW1hcmdpbi54LFxuICAgICAgICAgICAgeTogLW1hcmdpbi55LFxuICAgICAgICAgICAgd2lkdGg6IHN0YWdlLndpZHRoKCkgKyAyICogbWFyZ2luLngsXG4gICAgICAgICAgICBoZWlnaHQ6IHN0YWdlLmhlaWdodCgpICsgMiAqIG1hcmdpbi55LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVXRpbC5oYXZlSW50ZXJzZWN0aW9uKHNjcmVlblJlY3QsIHRoaXMuZ2V0Q2xpZW50UmVjdCgpKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShkYXRhLCBjb250YWluZXIpIHtcbiAgICAgICAgaWYgKFV0aWwuX2lzU3RyaW5nKGRhdGEpKSB7XG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlTm9kZShkYXRhLCBjb250YWluZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgX2NyZWF0ZU5vZGUob2JqLCBjb250YWluZXIpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IE5vZGUucHJvdG90eXBlLmdldENsYXNzTmFtZS5jYWxsKG9iaiksIGNoaWxkcmVuID0gb2JqLmNoaWxkcmVuLCBubywgbGVuLCBuO1xuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICBvYmouYXR0cnMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghS29udmFbY2xhc3NOYW1lXSkge1xuICAgICAgICAgICAgVXRpbC53YXJuKCdDYW4gbm90IGZpbmQgYSBub2RlIHdpdGggY2xhc3MgbmFtZSBcIicgK1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSArXG4gICAgICAgICAgICAgICAgJ1wiLiBGYWxsYmFjayB0byBcIlNoYXBlXCIuJyk7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSAnU2hhcGUnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IENsYXNzID0gS29udmFbY2xhc3NOYW1lXTtcbiAgICAgICAgbm8gPSBuZXcgQ2xhc3Mob2JqLmF0dHJzKTtcbiAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICBuby5hZGQoTm9kZS5fY3JlYXRlTm9kZShjaGlsZHJlbltuXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBubztcbiAgICB9XG59XG5Ob2RlLnByb3RvdHlwZS5ub2RlVHlwZSA9ICdOb2RlJztcbk5vZGUucHJvdG90eXBlLl9hdHRyc0FmZmVjdGluZ1NpemUgPSBbXTtcbk5vZGUucHJvdG90eXBlLmV2ZW50TGlzdGVuZXJzID0ge307XG5Ob2RlLnByb3RvdHlwZS5vbi5jYWxsKE5vZGUucHJvdG90eXBlLCBUUkFOU0ZPUk1fQ0hBTkdFX1NUUiwgZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9iYXRjaGluZ1RyYW5zZm9ybUNoYW5nZSkge1xuICAgICAgICB0aGlzLl9uZWVkQ2xlYXJUcmFuc2Zvcm1DYWNoZSA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY2xlYXJDYWNoZShUUkFOU0ZPUk0pO1xuICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShBQlNPTFVURV9UUkFOU0ZPUk0pO1xufSk7XG5Ob2RlLnByb3RvdHlwZS5vbi5jYWxsKE5vZGUucHJvdG90eXBlLCAndmlzaWJsZUNoYW5nZS5rb252YScsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoVklTSUJMRSk7XG59KTtcbk5vZGUucHJvdG90eXBlLm9uLmNhbGwoTm9kZS5wcm90b3R5cGUsICdsaXN0ZW5pbmdDaGFuZ2Uua29udmEnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKExJU1RFTklORyk7XG59KTtcbk5vZGUucHJvdG90eXBlLm9uLmNhbGwoTm9kZS5wcm90b3R5cGUsICdvcGFjaXR5Q2hhbmdlLmtvbnZhJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShBQlNPTFVURV9PUEFDSVRZKTtcbn0pO1xuY29uc3QgYWRkR2V0dGVyU2V0dGVyID0gRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXI7XG5hZGRHZXR0ZXJTZXR0ZXIoTm9kZSwgJ3pJbmRleCcpO1xuYWRkR2V0dGVyU2V0dGVyKE5vZGUsICdhYnNvbHV0ZVBvc2l0aW9uJyk7XG5hZGRHZXR0ZXJTZXR0ZXIoTm9kZSwgJ3Bvc2l0aW9uJyk7XG5hZGRHZXR0ZXJTZXR0ZXIoTm9kZSwgJ3gnLCAwLCBnZXROdW1iZXJWYWxpZGF0b3IoKSk7XG5hZGRHZXR0ZXJTZXR0ZXIoTm9kZSwgJ3knLCAwLCBnZXROdW1iZXJWYWxpZGF0b3IoKSk7XG5hZGRHZXR0ZXJTZXR0ZXIoTm9kZSwgJ2dsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbicsICdzb3VyY2Utb3ZlcicsIGdldFN0cmluZ1ZhbGlkYXRvcigpKTtcbmFkZEdldHRlclNldHRlcihOb2RlLCAnb3BhY2l0eScsIDEsIGdldE51bWJlclZhbGlkYXRvcigpKTtcbmFkZEdldHRlclNldHRlcihOb2RlLCAnbmFtZScsICcnLCBnZXRTdHJpbmdWYWxpZGF0b3IoKSk7XG5hZGRHZXR0ZXJTZXR0ZXIoTm9kZSwgJ2lkJywgJycsIGdldFN0cmluZ1ZhbGlkYXRvcigpKTtcbmFkZEdldHRlclNldHRlcihOb2RlLCAncm90YXRpb24nLCAwLCBnZXROdW1iZXJWYWxpZGF0b3IoKSk7XG5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoTm9kZSwgJ3NjYWxlJywgWyd4JywgJ3knXSk7XG5hZGRHZXR0ZXJTZXR0ZXIoTm9kZSwgJ3NjYWxlWCcsIDEsIGdldE51bWJlclZhbGlkYXRvcigpKTtcbmFkZEdldHRlclNldHRlcihOb2RlLCAnc2NhbGVZJywgMSwgZ2V0TnVtYmVyVmFsaWRhdG9yKCkpO1xuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKE5vZGUsICdza2V3JywgWyd4JywgJ3knXSk7XG5hZGRHZXR0ZXJTZXR0ZXIoTm9kZSwgJ3NrZXdYJywgMCwgZ2V0TnVtYmVyVmFsaWRhdG9yKCkpO1xuYWRkR2V0dGVyU2V0dGVyKE5vZGUsICdza2V3WScsIDAsIGdldE51bWJlclZhbGlkYXRvcigpKTtcbkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihOb2RlLCAnb2Zmc2V0JywgWyd4JywgJ3knXSk7XG5hZGRHZXR0ZXJTZXR0ZXIoTm9kZSwgJ29mZnNldFgnLCAwLCBnZXROdW1iZXJWYWxpZGF0b3IoKSk7XG5hZGRHZXR0ZXJTZXR0ZXIoTm9kZSwgJ29mZnNldFknLCAwLCBnZXROdW1iZXJWYWxpZGF0b3IoKSk7XG5hZGRHZXR0ZXJTZXR0ZXIoTm9kZSwgJ2RyYWdEaXN0YW5jZScsIG51bGwsIGdldE51bWJlclZhbGlkYXRvcigpKTtcbmFkZEdldHRlclNldHRlcihOb2RlLCAnd2lkdGgnLCAwLCBnZXROdW1iZXJWYWxpZGF0b3IoKSk7XG5hZGRHZXR0ZXJTZXR0ZXIoTm9kZSwgJ2hlaWdodCcsIDAsIGdldE51bWJlclZhbGlkYXRvcigpKTtcbmFkZEdldHRlclNldHRlcihOb2RlLCAnbGlzdGVuaW5nJywgdHJ1ZSwgZ2V0Qm9vbGVhblZhbGlkYXRvcigpKTtcbmFkZEdldHRlclNldHRlcihOb2RlLCAncHJldmVudERlZmF1bHQnLCB0cnVlLCBnZXRCb29sZWFuVmFsaWRhdG9yKCkpO1xuYWRkR2V0dGVyU2V0dGVyKE5vZGUsICdmaWx0ZXJzJywgbnVsbCwgZnVuY3Rpb24gKHZhbCkge1xuICAgIHRoaXMuX2ZpbHRlclVwVG9EYXRlID0gZmFsc2U7XG4gICAgcmV0dXJuIHZhbDtcbn0pO1xuYWRkR2V0dGVyU2V0dGVyKE5vZGUsICd2aXNpYmxlJywgdHJ1ZSwgZ2V0Qm9vbGVhblZhbGlkYXRvcigpKTtcbmFkZEdldHRlclNldHRlcihOb2RlLCAndHJhbnNmb3Jtc0VuYWJsZWQnLCAnYWxsJywgZ2V0U3RyaW5nVmFsaWRhdG9yKCkpO1xuYWRkR2V0dGVyU2V0dGVyKE5vZGUsICdzaXplJyk7XG5hZGRHZXR0ZXJTZXR0ZXIoTm9kZSwgJ2RyYWdCb3VuZEZ1bmMnKTtcbmFkZEdldHRlclNldHRlcihOb2RlLCAnZHJhZ2dhYmxlJywgZmFsc2UsIGdldEJvb2xlYW5WYWxpZGF0b3IoKSk7XG5GYWN0b3J5LmJhY2tDb21wYXQoTm9kZSwge1xuICAgIHJvdGF0ZURlZzogJ3JvdGF0ZScsXG4gICAgc2V0Um90YXRpb25EZWc6ICdzZXRSb3RhdGlvbicsXG4gICAgZ2V0Um90YXRpb25EZWc6ICdnZXRSb3RhdGlvbicsXG59KTtcbiIsImltcG9ydCB7IEZhY3RvcnkgfSBmcm9tICcuL0ZhY3RvcnkuanMnO1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4vTm9kZS5qcyc7XG5pbXBvcnQgeyBnZXROdW1iZXJWYWxpZGF0b3IgfSBmcm9tICcuL1ZhbGlkYXRvcnMuanMnO1xuZXhwb3J0IGNsYXNzIENvbnRhaW5lciBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgfVxuICAgIGdldENoaWxkcmVuKGZpbHRlckZ1bmMpIHtcbiAgICAgICAgaWYgKCFmaWx0ZXJGdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbiB8fCBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gfHwgW107XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoZmlsdGVyRnVuYyhjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIGhhc0NoaWxkcmVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDaGlsZHJlbigpLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIHJlbW92ZUNoaWxkcmVuKCkge1xuICAgICAgICB0aGlzLmdldENoaWxkcmVuKCkuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICBjaGlsZC5pbmRleCA9IDA7XG4gICAgICAgICAgICBjaGlsZC5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdERyYXcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlc3Ryb3lDaGlsZHJlbigpIHtcbiAgICAgICAgdGhpcy5nZXRDaGlsZHJlbigpLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgY2hpbGQuaW5kZXggPSAwO1xuICAgICAgICAgICAgY2hpbGQuZGVzdHJveSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0RHJhdygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkKC4uLmNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChhcmd1bWVudHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5bMF07XG4gICAgICAgIGlmIChjaGlsZC5nZXRQYXJlbnQoKSkge1xuICAgICAgICAgICAgY2hpbGQubW92ZVRvKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmFsaWRhdGVBZGQoY2hpbGQpO1xuICAgICAgICBjaGlsZC5pbmRleCA9IHRoaXMuZ2V0Q2hpbGRyZW4oKS5sZW5ndGg7XG4gICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgICAgIGNoaWxkLl9jbGVhckNhY2hlcygpO1xuICAgICAgICB0aGlzLmdldENoaWxkcmVuKCkucHVzaChjaGlsZCk7XG4gICAgICAgIHRoaXMuX2ZpcmUoJ2FkZCcsIHtcbiAgICAgICAgICAgIGNoaWxkOiBjaGlsZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3REcmF3KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5oYXNDaGlsZHJlbigpKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lDaGlsZHJlbigpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZpbmQoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dlbmVyYWxGaW5kKHNlbGVjdG9yLCBmYWxzZSk7XG4gICAgfVxuICAgIGZpbmRPbmUoc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2dlbmVyYWxGaW5kKHNlbGVjdG9yLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPiAwID8gcmVzdWx0WzBdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBfZ2VuZXJhbEZpbmQoc2VsZWN0b3IsIGZpbmRPbmUpIHtcbiAgICAgICAgdmFyIHJldEFyciA9IFtdO1xuICAgICAgICB0aGlzLl9kZXNjZW5kYW50cygobm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBub2RlLl9pc01hdGNoKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAgICAgICAgIHJldEFyci5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbGlkICYmIGZpbmRPbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgfVxuICAgIF9kZXNjZW5kYW50cyhmbikge1xuICAgICAgICBsZXQgc2hvdWxkU3RvcCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgICAgICAgc2hvdWxkU3RvcCA9IGZuKGNoaWxkKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRTdG9wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNoaWxkLmhhc0NoaWxkcmVuKCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNob3VsZFN0b3AgPSBjaGlsZC5fZGVzY2VuZGFudHMoZm4pO1xuICAgICAgICAgICAgaWYgKHNob3VsZFN0b3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRvT2JqZWN0KCkge1xuICAgICAgICB2YXIgb2JqID0gTm9kZS5wcm90b3R5cGUudG9PYmplY3QuY2FsbCh0aGlzKTtcbiAgICAgICAgb2JqLmNoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMuZ2V0Q2hpbGRyZW4oKS5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgb2JqLmNoaWxkcmVuLnB1c2goY2hpbGQudG9PYmplY3QoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBpc0FuY2VzdG9yT2Yobm9kZSkge1xuICAgICAgICB2YXIgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudC5faWQgPT09IHRoaXMuX2lkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjbG9uZShvYmopIHtcbiAgICAgICAgdmFyIG5vZGUgPSBOb2RlLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsIG9iaik7XG4gICAgICAgIHRoaXMuZ2V0Q2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uIChubykge1xuICAgICAgICAgICAgbm9kZS5hZGQobm8uY2xvbmUoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZ2V0QWxsSW50ZXJzZWN0aW9ucyhwb3MpIHtcbiAgICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgICB0aGlzLmZpbmQoJ1NoYXBlJykuZm9yRWFjaChmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgICAgIGlmIChzaGFwZS5pc1Zpc2libGUoKSAmJiBzaGFwZS5pbnRlcnNlY3RzKHBvcykpIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChzaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbiAgICBfY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKGF0dHIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzdXBlci5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKGF0dHIpO1xuICAgICAgICBpZiAodGhpcy5pc0NhY2hlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5jaGlsZHJlbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShhdHRyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9zZXRDaGlsZHJlbkluZGljZXMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5jaGlsZHJlbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBuKSB7XG4gICAgICAgICAgICBjaGlsZC5pbmRleCA9IG47XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0RHJhdygpO1xuICAgIH1cbiAgICBkcmF3U2NlbmUoY2FuLCB0b3ApIHtcbiAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpLCBjYW52YXMgPSBjYW4gfHwgKGxheWVyICYmIGxheWVyLmdldENhbnZhcygpKSwgY29udGV4dCA9IGNhbnZhcyAmJiBjYW52YXMuZ2V0Q29udGV4dCgpLCBjYWNoZWRDYW52YXMgPSB0aGlzLl9nZXRDYW52YXNDYWNoZSgpLCBjYWNoZWRTY2VuZUNhbnZhcyA9IGNhY2hlZENhbnZhcyAmJiBjYWNoZWRDYW52YXMuc2NlbmU7XG4gICAgICAgIHZhciBjYWNoaW5nID0gY2FudmFzICYmIGNhbnZhcy5pc0NhY2hlO1xuICAgICAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKCkgJiYgIWNhY2hpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWNoZWRTY2VuZUNhbnZhcykge1xuICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICB2YXIgbSA9IHRoaXMuZ2V0QWJzb2x1dGVUcmFuc2Zvcm0odG9wKS5nZXRNYXRyaXgoKTtcbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNmb3JtKG1bMF0sIG1bMV0sIG1bMl0sIG1bM10sIG1bNF0sIG1bNV0pO1xuICAgICAgICAgICAgdGhpcy5fZHJhd0NhY2hlZFNjZW5lQ2FudmFzKGNvbnRleHQpO1xuICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kcmF3Q2hpbGRyZW4oJ2RyYXdTY2VuZScsIGNhbnZhcywgdG9wKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZHJhd0hpdChjYW4sIHRvcCkge1xuICAgICAgICBpZiAoIXRoaXMuc2hvdWxkRHJhd0hpdCh0b3ApKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCksIGNhbnZhcyA9IGNhbiB8fCAobGF5ZXIgJiYgbGF5ZXIuaGl0Q2FudmFzKSwgY29udGV4dCA9IGNhbnZhcyAmJiBjYW52YXMuZ2V0Q29udGV4dCgpLCBjYWNoZWRDYW52YXMgPSB0aGlzLl9nZXRDYW52YXNDYWNoZSgpLCBjYWNoZWRIaXRDYW52YXMgPSBjYWNoZWRDYW52YXMgJiYgY2FjaGVkQ2FudmFzLmhpdDtcbiAgICAgICAgaWYgKGNhY2hlZEhpdENhbnZhcykge1xuICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICB2YXIgbSA9IHRoaXMuZ2V0QWJzb2x1dGVUcmFuc2Zvcm0odG9wKS5nZXRNYXRyaXgoKTtcbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNmb3JtKG1bMF0sIG1bMV0sIG1bMl0sIG1bM10sIG1bNF0sIG1bNV0pO1xuICAgICAgICAgICAgdGhpcy5fZHJhd0NhY2hlZEhpdENhbnZhcyhjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZHJhd0NoaWxkcmVuKCdkcmF3SGl0JywgY2FudmFzLCB0b3ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBfZHJhd0NoaWxkcmVuKGRyYXdNZXRob2QsIGNhbnZhcywgdG9wKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMgJiYgY2FudmFzLmdldENvbnRleHQoKSwgY2xpcFdpZHRoID0gdGhpcy5jbGlwV2lkdGgoKSwgY2xpcEhlaWdodCA9IHRoaXMuY2xpcEhlaWdodCgpLCBjbGlwRnVuYyA9IHRoaXMuY2xpcEZ1bmMoKSwgaGFzQ2xpcCA9IChjbGlwV2lkdGggJiYgY2xpcEhlaWdodCkgfHwgY2xpcEZ1bmM7XG4gICAgICAgIGNvbnN0IHNlbGZDYWNoZSA9IHRvcCA9PT0gdGhpcztcbiAgICAgICAgaWYgKGhhc0NsaXApIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMuZ2V0QWJzb2x1dGVUcmFuc2Zvcm0odG9wKTtcbiAgICAgICAgICAgIHZhciBtID0gdHJhbnNmb3JtLmdldE1hdHJpeCgpO1xuICAgICAgICAgICAgY29udGV4dC50cmFuc2Zvcm0obVswXSwgbVsxXSwgbVsyXSwgbVszXSwgbVs0XSwgbVs1XSk7XG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgaWYgKGNsaXBGdW5jKSB7XG4gICAgICAgICAgICAgICAgY2xpcEZ1bmMuY2FsbCh0aGlzLCBjb250ZXh0LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjbGlwWCA9IHRoaXMuY2xpcFgoKTtcbiAgICAgICAgICAgICAgICB2YXIgY2xpcFkgPSB0aGlzLmNsaXBZKCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5yZWN0KGNsaXBYLCBjbGlwWSwgY2xpcFdpZHRoLCBjbGlwSGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQuY2xpcCgpO1xuICAgICAgICAgICAgbSA9IHRyYW5zZm9ybS5jb3B5KCkuaW52ZXJ0KCkuZ2V0TWF0cml4KCk7XG4gICAgICAgICAgICBjb250ZXh0LnRyYW5zZm9ybShtWzBdLCBtWzFdLCBtWzJdLCBtWzNdLCBtWzRdLCBtWzVdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGFzQ29tcG9zaXRpb24gPSAhc2VsZkNhY2hlICYmXG4gICAgICAgICAgICB0aGlzLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbigpICE9PSAnc291cmNlLW92ZXInICYmXG4gICAgICAgICAgICBkcmF3TWV0aG9kID09PSAnZHJhd1NjZW5lJztcbiAgICAgICAgaWYgKGhhc0NvbXBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgIGNvbnRleHQuX2FwcGx5R2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMuY2hpbGRyZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGRbZHJhd01ldGhvZF0oY2FudmFzLCB0b3ApO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGhhc0NvbXBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzQ2xpcCkge1xuICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q2xpZW50UmVjdChjb25maWcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgICAgIHZhciBza2lwVHJhbnNmb3JtID0gY29uZmlnLnNraXBUcmFuc2Zvcm07XG4gICAgICAgIHZhciByZWxhdGl2ZVRvID0gY29uZmlnLnJlbGF0aXZlVG87XG4gICAgICAgIHZhciBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZO1xuICAgICAgICB2YXIgc2VsZlJlY3QgPSB7XG4gICAgICAgICAgICB4OiBJbmZpbml0eSxcbiAgICAgICAgICAgIHk6IEluZmluaXR5LFxuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIH07XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgKF9hID0gdGhpcy5jaGlsZHJlbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoIWNoaWxkLnZpc2libGUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZWN0ID0gY2hpbGQuZ2V0Q2xpZW50UmVjdCh7XG4gICAgICAgICAgICAgICAgcmVsYXRpdmVUbzogdGhhdCxcbiAgICAgICAgICAgICAgICBza2lwU2hhZG93OiBjb25maWcuc2tpcFNoYWRvdyxcbiAgICAgICAgICAgICAgICBza2lwU3Ryb2tlOiBjb25maWcuc2tpcFN0cm9rZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlY3Qud2lkdGggPT09IDAgJiYgcmVjdC5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWluWCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWluWCA9IHJlY3QueDtcbiAgICAgICAgICAgICAgICBtaW5ZID0gcmVjdC55O1xuICAgICAgICAgICAgICAgIG1heFggPSByZWN0LnggKyByZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgIG1heFkgPSByZWN0LnkgKyByZWN0LmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCByZWN0LngpO1xuICAgICAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCByZWN0LnkpO1xuICAgICAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCByZWN0LnggKyByZWN0LndpZHRoKTtcbiAgICAgICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgcmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNoYXBlcyA9IHRoaXMuZmluZCgnU2hhcGUnKTtcbiAgICAgICAgdmFyIGhhc1Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGFwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHNoYXBlc1tpXTtcbiAgICAgICAgICAgIGlmIChzaGFwZS5faXNWaXNpYmxlKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgaGFzVmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc1Zpc2libGUgJiYgbWluWCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZWxmUmVjdCA9IHtcbiAgICAgICAgICAgICAgICB4OiBtaW5YLFxuICAgICAgICAgICAgICAgIHk6IG1pblksXG4gICAgICAgICAgICAgICAgd2lkdGg6IG1heFggLSBtaW5YLFxuICAgICAgICAgICAgICAgIGhlaWdodDogbWF4WSAtIG1pblksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZlJlY3QgPSB7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFza2lwVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtZWRSZWN0KHNlbGZSZWN0LCByZWxhdGl2ZVRvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZlJlY3Q7XG4gICAgfVxufVxuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKENvbnRhaW5lciwgJ2NsaXAnLCBbXG4gICAgJ3gnLFxuICAgICd5JyxcbiAgICAnd2lkdGgnLFxuICAgICdoZWlnaHQnLFxuXSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihDb250YWluZXIsICdjbGlwWCcsIHVuZGVmaW5lZCwgZ2V0TnVtYmVyVmFsaWRhdG9yKCkpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoQ29udGFpbmVyLCAnY2xpcFknLCB1bmRlZmluZWQsIGdldE51bWJlclZhbGlkYXRvcigpKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKENvbnRhaW5lciwgJ2NsaXBXaWR0aCcsIHVuZGVmaW5lZCwgZ2V0TnVtYmVyVmFsaWRhdG9yKCkpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoQ29udGFpbmVyLCAnY2xpcEhlaWdodCcsIHVuZGVmaW5lZCwgZ2V0TnVtYmVyVmFsaWRhdG9yKCkpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoQ29udGFpbmVyLCAnY2xpcEZ1bmMnKTtcbiIsImltcG9ydCB7IEtvbnZhIH0gZnJvbSAnLi9HbG9iYWwuanMnO1xuY29uc3QgQ2FwdHVyZXMgPSBuZXcgTWFwKCk7XG5jb25zdCBTVVBQT1JUX1BPSU5URVJfRVZFTlRTID0gS29udmEuX2dsb2JhbFsnUG9pbnRlckV2ZW50J10gIT09IHVuZGVmaW5lZDtcbmV4cG9ydCBmdW5jdGlvbiBnZXRDYXB0dXJlZFNoYXBlKHBvaW50ZXJJZCkge1xuICAgIHJldHVybiBDYXB0dXJlcy5nZXQocG9pbnRlcklkKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFdmVudChldnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBldnQsXG4gICAgICAgIHBvaW50ZXJJZDogZXZ0LnBvaW50ZXJJZCxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhhc1BvaW50ZXJDYXB0dXJlKHBvaW50ZXJJZCwgc2hhcGUpIHtcbiAgICByZXR1cm4gQ2FwdHVyZXMuZ2V0KHBvaW50ZXJJZCkgPT09IHNoYXBlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNldFBvaW50ZXJDYXB0dXJlKHBvaW50ZXJJZCwgc2hhcGUpIHtcbiAgICByZWxlYXNlQ2FwdHVyZShwb2ludGVySWQpO1xuICAgIGNvbnN0IHN0YWdlID0gc2hhcGUuZ2V0U3RhZ2UoKTtcbiAgICBpZiAoIXN0YWdlKVxuICAgICAgICByZXR1cm47XG4gICAgQ2FwdHVyZXMuc2V0KHBvaW50ZXJJZCwgc2hhcGUpO1xuICAgIGlmIChTVVBQT1JUX1BPSU5URVJfRVZFTlRTKSB7XG4gICAgICAgIHNoYXBlLl9maXJlKCdnb3Rwb2ludGVyY2FwdHVyZScsIGNyZWF0ZUV2ZW50KG5ldyBQb2ludGVyRXZlbnQoJ2dvdHBvaW50ZXJjYXB0dXJlJykpKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gcmVsZWFzZUNhcHR1cmUocG9pbnRlcklkLCB0YXJnZXQpIHtcbiAgICBjb25zdCBzaGFwZSA9IENhcHR1cmVzLmdldChwb2ludGVySWQpO1xuICAgIGlmICghc2hhcGUpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBzdGFnZSA9IHNoYXBlLmdldFN0YWdlKCk7XG4gICAgaWYgKHN0YWdlICYmIHN0YWdlLmNvbnRlbnQpIHtcbiAgICB9XG4gICAgQ2FwdHVyZXMuZGVsZXRlKHBvaW50ZXJJZCk7XG4gICAgaWYgKFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMpIHtcbiAgICAgICAgc2hhcGUuX2ZpcmUoJ2xvc3Rwb2ludGVyY2FwdHVyZScsIGNyZWF0ZUV2ZW50KG5ldyBQb2ludGVyRXZlbnQoJ2xvc3Rwb2ludGVyY2FwdHVyZScpKSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgVXRpbCB9IGZyb20gJy4vVXRpbC5qcyc7XG5pbXBvcnQgeyBGYWN0b3J5IH0gZnJvbSAnLi9GYWN0b3J5LmpzJztcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gJy4vQ29udGFpbmVyLmpzJztcbmltcG9ydCB7IEtvbnZhIH0gZnJvbSAnLi9HbG9iYWwuanMnO1xuaW1wb3J0IHsgU2NlbmVDYW52YXMsIEhpdENhbnZhcyB9IGZyb20gJy4vQ2FudmFzLmpzJztcbmltcG9ydCB7IEREIH0gZnJvbSAnLi9EcmFnQW5kRHJvcC5qcyc7XG5pbXBvcnQgeyBfcmVnaXN0ZXJOb2RlIH0gZnJvbSAnLi9HbG9iYWwuanMnO1xuaW1wb3J0ICogYXMgUG9pbnRlckV2ZW50cyBmcm9tICcuL1BvaW50ZXJFdmVudHMuanMnO1xudmFyIFNUQUdFID0gJ1N0YWdlJywgU1RSSU5HID0gJ3N0cmluZycsIFBYID0gJ3B4JywgTU9VU0VPVVQgPSAnbW91c2VvdXQnLCBNT1VTRUxFQVZFID0gJ21vdXNlbGVhdmUnLCBNT1VTRU9WRVIgPSAnbW91c2VvdmVyJywgTU9VU0VFTlRFUiA9ICdtb3VzZWVudGVyJywgTU9VU0VNT1ZFID0gJ21vdXNlbW92ZScsIE1PVVNFRE9XTiA9ICdtb3VzZWRvd24nLCBNT1VTRVVQID0gJ21vdXNldXAnLCBQT0lOVEVSTU9WRSA9ICdwb2ludGVybW92ZScsIFBPSU5URVJET1dOID0gJ3BvaW50ZXJkb3duJywgUE9JTlRFUlVQID0gJ3BvaW50ZXJ1cCcsIFBPSU5URVJDQU5DRUwgPSAncG9pbnRlcmNhbmNlbCcsIExPU1RQT0lOVEVSQ0FQVFVSRSA9ICdsb3N0cG9pbnRlcmNhcHR1cmUnLCBQT0lOVEVST1VUID0gJ3BvaW50ZXJvdXQnLCBQT0lOVEVSTEVBVkUgPSAncG9pbnRlcmxlYXZlJywgUE9JTlRFUk9WRVIgPSAncG9pbnRlcm92ZXInLCBQT0lOVEVSRU5URVIgPSAncG9pbnRlcmVudGVyJywgQ09OVEVYVE1FTlUgPSAnY29udGV4dG1lbnUnLCBUT1VDSFNUQVJUID0gJ3RvdWNoc3RhcnQnLCBUT1VDSEVORCA9ICd0b3VjaGVuZCcsIFRPVUNITU9WRSA9ICd0b3VjaG1vdmUnLCBUT1VDSENBTkNFTCA9ICd0b3VjaGNhbmNlbCcsIFdIRUVMID0gJ3doZWVsJywgTUFYX0xBWUVSU19OVU1CRVIgPSA1LCBFVkVOVFMgPSBbXG4gICAgW01PVVNFRU5URVIsICdfcG9pbnRlcmVudGVyJ10sXG4gICAgW01PVVNFRE9XTiwgJ19wb2ludGVyZG93biddLFxuICAgIFtNT1VTRU1PVkUsICdfcG9pbnRlcm1vdmUnXSxcbiAgICBbTU9VU0VVUCwgJ19wb2ludGVydXAnXSxcbiAgICBbTU9VU0VMRUFWRSwgJ19wb2ludGVybGVhdmUnXSxcbiAgICBbVE9VQ0hTVEFSVCwgJ19wb2ludGVyZG93biddLFxuICAgIFtUT1VDSE1PVkUsICdfcG9pbnRlcm1vdmUnXSxcbiAgICBbVE9VQ0hFTkQsICdfcG9pbnRlcnVwJ10sXG4gICAgW1RPVUNIQ0FOQ0VMLCAnX3BvaW50ZXJjYW5jZWwnXSxcbiAgICBbTU9VU0VPVkVSLCAnX3BvaW50ZXJvdmVyJ10sXG4gICAgW1dIRUVMLCAnX3doZWVsJ10sXG4gICAgW0NPTlRFWFRNRU5VLCAnX2NvbnRleHRtZW51J10sXG4gICAgW1BPSU5URVJET1dOLCAnX3BvaW50ZXJkb3duJ10sXG4gICAgW1BPSU5URVJNT1ZFLCAnX3BvaW50ZXJtb3ZlJ10sXG4gICAgW1BPSU5URVJVUCwgJ19wb2ludGVydXAnXSxcbiAgICBbUE9JTlRFUkNBTkNFTCwgJ19wb2ludGVyY2FuY2VsJ10sXG4gICAgW0xPU1RQT0lOVEVSQ0FQVFVSRSwgJ19sb3N0cG9pbnRlcmNhcHR1cmUnXSxcbl07XG5jb25zdCBFVkVOVFNfTUFQID0ge1xuICAgIG1vdXNlOiB7XG4gICAgICAgIFtQT0lOVEVST1VUXTogTU9VU0VPVVQsXG4gICAgICAgIFtQT0lOVEVSTEVBVkVdOiBNT1VTRUxFQVZFLFxuICAgICAgICBbUE9JTlRFUk9WRVJdOiBNT1VTRU9WRVIsXG4gICAgICAgIFtQT0lOVEVSRU5URVJdOiBNT1VTRUVOVEVSLFxuICAgICAgICBbUE9JTlRFUk1PVkVdOiBNT1VTRU1PVkUsXG4gICAgICAgIFtQT0lOVEVSRE9XTl06IE1PVVNFRE9XTixcbiAgICAgICAgW1BPSU5URVJVUF06IE1PVVNFVVAsXG4gICAgICAgIFtQT0lOVEVSQ0FOQ0VMXTogJ21vdXNlY2FuY2VsJyxcbiAgICAgICAgcG9pbnRlcmNsaWNrOiAnY2xpY2snLFxuICAgICAgICBwb2ludGVyZGJsY2xpY2s6ICdkYmxjbGljaycsXG4gICAgfSxcbiAgICB0b3VjaDoge1xuICAgICAgICBbUE9JTlRFUk9VVF06ICd0b3VjaG91dCcsXG4gICAgICAgIFtQT0lOVEVSTEVBVkVdOiAndG91Y2hsZWF2ZScsXG4gICAgICAgIFtQT0lOVEVST1ZFUl06ICd0b3VjaG92ZXInLFxuICAgICAgICBbUE9JTlRFUkVOVEVSXTogJ3RvdWNoZW50ZXInLFxuICAgICAgICBbUE9JTlRFUk1PVkVdOiBUT1VDSE1PVkUsXG4gICAgICAgIFtQT0lOVEVSRE9XTl06IFRPVUNIU1RBUlQsXG4gICAgICAgIFtQT0lOVEVSVVBdOiBUT1VDSEVORCxcbiAgICAgICAgW1BPSU5URVJDQU5DRUxdOiBUT1VDSENBTkNFTCxcbiAgICAgICAgcG9pbnRlcmNsaWNrOiAndGFwJyxcbiAgICAgICAgcG9pbnRlcmRibGNsaWNrOiAnZGJsdGFwJyxcbiAgICB9LFxuICAgIHBvaW50ZXI6IHtcbiAgICAgICAgW1BPSU5URVJPVVRdOiBQT0lOVEVST1VULFxuICAgICAgICBbUE9JTlRFUkxFQVZFXTogUE9JTlRFUkxFQVZFLFxuICAgICAgICBbUE9JTlRFUk9WRVJdOiBQT0lOVEVST1ZFUixcbiAgICAgICAgW1BPSU5URVJFTlRFUl06IFBPSU5URVJFTlRFUixcbiAgICAgICAgW1BPSU5URVJNT1ZFXTogUE9JTlRFUk1PVkUsXG4gICAgICAgIFtQT0lOVEVSRE9XTl06IFBPSU5URVJET1dOLFxuICAgICAgICBbUE9JTlRFUlVQXTogUE9JTlRFUlVQLFxuICAgICAgICBbUE9JTlRFUkNBTkNFTF06IFBPSU5URVJDQU5DRUwsXG4gICAgICAgIHBvaW50ZXJjbGljazogJ3BvaW50ZXJjbGljaycsXG4gICAgICAgIHBvaW50ZXJkYmxjbGljazogJ3BvaW50ZXJkYmxjbGljaycsXG4gICAgfSxcbn07XG5jb25zdCBnZXRFdmVudFR5cGUgPSAodHlwZSkgPT4ge1xuICAgIGlmICh0eXBlLmluZGV4T2YoJ3BvaW50ZXInKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiAncG9pbnRlcic7XG4gICAgfVxuICAgIGlmICh0eXBlLmluZGV4T2YoJ3RvdWNoJykgPj0gMCkge1xuICAgICAgICByZXR1cm4gJ3RvdWNoJztcbiAgICB9XG4gICAgcmV0dXJuICdtb3VzZSc7XG59O1xuY29uc3QgZ2V0RXZlbnRzTWFwID0gKGV2ZW50VHlwZSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBnZXRFdmVudFR5cGUoZXZlbnRUeXBlKTtcbiAgICBpZiAodHlwZSA9PT0gJ3BvaW50ZXInKSB7XG4gICAgICAgIHJldHVybiBLb252YS5wb2ludGVyRXZlbnRzRW5hYmxlZCAmJiBFVkVOVFNfTUFQLnBvaW50ZXI7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAndG91Y2gnKSB7XG4gICAgICAgIHJldHVybiBFVkVOVFNfTUFQLnRvdWNoO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ21vdXNlJykge1xuICAgICAgICByZXR1cm4gRVZFTlRTX01BUC5tb3VzZTtcbiAgICB9XG59O1xuZnVuY3Rpb24gY2hlY2tOb0NsaXAoYXR0cnMgPSB7fSkge1xuICAgIGlmIChhdHRycy5jbGlwRnVuYyB8fCBhdHRycy5jbGlwV2lkdGggfHwgYXR0cnMuY2xpcEhlaWdodCkge1xuICAgICAgICBVdGlsLndhcm4oJ1N0YWdlIGRvZXMgbm90IHN1cHBvcnQgY2xpcHBpbmcuIFBsZWFzZSB1c2UgY2xpcCBmb3IgTGF5ZXJzIG9yIEdyb3Vwcy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJzO1xufVxuY29uc3QgTk9fUE9JTlRFUlNfTUVTU0FHRSA9IGBQb2ludGVyIHBvc2l0aW9uIGlzIG1pc3NpbmcgYW5kIG5vdCByZWdpc3RlcmVkIGJ5IHRoZSBzdGFnZS4gTG9va3MgbGlrZSBpdCBpcyBvdXRzaWRlIG9mIHRoZSBzdGFnZSBjb250YWluZXIuIFlvdSBjYW4gc2V0IGl0IG1hbnVhbGx5IGZyb20gZXZlbnQ6IHN0YWdlLnNldFBvaW50ZXJzUG9zaXRpb25zKGV2ZW50KTtgO1xuZXhwb3J0IGNvbnN0IHN0YWdlcyA9IFtdO1xuZXhwb3J0IGNsYXNzIFN0YWdlIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY2hlY2tOb0NsaXAoY29uZmlnKSk7XG4gICAgICAgIHRoaXMuX3BvaW50ZXJQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5fY2hhbmdlZFBvaW50ZXJQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5fYnVpbGRET00oKTtcbiAgICAgICAgdGhpcy5fYmluZENvbnRlbnRFdmVudHMoKTtcbiAgICAgICAgc3RhZ2VzLnB1c2godGhpcyk7XG4gICAgICAgIHRoaXMub24oJ3dpZHRoQ2hhbmdlLmtvbnZhIGhlaWdodENoYW5nZS5rb252YScsIHRoaXMuX3Jlc2l6ZURPTSk7XG4gICAgICAgIHRoaXMub24oJ3Zpc2libGVDaGFuZ2Uua29udmEnLCB0aGlzLl9jaGVja1Zpc2liaWxpdHkpO1xuICAgICAgICB0aGlzLm9uKCdjbGlwV2lkdGhDaGFuZ2Uua29udmEgY2xpcEhlaWdodENoYW5nZS5rb252YSBjbGlwRnVuY0NoYW5nZS5rb252YScsICgpID0+IHtcbiAgICAgICAgICAgIGNoZWNrTm9DbGlwKHRoaXMuYXR0cnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fY2hlY2tWaXNpYmlsaXR5KCk7XG4gICAgfVxuICAgIF92YWxpZGF0ZUFkZChjaGlsZCkge1xuICAgICAgICBjb25zdCBpc0xheWVyID0gY2hpbGQuZ2V0VHlwZSgpID09PSAnTGF5ZXInO1xuICAgICAgICBjb25zdCBpc0Zhc3RMYXllciA9IGNoaWxkLmdldFR5cGUoKSA9PT0gJ0Zhc3RMYXllcic7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gaXNMYXllciB8fCBpc0Zhc3RMYXllcjtcbiAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgVXRpbC50aHJvdygnWW91IG1heSBvbmx5IGFkZCBsYXllcnMgdG8gdGhlIHN0YWdlLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jaGVja1Zpc2liaWxpdHkoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3R5bGUgPSB0aGlzLnZpc2libGUoKSA/ICcnIDogJ25vbmUnO1xuICAgICAgICB0aGlzLmNvbnRlbnQuc3R5bGUuZGlzcGxheSA9IHN0eWxlO1xuICAgIH1cbiAgICBzZXRDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29udGFpbmVyID09PSBTVFJJTkcpIHtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIuY2hhckF0KDApID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gY29udGFpbmVyLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xhc3NOYW1lKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBpZDtcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyLmNoYXJBdCgwKSAhPT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkID0gY29udGFpbmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWQgPSBjb250YWluZXIuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0NhbiBub3QgZmluZCBjb250YWluZXIgaW4gZG9jdW1lbnQgd2l0aCBpZCAnICsgaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0QXR0cignY29udGFpbmVyJywgY29udGFpbmVyKTtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50LnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5jb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzaG91bGREcmF3SGl0KCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHZhciBsYXllcnMgPSB0aGlzLmNoaWxkcmVuLCBsZW4gPSBsYXllcnMubGVuZ3RoLCBuO1xuICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgIGxheWVyc1tuXS5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjbG9uZShvYmopIHtcbiAgICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgICAgIG9iaiA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIG9iai5jb250YWluZXIgPVxuICAgICAgICAgICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgcmV0dXJuIENvbnRhaW5lci5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzLCBvYmopO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5jb250ZW50O1xuICAgICAgICBpZiAoY29udGVudCAmJiBVdGlsLl9pc0luRG9jdW1lbnQoY29udGVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyKCkucmVtb3ZlQ2hpbGQoY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gc3RhZ2VzLmluZGV4T2YodGhpcyk7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBzdGFnZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0UG9pbnRlclBvc2l0aW9uKCkge1xuICAgICAgICBjb25zdCBwb3MgPSB0aGlzLl9wb2ludGVyUG9zaXRpb25zWzBdIHx8IHRoaXMuX2NoYW5nZWRQb2ludGVyUG9zaXRpb25zWzBdO1xuICAgICAgICBpZiAoIXBvcykge1xuICAgICAgICAgICAgVXRpbC53YXJuKE5PX1BPSU5URVJTX01FU1NBR0UpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHBvcy54LFxuICAgICAgICAgICAgeTogcG9zLnksXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9nZXRQb2ludGVyQnlJZChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRlclBvc2l0aW9ucy5maW5kKChwKSA9PiBwLmlkID09PSBpZCk7XG4gICAgfVxuICAgIGdldFBvaW50ZXJzUG9zaXRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRlclBvc2l0aW9ucztcbiAgICB9XG4gICAgZ2V0U3RhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50O1xuICAgIH1cbiAgICBfdG9Lb252YUNhbnZhcyhjb25maWcpIHtcbiAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgICBjb25maWcueCA9IGNvbmZpZy54IHx8IDA7XG4gICAgICAgIGNvbmZpZy55ID0gY29uZmlnLnkgfHwgMDtcbiAgICAgICAgY29uZmlnLndpZHRoID0gY29uZmlnLndpZHRoIHx8IHRoaXMud2lkdGgoKTtcbiAgICAgICAgY29uZmlnLmhlaWdodCA9IGNvbmZpZy5oZWlnaHQgfHwgdGhpcy5oZWlnaHQoKTtcbiAgICAgICAgdmFyIGNhbnZhcyA9IG5ldyBTY2VuZUNhbnZhcyh7XG4gICAgICAgICAgICB3aWR0aDogY29uZmlnLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBjb25maWcuaGVpZ2h0LFxuICAgICAgICAgICAgcGl4ZWxSYXRpbzogY29uZmlnLnBpeGVsUmF0aW8gfHwgMSxcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBfY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCkuX2NvbnRleHQ7XG4gICAgICAgIHZhciBsYXllcnMgPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgICBpZiAoY29uZmlnLnggfHwgY29uZmlnLnkpIHtcbiAgICAgICAgICAgIF9jb250ZXh0LnRyYW5zbGF0ZSgtMSAqIGNvbmZpZy54LCAtMSAqIGNvbmZpZy55KTtcbiAgICAgICAgfVxuICAgICAgICBsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgIGlmICghbGF5ZXIuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGF5ZXJDYW52YXMgPSBsYXllci5fdG9Lb252YUNhbnZhcyhjb25maWcpO1xuICAgICAgICAgICAgX2NvbnRleHQuZHJhd0ltYWdlKGxheWVyQ2FudmFzLl9jYW52YXMsIGNvbmZpZy54LCBjb25maWcueSwgbGF5ZXJDYW52YXMuZ2V0V2lkdGgoKSAvIGxheWVyQ2FudmFzLmdldFBpeGVsUmF0aW8oKSwgbGF5ZXJDYW52YXMuZ2V0SGVpZ2h0KCkgLyBsYXllckNhbnZhcy5nZXRQaXhlbFJhdGlvKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9XG4gICAgZ2V0SW50ZXJzZWN0aW9uKHBvcykge1xuICAgICAgICBpZiAoIXBvcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuY2hpbGRyZW4sIGxlbiA9IGxheWVycy5sZW5ndGgsIGVuZCA9IGxlbiAtIDEsIG47XG4gICAgICAgIGZvciAobiA9IGVuZDsgbiA+PSAwOyBuLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYXBlID0gbGF5ZXJzW25dLmdldEludGVyc2VjdGlvbihwb3MpO1xuICAgICAgICAgICAgaWYgKHNoYXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfcmVzaXplRE9NKCkge1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoKCk7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodCgpO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQuc3R5bGUud2lkdGggPSB3aWR0aCArIFBYO1xuICAgICAgICAgICAgdGhpcy5jb250ZW50LnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFBYO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmZmVyQ2FudmFzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuYnVmZmVySGl0Q2FudmFzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgobGF5ZXIpID0+IHtcbiAgICAgICAgICAgIGxheWVyLnNldFNpemUoeyB3aWR0aCwgaGVpZ2h0IH0pO1xuICAgICAgICAgICAgbGF5ZXIuZHJhdygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWRkKGxheWVyLCAuLi5yZXN0KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChhcmd1bWVudHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuYWRkKGxheWVyKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoID4gTUFYX0xBWUVSU19OVU1CRVIpIHtcbiAgICAgICAgICAgIFV0aWwud2FybignVGhlIHN0YWdlIGhhcyAnICtcbiAgICAgICAgICAgICAgICBsZW5ndGggK1xuICAgICAgICAgICAgICAgICcgbGF5ZXJzLiBSZWNvbW1lbmRlZCBtYXhpbXVtIG51bWJlciBvZiBsYXllcnMgaXMgMy01LiBBZGRpbmcgbW9yZSBsYXllcnMgaW50byB0aGUgc3RhZ2UgbWF5IGRyb3AgdGhlIHBlcmZvcm1hbmNlLiBSZXRoaW5rIHlvdXIgdHJlZSBzdHJ1Y3R1cmUsIHlvdSBjYW4gdXNlIEtvbnZhLkdyb3VwLicpO1xuICAgICAgICB9XG4gICAgICAgIGxheWVyLnNldFNpemUoeyB3aWR0aDogdGhpcy53aWR0aCgpLCBoZWlnaHQ6IHRoaXMuaGVpZ2h0KCkgfSk7XG4gICAgICAgIGxheWVyLmRyYXcoKTtcbiAgICAgICAgaWYgKEtvbnZhLmlzQnJvd3Nlcikge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50LmFwcGVuZENoaWxkKGxheWVyLmNhbnZhcy5fY2FudmFzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0UGFyZW50KCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0TGF5ZXIoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBoYXNQb2ludGVyQ2FwdHVyZShwb2ludGVySWQpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50ZXJFdmVudHMuaGFzUG9pbnRlckNhcHR1cmUocG9pbnRlcklkLCB0aGlzKTtcbiAgICB9XG4gICAgc2V0UG9pbnRlckNhcHR1cmUocG9pbnRlcklkKSB7XG4gICAgICAgIFBvaW50ZXJFdmVudHMuc2V0UG9pbnRlckNhcHR1cmUocG9pbnRlcklkLCB0aGlzKTtcbiAgICB9XG4gICAgcmVsZWFzZUNhcHR1cmUocG9pbnRlcklkKSB7XG4gICAgICAgIFBvaW50ZXJFdmVudHMucmVsZWFzZUNhcHR1cmUocG9pbnRlcklkLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0TGF5ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbjtcbiAgICB9XG4gICAgX2JpbmRDb250ZW50RXZlbnRzKCkge1xuICAgICAgICBpZiAoIUtvbnZhLmlzQnJvd3Nlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIEVWRU5UUy5mb3JFYWNoKChbZXZlbnQsIG1ldGhvZE5hbWVdKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgKGV2dCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0oZXZ0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3BvaW50ZXJlbnRlcihldnQpIHtcbiAgICAgICAgdGhpcy5zZXRQb2ludGVyc1Bvc2l0aW9ucyhldnQpO1xuICAgICAgICBjb25zdCBldmVudHMgPSBnZXRFdmVudHNNYXAoZXZ0LnR5cGUpO1xuICAgICAgICB0aGlzLl9maXJlKGV2ZW50cy5wb2ludGVyZW50ZXIsIHtcbiAgICAgICAgICAgIGV2dDogZXZ0LFxuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgY3VycmVudFRhcmdldDogdGhpcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9wb2ludGVyb3ZlcihldnQpIHtcbiAgICAgICAgdGhpcy5zZXRQb2ludGVyc1Bvc2l0aW9ucyhldnQpO1xuICAgICAgICBjb25zdCBldmVudHMgPSBnZXRFdmVudHNNYXAoZXZ0LnR5cGUpO1xuICAgICAgICB0aGlzLl9maXJlKGV2ZW50cy5wb2ludGVyb3Zlciwge1xuICAgICAgICAgICAgZXZ0OiBldnQsXG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiB0aGlzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldFRhcmdldFNoYXBlKGV2ZW5UeXBlKSB7XG4gICAgICAgIGxldCBzaGFwZSA9IHRoaXNbZXZlblR5cGUgKyAndGFyZ2V0U2hhcGUnXTtcbiAgICAgICAgaWYgKHNoYXBlICYmICFzaGFwZS5nZXRTdGFnZSgpKSB7XG4gICAgICAgICAgICBzaGFwZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgIH1cbiAgICBfcG9pbnRlcmxlYXZlKGV2dCkge1xuICAgICAgICBjb25zdCBldmVudHMgPSBnZXRFdmVudHNNYXAoZXZ0LnR5cGUpO1xuICAgICAgICBjb25zdCBldmVudFR5cGUgPSBnZXRFdmVudFR5cGUoZXZ0LnR5cGUpO1xuICAgICAgICBpZiAoIWV2ZW50cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0UG9pbnRlcnNQb3NpdGlvbnMoZXZ0KTtcbiAgICAgICAgdmFyIHRhcmdldFNoYXBlID0gdGhpcy5fZ2V0VGFyZ2V0U2hhcGUoZXZlbnRUeXBlKTtcbiAgICAgICAgdmFyIGV2ZW50c0VuYWJsZWQgPSAhREQuaXNEcmFnZ2luZyB8fCBLb252YS5oaXRPbkRyYWdFbmFibGVkO1xuICAgICAgICBpZiAodGFyZ2V0U2hhcGUgJiYgZXZlbnRzRW5hYmxlZCkge1xuICAgICAgICAgICAgdGFyZ2V0U2hhcGUuX2ZpcmVBbmRCdWJibGUoZXZlbnRzLnBvaW50ZXJvdXQsIHsgZXZ0OiBldnQgfSk7XG4gICAgICAgICAgICB0YXJnZXRTaGFwZS5fZmlyZUFuZEJ1YmJsZShldmVudHMucG9pbnRlcmxlYXZlLCB7IGV2dDogZXZ0IH0pO1xuICAgICAgICAgICAgdGhpcy5fZmlyZShldmVudHMucG9pbnRlcmxlYXZlLCB7XG4gICAgICAgICAgICAgICAgZXZ0OiBldnQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXNbZXZlbnRUeXBlICsgJ3RhcmdldFNoYXBlJ10gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50c0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmUoZXZlbnRzLnBvaW50ZXJsZWF2ZSwge1xuICAgICAgICAgICAgICAgIGV2dDogZXZ0LFxuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9maXJlKGV2ZW50cy5wb2ludGVyb3V0LCB7XG4gICAgICAgICAgICAgICAgZXZ0OiBldnQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvaW50ZXJQb3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3BvaW50ZXJQb3NpdGlvbnMgPSBbXTtcbiAgICB9XG4gICAgX3BvaW50ZXJkb3duKGV2dCkge1xuICAgICAgICBjb25zdCBldmVudHMgPSBnZXRFdmVudHNNYXAoZXZ0LnR5cGUpO1xuICAgICAgICBjb25zdCBldmVudFR5cGUgPSBnZXRFdmVudFR5cGUoZXZ0LnR5cGUpO1xuICAgICAgICBpZiAoIWV2ZW50cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0UG9pbnRlcnNQb3NpdGlvbnMoZXZ0KTtcbiAgICAgICAgdmFyIHRyaWdnZXJlZE9uU2hhcGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY2hhbmdlZFBvaW50ZXJQb3NpdGlvbnMuZm9yRWFjaCgocG9zKSA9PiB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLmdldEludGVyc2VjdGlvbihwb3MpO1xuICAgICAgICAgICAgREQuanVzdERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIEtvbnZhWydfJyArIGV2ZW50VHlwZSArICdMaXN0ZW5DbGljayddID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGhhc1NoYXBlID0gc2hhcGUgJiYgc2hhcGUuaXNMaXN0ZW5pbmcoKTtcbiAgICAgICAgICAgIGlmICghaGFzU2hhcGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoS29udmEuY2FwdHVyZVBvaW50ZXJFdmVudHNFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgc2hhcGUuc2V0UG9pbnRlckNhcHR1cmUocG9zLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbZXZlbnRUeXBlICsgJ0NsaWNrU3RhcnRTaGFwZSddID0gc2hhcGU7XG4gICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShldmVudHMucG9pbnRlcmRvd24sIHtcbiAgICAgICAgICAgICAgICBldnQ6IGV2dCxcbiAgICAgICAgICAgICAgICBwb2ludGVySWQ6IHBvcy5pZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJpZ2dlcmVkT25TaGFwZSA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBpc1RvdWNoID0gZXZ0LnR5cGUuaW5kZXhPZigndG91Y2gnKSA+PSAwO1xuICAgICAgICAgICAgaWYgKHNoYXBlLnByZXZlbnREZWZhdWx0KCkgJiYgZXZ0LmNhbmNlbGFibGUgJiYgaXNUb3VjaCkge1xuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF0cmlnZ2VyZWRPblNoYXBlKSB7XG4gICAgICAgICAgICB0aGlzLl9maXJlKGV2ZW50cy5wb2ludGVyZG93biwge1xuICAgICAgICAgICAgICAgIGV2dDogZXZ0LFxuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJJZDogdGhpcy5fcG9pbnRlclBvc2l0aW9uc1swXS5pZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wb2ludGVybW92ZShldnQpIHtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gZ2V0RXZlbnRzTWFwKGV2dC50eXBlKTtcbiAgICAgICAgY29uc3QgZXZlbnRUeXBlID0gZ2V0RXZlbnRUeXBlKGV2dC50eXBlKTtcbiAgICAgICAgaWYgKCFldmVudHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoREQuaXNEcmFnZ2luZyAmJiBERC5ub2RlLnByZXZlbnREZWZhdWx0KCkgJiYgZXZ0LmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0UG9pbnRlcnNQb3NpdGlvbnMoZXZ0KTtcbiAgICAgICAgdmFyIGV2ZW50c0VuYWJsZWQgPSAhREQuaXNEcmFnZ2luZyB8fCBLb252YS5oaXRPbkRyYWdFbmFibGVkO1xuICAgICAgICBpZiAoIWV2ZW50c0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvY2Vzc2VkU2hhcGVzSWRzID0ge307XG4gICAgICAgIGxldCB0cmlnZ2VyZWRPblNoYXBlID0gZmFsc2U7XG4gICAgICAgIHZhciB0YXJnZXRTaGFwZSA9IHRoaXMuX2dldFRhcmdldFNoYXBlKGV2ZW50VHlwZSk7XG4gICAgICAgIHRoaXMuX2NoYW5nZWRQb2ludGVyUG9zaXRpb25zLmZvckVhY2goKHBvcykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2hhcGUgPSAoUG9pbnRlckV2ZW50cy5nZXRDYXB0dXJlZFNoYXBlKHBvcy5pZCkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmdldEludGVyc2VjdGlvbihwb3MpKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXJJZCA9IHBvcy5pZDtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0geyBldnQ6IGV2dCwgcG9pbnRlcklkIH07XG4gICAgICAgICAgICB2YXIgZGlmZmVyZW50VGFyZ2V0ID0gdGFyZ2V0U2hhcGUgIT09IHNoYXBlO1xuICAgICAgICAgICAgaWYgKGRpZmZlcmVudFRhcmdldCAmJiB0YXJnZXRTaGFwZSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFNoYXBlLl9maXJlQW5kQnViYmxlKGV2ZW50cy5wb2ludGVyb3V0LCBPYmplY3QuYXNzaWduKHt9LCBldmVudCksIHNoYXBlKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRTaGFwZS5fZmlyZUFuZEJ1YmJsZShldmVudHMucG9pbnRlcmxlYXZlLCBPYmplY3QuYXNzaWduKHt9LCBldmVudCksIHNoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaGFwZSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzZWRTaGFwZXNJZHNbc2hhcGUuX2lkXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb2Nlc3NlZFNoYXBlc0lkc1tzaGFwZS5faWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5pc0xpc3RlbmluZygpKSB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlcmVkT25TaGFwZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGRpZmZlcmVudFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShldmVudHMucG9pbnRlcm92ZXIsIE9iamVjdC5hc3NpZ24oe30sIGV2ZW50KSwgdGFyZ2V0U2hhcGUpO1xuICAgICAgICAgICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShldmVudHMucG9pbnRlcmVudGVyLCBPYmplY3QuYXNzaWduKHt9LCBldmVudCksIHRhcmdldFNoYXBlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tldmVudFR5cGUgKyAndGFyZ2V0U2hhcGUnXSA9IHNoYXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShldmVudHMucG9pbnRlcm1vdmUsIE9iamVjdC5hc3NpZ24oe30sIGV2ZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0U2hhcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlyZShldmVudHMucG9pbnRlcm92ZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2dDogZXZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhcmdldDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbZXZlbnRUeXBlICsgJ3RhcmdldFNoYXBlJ10gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdHJpZ2dlcmVkT25TaGFwZSkge1xuICAgICAgICAgICAgdGhpcy5fZmlyZShldmVudHMucG9pbnRlcm1vdmUsIHtcbiAgICAgICAgICAgICAgICBldnQ6IGV2dCxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgY3VycmVudFRhcmdldDogdGhpcyxcbiAgICAgICAgICAgICAgICBwb2ludGVySWQ6IHRoaXMuX2NoYW5nZWRQb2ludGVyUG9zaXRpb25zWzBdLmlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3BvaW50ZXJ1cChldnQpIHtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gZ2V0RXZlbnRzTWFwKGV2dC50eXBlKTtcbiAgICAgICAgY29uc3QgZXZlbnRUeXBlID0gZ2V0RXZlbnRUeXBlKGV2dC50eXBlKTtcbiAgICAgICAgaWYgKCFldmVudHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFBvaW50ZXJzUG9zaXRpb25zKGV2dCk7XG4gICAgICAgIGNvbnN0IGNsaWNrU3RhcnRTaGFwZSA9IHRoaXNbZXZlbnRUeXBlICsgJ0NsaWNrU3RhcnRTaGFwZSddO1xuICAgICAgICBjb25zdCBjbGlja0VuZFNoYXBlID0gdGhpc1tldmVudFR5cGUgKyAnQ2xpY2tFbmRTaGFwZSddO1xuICAgICAgICB2YXIgcHJvY2Vzc2VkU2hhcGVzSWRzID0ge307XG4gICAgICAgIGxldCB0cmlnZ2VyZWRPblNoYXBlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NoYW5nZWRQb2ludGVyUG9zaXRpb25zLmZvckVhY2goKHBvcykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2hhcGUgPSAoUG9pbnRlckV2ZW50cy5nZXRDYXB0dXJlZFNoYXBlKHBvcy5pZCkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmdldEludGVyc2VjdGlvbihwb3MpKTtcbiAgICAgICAgICAgIGlmIChzaGFwZSkge1xuICAgICAgICAgICAgICAgIHNoYXBlLnJlbGVhc2VDYXB0dXJlKHBvcy5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3NlZFNoYXBlc0lkc1tzaGFwZS5faWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkU2hhcGVzSWRzW3NoYXBlLl9pZF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcG9pbnRlcklkID0gcG9zLmlkO1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSB7IGV2dDogZXZ0LCBwb2ludGVySWQgfTtcbiAgICAgICAgICAgIGxldCBmaXJlRGJsQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChLb252YVsnXycgKyBldmVudFR5cGUgKyAnSW5EYmxDbGlja1dpbmRvdyddKSB7XG4gICAgICAgICAgICAgICAgZmlyZURibENsaWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpc1tldmVudFR5cGUgKyAnRGJsVGltZW91dCddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFERC5qdXN0RHJhZ2dlZCkge1xuICAgICAgICAgICAgICAgIEtvbnZhWydfJyArIGV2ZW50VHlwZSArICdJbkRibENsaWNrV2luZG93J10gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzW2V2ZW50VHlwZSArICdEYmxUaW1lb3V0J10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc1tldmVudFR5cGUgKyAnRGJsVGltZW91dCddID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgS29udmFbJ18nICsgZXZlbnRUeXBlICsgJ0luRGJsQ2xpY2tXaW5kb3cnXSA9IGZhbHNlO1xuICAgICAgICAgICAgfSwgS29udmEuZGJsQ2xpY2tXaW5kb3cpO1xuICAgICAgICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLmlzTGlzdGVuaW5nKCkpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyZWRPblNoYXBlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzW2V2ZW50VHlwZSArICdDbGlja0VuZFNoYXBlJ10gPSBzaGFwZTtcbiAgICAgICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShldmVudHMucG9pbnRlcnVwLCBPYmplY3QuYXNzaWduKHt9LCBldmVudCkpO1xuICAgICAgICAgICAgICAgIGlmIChLb252YVsnXycgKyBldmVudFR5cGUgKyAnTGlzdGVuQ2xpY2snXSAmJlxuICAgICAgICAgICAgICAgICAgICBjbGlja1N0YXJ0U2hhcGUgJiZcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tTdGFydFNoYXBlID09PSBzaGFwZSkge1xuICAgICAgICAgICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShldmVudHMucG9pbnRlcmNsaWNrLCBPYmplY3QuYXNzaWduKHt9LCBldmVudCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyZURibENsaWNrICYmIGNsaWNrRW5kU2hhcGUgJiYgY2xpY2tFbmRTaGFwZSA9PT0gc2hhcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlLl9maXJlQW5kQnViYmxlKGV2ZW50cy5wb2ludGVyZGJsY2xpY2ssIE9iamVjdC5hc3NpZ24oe30sIGV2ZW50KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzW2V2ZW50VHlwZSArICdDbGlja0VuZFNoYXBlJ10gPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChLb252YVsnXycgKyBldmVudFR5cGUgKyAnTGlzdGVuQ2xpY2snXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maXJlKGV2ZW50cy5wb2ludGVyY2xpY2ssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2dDogZXZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhcmdldDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmaXJlRGJsQ2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlyZShldmVudHMucG9pbnRlcmRibGNsaWNrLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldnQ6IGV2dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVySWQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdHJpZ2dlcmVkT25TaGFwZSkge1xuICAgICAgICAgICAgdGhpcy5fZmlyZShldmVudHMucG9pbnRlcnVwLCB7XG4gICAgICAgICAgICAgICAgZXZ0OiBldnQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgcG9pbnRlcklkOiB0aGlzLl9jaGFuZ2VkUG9pbnRlclBvc2l0aW9uc1swXS5pZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIEtvbnZhWydfJyArIGV2ZW50VHlwZSArICdMaXN0ZW5DbGljayddID0gZmFsc2U7XG4gICAgICAgIGlmIChldnQuY2FuY2VsYWJsZSkge1xuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NvbnRleHRtZW51KGV2dCkge1xuICAgICAgICB0aGlzLnNldFBvaW50ZXJzUG9zaXRpb25zKGV2dCk7XG4gICAgICAgIHZhciBzaGFwZSA9IHRoaXMuZ2V0SW50ZXJzZWN0aW9uKHRoaXMuZ2V0UG9pbnRlclBvc2l0aW9uKCkpO1xuICAgICAgICBpZiAoc2hhcGUgJiYgc2hhcGUuaXNMaXN0ZW5pbmcoKSkge1xuICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoQ09OVEVYVE1FTlUsIHsgZXZ0OiBldnQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9maXJlKENPTlRFWFRNRU5VLCB7XG4gICAgICAgICAgICAgICAgZXZ0OiBldnQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfd2hlZWwoZXZ0KSB7XG4gICAgICAgIHRoaXMuc2V0UG9pbnRlcnNQb3NpdGlvbnMoZXZ0KTtcbiAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5nZXRJbnRlcnNlY3Rpb24odGhpcy5nZXRQb2ludGVyUG9zaXRpb24oKSk7XG4gICAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5pc0xpc3RlbmluZygpKSB7XG4gICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShXSEVFTCwgeyBldnQ6IGV2dCB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmUoV0hFRUwsIHtcbiAgICAgICAgICAgICAgICBldnQ6IGV2dCxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgY3VycmVudFRhcmdldDogdGhpcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wb2ludGVyY2FuY2VsKGV2dCkge1xuICAgICAgICB0aGlzLnNldFBvaW50ZXJzUG9zaXRpb25zKGV2dCk7XG4gICAgICAgIGNvbnN0IHNoYXBlID0gUG9pbnRlckV2ZW50cy5nZXRDYXB0dXJlZFNoYXBlKGV2dC5wb2ludGVySWQpIHx8XG4gICAgICAgICAgICB0aGlzLmdldEludGVyc2VjdGlvbih0aGlzLmdldFBvaW50ZXJQb3NpdGlvbigpKTtcbiAgICAgICAgaWYgKHNoYXBlKSB7XG4gICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShQT0lOVEVSVVAsIFBvaW50ZXJFdmVudHMuY3JlYXRlRXZlbnQoZXZ0KSk7XG4gICAgICAgIH1cbiAgICAgICAgUG9pbnRlckV2ZW50cy5yZWxlYXNlQ2FwdHVyZShldnQucG9pbnRlcklkKTtcbiAgICB9XG4gICAgX2xvc3Rwb2ludGVyY2FwdHVyZShldnQpIHtcbiAgICAgICAgUG9pbnRlckV2ZW50cy5yZWxlYXNlQ2FwdHVyZShldnQucG9pbnRlcklkKTtcbiAgICB9XG4gICAgc2V0UG9pbnRlcnNQb3NpdGlvbnMoZXZ0KSB7XG4gICAgICAgIHZhciBjb250ZW50UG9zaXRpb24gPSB0aGlzLl9nZXRDb250ZW50UG9zaXRpb24oKSwgeCA9IG51bGwsIHkgPSBudWxsO1xuICAgICAgICBldnQgPSBldnQgPyBldnQgOiB3aW5kb3cuZXZlbnQ7XG4gICAgICAgIGlmIChldnQudG91Y2hlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wb2ludGVyUG9zaXRpb25zID0gW107XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkUG9pbnRlclBvc2l0aW9ucyA9IFtdO1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChldnQudG91Y2hlcywgKHRvdWNoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRlclBvc2l0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRvdWNoLmlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgIHg6ICh0b3VjaC5jbGllbnRYIC0gY29udGVudFBvc2l0aW9uLmxlZnQpIC8gY29udGVudFBvc2l0aW9uLnNjYWxlWCxcbiAgICAgICAgICAgICAgICAgICAgeTogKHRvdWNoLmNsaWVudFkgLSBjb250ZW50UG9zaXRpb24udG9wKSAvIGNvbnRlbnRQb3NpdGlvbi5zY2FsZVksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZXZ0LmNoYW5nZWRUb3VjaGVzIHx8IGV2dC50b3VjaGVzLCAodG91Y2gpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VkUG9pbnRlclBvc2l0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRvdWNoLmlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgIHg6ICh0b3VjaC5jbGllbnRYIC0gY29udGVudFBvc2l0aW9uLmxlZnQpIC8gY29udGVudFBvc2l0aW9uLnNjYWxlWCxcbiAgICAgICAgICAgICAgICAgICAgeTogKHRvdWNoLmNsaWVudFkgLSBjb250ZW50UG9zaXRpb24udG9wKSAvIGNvbnRlbnRQb3NpdGlvbi5zY2FsZVksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHggPSAoZXZ0LmNsaWVudFggLSBjb250ZW50UG9zaXRpb24ubGVmdCkgLyBjb250ZW50UG9zaXRpb24uc2NhbGVYO1xuICAgICAgICAgICAgeSA9IChldnQuY2xpZW50WSAtIGNvbnRlbnRQb3NpdGlvbi50b3ApIC8gY29udGVudFBvc2l0aW9uLnNjYWxlWTtcbiAgICAgICAgICAgIHRoaXMucG9pbnRlclBvcyA9IHtcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fcG9pbnRlclBvc2l0aW9ucyA9IFt7IHgsIHksIGlkOiBVdGlsLl9nZXRGaXJzdFBvaW50ZXJJZChldnQpIH1dO1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZFBvaW50ZXJQb3NpdGlvbnMgPSBbXG4gICAgICAgICAgICAgICAgeyB4LCB5LCBpZDogVXRpbC5fZ2V0Rmlyc3RQb2ludGVySWQoZXZ0KSB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc2V0UG9pbnRlclBvc2l0aW9uKGV2dCkge1xuICAgICAgICBVdGlsLndhcm4oJ01ldGhvZCBfc2V0UG9pbnRlclBvc2l0aW9uIGlzIGRlcHJlY2F0ZWQuIFVzZSBcInN0YWdlLnNldFBvaW50ZXJzUG9zaXRpb25zKGV2ZW50KVwiIGluc3RlYWQuJyk7XG4gICAgICAgIHRoaXMuc2V0UG9pbnRlcnNQb3NpdGlvbnMoZXZ0KTtcbiAgICB9XG4gICAgX2dldENvbnRlbnRQb3NpdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnQgfHwgIXRoaXMuY29udGVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgc2NhbGVYOiAxLFxuICAgICAgICAgICAgICAgIHNjYWxlWTogMSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmNvbnRlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6IHJlY3QudG9wLFxuICAgICAgICAgICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgICAgICAgICAgc2NhbGVYOiByZWN0LndpZHRoIC8gdGhpcy5jb250ZW50LmNsaWVudFdpZHRoIHx8IDEsXG4gICAgICAgICAgICBzY2FsZVk6IHJlY3QuaGVpZ2h0IC8gdGhpcy5jb250ZW50LmNsaWVudEhlaWdodCB8fCAxLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfYnVpbGRET00oKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyQ2FudmFzID0gbmV3IFNjZW5lQ2FudmFzKHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoKCksXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0KCksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJ1ZmZlckhpdENhbnZhcyA9IG5ldyBIaXRDYW52YXMoe1xuICAgICAgICAgICAgcGl4ZWxSYXRpbzogMSxcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoKCksXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0KCksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIUtvbnZhLmlzQnJvd3Nlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcigpO1xuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhyb3cgJ1N0YWdlIGhhcyBubyBjb250YWluZXIuIEEgY29udGFpbmVyIGlzIHJlcXVpcmVkLic7XG4gICAgICAgIH1cbiAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5jb250ZW50LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgdGhpcy5jb250ZW50LnN0eWxlLnVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuY29udGVudC5jbGFzc05hbWUgPSAna29udmFqcy1jb250ZW50JztcbiAgICAgICAgdGhpcy5jb250ZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdwcmVzZW50YXRpb24nKTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuY29udGVudCk7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZURPTSgpO1xuICAgIH1cbiAgICBjYWNoZSgpIHtcbiAgICAgICAgVXRpbC53YXJuKCdDYWNoZSBmdW5jdGlvbiBpcyBub3QgYWxsb3dlZCBmb3Igc3RhZ2UuIFlvdSBtYXkgdXNlIGNhY2hlIG9ubHkgZm9yIGxheWVycywgZ3JvdXBzIGFuZCBzaGFwZXMuJyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjbGVhckNhY2hlKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYmF0Y2hEcmF3KCkge1xuICAgICAgICB0aGlzLmdldENoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgIGxheWVyLmJhdGNoRHJhdygpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuU3RhZ2UucHJvdG90eXBlLm5vZGVUeXBlID0gU1RBR0U7XG5fcmVnaXN0ZXJOb2RlKFN0YWdlKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFN0YWdlLCAnY29udGFpbmVyJyk7XG4iLCJpbXBvcnQgeyBLb252YSB9IGZyb20gJy4vR2xvYmFsLmpzJztcbmltcG9ydCB7IFRyYW5zZm9ybSwgVXRpbCB9IGZyb20gJy4vVXRpbC5qcyc7XG5pbXBvcnQgeyBGYWN0b3J5IH0gZnJvbSAnLi9GYWN0b3J5LmpzJztcbmltcG9ydCB7IE5vZGUgfSBmcm9tICcuL05vZGUuanMnO1xuaW1wb3J0IHsgZ2V0TnVtYmVyVmFsaWRhdG9yLCBnZXROdW1iZXJPckF1dG9WYWxpZGF0b3IsIGdldFN0cmluZ1ZhbGlkYXRvciwgZ2V0Qm9vbGVhblZhbGlkYXRvciwgZ2V0U3RyaW5nT3JHcmFkaWVudFZhbGlkYXRvciwgfSBmcm9tICcuL1ZhbGlkYXRvcnMuanMnO1xuaW1wb3J0IHsgX3JlZ2lzdGVyTm9kZSB9IGZyb20gJy4vR2xvYmFsLmpzJztcbmltcG9ydCAqIGFzIFBvaW50ZXJFdmVudHMgZnJvbSAnLi9Qb2ludGVyRXZlbnRzLmpzJztcbnZhciBIQVNfU0hBRE9XID0gJ2hhc1NoYWRvdyc7XG52YXIgU0hBRE9XX1JHQkEgPSAnc2hhZG93UkdCQSc7XG52YXIgcGF0dGVybkltYWdlID0gJ3BhdHRlcm5JbWFnZSc7XG52YXIgbGluZWFyR3JhZGllbnQgPSAnbGluZWFyR3JhZGllbnQnO1xudmFyIHJhZGlhbEdyYWRpZW50ID0gJ3JhZGlhbEdyYWRpZW50JztcbmxldCBkdW1teUNvbnRleHQ7XG5mdW5jdGlvbiBnZXREdW1teUNvbnRleHQoKSB7XG4gICAgaWYgKGR1bW15Q29udGV4dCkge1xuICAgICAgICByZXR1cm4gZHVtbXlDb250ZXh0O1xuICAgIH1cbiAgICBkdW1teUNvbnRleHQgPSBVdGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKS5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHJldHVybiBkdW1teUNvbnRleHQ7XG59XG5leHBvcnQgY29uc3Qgc2hhcGVzID0ge307XG5mdW5jdGlvbiBfZmlsbEZ1bmMoY29udGV4dCkge1xuICAgIGNvbnRleHQuZmlsbCgpO1xufVxuZnVuY3Rpb24gX3N0cm9rZUZ1bmMoY29udGV4dCkge1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG59XG5mdW5jdGlvbiBfZmlsbEZ1bmNIaXQoY29udGV4dCkge1xuICAgIGNvbnRleHQuZmlsbCgpO1xufVxuZnVuY3Rpb24gX3N0cm9rZUZ1bmNIaXQoY29udGV4dCkge1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG59XG5mdW5jdGlvbiBfY2xlYXJIYXNTaGFkb3dDYWNoZSgpIHtcbiAgICB0aGlzLl9jbGVhckNhY2hlKEhBU19TSEFET1cpO1xufVxuZnVuY3Rpb24gX2NsZWFyR2V0U2hhZG93UkdCQUNhY2hlKCkge1xuICAgIHRoaXMuX2NsZWFyQ2FjaGUoU0hBRE9XX1JHQkEpO1xufVxuZnVuY3Rpb24gX2NsZWFyRmlsbFBhdHRlcm5DYWNoZSgpIHtcbiAgICB0aGlzLl9jbGVhckNhY2hlKHBhdHRlcm5JbWFnZSk7XG59XG5mdW5jdGlvbiBfY2xlYXJMaW5lYXJHcmFkaWVudENhY2hlKCkge1xuICAgIHRoaXMuX2NsZWFyQ2FjaGUobGluZWFyR3JhZGllbnQpO1xufVxuZnVuY3Rpb24gX2NsZWFyUmFkaWFsR3JhZGllbnRDYWNoZSgpIHtcbiAgICB0aGlzLl9jbGVhckNhY2hlKHJhZGlhbEdyYWRpZW50KTtcbn1cbmV4cG9ydCBjbGFzcyBTaGFwZSBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgICAgICBsZXQga2V5O1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAga2V5ID0gVXRpbC5nZXRSYW5kb21Db2xvcigpO1xuICAgICAgICAgICAgaWYgKGtleSAmJiAhKGtleSBpbiBzaGFwZXMpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2xvcktleSA9IGtleTtcbiAgICAgICAgc2hhcGVzW2tleV0gPSB0aGlzO1xuICAgIH1cbiAgICBnZXRDb250ZXh0KCkge1xuICAgICAgICBVdGlsLndhcm4oJ3NoYXBlLmdldENvbnRleHQoKSBtZXRob2QgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIGRvIG5vdCB1c2UgaXQuJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldExheWVyKCkuZ2V0Q29udGV4dCgpO1xuICAgIH1cbiAgICBnZXRDYW52YXMoKSB7XG4gICAgICAgIFV0aWwud2Fybignc2hhcGUuZ2V0Q2FudmFzKCkgbWV0aG9kIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSBkbyBub3QgdXNlIGl0LicpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMYXllcigpLmdldENhbnZhcygpO1xuICAgIH1cbiAgICBnZXRTY2VuZUZ1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJzLnNjZW5lRnVuYyB8fCB0aGlzWydfc2NlbmVGdW5jJ107XG4gICAgfVxuICAgIGdldEhpdEZ1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJzLmhpdEZ1bmMgfHwgdGhpc1snX2hpdEZ1bmMnXTtcbiAgICB9XG4gICAgaGFzU2hhZG93KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUoSEFTX1NIQURPVywgdGhpcy5faGFzU2hhZG93KTtcbiAgICB9XG4gICAgX2hhc1NoYWRvdygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnNoYWRvd0VuYWJsZWQoKSAmJlxuICAgICAgICAgICAgdGhpcy5zaGFkb3dPcGFjaXR5KCkgIT09IDAgJiZcbiAgICAgICAgICAgICEhKHRoaXMuc2hhZG93Q29sb3IoKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc2hhZG93Qmx1cigpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFkb3dPZmZzZXRYKCkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRvd09mZnNldFkoKSkpO1xuICAgIH1cbiAgICBfZ2V0RmlsbFBhdHRlcm4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZShwYXR0ZXJuSW1hZ2UsIHRoaXMuX19nZXRGaWxsUGF0dGVybik7XG4gICAgfVxuICAgIF9fZ2V0RmlsbFBhdHRlcm4oKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbGxQYXR0ZXJuSW1hZ2UoKSkge1xuICAgICAgICAgICAgdmFyIGN0eCA9IGdldER1bW15Q29udGV4dCgpO1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IGN0eC5jcmVhdGVQYXR0ZXJuKHRoaXMuZmlsbFBhdHRlcm5JbWFnZSgpLCB0aGlzLmZpbGxQYXR0ZXJuUmVwZWF0KCkgfHwgJ3JlcGVhdCcpO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4gJiYgcGF0dGVybi5zZXRUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ciA9IG5ldyBUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgICAgICB0ci50cmFuc2xhdGUodGhpcy5maWxsUGF0dGVyblgoKSwgdGhpcy5maWxsUGF0dGVyblkoKSk7XG4gICAgICAgICAgICAgICAgdHIucm90YXRlKEtvbnZhLmdldEFuZ2xlKHRoaXMuZmlsbFBhdHRlcm5Sb3RhdGlvbigpKSk7XG4gICAgICAgICAgICAgICAgdHIuc2NhbGUodGhpcy5maWxsUGF0dGVyblNjYWxlWCgpLCB0aGlzLmZpbGxQYXR0ZXJuU2NhbGVZKCkpO1xuICAgICAgICAgICAgICAgIHRyLnRyYW5zbGF0ZSgtMSAqIHRoaXMuZmlsbFBhdHRlcm5PZmZzZXRYKCksIC0xICogdGhpcy5maWxsUGF0dGVybk9mZnNldFkoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IHRyLmdldE1hdHJpeCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdHJpeCA9IHR5cGVvZiBET01NYXRyaXggPT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYTogbVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGI6IG1bMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjOiBtWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZDogbVszXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGU6IG1bNF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBmOiBtWzVdLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDogbmV3IERPTU1hdHJpeChtKTtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuLnNldFRyYW5zZm9ybShtYXRyaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldExpbmVhckdyYWRpZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUobGluZWFyR3JhZGllbnQsIHRoaXMuX19nZXRMaW5lYXJHcmFkaWVudCk7XG4gICAgfVxuICAgIF9fZ2V0TGluZWFyR3JhZGllbnQoKSB7XG4gICAgICAgIHZhciBjb2xvclN0b3BzID0gdGhpcy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzKCk7XG4gICAgICAgIGlmIChjb2xvclN0b3BzKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gZ2V0RHVtbXlDb250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnQoKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50KCk7XG4gICAgICAgICAgICB2YXIgZ3JkID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHN0YXJ0LngsIHN0YXJ0LnksIGVuZC54LCBlbmQueSk7XG4gICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGNvbG9yU3RvcHMubGVuZ3RoOyBuICs9IDIpIHtcbiAgICAgICAgICAgICAgICBncmQuYWRkQ29sb3JTdG9wKGNvbG9yU3RvcHNbbl0sIGNvbG9yU3RvcHNbbiArIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBncmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldFJhZGlhbEdyYWRpZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUocmFkaWFsR3JhZGllbnQsIHRoaXMuX19nZXRSYWRpYWxHcmFkaWVudCk7XG4gICAgfVxuICAgIF9fZ2V0UmFkaWFsR3JhZGllbnQoKSB7XG4gICAgICAgIHZhciBjb2xvclN0b3BzID0gdGhpcy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzKCk7XG4gICAgICAgIGlmIChjb2xvclN0b3BzKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gZ2V0RHVtbXlDb250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnQoKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50KCk7XG4gICAgICAgICAgICB2YXIgZ3JkID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHN0YXJ0LngsIHN0YXJ0LnksIHRoaXMuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXMoKSwgZW5kLngsIGVuZC55LCB0aGlzLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1cygpKTtcbiAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgY29sb3JTdG9wcy5sZW5ndGg7IG4gKz0gMikge1xuICAgICAgICAgICAgICAgIGdyZC5hZGRDb2xvclN0b3AoY29sb3JTdG9wc1tuXSwgY29sb3JTdG9wc1tuICsgMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdyZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTaGFkb3dSR0JBKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUoU0hBRE9XX1JHQkEsIHRoaXMuX2dldFNoYWRvd1JHQkEpO1xuICAgIH1cbiAgICBfZ2V0U2hhZG93UkdCQSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzU2hhZG93KCkpIHtcbiAgICAgICAgICAgIHZhciByZ2JhID0gVXRpbC5jb2xvclRvUkdCQSh0aGlzLnNoYWRvd0NvbG9yKCkpO1xuICAgICAgICAgICAgcmV0dXJuICgncmdiYSgnICtcbiAgICAgICAgICAgICAgICByZ2JhLnIgK1xuICAgICAgICAgICAgICAgICcsJyArXG4gICAgICAgICAgICAgICAgcmdiYS5nICtcbiAgICAgICAgICAgICAgICAnLCcgK1xuICAgICAgICAgICAgICAgIHJnYmEuYiArXG4gICAgICAgICAgICAgICAgJywnICtcbiAgICAgICAgICAgICAgICByZ2JhLmEgKiAodGhpcy5zaGFkb3dPcGFjaXR5KCkgfHwgMSkgK1xuICAgICAgICAgICAgICAgICcpJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzRmlsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZSgnaGFzRmlsbCcsIFtcbiAgICAgICAgICAgICdmaWxsRW5hYmxlZCcsXG4gICAgICAgICAgICAnZmlsbCcsXG4gICAgICAgICAgICAnZmlsbFBhdHRlcm5JbWFnZScsXG4gICAgICAgICAgICAnZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wcycsXG4gICAgICAgICAgICAnZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wcycsXG4gICAgICAgIF0sICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5maWxsRW5hYmxlZCgpICYmXG4gICAgICAgICAgICAgICAgISEodGhpcy5maWxsKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWxsUGF0dGVybkltYWdlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzKCkpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhc1N0cm9rZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZSgnaGFzU3Ryb2tlJywgW1xuICAgICAgICAgICAgJ3N0cm9rZUVuYWJsZWQnLFxuICAgICAgICAgICAgJ3N0cm9rZVdpZHRoJyxcbiAgICAgICAgICAgICdzdHJva2UnLFxuICAgICAgICAgICAgJ3N0cm9rZUxpbmVhckdyYWRpZW50Q29sb3JTdG9wcycsXG4gICAgICAgIF0sICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5zdHJva2VFbmFibGVkKCkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnN0cm9rZVdpZHRoKCkgJiZcbiAgICAgICAgICAgICAgICAhISh0aGlzLnN0cm9rZSgpIHx8IHRoaXMuc3Ryb2tlTGluZWFyR3JhZGllbnRDb2xvclN0b3BzKCkpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhc0hpdFN0cm9rZSgpIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmhpdFN0cm9rZVdpZHRoKCk7XG4gICAgICAgIGlmICh3aWR0aCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNTdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdHJva2VFbmFibGVkKCkgJiYgISF3aWR0aDtcbiAgICB9XG4gICAgaW50ZXJzZWN0cyhwb2ludCkge1xuICAgICAgICB2YXIgc3RhZ2UgPSB0aGlzLmdldFN0YWdlKCksIGJ1ZmZlckhpdENhbnZhcyA9IHN0YWdlLmJ1ZmZlckhpdENhbnZhcywgcDtcbiAgICAgICAgYnVmZmVySGl0Q2FudmFzLmdldENvbnRleHQoKS5jbGVhcigpO1xuICAgICAgICB0aGlzLmRyYXdIaXQoYnVmZmVySGl0Q2FudmFzLCBudWxsLCB0cnVlKTtcbiAgICAgICAgcCA9IGJ1ZmZlckhpdENhbnZhcy5jb250ZXh0LmdldEltYWdlRGF0YShNYXRoLnJvdW5kKHBvaW50LngpLCBNYXRoLnJvdW5kKHBvaW50LnkpLCAxLCAxKS5kYXRhO1xuICAgICAgICByZXR1cm4gcFszXSA+IDA7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIE5vZGUucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICAgICAgZGVsZXRlIHNoYXBlc1t0aGlzLmNvbG9yS2V5XTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY29sb3JLZXk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBfdXNlQnVmZmVyQ2FudmFzKGZvcmNlRmlsbCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5nZXRTdGFnZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGVyZmVjdERyYXdFbmFibGVkID0gKF9hID0gdGhpcy5hdHRycy5wZXJmZWN0RHJhd0VuYWJsZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWU7XG4gICAgICAgIGlmICghcGVyZmVjdERyYXdFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzRmlsbCA9IGZvcmNlRmlsbCB8fCB0aGlzLmhhc0ZpbGwoKTtcbiAgICAgICAgY29uc3QgaGFzU3Ryb2tlID0gdGhpcy5oYXNTdHJva2UoKTtcbiAgICAgICAgY29uc3QgaXNUcmFuc3BhcmVudCA9IHRoaXMuZ2V0QWJzb2x1dGVPcGFjaXR5KCkgIT09IDE7XG4gICAgICAgIGlmIChoYXNGaWxsICYmIGhhc1N0cm9rZSAmJiBpc1RyYW5zcGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNTaGFkb3cgPSB0aGlzLmhhc1NoYWRvdygpO1xuICAgICAgICBjb25zdCBzdHJva2VGb3JTaGFkb3cgPSB0aGlzLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWQoKTtcbiAgICAgICAgaWYgKGhhc0ZpbGwgJiYgaGFzU3Ryb2tlICYmIGhhc1NoYWRvdyAmJiBzdHJva2VGb3JTaGFkb3cpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2V0U3Ryb2tlSGl0RW5hYmxlZCh2YWwpIHtcbiAgICAgICAgVXRpbC53YXJuKCdzdHJva2VIaXRFbmFibGVkIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgaGl0U3Ryb2tlV2lkdGggaW5zdGVhZC4nKTtcbiAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5oaXRTdHJva2VXaWR0aCgnYXV0bycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oaXRTdHJva2VXaWR0aCgwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTdHJva2VIaXRFbmFibGVkKCkge1xuICAgICAgICBpZiAodGhpcy5oaXRTdHJva2VXaWR0aCgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTZWxmUmVjdCgpIHtcbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemUoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHRoaXMuX2NlbnRyb2lkID8gLXNpemUud2lkdGggLyAyIDogMCxcbiAgICAgICAgICAgIHk6IHRoaXMuX2NlbnRyb2lkID8gLXNpemUuaGVpZ2h0IC8gMiA6IDAsXG4gICAgICAgICAgICB3aWR0aDogc2l6ZS53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogc2l6ZS5oZWlnaHQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldENsaWVudFJlY3QoY29uZmlnID0ge30pIHtcbiAgICAgICAgY29uc3Qgc2tpcFRyYW5zZm9ybSA9IGNvbmZpZy5za2lwVHJhbnNmb3JtO1xuICAgICAgICBjb25zdCByZWxhdGl2ZVRvID0gY29uZmlnLnJlbGF0aXZlVG87XG4gICAgICAgIGNvbnN0IGZpbGxSZWN0ID0gdGhpcy5nZXRTZWxmUmVjdCgpO1xuICAgICAgICBjb25zdCBhcHBseVN0cm9rZSA9ICFjb25maWcuc2tpcFN0cm9rZSAmJiB0aGlzLmhhc1N0cm9rZSgpO1xuICAgICAgICBjb25zdCBzdHJva2VXaWR0aCA9IChhcHBseVN0cm9rZSAmJiB0aGlzLnN0cm9rZVdpZHRoKCkpIHx8IDA7XG4gICAgICAgIGNvbnN0IGZpbGxBbmRTdHJva2VXaWR0aCA9IGZpbGxSZWN0LndpZHRoICsgc3Ryb2tlV2lkdGg7XG4gICAgICAgIGNvbnN0IGZpbGxBbmRTdHJva2VIZWlnaHQgPSBmaWxsUmVjdC5oZWlnaHQgKyBzdHJva2VXaWR0aDtcbiAgICAgICAgY29uc3QgYXBwbHlTaGFkb3cgPSAhY29uZmlnLnNraXBTaGFkb3cgJiYgdGhpcy5oYXNTaGFkb3coKTtcbiAgICAgICAgY29uc3Qgc2hhZG93T2Zmc2V0WCA9IGFwcGx5U2hhZG93ID8gdGhpcy5zaGFkb3dPZmZzZXRYKCkgOiAwO1xuICAgICAgICBjb25zdCBzaGFkb3dPZmZzZXRZID0gYXBwbHlTaGFkb3cgPyB0aGlzLnNoYWRvd09mZnNldFkoKSA6IDA7XG4gICAgICAgIGNvbnN0IHByZVdpZHRoID0gZmlsbEFuZFN0cm9rZVdpZHRoICsgTWF0aC5hYnMoc2hhZG93T2Zmc2V0WCk7XG4gICAgICAgIGNvbnN0IHByZUhlaWdodCA9IGZpbGxBbmRTdHJva2VIZWlnaHQgKyBNYXRoLmFicyhzaGFkb3dPZmZzZXRZKTtcbiAgICAgICAgY29uc3QgYmx1clJhZGl1cyA9IChhcHBseVNoYWRvdyAmJiB0aGlzLnNoYWRvd0JsdXIoKSkgfHwgMDtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBwcmVXaWR0aCArIGJsdXJSYWRpdXMgKiAyO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBwcmVIZWlnaHQgKyBibHVyUmFkaXVzICogMjtcbiAgICAgICAgY29uc3QgcmVjdCA9IHtcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgeDogLShzdHJva2VXaWR0aCAvIDIgKyBibHVyUmFkaXVzKSArXG4gICAgICAgICAgICAgICAgTWF0aC5taW4oc2hhZG93T2Zmc2V0WCwgMCkgK1xuICAgICAgICAgICAgICAgIGZpbGxSZWN0LngsXG4gICAgICAgICAgICB5OiAtKHN0cm9rZVdpZHRoIC8gMiArIGJsdXJSYWRpdXMpICtcbiAgICAgICAgICAgICAgICBNYXRoLm1pbihzaGFkb3dPZmZzZXRZLCAwKSArXG4gICAgICAgICAgICAgICAgZmlsbFJlY3QueSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFza2lwVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtZWRSZWN0KHJlY3QsIHJlbGF0aXZlVG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cbiAgICBkcmF3U2NlbmUoY2FuLCB0b3ApIHtcbiAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpLCBjYW52YXMgPSBjYW4gfHwgbGF5ZXIuZ2V0Q2FudmFzKCksIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgpLCBjYWNoZWRDYW52YXMgPSB0aGlzLl9nZXRDYW52YXNDYWNoZSgpLCBkcmF3RnVuYyA9IHRoaXMuZ2V0U2NlbmVGdW5jKCksIGhhc1NoYWRvdyA9IHRoaXMuaGFzU2hhZG93KCksIHN0YWdlLCBidWZmZXJDYW52YXMsIGJ1ZmZlckNvbnRleHQ7XG4gICAgICAgIHZhciBza2lwQnVmZmVyID0gY2FudmFzLmlzQ2FjaGU7XG4gICAgICAgIHZhciBjYWNoaW5nU2VsZiA9IHRvcCA9PT0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmlzVmlzaWJsZSgpICYmICFjYWNoaW5nU2VsZikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhY2hlZENhbnZhcykge1xuICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICB2YXIgbSA9IHRoaXMuZ2V0QWJzb2x1dGVUcmFuc2Zvcm0odG9wKS5nZXRNYXRyaXgoKTtcbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNmb3JtKG1bMF0sIG1bMV0sIG1bMl0sIG1bM10sIG1bNF0sIG1bNV0pO1xuICAgICAgICAgICAgdGhpcy5fZHJhd0NhY2hlZFNjZW5lQ2FudmFzKGNvbnRleHQpO1xuICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRyYXdGdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgaWYgKHRoaXMuX3VzZUJ1ZmZlckNhbnZhcygpICYmICFza2lwQnVmZmVyKSB7XG4gICAgICAgICAgICBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKTtcbiAgICAgICAgICAgIGJ1ZmZlckNhbnZhcyA9IHN0YWdlLmJ1ZmZlckNhbnZhcztcbiAgICAgICAgICAgIGJ1ZmZlckNvbnRleHQgPSBidWZmZXJDYW52YXMuZ2V0Q29udGV4dCgpO1xuICAgICAgICAgICAgYnVmZmVyQ29udGV4dC5jbGVhcigpO1xuICAgICAgICAgICAgYnVmZmVyQ29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICBidWZmZXJDb250ZXh0Ll9hcHBseUxpbmVKb2luKHRoaXMpO1xuICAgICAgICAgICAgdmFyIG8gPSB0aGlzLmdldEFic29sdXRlVHJhbnNmb3JtKHRvcCkuZ2V0TWF0cml4KCk7XG4gICAgICAgICAgICBidWZmZXJDb250ZXh0LnRyYW5zZm9ybShvWzBdLCBvWzFdLCBvWzJdLCBvWzNdLCBvWzRdLCBvWzVdKTtcbiAgICAgICAgICAgIGRyYXdGdW5jLmNhbGwodGhpcywgYnVmZmVyQ29udGV4dCwgdGhpcyk7XG4gICAgICAgICAgICBidWZmZXJDb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIHZhciByYXRpbyA9IGJ1ZmZlckNhbnZhcy5waXhlbFJhdGlvO1xuICAgICAgICAgICAgaWYgKGhhc1NoYWRvdykge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuX2FwcGx5U2hhZG93KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5fYXBwbHlPcGFjaXR5KHRoaXMpO1xuICAgICAgICAgICAgY29udGV4dC5fYXBwbHlHbG9iYWxDb21wb3NpdGVPcGVyYXRpb24odGhpcyk7XG4gICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShidWZmZXJDYW52YXMuX2NhbnZhcywgMCwgMCwgYnVmZmVyQ2FudmFzLndpZHRoIC8gcmF0aW8sIGJ1ZmZlckNhbnZhcy5oZWlnaHQgLyByYXRpbyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0Ll9hcHBseUxpbmVKb2luKHRoaXMpO1xuICAgICAgICAgICAgaWYgKCFjYWNoaW5nU2VsZikge1xuICAgICAgICAgICAgICAgIHZhciBvID0gdGhpcy5nZXRBYnNvbHV0ZVRyYW5zZm9ybSh0b3ApLmdldE1hdHJpeCgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQudHJhbnNmb3JtKG9bMF0sIG9bMV0sIG9bMl0sIG9bM10sIG9bNF0sIG9bNV0pO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuX2FwcGx5T3BhY2l0eSh0aGlzKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0Ll9hcHBseUdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNTaGFkb3cpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Ll9hcHBseVNoYWRvdyh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRyYXdGdW5jLmNhbGwodGhpcywgY29udGV4dCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkcmF3SGl0KGNhbiwgdG9wLCBza2lwRHJhZ0NoZWNrID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNob3VsZERyYXdIaXQodG9wLCBza2lwRHJhZ0NoZWNrKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpLCBjYW52YXMgPSBjYW4gfHwgbGF5ZXIuaGl0Q2FudmFzLCBjb250ZXh0ID0gY2FudmFzICYmIGNhbnZhcy5nZXRDb250ZXh0KCksIGRyYXdGdW5jID0gdGhpcy5oaXRGdW5jKCkgfHwgdGhpcy5zY2VuZUZ1bmMoKSwgY2FjaGVkQ2FudmFzID0gdGhpcy5fZ2V0Q2FudmFzQ2FjaGUoKSwgY2FjaGVkSGl0Q2FudmFzID0gY2FjaGVkQ2FudmFzICYmIGNhY2hlZENhbnZhcy5oaXQ7XG4gICAgICAgIGlmICghdGhpcy5jb2xvcktleSkge1xuICAgICAgICAgICAgVXRpbC53YXJuKCdMb29rcyBsaWtlIHlvdXIgY2FudmFzIGhhcyBhIGRlc3Ryb3llZCBzaGFwZSBpbiBpdC4gRG8gbm90IHJldXNlIHNoYXBlIGFmdGVyIHlvdSBkZXN0cm95ZWQgaXQuIElmIHlvdSB3YW50IHRvIHJldXNlIHNoYXBlIHlvdSBzaG91bGQgY2FsbCByZW1vdmUoKSBpbnN0ZWFkIG9mIGRlc3Ryb3koKScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWNoZWRIaXRDYW52YXMpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgdmFyIG0gPSB0aGlzLmdldEFic29sdXRlVHJhbnNmb3JtKHRvcCkuZ2V0TWF0cml4KCk7XG4gICAgICAgICAgICBjb250ZXh0LnRyYW5zZm9ybShtWzBdLCBtWzFdLCBtWzJdLCBtWzNdLCBtWzRdLCBtWzVdKTtcbiAgICAgICAgICAgIHRoaXMuX2RyYXdDYWNoZWRIaXRDYW52YXMoY29udGV4dCk7XG4gICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZHJhd0Z1bmMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0Ll9hcHBseUxpbmVKb2luKHRoaXMpO1xuICAgICAgICBjb25zdCBzZWxmQ2FjaGUgPSB0aGlzID09PSB0b3A7XG4gICAgICAgIGlmICghc2VsZkNhY2hlKSB7XG4gICAgICAgICAgICB2YXIgbyA9IHRoaXMuZ2V0QWJzb2x1dGVUcmFuc2Zvcm0odG9wKS5nZXRNYXRyaXgoKTtcbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNmb3JtKG9bMF0sIG9bMV0sIG9bMl0sIG9bM10sIG9bNF0sIG9bNV0pO1xuICAgICAgICB9XG4gICAgICAgIGRyYXdGdW5jLmNhbGwodGhpcywgY29udGV4dCwgdGhpcyk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZHJhd0hpdEZyb21DYWNoZShhbHBoYVRocmVzaG9sZCA9IDApIHtcbiAgICAgICAgdmFyIGNhY2hlZENhbnZhcyA9IHRoaXMuX2dldENhbnZhc0NhY2hlKCksIHNjZW5lQ2FudmFzID0gdGhpcy5fZ2V0Q2FjaGVkU2NlbmVDYW52YXMoKSwgaGl0Q2FudmFzID0gY2FjaGVkQ2FudmFzLmhpdCwgaGl0Q29udGV4dCA9IGhpdENhbnZhcy5nZXRDb250ZXh0KCksIGhpdFdpZHRoID0gaGl0Q2FudmFzLmdldFdpZHRoKCksIGhpdEhlaWdodCA9IGhpdENhbnZhcy5nZXRIZWlnaHQoKSwgaGl0SW1hZ2VEYXRhLCBoaXREYXRhLCBsZW4sIHJnYkNvbG9yS2V5LCBpLCBhbHBoYTtcbiAgICAgICAgaGl0Q29udGV4dC5jbGVhcigpO1xuICAgICAgICBoaXRDb250ZXh0LmRyYXdJbWFnZShzY2VuZUNhbnZhcy5fY2FudmFzLCAwLCAwLCBoaXRXaWR0aCwgaGl0SGVpZ2h0KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGhpdEltYWdlRGF0YSA9IGhpdENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGhpdFdpZHRoLCBoaXRIZWlnaHQpO1xuICAgICAgICAgICAgaGl0RGF0YSA9IGhpdEltYWdlRGF0YS5kYXRhO1xuICAgICAgICAgICAgbGVuID0gaGl0RGF0YS5sZW5ndGg7XG4gICAgICAgICAgICByZ2JDb2xvcktleSA9IFV0aWwuX2hleFRvUmdiKHRoaXMuY29sb3JLZXkpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgICAgICAgICAgYWxwaGEgPSBoaXREYXRhW2kgKyAzXTtcbiAgICAgICAgICAgICAgICBpZiAoYWxwaGEgPiBhbHBoYVRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICBoaXREYXRhW2ldID0gcmdiQ29sb3JLZXkucjtcbiAgICAgICAgICAgICAgICAgICAgaGl0RGF0YVtpICsgMV0gPSByZ2JDb2xvcktleS5nO1xuICAgICAgICAgICAgICAgICAgICBoaXREYXRhW2kgKyAyXSA9IHJnYkNvbG9yS2V5LmI7XG4gICAgICAgICAgICAgICAgICAgIGhpdERhdGFbaSArIDNdID0gMjU1O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGl0RGF0YVtpICsgM10gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhpdENvbnRleHQucHV0SW1hZ2VEYXRhKGhpdEltYWdlRGF0YSwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIFV0aWwuZXJyb3IoJ1VuYWJsZSB0byBkcmF3IGhpdCBncmFwaCBmcm9tIGNhY2hlZCBzY2VuZSBjYW52YXMuICcgKyBlLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBoYXNQb2ludGVyQ2FwdHVyZShwb2ludGVySWQpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50ZXJFdmVudHMuaGFzUG9pbnRlckNhcHR1cmUocG9pbnRlcklkLCB0aGlzKTtcbiAgICB9XG4gICAgc2V0UG9pbnRlckNhcHR1cmUocG9pbnRlcklkKSB7XG4gICAgICAgIFBvaW50ZXJFdmVudHMuc2V0UG9pbnRlckNhcHR1cmUocG9pbnRlcklkLCB0aGlzKTtcbiAgICB9XG4gICAgcmVsZWFzZUNhcHR1cmUocG9pbnRlcklkKSB7XG4gICAgICAgIFBvaW50ZXJFdmVudHMucmVsZWFzZUNhcHR1cmUocG9pbnRlcklkLCB0aGlzKTtcbiAgICB9XG59XG5TaGFwZS5wcm90b3R5cGUuX2ZpbGxGdW5jID0gX2ZpbGxGdW5jO1xuU2hhcGUucHJvdG90eXBlLl9zdHJva2VGdW5jID0gX3N0cm9rZUZ1bmM7XG5TaGFwZS5wcm90b3R5cGUuX2ZpbGxGdW5jSGl0ID0gX2ZpbGxGdW5jSGl0O1xuU2hhcGUucHJvdG90eXBlLl9zdHJva2VGdW5jSGl0ID0gX3N0cm9rZUZ1bmNIaXQ7XG5TaGFwZS5wcm90b3R5cGUuX2NlbnRyb2lkID0gZmFsc2U7XG5TaGFwZS5wcm90b3R5cGUubm9kZVR5cGUgPSAnU2hhcGUnO1xuX3JlZ2lzdGVyTm9kZShTaGFwZSk7XG5TaGFwZS5wcm90b3R5cGUuZXZlbnRMaXN0ZW5lcnMgPSB7fTtcblNoYXBlLnByb3RvdHlwZS5vbi5jYWxsKFNoYXBlLnByb3RvdHlwZSwgJ3NoYWRvd0NvbG9yQ2hhbmdlLmtvbnZhIHNoYWRvd0JsdXJDaGFuZ2Uua29udmEgc2hhZG93T2Zmc2V0Q2hhbmdlLmtvbnZhIHNoYWRvd09wYWNpdHlDaGFuZ2Uua29udmEgc2hhZG93RW5hYmxlZENoYW5nZS5rb252YScsIF9jbGVhckhhc1NoYWRvd0NhY2hlKTtcblNoYXBlLnByb3RvdHlwZS5vbi5jYWxsKFNoYXBlLnByb3RvdHlwZSwgJ3NoYWRvd0NvbG9yQ2hhbmdlLmtvbnZhIHNoYWRvd09wYWNpdHlDaGFuZ2Uua29udmEgc2hhZG93RW5hYmxlZENoYW5nZS5rb252YScsIF9jbGVhckdldFNoYWRvd1JHQkFDYWNoZSk7XG5TaGFwZS5wcm90b3R5cGUub24uY2FsbChTaGFwZS5wcm90b3R5cGUsICdmaWxsUHJpb3JpdHlDaGFuZ2Uua29udmEgZmlsbFBhdHRlcm5JbWFnZUNoYW5nZS5rb252YSBmaWxsUGF0dGVyblJlcGVhdENoYW5nZS5rb252YSBmaWxsUGF0dGVyblNjYWxlWENoYW5nZS5rb252YSBmaWxsUGF0dGVyblNjYWxlWUNoYW5nZS5rb252YSBmaWxsUGF0dGVybk9mZnNldFhDaGFuZ2Uua29udmEgZmlsbFBhdHRlcm5PZmZzZXRZQ2hhbmdlLmtvbnZhIGZpbGxQYXR0ZXJuWENoYW5nZS5rb252YSBmaWxsUGF0dGVybllDaGFuZ2Uua29udmEgZmlsbFBhdHRlcm5Sb3RhdGlvbkNoYW5nZS5rb252YScsIF9jbGVhckZpbGxQYXR0ZXJuQ2FjaGUpO1xuU2hhcGUucHJvdG90eXBlLm9uLmNhbGwoU2hhcGUucHJvdG90eXBlLCAnZmlsbFByaW9yaXR5Q2hhbmdlLmtvbnZhIGZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNDaGFuZ2Uua29udmEgZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhDaGFuZ2Uua29udmEgZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFlDaGFuZ2Uua29udmEgZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYQ2hhbmdlLmtvbnZhIGZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WUNoYW5nZS5rb252YScsIF9jbGVhckxpbmVhckdyYWRpZW50Q2FjaGUpO1xuU2hhcGUucHJvdG90eXBlLm9uLmNhbGwoU2hhcGUucHJvdG90eXBlLCAnZmlsbFByaW9yaXR5Q2hhbmdlLmtvbnZhIGZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNDaGFuZ2Uua29udmEgZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhDaGFuZ2Uua29udmEgZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFlDaGFuZ2Uua29udmEgZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYQ2hhbmdlLmtvbnZhIGZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WUNoYW5nZS5rb252YSBmaWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c0NoYW5nZS5rb252YSBmaWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNDaGFuZ2Uua29udmEnLCBfY2xlYXJSYWRpYWxHcmFkaWVudENhY2hlKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFNoYXBlLCAnc3Ryb2tlJywgdW5kZWZpbmVkLCBnZXRTdHJpbmdPckdyYWRpZW50VmFsaWRhdG9yKCkpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoU2hhcGUsICdzdHJva2VXaWR0aCcsIDIsIGdldE51bWJlclZhbGlkYXRvcigpKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFNoYXBlLCAnZmlsbEFmdGVyU3Ryb2tlRW5hYmxlZCcsIGZhbHNlKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFNoYXBlLCAnaGl0U3Ryb2tlV2lkdGgnLCAnYXV0bycsIGdldE51bWJlck9yQXV0b1ZhbGlkYXRvcigpKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFNoYXBlLCAnc3Ryb2tlSGl0RW5hYmxlZCcsIHRydWUsIGdldEJvb2xlYW5WYWxpZGF0b3IoKSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihTaGFwZSwgJ3BlcmZlY3REcmF3RW5hYmxlZCcsIHRydWUsIGdldEJvb2xlYW5WYWxpZGF0b3IoKSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihTaGFwZSwgJ3NoYWRvd0ZvclN0cm9rZUVuYWJsZWQnLCB0cnVlLCBnZXRCb29sZWFuVmFsaWRhdG9yKCkpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoU2hhcGUsICdsaW5lSm9pbicpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoU2hhcGUsICdsaW5lQ2FwJyk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihTaGFwZSwgJ3NjZW5lRnVuYycpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoU2hhcGUsICdoaXRGdW5jJyk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihTaGFwZSwgJ2Rhc2gnKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFNoYXBlLCAnZGFzaE9mZnNldCcsIDAsIGdldE51bWJlclZhbGlkYXRvcigpKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFNoYXBlLCAnc2hhZG93Q29sb3InLCB1bmRlZmluZWQsIGdldFN0cmluZ1ZhbGlkYXRvcigpKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFNoYXBlLCAnc2hhZG93Qmx1cicsIDAsIGdldE51bWJlclZhbGlkYXRvcigpKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFNoYXBlLCAnc2hhZG93T3BhY2l0eScsIDEsIGdldE51bWJlclZhbGlkYXRvcigpKTtcbkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihTaGFwZSwgJ3NoYWRvd09mZnNldCcsIFsneCcsICd5J10pO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoU2hhcGUsICdzaGFkb3dPZmZzZXRYJywgMCwgZ2V0TnVtYmVyVmFsaWRhdG9yKCkpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoU2hhcGUsICdzaGFkb3dPZmZzZXRZJywgMCwgZ2V0TnVtYmVyVmFsaWRhdG9yKCkpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoU2hhcGUsICdmaWxsUGF0dGVybkltYWdlJyk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihTaGFwZSwgJ2ZpbGwnLCB1bmRlZmluZWQsIGdldFN0cmluZ09yR3JhZGllbnRWYWxpZGF0b3IoKSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihTaGFwZSwgJ2ZpbGxQYXR0ZXJuWCcsIDAsIGdldE51bWJlclZhbGlkYXRvcigpKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFNoYXBlLCAnZmlsbFBhdHRlcm5ZJywgMCwgZ2V0TnVtYmVyVmFsaWRhdG9yKCkpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoU2hhcGUsICdmaWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzJyk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihTaGFwZSwgJ3N0cm9rZUxpbmVhckdyYWRpZW50Q29sb3JTdG9wcycpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoU2hhcGUsICdmaWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1cycsIDApO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoU2hhcGUsICdmaWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXMnLCAwKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFNoYXBlLCAnZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wcycpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoU2hhcGUsICdmaWxsUGF0dGVyblJlcGVhdCcsICdyZXBlYXQnKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFNoYXBlLCAnZmlsbEVuYWJsZWQnLCB0cnVlKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFNoYXBlLCAnc3Ryb2tlRW5hYmxlZCcsIHRydWUpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoU2hhcGUsICdzaGFkb3dFbmFibGVkJywgdHJ1ZSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihTaGFwZSwgJ2Rhc2hFbmFibGVkJywgdHJ1ZSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihTaGFwZSwgJ3N0cm9rZVNjYWxlRW5hYmxlZCcsIHRydWUpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoU2hhcGUsICdmaWxsUHJpb3JpdHknLCAnY29sb3InKTtcbkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihTaGFwZSwgJ2ZpbGxQYXR0ZXJuT2Zmc2V0JywgWyd4JywgJ3knXSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihTaGFwZSwgJ2ZpbGxQYXR0ZXJuT2Zmc2V0WCcsIDAsIGdldE51bWJlclZhbGlkYXRvcigpKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFNoYXBlLCAnZmlsbFBhdHRlcm5PZmZzZXRZJywgMCwgZ2V0TnVtYmVyVmFsaWRhdG9yKCkpO1xuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKFNoYXBlLCAnZmlsbFBhdHRlcm5TY2FsZScsIFsneCcsICd5J10pO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoU2hhcGUsICdmaWxsUGF0dGVyblNjYWxlWCcsIDEsIGdldE51bWJlclZhbGlkYXRvcigpKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFNoYXBlLCAnZmlsbFBhdHRlcm5TY2FsZVknLCAxLCBnZXROdW1iZXJWYWxpZGF0b3IoKSk7XG5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoU2hhcGUsICdmaWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50JywgW1xuICAgICd4JyxcbiAgICAneScsXG5dKTtcbkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihTaGFwZSwgJ3N0cm9rZUxpbmVhckdyYWRpZW50U3RhcnRQb2ludCcsIFtcbiAgICAneCcsXG4gICAgJ3knLFxuXSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihTaGFwZSwgJ2ZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYJywgMCk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihTaGFwZSwgJ3N0cm9rZUxpbmVhckdyYWRpZW50U3RhcnRQb2ludFgnLCAwKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFNoYXBlLCAnZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFknLCAwKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFNoYXBlLCAnc3Ryb2tlTGluZWFyR3JhZGllbnRTdGFydFBvaW50WScsIDApO1xuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKFNoYXBlLCAnZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnQnLCBbXG4gICAgJ3gnLFxuICAgICd5Jyxcbl0pO1xuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKFNoYXBlLCAnc3Ryb2tlTGluZWFyR3JhZGllbnRFbmRQb2ludCcsIFtcbiAgICAneCcsXG4gICAgJ3knLFxuXSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihTaGFwZSwgJ2ZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WCcsIDApO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoU2hhcGUsICdzdHJva2VMaW5lYXJHcmFkaWVudEVuZFBvaW50WCcsIDApO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoU2hhcGUsICdmaWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFknLCAwKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFNoYXBlLCAnc3Ryb2tlTGluZWFyR3JhZGllbnRFbmRQb2ludFknLCAwKTtcbkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihTaGFwZSwgJ2ZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnQnLCBbXG4gICAgJ3gnLFxuICAgICd5Jyxcbl0pO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoU2hhcGUsICdmaWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WCcsIDApO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoU2hhcGUsICdmaWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WScsIDApO1xuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKFNoYXBlLCAnZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnQnLCBbXG4gICAgJ3gnLFxuICAgICd5Jyxcbl0pO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoU2hhcGUsICdmaWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFgnLCAwKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFNoYXBlLCAnZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZJywgMCk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihTaGFwZSwgJ2ZpbGxQYXR0ZXJuUm90YXRpb24nLCAwKTtcbkZhY3RvcnkuYmFja0NvbXBhdChTaGFwZSwge1xuICAgIGRhc2hBcnJheTogJ2Rhc2gnLFxuICAgIGdldERhc2hBcnJheTogJ2dldERhc2gnLFxuICAgIHNldERhc2hBcnJheTogJ2dldERhc2gnLFxuICAgIGRyYXdGdW5jOiAnc2NlbmVGdW5jJyxcbiAgICBnZXREcmF3RnVuYzogJ2dldFNjZW5lRnVuYycsXG4gICAgc2V0RHJhd0Z1bmM6ICdzZXRTY2VuZUZ1bmMnLFxuICAgIGRyYXdIaXRGdW5jOiAnaGl0RnVuYycsXG4gICAgZ2V0RHJhd0hpdEZ1bmM6ICdnZXRIaXRGdW5jJyxcbiAgICBzZXREcmF3SGl0RnVuYzogJ3NldEhpdEZ1bmMnLFxufSk7XG4iLCJpbXBvcnQgeyBVdGlsIH0gZnJvbSAnLi9VdGlsLmpzJztcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gJy4vQ29udGFpbmVyLmpzJztcbmltcG9ydCB7IE5vZGUgfSBmcm9tICcuL05vZGUuanMnO1xuaW1wb3J0IHsgRmFjdG9yeSB9IGZyb20gJy4vRmFjdG9yeS5qcyc7XG5pbXBvcnQgeyBTY2VuZUNhbnZhcywgSGl0Q2FudmFzIH0gZnJvbSAnLi9DYW52YXMuanMnO1xuaW1wb3J0IHsgZ2V0Qm9vbGVhblZhbGlkYXRvciB9IGZyb20gJy4vVmFsaWRhdG9ycy5qcyc7XG5pbXBvcnQgeyBzaGFwZXMgfSBmcm9tICcuL1NoYXBlLmpzJztcbmltcG9ydCB7IF9yZWdpc3Rlck5vZGUgfSBmcm9tICcuL0dsb2JhbC5qcyc7XG52YXIgSEFTSCA9ICcjJywgQkVGT1JFX0RSQVcgPSAnYmVmb3JlRHJhdycsIERSQVcgPSAnZHJhdycsIElOVEVSU0VDVElPTl9PRkZTRVRTID0gW1xuICAgIHsgeDogMCwgeTogMCB9LFxuICAgIHsgeDogLTEsIHk6IC0xIH0sXG4gICAgeyB4OiAxLCB5OiAtMSB9LFxuICAgIHsgeDogMSwgeTogMSB9LFxuICAgIHsgeDogLTEsIHk6IDEgfSxcbl0sIElOVEVSU0VDVElPTl9PRkZTRVRTX0xFTiA9IElOVEVSU0VDVElPTl9PRkZTRVRTLmxlbmd0aDtcbmV4cG9ydCBjbGFzcyBMYXllciBleHRlbmRzIENvbnRhaW5lciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG4gICAgICAgIHRoaXMuY2FudmFzID0gbmV3IFNjZW5lQ2FudmFzKCk7XG4gICAgICAgIHRoaXMuaGl0Q2FudmFzID0gbmV3IEhpdENhbnZhcyh7XG4gICAgICAgICAgICBwaXhlbFJhdGlvOiAxLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fd2FpdGluZ0ZvckRyYXcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbigndmlzaWJsZUNoYW5nZS5rb252YScsIHRoaXMuX2NoZWNrVmlzaWJpbGl0eSk7XG4gICAgICAgIHRoaXMuX2NoZWNrVmlzaWJpbGl0eSgpO1xuICAgICAgICB0aGlzLm9uKCdpbWFnZVNtb290aGluZ0VuYWJsZWRDaGFuZ2Uua29udmEnLCB0aGlzLl9zZXRTbW9vdGhFbmFibGVkKTtcbiAgICAgICAgdGhpcy5fc2V0U21vb3RoRW5hYmxlZCgpO1xuICAgIH1cbiAgICBjcmVhdGVQTkdTdHJlYW0oKSB7XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzLmNhbnZhcy5fY2FudmFzO1xuICAgICAgICByZXR1cm4gYy5jcmVhdGVQTkdTdHJlYW0oKTtcbiAgICB9XG4gICAgZ2V0Q2FudmFzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXM7XG4gICAgfVxuICAgIGdldE5hdGl2ZUNhbnZhc0VsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5fY2FudmFzO1xuICAgIH1cbiAgICBnZXRIaXRDYW52YXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhpdENhbnZhcztcbiAgICB9XG4gICAgZ2V0Q29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2FudmFzKCkuZ2V0Q29udGV4dCgpO1xuICAgIH1cbiAgICBjbGVhcihib3VuZHMpIHtcbiAgICAgICAgdGhpcy5nZXRDb250ZXh0KCkuY2xlYXIoYm91bmRzKTtcbiAgICAgICAgdGhpcy5nZXRIaXRDYW52YXMoKS5nZXRDb250ZXh0KCkuY2xlYXIoYm91bmRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldFpJbmRleChpbmRleCkge1xuICAgICAgICBzdXBlci5zZXRaSW5kZXgoaW5kZXgpO1xuICAgICAgICB2YXIgc3RhZ2UgPSB0aGlzLmdldFN0YWdlKCk7XG4gICAgICAgIGlmIChzdGFnZSAmJiBzdGFnZS5jb250ZW50KSB7XG4gICAgICAgICAgICBzdGFnZS5jb250ZW50LnJlbW92ZUNoaWxkKHRoaXMuZ2V0TmF0aXZlQ2FudmFzRWxlbWVudCgpKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IHN0YWdlLmNoaWxkcmVuLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBzdGFnZS5jb250ZW50Lmluc2VydEJlZm9yZSh0aGlzLmdldE5hdGl2ZUNhbnZhc0VsZW1lbnQoKSwgc3RhZ2UuY2hpbGRyZW5baW5kZXggKyAxXS5nZXRDYW52YXMoKS5fY2FudmFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YWdlLmNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5nZXROYXRpdmVDYW52YXNFbGVtZW50KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBtb3ZlVG9Ub3AoKSB7XG4gICAgICAgIE5vZGUucHJvdG90eXBlLm1vdmVUb1RvcC5jYWxsKHRoaXMpO1xuICAgICAgICB2YXIgc3RhZ2UgPSB0aGlzLmdldFN0YWdlKCk7XG4gICAgICAgIGlmIChzdGFnZSAmJiBzdGFnZS5jb250ZW50KSB7XG4gICAgICAgICAgICBzdGFnZS5jb250ZW50LnJlbW92ZUNoaWxkKHRoaXMuZ2V0TmF0aXZlQ2FudmFzRWxlbWVudCgpKTtcbiAgICAgICAgICAgIHN0YWdlLmNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5nZXROYXRpdmVDYW52YXNFbGVtZW50KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBtb3ZlVXAoKSB7XG4gICAgICAgIHZhciBtb3ZlZCA9IE5vZGUucHJvdG90eXBlLm1vdmVVcC5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAoIW1vdmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpO1xuICAgICAgICBpZiAoIXN0YWdlIHx8ICFzdGFnZS5jb250ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3RhZ2UuY29udGVudC5yZW1vdmVDaGlsZCh0aGlzLmdldE5hdGl2ZUNhbnZhc0VsZW1lbnQoKSk7XG4gICAgICAgIGlmICh0aGlzLmluZGV4IDwgc3RhZ2UuY2hpbGRyZW4ubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgc3RhZ2UuY29udGVudC5pbnNlcnRCZWZvcmUodGhpcy5nZXROYXRpdmVDYW52YXNFbGVtZW50KCksIHN0YWdlLmNoaWxkcmVuW3RoaXMuaW5kZXggKyAxXS5nZXRDYW52YXMoKS5fY2FudmFzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YWdlLmNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5nZXROYXRpdmVDYW52YXNFbGVtZW50KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBtb3ZlRG93bigpIHtcbiAgICAgICAgaWYgKE5vZGUucHJvdG90eXBlLm1vdmVEb3duLmNhbGwodGhpcykpIHtcbiAgICAgICAgICAgIHZhciBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKTtcbiAgICAgICAgICAgIGlmIChzdGFnZSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHN0YWdlLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgIGlmIChzdGFnZS5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWdlLmNvbnRlbnQucmVtb3ZlQ2hpbGQodGhpcy5nZXROYXRpdmVDYW52YXNFbGVtZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICBzdGFnZS5jb250ZW50Lmluc2VydEJlZm9yZSh0aGlzLmdldE5hdGl2ZUNhbnZhc0VsZW1lbnQoKSwgY2hpbGRyZW5bdGhpcy5pbmRleCArIDFdLmdldENhbnZhcygpLl9jYW52YXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbW92ZVRvQm90dG9tKCkge1xuICAgICAgICBpZiAoTm9kZS5wcm90b3R5cGUubW92ZVRvQm90dG9tLmNhbGwodGhpcykpIHtcbiAgICAgICAgICAgIHZhciBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKTtcbiAgICAgICAgICAgIGlmIChzdGFnZSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHN0YWdlLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgIGlmIChzdGFnZS5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWdlLmNvbnRlbnQucmVtb3ZlQ2hpbGQodGhpcy5nZXROYXRpdmVDYW52YXNFbGVtZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICBzdGFnZS5jb250ZW50Lmluc2VydEJlZm9yZSh0aGlzLmdldE5hdGl2ZUNhbnZhc0VsZW1lbnQoKSwgY2hpbGRyZW5bMV0uZ2V0Q2FudmFzKCkuX2NhbnZhcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXRMYXllcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlbW92ZSgpIHtcbiAgICAgICAgdmFyIF9jYW52YXMgPSB0aGlzLmdldE5hdGl2ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgICAgTm9kZS5wcm90b3R5cGUucmVtb3ZlLmNhbGwodGhpcyk7XG4gICAgICAgIGlmIChfY2FudmFzICYmIF9jYW52YXMucGFyZW50Tm9kZSAmJiBVdGlsLl9pc0luRG9jdW1lbnQoX2NhbnZhcykpIHtcbiAgICAgICAgICAgIF9jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChfY2FudmFzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0U3RhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgICB9XG4gICAgc2V0U2l6ZSh7IHdpZHRoLCBoZWlnaHQgfSkge1xuICAgICAgICB0aGlzLmNhbnZhcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmhpdENhbnZhcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLl9zZXRTbW9vdGhFbmFibGVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBfdmFsaWRhdGVBZGQoY2hpbGQpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBjaGlsZC5nZXRUeXBlKCk7XG4gICAgICAgIGlmICh0eXBlICE9PSAnR3JvdXAnICYmIHR5cGUgIT09ICdTaGFwZScpIHtcbiAgICAgICAgICAgIFV0aWwudGhyb3coJ1lvdSBtYXkgb25seSBhZGQgZ3JvdXBzIGFuZCBzaGFwZXMgdG8gYSBsYXllci4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfdG9Lb252YUNhbnZhcyhjb25maWcpIHtcbiAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgICBjb25maWcud2lkdGggPSBjb25maWcud2lkdGggfHwgdGhpcy5nZXRXaWR0aCgpO1xuICAgICAgICBjb25maWcuaGVpZ2h0ID0gY29uZmlnLmhlaWdodCB8fCB0aGlzLmdldEhlaWdodCgpO1xuICAgICAgICBjb25maWcueCA9IGNvbmZpZy54ICE9PSB1bmRlZmluZWQgPyBjb25maWcueCA6IHRoaXMueCgpO1xuICAgICAgICBjb25maWcueSA9IGNvbmZpZy55ICE9PSB1bmRlZmluZWQgPyBjb25maWcueSA6IHRoaXMueSgpO1xuICAgICAgICByZXR1cm4gTm9kZS5wcm90b3R5cGUuX3RvS29udmFDYW52YXMuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgIH1cbiAgICBfY2hlY2tWaXNpYmlsaXR5KCkge1xuICAgICAgICBjb25zdCB2aXNpYmxlID0gdGhpcy52aXNpYmxlKCk7XG4gICAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5fY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuX2NhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9zZXRTbW9vdGhFbmFibGVkKCkge1xuICAgICAgICB0aGlzLmdldENvbnRleHQoKS5fY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPVxuICAgICAgICAgICAgdGhpcy5pbWFnZVNtb290aGluZ0VuYWJsZWQoKTtcbiAgICB9XG4gICAgZ2V0V2lkdGgoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LndpZHRoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0V2lkdGgoKSB7XG4gICAgICAgIFV0aWwud2FybignQ2FuIG5vdCBjaGFuZ2Ugd2lkdGggb2YgbGF5ZXIuIFVzZSBcInN0YWdlLndpZHRoKHZhbHVlKVwiIGZ1bmN0aW9uIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIGdldEhlaWdodCgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuaGVpZ2h0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0SGVpZ2h0KCkge1xuICAgICAgICBVdGlsLndhcm4oJ0NhbiBub3QgY2hhbmdlIGhlaWdodCBvZiBsYXllci4gVXNlIFwic3RhZ2UuaGVpZ2h0KHZhbHVlKVwiIGZ1bmN0aW9uIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIGJhdGNoRHJhdygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl93YWl0aW5nRm9yRHJhdykge1xuICAgICAgICAgICAgdGhpcy5fd2FpdGluZ0ZvckRyYXcgPSB0cnVlO1xuICAgICAgICAgICAgVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXcoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93YWl0aW5nRm9yRHJhdyA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldEludGVyc2VjdGlvbihwb3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzTGlzdGVuaW5nKCkgfHwgIXRoaXMuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzcGlyYWxTZWFyY2hEaXN0YW5jZSA9IDE7XG4gICAgICAgIHZhciBjb250aW51ZVNlYXJjaCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBJTlRFUlNFQ1RJT05fT0ZGU0VUU19MRU47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdGlvbk9mZnNldCA9IElOVEVSU0VDVElPTl9PRkZTRVRTW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuX2dldEludGVyc2VjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHg6IHBvcy54ICsgaW50ZXJzZWN0aW9uT2Zmc2V0LnggKiBzcGlyYWxTZWFyY2hEaXN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgeTogcG9zLnkgKyBpbnRlcnNlY3Rpb25PZmZzZXQueSAqIHNwaXJhbFNlYXJjaERpc3RhbmNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNoYXBlID0gb2JqLnNoYXBlO1xuICAgICAgICAgICAgICAgIGlmIChzaGFwZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlU2VhcmNoID0gISFvYmouYW50aWFsaWFzZWQ7XG4gICAgICAgICAgICAgICAgaWYgKCFvYmouYW50aWFsaWFzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRpbnVlU2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgc3BpcmFsU2VhcmNoRGlzdGFuY2UgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9nZXRJbnRlcnNlY3Rpb24ocG9zKSB7XG4gICAgICAgIGNvbnN0IHJhdGlvID0gdGhpcy5oaXRDYW52YXMucGl4ZWxSYXRpbztcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuaGl0Q2FudmFzLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKE1hdGgucm91bmQocG9zLnggKiByYXRpbyksIE1hdGgucm91bmQocG9zLnkgKiByYXRpbyksIDEsIDEpLmRhdGE7XG4gICAgICAgIGNvbnN0IHAzID0gcFszXTtcbiAgICAgICAgaWYgKHAzID09PSAyNTUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yS2V5ID0gVXRpbC5fcmdiVG9IZXgocFswXSwgcFsxXSwgcFsyXSk7XG4gICAgICAgICAgICBjb25zdCBzaGFwZSA9IHNoYXBlc1tIQVNIICsgY29sb3JLZXldO1xuICAgICAgICAgICAgaWYgKHNoYXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHNoYXBlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFudGlhbGlhc2VkOiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwMyA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYW50aWFsaWFzZWQ6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgZHJhd1NjZW5lKGNhbiwgdG9wKSB7XG4gICAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKSwgY2FudmFzID0gY2FuIHx8IChsYXllciAmJiBsYXllci5nZXRDYW52YXMoKSk7XG4gICAgICAgIHRoaXMuX2ZpcmUoQkVGT1JFX0RSQVcsIHtcbiAgICAgICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5jbGVhckJlZm9yZURyYXcoKSkge1xuICAgICAgICAgICAgY2FudmFzLmdldENvbnRleHQoKS5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIENvbnRhaW5lci5wcm90b3R5cGUuZHJhd1NjZW5lLmNhbGwodGhpcywgY2FudmFzLCB0b3ApO1xuICAgICAgICB0aGlzLl9maXJlKERSQVcsIHtcbiAgICAgICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZHJhd0hpdChjYW4sIHRvcCkge1xuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCksIGNhbnZhcyA9IGNhbiB8fCAobGF5ZXIgJiYgbGF5ZXIuaGl0Q2FudmFzKTtcbiAgICAgICAgaWYgKGxheWVyICYmIGxheWVyLmNsZWFyQmVmb3JlRHJhdygpKSB7XG4gICAgICAgICAgICBsYXllci5nZXRIaXRDYW52YXMoKS5nZXRDb250ZXh0KCkuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBDb250YWluZXIucHJvdG90eXBlLmRyYXdIaXQuY2FsbCh0aGlzLCBjYW52YXMsIHRvcCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBlbmFibGVIaXRHcmFwaCgpIHtcbiAgICAgICAgdGhpcy5oaXRHcmFwaEVuYWJsZWQodHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaXNhYmxlSGl0R3JhcGgoKSB7XG4gICAgICAgIHRoaXMuaGl0R3JhcGhFbmFibGVkKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldEhpdEdyYXBoRW5hYmxlZCh2YWwpIHtcbiAgICAgICAgVXRpbC53YXJuKCdoaXRHcmFwaEVuYWJsZWQgbWV0aG9kIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgbGF5ZXIubGlzdGVuaW5nKCkgaW5zdGVhZC4nKTtcbiAgICAgICAgdGhpcy5saXN0ZW5pbmcodmFsKTtcbiAgICB9XG4gICAgZ2V0SGl0R3JhcGhFbmFibGVkKHZhbCkge1xuICAgICAgICBVdGlsLndhcm4oJ2hpdEdyYXBoRW5hYmxlZCBtZXRob2QgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBsYXllci5saXN0ZW5pbmcoKSBpbnN0ZWFkLicpO1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5pbmcoKTtcbiAgICB9XG4gICAgdG9nZ2xlSGl0Q2FudmFzKCkge1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50IHx8ICF0aGlzLnBhcmVudFsnY29udGVudCddKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICB2YXIgYWRkZWQgPSAhIXRoaXMuaGl0Q2FudmFzLl9jYW52YXMucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKGFkZGVkKSB7XG4gICAgICAgICAgICBwYXJlbnQuY29udGVudC5yZW1vdmVDaGlsZCh0aGlzLmhpdENhbnZhcy5fY2FudmFzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudC5jb250ZW50LmFwcGVuZENoaWxkKHRoaXMuaGl0Q2FudmFzLl9jYW52YXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuTGF5ZXIucHJvdG90eXBlLm5vZGVUeXBlID0gJ0xheWVyJztcbl9yZWdpc3Rlck5vZGUoTGF5ZXIpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoTGF5ZXIsICdpbWFnZVNtb290aGluZ0VuYWJsZWQnLCB0cnVlKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKExheWVyLCAnY2xlYXJCZWZvcmVEcmF3JywgdHJ1ZSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihMYXllciwgJ2hpdEdyYXBoRW5hYmxlZCcsIHRydWUsIGdldEJvb2xlYW5WYWxpZGF0b3IoKSk7XG4iLCJpbXBvcnQgeyBVdGlsIH0gZnJvbSAnLi9VdGlsLmpzJztcbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi9MYXllci5qcyc7XG5pbXBvcnQgeyBfcmVnaXN0ZXJOb2RlIH0gZnJvbSAnLi9HbG9iYWwuanMnO1xuZXhwb3J0IGNsYXNzIEZhc3RMYXllciBleHRlbmRzIExheWVyIHtcbiAgICBjb25zdHJ1Y3RvcihhdHRycykge1xuICAgICAgICBzdXBlcihhdHRycyk7XG4gICAgICAgIHRoaXMubGlzdGVuaW5nKGZhbHNlKTtcbiAgICAgICAgVXRpbC53YXJuKCdLb252YS5GYXN0IGxheWVyIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCJuZXcgS29udmEuTGF5ZXIoeyBsaXN0ZW5pbmc6IGZhbHNlIH0pXCIgaW5zdGVhZC4nKTtcbiAgICB9XG59XG5GYXN0TGF5ZXIucHJvdG90eXBlLm5vZGVUeXBlID0gJ0Zhc3RMYXllcic7XG5fcmVnaXN0ZXJOb2RlKEZhc3RMYXllcik7XG4iLCJpbXBvcnQgeyBVdGlsIH0gZnJvbSAnLi9VdGlsLmpzJztcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gJy4vQ29udGFpbmVyLmpzJztcbmltcG9ydCB7IF9yZWdpc3Rlck5vZGUgfSBmcm9tICcuL0dsb2JhbC5qcyc7XG5leHBvcnQgY2xhc3MgR3JvdXAgZXh0ZW5kcyBDb250YWluZXIge1xuICAgIF92YWxpZGF0ZUFkZChjaGlsZCkge1xuICAgICAgICB2YXIgdHlwZSA9IGNoaWxkLmdldFR5cGUoKTtcbiAgICAgICAgaWYgKHR5cGUgIT09ICdHcm91cCcgJiYgdHlwZSAhPT0gJ1NoYXBlJykge1xuICAgICAgICAgICAgVXRpbC50aHJvdygnWW91IG1heSBvbmx5IGFkZCBncm91cHMgYW5kIHNoYXBlcyB0byBncm91cHMuJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5Hcm91cC5wcm90b3R5cGUubm9kZVR5cGUgPSAnR3JvdXAnO1xuX3JlZ2lzdGVyTm9kZShHcm91cCk7XG4iLCJpbXBvcnQgeyBnbG9iIH0gZnJvbSAnLi9HbG9iYWwuanMnO1xuaW1wb3J0IHsgVXRpbCB9IGZyb20gJy4vVXRpbC5qcyc7XG52YXIgbm93ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZ2xvYi5wZXJmb3JtYW5jZSAmJiBnbG9iLnBlcmZvcm1hbmNlLm5vdykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2IucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9O1xufSkoKTtcbmV4cG9ydCBjbGFzcyBBbmltYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGZ1bmMsIGxheWVycykge1xuICAgICAgICB0aGlzLmlkID0gQW5pbWF0aW9uLmFuaW1JZENvdW50ZXIrKztcbiAgICAgICAgdGhpcy5mcmFtZSA9IHtcbiAgICAgICAgICAgIHRpbWU6IDAsXG4gICAgICAgICAgICB0aW1lRGlmZjogMCxcbiAgICAgICAgICAgIGxhc3RUaW1lOiBub3coKSxcbiAgICAgICAgICAgIGZyYW1lUmF0ZTogMCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5mdW5jID0gZnVuYztcbiAgICAgICAgdGhpcy5zZXRMYXllcnMobGF5ZXJzKTtcbiAgICB9XG4gICAgc2V0TGF5ZXJzKGxheWVycykge1xuICAgICAgICB2YXIgbGF5cyA9IFtdO1xuICAgICAgICBpZiAoIWxheWVycykge1xuICAgICAgICAgICAgbGF5cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxheWVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsYXlzID0gbGF5ZXJzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGF5cyA9IFtsYXllcnNdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGF5ZXJzID0gbGF5cztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldExheWVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXJzO1xuICAgIH1cbiAgICBhZGRMYXllcihsYXllcikge1xuICAgICAgICB2YXIgbGF5ZXJzID0gdGhpcy5sYXllcnMsIGxlbiA9IGxheWVycy5sZW5ndGgsIG47XG4gICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgaWYgKGxheWVyc1tuXS5faWQgPT09IGxheWVyLl9pZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxheWVycy5wdXNoKGxheWVyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlzUnVubmluZygpIHtcbiAgICAgICAgdmFyIGEgPSBBbmltYXRpb24sIGFuaW1hdGlvbnMgPSBhLmFuaW1hdGlvbnMsIGxlbiA9IGFuaW1hdGlvbnMubGVuZ3RoLCBuO1xuICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgIGlmIChhbmltYXRpb25zW25dLmlkID09PSB0aGlzLmlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIHRoaXMuZnJhbWUudGltZURpZmYgPSAwO1xuICAgICAgICB0aGlzLmZyYW1lLmxhc3RUaW1lID0gbm93KCk7XG4gICAgICAgIEFuaW1hdGlvbi5fYWRkQW5pbWF0aW9uKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgQW5pbWF0aW9uLl9yZW1vdmVBbmltYXRpb24odGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBfdXBkYXRlRnJhbWVPYmplY3QodGltZSkge1xuICAgICAgICB0aGlzLmZyYW1lLnRpbWVEaWZmID0gdGltZSAtIHRoaXMuZnJhbWUubGFzdFRpbWU7XG4gICAgICAgIHRoaXMuZnJhbWUubGFzdFRpbWUgPSB0aW1lO1xuICAgICAgICB0aGlzLmZyYW1lLnRpbWUgKz0gdGhpcy5mcmFtZS50aW1lRGlmZjtcbiAgICAgICAgdGhpcy5mcmFtZS5mcmFtZVJhdGUgPSAxMDAwIC8gdGhpcy5mcmFtZS50aW1lRGlmZjtcbiAgICB9XG4gICAgc3RhdGljIF9hZGRBbmltYXRpb24oYW5pbSkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnMucHVzaChhbmltKTtcbiAgICAgICAgdGhpcy5faGFuZGxlQW5pbWF0aW9uKCk7XG4gICAgfVxuICAgIHN0YXRpYyBfcmVtb3ZlQW5pbWF0aW9uKGFuaW0pIHtcbiAgICAgICAgdmFyIGlkID0gYW5pbS5pZCwgYW5pbWF0aW9ucyA9IHRoaXMuYW5pbWF0aW9ucywgbGVuID0gYW5pbWF0aW9ucy5sZW5ndGgsIG47XG4gICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgaWYgKGFuaW1hdGlvbnNbbl0uaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25zLnNwbGljZShuLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgX3J1bkZyYW1lcygpIHtcbiAgICAgICAgdmFyIGxheWVySGFzaCA9IHt9LCBhbmltYXRpb25zID0gdGhpcy5hbmltYXRpb25zLCBhbmltLCBsYXllcnMsIGZ1bmMsIG4sIGksIGxheWVyc0xlbiwgbGF5ZXIsIGtleSwgbmVlZFJlZHJhdztcbiAgICAgICAgZm9yIChuID0gMDsgbiA8IGFuaW1hdGlvbnMubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgIGFuaW0gPSBhbmltYXRpb25zW25dO1xuICAgICAgICAgICAgbGF5ZXJzID0gYW5pbS5sYXllcnM7XG4gICAgICAgICAgICBmdW5jID0gYW5pbS5mdW5jO1xuICAgICAgICAgICAgYW5pbS5fdXBkYXRlRnJhbWVPYmplY3Qobm93KCkpO1xuICAgICAgICAgICAgbGF5ZXJzTGVuID0gbGF5ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgICAgICAgICAgbmVlZFJlZHJhdyA9IGZ1bmMuY2FsbChhbmltLCBhbmltLmZyYW1lKSAhPT0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZWVkUmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmVlZFJlZHJhdykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxheWVyc0xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIgPSBsYXllcnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLl9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVySGFzaFtsYXllci5faWRdID0gbGF5ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoa2V5IGluIGxheWVySGFzaCkge1xuICAgICAgICAgICAgaWYgKCFsYXllckhhc2guaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGF5ZXJIYXNoW2tleV0uYmF0Y2hEcmF3KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIF9hbmltYXRpb25Mb29wKCkge1xuICAgICAgICB2YXIgQW5pbSA9IEFuaW1hdGlvbjtcbiAgICAgICAgaWYgKEFuaW0uYW5pbWF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIEFuaW0uX3J1bkZyYW1lcygpO1xuICAgICAgICAgICAgVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKEFuaW0uX2FuaW1hdGlvbkxvb3ApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgQW5pbS5hbmltUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBfaGFuZGxlQW5pbWF0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuYW5pbVJ1bm5pbmcpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbVJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FuaW1hdGlvbkxvb3ApO1xuICAgICAgICB9XG4gICAgfVxufVxuQW5pbWF0aW9uLmFuaW1hdGlvbnMgPSBbXTtcbkFuaW1hdGlvbi5hbmltSWRDb3VudGVyID0gMDtcbkFuaW1hdGlvbi5hbmltUnVubmluZyA9IGZhbHNlO1xuIiwiaW1wb3J0IHsgVXRpbCB9IGZyb20gJy4vVXRpbC5qcyc7XG5pbXBvcnQgeyBBbmltYXRpb24gfSBmcm9tICcuL0FuaW1hdGlvbi5qcyc7XG5pbXBvcnQgeyBOb2RlIH0gZnJvbSAnLi9Ob2RlLmpzJztcbmltcG9ydCB7IEtvbnZhIH0gZnJvbSAnLi9HbG9iYWwuanMnO1xudmFyIGJsYWNrbGlzdCA9IHtcbiAgICBub2RlOiAxLFxuICAgIGR1cmF0aW9uOiAxLFxuICAgIGVhc2luZzogMSxcbiAgICBvbkZpbmlzaDogMSxcbiAgICB5b3lvOiAxLFxufSwgUEFVU0VEID0gMSwgUExBWUlORyA9IDIsIFJFVkVSU0lORyA9IDMsIGlkQ291bnRlciA9IDAsIGNvbG9yQXR0cnMgPSBbJ2ZpbGwnLCAnc3Ryb2tlJywgJ3NoYWRvd0NvbG9yJ107XG5jbGFzcyBUd2VlbkVuZ2luZSB7XG4gICAgY29uc3RydWN0b3IocHJvcCwgcHJvcEZ1bmMsIGZ1bmMsIGJlZ2luLCBmaW5pc2gsIGR1cmF0aW9uLCB5b3lvKSB7XG4gICAgICAgIHRoaXMucHJvcCA9IHByb3A7XG4gICAgICAgIHRoaXMucHJvcEZ1bmMgPSBwcm9wRnVuYztcbiAgICAgICAgdGhpcy5iZWdpbiA9IGJlZ2luO1xuICAgICAgICB0aGlzLl9wb3MgPSBiZWdpbjtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICB0aGlzLl9jaGFuZ2UgPSAwO1xuICAgICAgICB0aGlzLnByZXZQb3MgPSAwO1xuICAgICAgICB0aGlzLnlveW8gPSB5b3lvO1xuICAgICAgICB0aGlzLl90aW1lID0gMDtcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSAwO1xuICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSAwO1xuICAgICAgICB0aGlzLl9maW5pc2ggPSAwO1xuICAgICAgICB0aGlzLmZ1bmMgPSBmdW5jO1xuICAgICAgICB0aGlzLl9jaGFuZ2UgPSBmaW5pc2ggLSB0aGlzLmJlZ2luO1xuICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgfVxuICAgIGZpcmUoc3RyKSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gdGhpc1tzdHJdO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgaGFuZGxlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFRpbWUodCkge1xuICAgICAgICBpZiAodCA+IHRoaXMuZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnlveW8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lID0gdGhpcy5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICB0aGlzLnJldmVyc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodCA8IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnlveW8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbWUgPSB0O1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRUaW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGltZTtcbiAgICB9XG4gICAgc2V0UG9zaXRpb24ocCkge1xuICAgICAgICB0aGlzLnByZXZQb3MgPSB0aGlzLl9wb3M7XG4gICAgICAgIHRoaXMucHJvcEZ1bmMocCk7XG4gICAgICAgIHRoaXMuX3BvcyA9IHA7XG4gICAgfVxuICAgIGdldFBvc2l0aW9uKHQpIHtcbiAgICAgICAgaWYgKHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdCA9IHRoaXMuX3RpbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuYyh0LCB0aGlzLmJlZ2luLCB0aGlzLl9jaGFuZ2UsIHRoaXMuZHVyYXRpb24pO1xuICAgIH1cbiAgICBwbGF5KCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gUExBWUlORztcbiAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gdGhpcy5nZXRUaW1lcigpIC0gdGhpcy5fdGltZTtcbiAgICAgICAgdGhpcy5vbkVudGVyRnJhbWUoKTtcbiAgICAgICAgdGhpcy5maXJlKCdvblBsYXknKTtcbiAgICB9XG4gICAgcmV2ZXJzZSgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFJFVkVSU0lORztcbiAgICAgICAgdGhpcy5fdGltZSA9IHRoaXMuZHVyYXRpb24gLSB0aGlzLl90aW1lO1xuICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSB0aGlzLmdldFRpbWVyKCkgLSB0aGlzLl90aW1lO1xuICAgICAgICB0aGlzLm9uRW50ZXJGcmFtZSgpO1xuICAgICAgICB0aGlzLmZpcmUoJ29uUmV2ZXJzZScpO1xuICAgIH1cbiAgICBzZWVrKHQpIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICB0aGlzLl90aW1lID0gdDtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgdGhpcy5maXJlKCdvblNlZWsnKTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgdGhpcy5fdGltZSA9IDA7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIHRoaXMuZmlyZSgnb25SZXNldCcpO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgdGhpcy5fdGltZSA9IHRoaXMuZHVyYXRpb247XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIHRoaXMuZmlyZSgnb25GaW5pc2gnKTtcbiAgICB9XG4gICAgdXBkYXRlKCkge1xuICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHRoaXMuZ2V0UG9zaXRpb24odGhpcy5fdGltZSkpO1xuICAgICAgICB0aGlzLmZpcmUoJ29uVXBkYXRlJyk7XG4gICAgfVxuICAgIG9uRW50ZXJGcmFtZSgpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLmdldFRpbWVyKCkgLSB0aGlzLl9zdGFydFRpbWU7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBQTEFZSU5HKSB7XG4gICAgICAgICAgICB0aGlzLnNldFRpbWUodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gUkVWRVJTSU5HKSB7XG4gICAgICAgICAgICB0aGlzLnNldFRpbWUodGhpcy5kdXJhdGlvbiAtIHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gUEFVU0VEO1xuICAgICAgICB0aGlzLmZpcmUoJ29uUGF1c2UnKTtcbiAgICB9XG4gICAgZ2V0VGltZXIoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVHdlZW4ge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXMsIG5vZGUgPSBjb25maWcubm9kZSwgbm9kZUlkID0gbm9kZS5faWQsIGR1cmF0aW9uLCBlYXNpbmcgPSBjb25maWcuZWFzaW5nIHx8IEVhc2luZ3MuTGluZWFyLCB5b3lvID0gISFjb25maWcueW95bywga2V5O1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5kdXJhdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gMC4zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZy5kdXJhdGlvbiA9PT0gMCkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSAwLjAwMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gY29uZmlnLmR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuX2lkID0gaWRDb3VudGVyKys7XG4gICAgICAgIHZhciBsYXllcnMgPSBub2RlLmdldExheWVyKCkgfHxcbiAgICAgICAgICAgIChub2RlIGluc3RhbmNlb2YgS29udmFbJ1N0YWdlJ10gPyBub2RlLmdldExheWVycygpIDogbnVsbCk7XG4gICAgICAgIGlmICghbGF5ZXJzKSB7XG4gICAgICAgICAgICBVdGlsLmVycm9yKCdUd2VlbiBjb25zdHJ1Y3RvciBoYXZlIGBub2RlYCB0aGF0IGlzIG5vdCBpbiBhIGxheWVyLiBQbGVhc2UgYWRkIG5vZGUgaW50byBsYXllciBmaXJzdC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFuaW0gPSBuZXcgQW5pbWF0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQudHdlZW4ub25FbnRlckZyYW1lKCk7XG4gICAgICAgIH0sIGxheWVycyk7XG4gICAgICAgIHRoaXMudHdlZW4gPSBuZXcgVHdlZW5FbmdpbmUoa2V5LCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgdGhhdC5fdHdlZW5GdW5jKGkpO1xuICAgICAgICB9LCBlYXNpbmcsIDAsIDEsIGR1cmF0aW9uICogMTAwMCwgeW95byk7XG4gICAgICAgIHRoaXMuX2FkZExpc3RlbmVycygpO1xuICAgICAgICBpZiAoIVR3ZWVuLmF0dHJzW25vZGVJZF0pIHtcbiAgICAgICAgICAgIFR3ZWVuLmF0dHJzW25vZGVJZF0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIVR3ZWVuLmF0dHJzW25vZGVJZF1bdGhpcy5faWRdKSB7XG4gICAgICAgICAgICBUd2Vlbi5hdHRyc1tub2RlSWRdW3RoaXMuX2lkXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghVHdlZW4udHdlZW5zW25vZGVJZF0pIHtcbiAgICAgICAgICAgIFR3ZWVuLnR3ZWVuc1tub2RlSWRdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChrZXkgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoYmxhY2tsaXN0W2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZEF0dHIoa2V5LCBjb25maWdba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLm9uRmluaXNoID0gY29uZmlnLm9uRmluaXNoO1xuICAgICAgICB0aGlzLm9uUmVzZXQgPSBjb25maWcub25SZXNldDtcbiAgICAgICAgdGhpcy5vblVwZGF0ZSA9IGNvbmZpZy5vblVwZGF0ZTtcbiAgICB9XG4gICAgX2FkZEF0dHIoa2V5LCBlbmQpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUsIG5vZGVJZCA9IG5vZGUuX2lkLCBzdGFydCwgZGlmZiwgdHdlZW5JZCwgbiwgbGVuLCB0cnVlRW5kLCB0cnVlU3RhcnQsIGVuZFJHQkE7XG4gICAgICAgIHR3ZWVuSWQgPSBUd2Vlbi50d2VlbnNbbm9kZUlkXVtrZXldO1xuICAgICAgICBpZiAodHdlZW5JZCkge1xuICAgICAgICAgICAgZGVsZXRlIFR3ZWVuLmF0dHJzW25vZGVJZF1bdHdlZW5JZF1ba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBzdGFydCA9IG5vZGUuZ2V0QXR0cihrZXkpO1xuICAgICAgICBpZiAoVXRpbC5faXNBcnJheShlbmQpKSB7XG4gICAgICAgICAgICBkaWZmID0gW107XG4gICAgICAgICAgICBsZW4gPSBNYXRoLm1heChlbmQubGVuZ3RoLCBzdGFydC5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3BvaW50cycgJiYgZW5kLmxlbmd0aCAhPT0gc3RhcnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuZC5sZW5ndGggPiBzdGFydC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZVN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gVXRpbC5fcHJlcGFyZUFycmF5Rm9yVHdlZW4oc3RhcnQsIGVuZCwgbm9kZS5jbG9zZWQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cnVlRW5kID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBVdGlsLl9wcmVwYXJlQXJyYXlGb3JUd2VlbihlbmQsIHN0YXJ0LCBub2RlLmNsb3NlZCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5LmluZGV4T2YoJ2ZpbGwnKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobiAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYucHVzaChlbmRbbl0gLSBzdGFydFtuXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRSR0JBID0gVXRpbC5jb2xvclRvUkdCQShzdGFydFtuXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRSR0JBID0gVXRpbC5jb2xvclRvUkdCQShlbmRbbl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRbbl0gPSBzdGFydFJHQkE7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWZmLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHI6IGVuZFJHQkEuciAtIHN0YXJ0UkdCQS5yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGc6IGVuZFJHQkEuZyAtIHN0YXJ0UkdCQS5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGI6IGVuZFJHQkEuYiAtIHN0YXJ0UkdCQS5iLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE6IGVuZFJHQkEuYSAtIHN0YXJ0UkdCQS5hLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZGlmZi5wdXNoKGVuZFtuXSAtIHN0YXJ0W25dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29sb3JBdHRycy5pbmRleE9mKGtleSkgIT09IC0xKSB7XG4gICAgICAgICAgICBzdGFydCA9IFV0aWwuY29sb3JUb1JHQkEoc3RhcnQpO1xuICAgICAgICAgICAgZW5kUkdCQSA9IFV0aWwuY29sb3JUb1JHQkEoZW5kKTtcbiAgICAgICAgICAgIGRpZmYgPSB7XG4gICAgICAgICAgICAgICAgcjogZW5kUkdCQS5yIC0gc3RhcnQucixcbiAgICAgICAgICAgICAgICBnOiBlbmRSR0JBLmcgLSBzdGFydC5nLFxuICAgICAgICAgICAgICAgIGI6IGVuZFJHQkEuYiAtIHN0YXJ0LmIsXG4gICAgICAgICAgICAgICAgYTogZW5kUkdCQS5hIC0gc3RhcnQuYSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkaWZmID0gZW5kIC0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgVHdlZW4uYXR0cnNbbm9kZUlkXVt0aGlzLl9pZF1ba2V5XSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGRpZmY6IGRpZmYsXG4gICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgIHRydWVFbmQ6IHRydWVFbmQsXG4gICAgICAgICAgICB0cnVlU3RhcnQ6IHRydWVTdGFydCxcbiAgICAgICAgfTtcbiAgICAgICAgVHdlZW4udHdlZW5zW25vZGVJZF1ba2V5XSA9IHRoaXMuX2lkO1xuICAgIH1cbiAgICBfdHdlZW5GdW5jKGkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUsIGF0dHJzID0gVHdlZW4uYXR0cnNbbm9kZS5faWRdW3RoaXMuX2lkXSwga2V5LCBhdHRyLCBzdGFydCwgZGlmZiwgbmV3VmFsLCBuLCBsZW4sIGVuZDtcbiAgICAgICAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgIGF0dHIgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgc3RhcnQgPSBhdHRyLnN0YXJ0O1xuICAgICAgICAgICAgZGlmZiA9IGF0dHIuZGlmZjtcbiAgICAgICAgICAgIGVuZCA9IGF0dHIuZW5kO1xuICAgICAgICAgICAgaWYgKFV0aWwuX2lzQXJyYXkoc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsID0gW107XG4gICAgICAgICAgICAgICAgbGVuID0gTWF0aC5tYXgoc3RhcnQubGVuZ3RoLCBlbmQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5LmluZGV4T2YoJ2ZpbGwnKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbC5wdXNoKChzdGFydFtuXSB8fCAwKSArIGRpZmZbbl0gKiBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbC5wdXNoKCdyZ2JhKCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKHN0YXJ0W25dLnIgKyBkaWZmW25dLnIgKiBpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcsJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucm91bmQoc3RhcnRbbl0uZyArIGRpZmZbbl0uZyAqIGkpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJywnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5yb3VuZChzdGFydFtuXS5iICsgZGlmZltuXS5iICogaSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3RhcnRbbl0uYSArIGRpZmZbbl0uYSAqIGkpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWwucHVzaCgoc3RhcnRbbl0gfHwgMCkgKyBkaWZmW25dICogaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb2xvckF0dHJzLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBuZXdWYWwgPVxuICAgICAgICAgICAgICAgICAgICAncmdiYSgnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucm91bmQoc3RhcnQuciArIGRpZmYuciAqIGkpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcsJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKHN0YXJ0LmcgKyBkaWZmLmcgKiBpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnLCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5yb3VuZChzdGFydC5iICsgZGlmZi5iICogaSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJywnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzdGFydC5hICsgZGlmZi5hICogaSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsID0gc3RhcnQgKyBkaWZmICogaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuc2V0QXR0cihrZXksIG5ld1ZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2FkZExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy50d2Vlbi5vblBsYXkgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFuaW0uc3RhcnQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50d2Vlbi5vblJldmVyc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFuaW0uc3RhcnQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50d2Vlbi5vblBhdXNlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hbmltLnN0b3AoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50d2Vlbi5vbkZpbmlzaCA9ICgpID0+IHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlO1xuICAgICAgICAgICAgdmFyIGF0dHJzID0gVHdlZW4uYXR0cnNbbm9kZS5faWRdW3RoaXMuX2lkXTtcbiAgICAgICAgICAgIGlmIChhdHRycy5wb2ludHMgJiYgYXR0cnMucG9pbnRzLnRydWVFbmQpIHtcbiAgICAgICAgICAgICAgICBub2RlLnNldEF0dHIoJ3BvaW50cycsIGF0dHJzLnBvaW50cy50cnVlRW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm9uRmluaXNoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkZpbmlzaC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnR3ZWVuLm9uUmVzZXQgPSAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZTtcbiAgICAgICAgICAgIHZhciBhdHRycyA9IFR3ZWVuLmF0dHJzW25vZGUuX2lkXVt0aGlzLl9pZF07XG4gICAgICAgICAgICBpZiAoYXR0cnMucG9pbnRzICYmIGF0dHJzLnBvaW50cy50cnVlU3RhcnQpIHtcbiAgICAgICAgICAgICAgICBub2RlLnBvaW50cyhhdHRycy5wb2ludHMudHJ1ZVN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm9uUmVzZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uUmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50d2Vlbi5vblVwZGF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblVwZGF0ZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBwbGF5KCkge1xuICAgICAgICB0aGlzLnR3ZWVuLnBsYXkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldmVyc2UoKSB7XG4gICAgICAgIHRoaXMudHdlZW4ucmV2ZXJzZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMudHdlZW4ucmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNlZWsodCkge1xuICAgICAgICB0aGlzLnR3ZWVuLnNlZWsodCAqIDEwMDApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcGF1c2UoKSB7XG4gICAgICAgIHRoaXMudHdlZW4ucGF1c2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgdGhpcy50d2Vlbi5maW5pc2goKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBub2RlSWQgPSB0aGlzLm5vZGUuX2lkLCB0aGlzSWQgPSB0aGlzLl9pZCwgYXR0cnMgPSBUd2Vlbi50d2VlbnNbbm9kZUlkXSwga2V5O1xuICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgICBkZWxldGUgVHdlZW4udHdlZW5zW25vZGVJZF1ba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgVHdlZW4uYXR0cnNbbm9kZUlkXVt0aGlzSWRdO1xuICAgIH1cbn1cblR3ZWVuLmF0dHJzID0ge307XG5Ud2Vlbi50d2VlbnMgPSB7fTtcbk5vZGUucHJvdG90eXBlLnRvID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHZhciBvbkZpbmlzaCA9IHBhcmFtcy5vbkZpbmlzaDtcbiAgICBwYXJhbXMubm9kZSA9IHRoaXM7XG4gICAgcGFyYW1zLm9uRmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKG9uRmluaXNoKSB7XG4gICAgICAgICAgICBvbkZpbmlzaCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgdHdlZW4gPSBuZXcgVHdlZW4ocGFyYW1zKTtcbiAgICB0d2Vlbi5wbGF5KCk7XG59O1xuZXhwb3J0IGNvbnN0IEVhc2luZ3MgPSB7XG4gICAgQmFja0Vhc2VJbih0LCBiLCBjLCBkKSB7XG4gICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKSArIGI7XG4gICAgfSxcbiAgICBCYWNrRWFzZU91dCh0LCBiLCBjLCBkKSB7XG4gICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgcmV0dXJuIGMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMSkgKyBiO1xuICAgIH0sXG4gICAgQmFja0Vhc2VJbk91dCh0LCBiLCBjLCBkKSB7XG4gICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgaWYgKCh0IC89IGQgLyAyKSA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAoYyAvIDIpICogKHQgKiB0ICogKCgocyAqPSAxLjUyNSkgKyAxKSAqIHQgLSBzKSkgKyBiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoYyAvIDIpICogKCh0IC09IDIpICogdCAqICgoKHMgKj0gMS41MjUpICsgMSkgKiB0ICsgcykgKyAyKSArIGI7XG4gICAgfSxcbiAgICBFbGFzdGljRWFzZUluKHQsIGIsIGMsIGQsIGEsIHApIHtcbiAgICAgICAgdmFyIHMgPSAwO1xuICAgICAgICBpZiAodCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0IC89IGQpID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gYiArIGM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwKSB7XG4gICAgICAgICAgICBwID0gZCAqIDAuMztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWEgfHwgYSA8IE1hdGguYWJzKGMpKSB7XG4gICAgICAgICAgICBhID0gYztcbiAgICAgICAgICAgIHMgPSBwIC8gNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHMgPSAocCAvICgyICogTWF0aC5QSSkpICogTWF0aC5hc2luKGMgLyBhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKC0oYSAqXG4gICAgICAgICAgICBNYXRoLnBvdygyLCAxMCAqICh0IC09IDEpKSAqXG4gICAgICAgICAgICBNYXRoLnNpbigoKHQgKiBkIC0gcykgKiAoMiAqIE1hdGguUEkpKSAvIHApKSArIGIpO1xuICAgIH0sXG4gICAgRWxhc3RpY0Vhc2VPdXQodCwgYiwgYywgZCwgYSwgcCkge1xuICAgICAgICB2YXIgcyA9IDA7XG4gICAgICAgIGlmICh0ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHQgLz0gZCkgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBiICsgYztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXApIHtcbiAgICAgICAgICAgIHAgPSBkICogMC4zO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYSB8fCBhIDwgTWF0aC5hYnMoYykpIHtcbiAgICAgICAgICAgIGEgPSBjO1xuICAgICAgICAgICAgcyA9IHAgLyA0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcyA9IChwIC8gKDIgKiBNYXRoLlBJKSkgKiBNYXRoLmFzaW4oYyAvIGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoYSAqIE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKCh0ICogZCAtIHMpICogKDIgKiBNYXRoLlBJKSkgLyBwKSArXG4gICAgICAgICAgICBjICtcbiAgICAgICAgICAgIGIpO1xuICAgIH0sXG4gICAgRWxhc3RpY0Vhc2VJbk91dCh0LCBiLCBjLCBkLCBhLCBwKSB7XG4gICAgICAgIHZhciBzID0gMDtcbiAgICAgICAgaWYgKHQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodCAvPSBkIC8gMikgPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBiICsgYztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXApIHtcbiAgICAgICAgICAgIHAgPSBkICogKDAuMyAqIDEuNSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhIHx8IGEgPCBNYXRoLmFicyhjKSkge1xuICAgICAgICAgICAgYSA9IGM7XG4gICAgICAgICAgICBzID0gcCAvIDQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzID0gKHAgLyAoMiAqIE1hdGguUEkpKSAqIE1hdGguYXNpbihjIC8gYSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHQgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gKC0wLjUgKlxuICAgICAgICAgICAgICAgIChhICpcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5wb3coMiwgMTAgKiAodCAtPSAxKSkgKlxuICAgICAgICAgICAgICAgICAgICBNYXRoLnNpbigoKHQgKiBkIC0gcykgKiAoMiAqIE1hdGguUEkpKSAvIHApKSArXG4gICAgICAgICAgICAgICAgYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChhICpcbiAgICAgICAgICAgIE1hdGgucG93KDIsIC0xMCAqICh0IC09IDEpKSAqXG4gICAgICAgICAgICBNYXRoLnNpbigoKHQgKiBkIC0gcykgKiAoMiAqIE1hdGguUEkpKSAvIHApICpcbiAgICAgICAgICAgIDAuNSArXG4gICAgICAgICAgICBjICtcbiAgICAgICAgICAgIGIpO1xuICAgIH0sXG4gICAgQm91bmNlRWFzZU91dCh0LCBiLCBjLCBkKSB7XG4gICAgICAgIGlmICgodCAvPSBkKSA8IDEgLyAyLjc1KSB7XG4gICAgICAgICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiB0ICogdCkgKyBiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHQgPCAyIC8gMi43NSkge1xuICAgICAgICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogKHQgLT0gMS41IC8gMi43NSkgKiB0ICsgMC43NSkgKyBiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHQgPCAyLjUgLyAyLjc1KSB7XG4gICAgICAgICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiAodCAtPSAyLjI1IC8gMi43NSkgKiB0ICsgMC45Mzc1KSArIGI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiAodCAtPSAyLjYyNSAvIDIuNzUpICogdCArIDAuOTg0Mzc1KSArIGI7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIEJvdW5jZUVhc2VJbih0LCBiLCBjLCBkKSB7XG4gICAgICAgIHJldHVybiBjIC0gRWFzaW5ncy5Cb3VuY2VFYXNlT3V0KGQgLSB0LCAwLCBjLCBkKSArIGI7XG4gICAgfSxcbiAgICBCb3VuY2VFYXNlSW5PdXQodCwgYiwgYywgZCkge1xuICAgICAgICBpZiAodCA8IGQgLyAyKSB7XG4gICAgICAgICAgICByZXR1cm4gRWFzaW5ncy5Cb3VuY2VFYXNlSW4odCAqIDIsIDAsIGMsIGQpICogMC41ICsgYjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBFYXNpbmdzLkJvdW5jZUVhc2VPdXQodCAqIDIgLSBkLCAwLCBjLCBkKSAqIDAuNSArIGMgKiAwLjUgKyBiO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBFYXNlSW4odCwgYiwgYywgZCkge1xuICAgICAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCArIGI7XG4gICAgfSxcbiAgICBFYXNlT3V0KHQsIGIsIGMsIGQpIHtcbiAgICAgICAgcmV0dXJuIC1jICogKHQgLz0gZCkgKiAodCAtIDIpICsgYjtcbiAgICB9LFxuICAgIEVhc2VJbk91dCh0LCBiLCBjLCBkKSB7XG4gICAgICAgIGlmICgodCAvPSBkIC8gMikgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gKGMgLyAyKSAqIHQgKiB0ICsgYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKC1jIC8gMikgKiAoLS10ICogKHQgLSAyKSAtIDEpICsgYjtcbiAgICB9LFxuICAgIFN0cm9uZ0Vhc2VJbih0LCBiLCBjLCBkKSB7XG4gICAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogdCAqIHQgKiB0ICsgYjtcbiAgICB9LFxuICAgIFN0cm9uZ0Vhc2VPdXQodCwgYiwgYywgZCkge1xuICAgICAgICByZXR1cm4gYyAqICgodCA9IHQgLyBkIC0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMSkgKyBiO1xuICAgIH0sXG4gICAgU3Ryb25nRWFzZUluT3V0KHQsIGIsIGMsIGQpIHtcbiAgICAgICAgaWYgKCh0IC89IGQgLyAyKSA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAoYyAvIDIpICogdCAqIHQgKiB0ICogdCAqIHQgKyBiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoYyAvIDIpICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpICsgYjtcbiAgICB9LFxuICAgIExpbmVhcih0LCBiLCBjLCBkKSB7XG4gICAgICAgIHJldHVybiAoYyAqIHQpIC8gZCArIGI7XG4gICAgfSxcbn07XG4iLCJpbXBvcnQgeyBLb252YSBhcyBHbG9iYWwgfSBmcm9tICcuL0dsb2JhbC5qcyc7XG5pbXBvcnQgeyBVdGlsLCBUcmFuc2Zvcm0gfSBmcm9tICcuL1V0aWwuanMnO1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4vTm9kZS5qcyc7XG5pbXBvcnQgeyBDb250YWluZXIgfSBmcm9tICcuL0NvbnRhaW5lci5qcyc7XG5pbXBvcnQgeyBTdGFnZSwgc3RhZ2VzIH0gZnJvbSAnLi9TdGFnZS5qcyc7XG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4vTGF5ZXIuanMnO1xuaW1wb3J0IHsgRmFzdExheWVyIH0gZnJvbSAnLi9GYXN0TGF5ZXIuanMnO1xuaW1wb3J0IHsgR3JvdXAgfSBmcm9tICcuL0dyb3VwLmpzJztcbmltcG9ydCB7IEREIH0gZnJvbSAnLi9EcmFnQW5kRHJvcC5qcyc7XG5pbXBvcnQgeyBTaGFwZSwgc2hhcGVzIH0gZnJvbSAnLi9TaGFwZS5qcyc7XG5pbXBvcnQgeyBBbmltYXRpb24gfSBmcm9tICcuL0FuaW1hdGlvbi5qcyc7XG5pbXBvcnQgeyBUd2VlbiwgRWFzaW5ncyB9IGZyb20gJy4vVHdlZW4uanMnO1xuaW1wb3J0IHsgQ29udGV4dCB9IGZyb20gJy4vQ29udGV4dC5qcyc7XG5pbXBvcnQgeyBDYW52YXMgfSBmcm9tICcuL0NhbnZhcy5qcyc7XG5leHBvcnQgY29uc3QgS29udmEgPSBVdGlsLl9hc3NpZ24oR2xvYmFsLCB7XG4gICAgVXRpbCxcbiAgICBUcmFuc2Zvcm0sXG4gICAgTm9kZSxcbiAgICBDb250YWluZXIsXG4gICAgU3RhZ2UsXG4gICAgc3RhZ2VzLFxuICAgIExheWVyLFxuICAgIEZhc3RMYXllcixcbiAgICBHcm91cCxcbiAgICBERCxcbiAgICBTaGFwZSxcbiAgICBzaGFwZXMsXG4gICAgQW5pbWF0aW9uLFxuICAgIFR3ZWVuLFxuICAgIEVhc2luZ3MsXG4gICAgQ29udGV4dCxcbiAgICBDYW52YXMsXG59KTtcbmV4cG9ydCBkZWZhdWx0IEtvbnZhO1xuIiwiaW1wb3J0IHsgRmFjdG9yeSB9IGZyb20gJy4uL0ZhY3RvcnkuanMnO1xuaW1wb3J0IHsgU2hhcGUgfSBmcm9tICcuLi9TaGFwZS5qcyc7XG5pbXBvcnQgeyBLb252YSB9IGZyb20gJy4uL0dsb2JhbC5qcyc7XG5pbXBvcnQgeyBnZXROdW1iZXJWYWxpZGF0b3IsIGdldEJvb2xlYW5WYWxpZGF0b3IgfSBmcm9tICcuLi9WYWxpZGF0b3JzLmpzJztcbmltcG9ydCB7IF9yZWdpc3Rlck5vZGUgfSBmcm9tICcuLi9HbG9iYWwuanMnO1xuZXhwb3J0IGNsYXNzIEFyYyBleHRlbmRzIFNoYXBlIHtcbiAgICBfc2NlbmVGdW5jKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGFuZ2xlID0gS29udmEuZ2V0QW5nbGUodGhpcy5hbmdsZSgpKSwgY2xvY2t3aXNlID0gdGhpcy5jbG9ja3dpc2UoKTtcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgdGhpcy5vdXRlclJhZGl1cygpLCAwLCBhbmdsZSwgY2xvY2t3aXNlKTtcbiAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgdGhpcy5pbm5lclJhZGl1cygpLCBhbmdsZSwgMCwgIWNsb2Nrd2lzZSk7XG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgIH1cbiAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0ZXJSYWRpdXMoKSAqIDI7XG4gICAgfVxuICAgIGdldEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0ZXJSYWRpdXMoKSAqIDI7XG4gICAgfVxuICAgIHNldFdpZHRoKHdpZHRoKSB7XG4gICAgICAgIHRoaXMub3V0ZXJSYWRpdXMod2lkdGggLyAyKTtcbiAgICB9XG4gICAgc2V0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICB0aGlzLm91dGVyUmFkaXVzKGhlaWdodCAvIDIpO1xuICAgIH1cbiAgICBnZXRTZWxmUmVjdCgpIHtcbiAgICAgICAgY29uc3QgaW5uZXJSYWRpdXMgPSB0aGlzLmlubmVyUmFkaXVzKCk7XG4gICAgICAgIGNvbnN0IG91dGVyUmFkaXVzID0gdGhpcy5vdXRlclJhZGl1cygpO1xuICAgICAgICBjb25zdCBjbG9ja3dpc2UgPSB0aGlzLmNsb2Nrd2lzZSgpO1xuICAgICAgICBjb25zdCBhbmdsZSA9IEtvbnZhLmdldEFuZ2xlKGNsb2Nrd2lzZSA/IDM2MCAtIHRoaXMuYW5nbGUoKSA6IHRoaXMuYW5nbGUoKSk7XG4gICAgICAgIGNvbnN0IGJvdW5kTGVmdFJhdGlvID0gTWF0aC5jb3MoTWF0aC5taW4oYW5nbGUsIE1hdGguUEkpKTtcbiAgICAgICAgY29uc3QgYm91bmRSaWdodFJhdGlvID0gMTtcbiAgICAgICAgY29uc3QgYm91bmRUb3BSYXRpbyA9IE1hdGguc2luKE1hdGgubWluKE1hdGgubWF4KE1hdGguUEksIGFuZ2xlKSwgKDMgKiBNYXRoLlBJKSAvIDIpKTtcbiAgICAgICAgY29uc3QgYm91bmRCb3R0b21SYXRpbyA9IE1hdGguc2luKE1hdGgubWluKGFuZ2xlLCBNYXRoLlBJIC8gMikpO1xuICAgICAgICBjb25zdCBib3VuZExlZnQgPSBib3VuZExlZnRSYXRpbyAqIChib3VuZExlZnRSYXRpbyA+IDAgPyBpbm5lclJhZGl1cyA6IG91dGVyUmFkaXVzKTtcbiAgICAgICAgY29uc3QgYm91bmRSaWdodCA9IGJvdW5kUmlnaHRSYXRpbyAqIChib3VuZFJpZ2h0UmF0aW8gPiAwID8gb3V0ZXJSYWRpdXMgOiBpbm5lclJhZGl1cyk7XG4gICAgICAgIGNvbnN0IGJvdW5kVG9wID0gYm91bmRUb3BSYXRpbyAqIChib3VuZFRvcFJhdGlvID4gMCA/IGlubmVyUmFkaXVzIDogb3V0ZXJSYWRpdXMpO1xuICAgICAgICBjb25zdCBib3VuZEJvdHRvbSA9IGJvdW5kQm90dG9tUmF0aW8gKiAoYm91bmRCb3R0b21SYXRpbyA+IDAgPyBvdXRlclJhZGl1cyA6IGlubmVyUmFkaXVzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGJvdW5kTGVmdCxcbiAgICAgICAgICAgIHk6IGNsb2Nrd2lzZSA/IC0xICogYm91bmRCb3R0b20gOiBib3VuZFRvcCxcbiAgICAgICAgICAgIHdpZHRoOiBib3VuZFJpZ2h0IC0gYm91bmRMZWZ0LFxuICAgICAgICAgICAgaGVpZ2h0OiBib3VuZEJvdHRvbSAtIGJvdW5kVG9wLFxuICAgICAgICB9O1xuICAgIH1cbn1cbkFyYy5wcm90b3R5cGUuX2NlbnRyb2lkID0gdHJ1ZTtcbkFyYy5wcm90b3R5cGUuY2xhc3NOYW1lID0gJ0FyYyc7XG5BcmMucHJvdG90eXBlLl9hdHRyc0FmZmVjdGluZ1NpemUgPSBbJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJ107XG5fcmVnaXN0ZXJOb2RlKEFyYyk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihBcmMsICdpbm5lclJhZGl1cycsIDAsIGdldE51bWJlclZhbGlkYXRvcigpKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEFyYywgJ291dGVyUmFkaXVzJywgMCwgZ2V0TnVtYmVyVmFsaWRhdG9yKCkpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoQXJjLCAnYW5nbGUnLCAwLCBnZXROdW1iZXJWYWxpZGF0b3IoKSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihBcmMsICdjbG9ja3dpc2UnLCBmYWxzZSwgZ2V0Qm9vbGVhblZhbGlkYXRvcigpKTtcbiIsImltcG9ydCB7IEZhY3RvcnkgfSBmcm9tICcuLi9GYWN0b3J5LmpzJztcbmltcG9ydCB7IFNoYXBlIH0gZnJvbSAnLi4vU2hhcGUuanMnO1xuaW1wb3J0IHsgZ2V0TnVtYmVyVmFsaWRhdG9yLCBnZXROdW1iZXJBcnJheVZhbGlkYXRvciB9IGZyb20gJy4uL1ZhbGlkYXRvcnMuanMnO1xuaW1wb3J0IHsgX3JlZ2lzdGVyTm9kZSB9IGZyb20gJy4uL0dsb2JhbC5qcyc7XG5mdW5jdGlvbiBnZXRDb250cm9sUG9pbnRzKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHQpIHtcbiAgICB2YXIgZDAxID0gTWF0aC5zcXJ0KE1hdGgucG93KHgxIC0geDAsIDIpICsgTWF0aC5wb3coeTEgLSB5MCwgMikpLCBkMTIgPSBNYXRoLnNxcnQoTWF0aC5wb3coeDIgLSB4MSwgMikgKyBNYXRoLnBvdyh5MiAtIHkxLCAyKSksIGZhID0gKHQgKiBkMDEpIC8gKGQwMSArIGQxMiksIGZiID0gKHQgKiBkMTIpIC8gKGQwMSArIGQxMiksIHAxeCA9IHgxIC0gZmEgKiAoeDIgLSB4MCksIHAxeSA9IHkxIC0gZmEgKiAoeTIgLSB5MCksIHAyeCA9IHgxICsgZmIgKiAoeDIgLSB4MCksIHAyeSA9IHkxICsgZmIgKiAoeTIgLSB5MCk7XG4gICAgcmV0dXJuIFtwMXgsIHAxeSwgcDJ4LCBwMnldO1xufVxuZnVuY3Rpb24gZXhwYW5kUG9pbnRzKHAsIHRlbnNpb24pIHtcbiAgICB2YXIgbGVuID0gcC5sZW5ndGgsIGFsbFBvaW50cyA9IFtdLCBuLCBjcDtcbiAgICBmb3IgKG4gPSAyOyBuIDwgbGVuIC0gMjsgbiArPSAyKSB7XG4gICAgICAgIGNwID0gZ2V0Q29udHJvbFBvaW50cyhwW24gLSAyXSwgcFtuIC0gMV0sIHBbbl0sIHBbbiArIDFdLCBwW24gKyAyXSwgcFtuICsgM10sIHRlbnNpb24pO1xuICAgICAgICBpZiAoaXNOYU4oY3BbMF0pKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBhbGxQb2ludHMucHVzaChjcFswXSk7XG4gICAgICAgIGFsbFBvaW50cy5wdXNoKGNwWzFdKTtcbiAgICAgICAgYWxsUG9pbnRzLnB1c2gocFtuXSk7XG4gICAgICAgIGFsbFBvaW50cy5wdXNoKHBbbiArIDFdKTtcbiAgICAgICAgYWxsUG9pbnRzLnB1c2goY3BbMl0pO1xuICAgICAgICBhbGxQb2ludHMucHVzaChjcFszXSk7XG4gICAgfVxuICAgIHJldHVybiBhbGxQb2ludHM7XG59XG5leHBvcnQgY2xhc3MgTGluZSBleHRlbmRzIFNoYXBlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcbiAgICAgICAgdGhpcy5vbigncG9pbnRzQ2hhbmdlLmtvbnZhIHRlbnNpb25DaGFuZ2Uua29udmEgY2xvc2VkQ2hhbmdlLmtvbnZhIGJlemllckNoYW5nZS5rb252YScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyQ2FjaGUoJ3RlbnNpb25Qb2ludHMnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9zY2VuZUZ1bmMoY29udGV4dCkge1xuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHMoKSwgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCwgdGVuc2lvbiA9IHRoaXMudGVuc2lvbigpLCBjbG9zZWQgPSB0aGlzLmNsb3NlZCgpLCBiZXppZXIgPSB0aGlzLmJlemllcigpLCB0cCwgbGVuLCBuO1xuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcbiAgICAgICAgaWYgKHRlbnNpb24gIT09IDAgJiYgbGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgdHAgPSB0aGlzLmdldFRlbnNpb25Qb2ludHMoKTtcbiAgICAgICAgICAgIGxlbiA9IHRwLmxlbmd0aDtcbiAgICAgICAgICAgIG4gPSBjbG9zZWQgPyAwIDogNDtcbiAgICAgICAgICAgIGlmICghY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHRwWzBdLCB0cFsxXSwgdHBbMl0sIHRwWzNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChuIDwgbGVuIC0gMikge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh0cFtuKytdLCB0cFtuKytdLCB0cFtuKytdLCB0cFtuKytdLCB0cFtuKytdLCB0cFtuKytdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHRwW2xlbiAtIDJdLCB0cFtsZW4gLSAxXSwgcG9pbnRzW2xlbmd0aCAtIDJdLCBwb2ludHNbbGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJlemllcikge1xuICAgICAgICAgICAgbiA9IDI7XG4gICAgICAgICAgICB3aGlsZSAobiA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyhwb2ludHNbbisrXSwgcG9pbnRzW24rK10sIHBvaW50c1tuKytdLCBwb2ludHNbbisrXSwgcG9pbnRzW24rK10sIHBvaW50c1tuKytdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobiA9IDI7IG4gPCBsZW5ndGg7IG4gKz0gMikge1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHBvaW50c1tuXSwgcG9pbnRzW24gKyAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsb3NlZCkge1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRUZW5zaW9uUG9pbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUoJ3RlbnNpb25Qb2ludHMnLCB0aGlzLl9nZXRUZW5zaW9uUG9pbnRzKTtcbiAgICB9XG4gICAgX2dldFRlbnNpb25Qb2ludHMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VGVuc2lvblBvaW50c0Nsb3NlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGV4cGFuZFBvaW50cyh0aGlzLnBvaW50cygpLCB0aGlzLnRlbnNpb24oKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldFRlbnNpb25Qb2ludHNDbG9zZWQoKSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5wb2ludHMoKSwgbGVuID0gcC5sZW5ndGgsIHRlbnNpb24gPSB0aGlzLnRlbnNpb24oKSwgZmlyc3RDb250cm9sUG9pbnRzID0gZ2V0Q29udHJvbFBvaW50cyhwW2xlbiAtIDJdLCBwW2xlbiAtIDFdLCBwWzBdLCBwWzFdLCBwWzJdLCBwWzNdLCB0ZW5zaW9uKSwgbGFzdENvbnRyb2xQb2ludHMgPSBnZXRDb250cm9sUG9pbnRzKHBbbGVuIC0gNF0sIHBbbGVuIC0gM10sIHBbbGVuIC0gMl0sIHBbbGVuIC0gMV0sIHBbMF0sIHBbMV0sIHRlbnNpb24pLCBtaWRkbGUgPSBleHBhbmRQb2ludHMocCwgdGVuc2lvbiksIHRwID0gW2ZpcnN0Q29udHJvbFBvaW50c1syXSwgZmlyc3RDb250cm9sUG9pbnRzWzNdXVxuICAgICAgICAgICAgLmNvbmNhdChtaWRkbGUpXG4gICAgICAgICAgICAuY29uY2F0KFtcbiAgICAgICAgICAgIGxhc3RDb250cm9sUG9pbnRzWzBdLFxuICAgICAgICAgICAgbGFzdENvbnRyb2xQb2ludHNbMV0sXG4gICAgICAgICAgICBwW2xlbiAtIDJdLFxuICAgICAgICAgICAgcFtsZW4gLSAxXSxcbiAgICAgICAgICAgIGxhc3RDb250cm9sUG9pbnRzWzJdLFxuICAgICAgICAgICAgbGFzdENvbnRyb2xQb2ludHNbM10sXG4gICAgICAgICAgICBmaXJzdENvbnRyb2xQb2ludHNbMF0sXG4gICAgICAgICAgICBmaXJzdENvbnRyb2xQb2ludHNbMV0sXG4gICAgICAgICAgICBwWzBdLFxuICAgICAgICAgICAgcFsxXSxcbiAgICAgICAgXSk7XG4gICAgICAgIHJldHVybiB0cDtcbiAgICB9XG4gICAgZ2V0V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNlbGZSZWN0KCkud2lkdGg7XG4gICAgfVxuICAgIGdldEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VsZlJlY3QoKS5oZWlnaHQ7XG4gICAgfVxuICAgIGdldFNlbGZSZWN0KCkge1xuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHMoKTtcbiAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPCA0KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHBvaW50c1swXSB8fCAwLFxuICAgICAgICAgICAgICAgIHk6IHBvaW50c1sxXSB8fCAwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGVuc2lvbigpICE9PSAwKSB7XG4gICAgICAgICAgICBwb2ludHMgPSBbXG4gICAgICAgICAgICAgICAgcG9pbnRzWzBdLFxuICAgICAgICAgICAgICAgIHBvaW50c1sxXSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9nZXRUZW5zaW9uUG9pbnRzKCksXG4gICAgICAgICAgICAgICAgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSxcbiAgICAgICAgICAgICAgICBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvaW50cyA9IHRoaXMucG9pbnRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pblggPSBwb2ludHNbMF07XG4gICAgICAgIHZhciBtYXhYID0gcG9pbnRzWzBdO1xuICAgICAgICB2YXIgbWluWSA9IHBvaW50c1sxXTtcbiAgICAgICAgdmFyIG1heFkgPSBwb2ludHNbMV07XG4gICAgICAgIHZhciB4LCB5O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgICAgIHggPSBwb2ludHNbaSAqIDJdO1xuICAgICAgICAgICAgeSA9IHBvaW50c1tpICogMiArIDFdO1xuICAgICAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHgpO1xuICAgICAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHgpO1xuICAgICAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHkpO1xuICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBtaW5YLFxuICAgICAgICAgICAgeTogbWluWSxcbiAgICAgICAgICAgIHdpZHRoOiBtYXhYIC0gbWluWCxcbiAgICAgICAgICAgIGhlaWdodDogbWF4WSAtIG1pblksXG4gICAgICAgIH07XG4gICAgfVxufVxuTGluZS5wcm90b3R5cGUuY2xhc3NOYW1lID0gJ0xpbmUnO1xuTGluZS5wcm90b3R5cGUuX2F0dHJzQWZmZWN0aW5nU2l6ZSA9IFsncG9pbnRzJywgJ2JlemllcicsICd0ZW5zaW9uJ107XG5fcmVnaXN0ZXJOb2RlKExpbmUpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoTGluZSwgJ2Nsb3NlZCcsIGZhbHNlKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKExpbmUsICdiZXppZXInLCBmYWxzZSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihMaW5lLCAndGVuc2lvbicsIDAsIGdldE51bWJlclZhbGlkYXRvcigpKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKExpbmUsICdwb2ludHMnLCBbXSwgZ2V0TnVtYmVyQXJyYXlWYWxpZGF0b3IoKSk7XG4iLCJpbXBvcnQgeyBGYWN0b3J5IH0gZnJvbSAnLi4vRmFjdG9yeS5qcyc7XG5pbXBvcnQgeyBTaGFwZSB9IGZyb20gJy4uL1NoYXBlLmpzJztcbmltcG9ydCB7IF9yZWdpc3Rlck5vZGUgfSBmcm9tICcuLi9HbG9iYWwuanMnO1xuZXhwb3J0IGNsYXNzIFBhdGggZXh0ZW5kcyBTaGFwZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG4gICAgICAgIHRoaXMuZGF0YUFycmF5ID0gW107XG4gICAgICAgIHRoaXMucGF0aExlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuZGF0YUFycmF5ID0gUGF0aC5wYXJzZVBhdGhEYXRhKHRoaXMuZGF0YSgpKTtcbiAgICAgICAgdGhpcy5wYXRoTGVuZ3RoID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGFBcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5wYXRoTGVuZ3RoICs9IHRoaXMuZGF0YUFycmF5W2ldLnBhdGhMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbignZGF0YUNoYW5nZS5rb252YScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YUFycmF5ID0gUGF0aC5wYXJzZVBhdGhEYXRhKHRoaXMuZGF0YSgpKTtcbiAgICAgICAgICAgIHRoaXMucGF0aExlbmd0aCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YUFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoTGVuZ3RoICs9IHRoaXMuZGF0YUFycmF5W2ldLnBhdGhMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfc2NlbmVGdW5jKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGNhID0gdGhpcy5kYXRhQXJyYXk7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIHZhciBpc0Nsb3NlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGNhLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGNhW25dLmNvbW1hbmQ7XG4gICAgICAgICAgICB2YXIgcCA9IGNhW25dLnBvaW50cztcbiAgICAgICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwWzBdLCBwWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHBbMF0sIHBbMV0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHBbMF0sIHBbMV0sIHBbMl0sIHBbM10sIHBbNF0sIHBbNV0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHBbMF0sIHBbMV0sIHBbMl0sIHBbM10pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN4ID0gcFswXSwgY3kgPSBwWzFdLCByeCA9IHBbMl0sIHJ5ID0gcFszXSwgdGhldGEgPSBwWzRdLCBkVGhldGEgPSBwWzVdLCBwc2kgPSBwWzZdLCBmcyA9IHBbN107XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gcnggPiByeSA/IHJ4IDogcnk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZVggPSByeCA+IHJ5ID8gMSA6IHJ4IC8gcnk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZVkgPSByeCA+IHJ5ID8gcnkgLyByeCA6IDE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKGN4LCBjeSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucm90YXRlKHBzaSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByLCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIDEgLSBmcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc2NhbGUoMSAvIHNjYWxlWCwgMSAvIHNjYWxlWSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucm90YXRlKC1wc2kpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtY3gsIC1jeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3onOlxuICAgICAgICAgICAgICAgICAgICBpc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNDbG9zZWQgJiYgIXRoaXMuaGFzRmlsbCgpKSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0U2VsZlJlY3QoKSB7XG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICAgICAgdGhpcy5kYXRhQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgaWYgKGRhdGEuY29tbWFuZCA9PT0gJ0EnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZGF0YS5wb2ludHNbNF07XG4gICAgICAgICAgICAgICAgdmFyIGRUaGV0YSA9IGRhdGEucG9pbnRzWzVdO1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBkYXRhLnBvaW50c1s0XSArIGRUaGV0YTtcbiAgICAgICAgICAgICAgICB2YXIgaW5jID0gTWF0aC5QSSAvIDE4MC4wO1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhzdGFydCAtIGVuZCkgPCBpbmMpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jID0gTWF0aC5hYnMoc3RhcnQgLSBlbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZFRoZXRhIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0ID0gc3RhcnQgLSBpbmM7IHQgPiBlbmQ7IHQgLT0gaW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2ludCA9IFBhdGguZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMoZGF0YS5wb2ludHNbMF0sIGRhdGEucG9pbnRzWzFdLCBkYXRhLnBvaW50c1syXSwgZGF0YS5wb2ludHNbM10sIHQsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHQgPSBzdGFydCArIGluYzsgdCA8IGVuZDsgdCArPSBpbmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gUGF0aC5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhkYXRhLnBvaW50c1swXSwgZGF0YS5wb2ludHNbMV0sIGRhdGEucG9pbnRzWzJdLCBkYXRhLnBvaW50c1szXSwgdCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEuY29tbWFuZCA9PT0gJ0MnKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdCA9IDAuMDsgdCA8PSAxOyB0ICs9IDAuMDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBQYXRoLmdldFBvaW50T25DdWJpY0Jlemllcih0LCBkYXRhLnN0YXJ0LngsIGRhdGEuc3RhcnQueSwgZGF0YS5wb2ludHNbMF0sIGRhdGEucG9pbnRzWzFdLCBkYXRhLnBvaW50c1syXSwgZGF0YS5wb2ludHNbM10sIGRhdGEucG9pbnRzWzRdLCBkYXRhLnBvaW50c1s1XSk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvaW50cyA9IHBvaW50cy5jb25jYXQoZGF0YS5wb2ludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG1pblggPSBwb2ludHNbMF07XG4gICAgICAgIHZhciBtYXhYID0gcG9pbnRzWzBdO1xuICAgICAgICB2YXIgbWluWSA9IHBvaW50c1sxXTtcbiAgICAgICAgdmFyIG1heFkgPSBwb2ludHNbMV07XG4gICAgICAgIHZhciB4LCB5O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgICAgIHggPSBwb2ludHNbaSAqIDJdO1xuICAgICAgICAgICAgeSA9IHBvaW50c1tpICogMiArIDFdO1xuICAgICAgICAgICAgaWYgKCFpc05hTih4KSkge1xuICAgICAgICAgICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4KTtcbiAgICAgICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTmFOKHkpKSB7XG4gICAgICAgICAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHkpO1xuICAgICAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogbWluWCxcbiAgICAgICAgICAgIHk6IG1pblksXG4gICAgICAgICAgICB3aWR0aDogbWF4WCAtIG1pblgsXG4gICAgICAgICAgICBoZWlnaHQ6IG1heFkgLSBtaW5ZLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdGhMZW5ndGg7XG4gICAgfVxuICAgIGdldFBvaW50QXRMZW5ndGgobGVuZ3RoKSB7XG4gICAgICAgIHZhciBwb2ludCwgaSA9IDAsIGlpID0gdGhpcy5kYXRhQXJyYXkubGVuZ3RoO1xuICAgICAgICBpZiAoIWlpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaSA8IGlpICYmIGxlbmd0aCA+IHRoaXMuZGF0YUFycmF5W2ldLnBhdGhMZW5ndGgpIHtcbiAgICAgICAgICAgIGxlbmd0aCAtPSB0aGlzLmRhdGFBcnJheVtpXS5wYXRoTGVuZ3RoO1xuICAgICAgICAgICAgKytpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID09PSBpaSkge1xuICAgICAgICAgICAgcG9pbnQgPSB0aGlzLmRhdGFBcnJheVtpIC0gMV0ucG9pbnRzLnNsaWNlKC0yKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogcG9pbnRbMF0sXG4gICAgICAgICAgICAgICAgeTogcG9pbnRbMV0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCAwLjAxKSB7XG4gICAgICAgICAgICBwb2ludCA9IHRoaXMuZGF0YUFycmF5W2ldLnBvaW50cy5zbGljZSgwLCAyKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogcG9pbnRbMF0sXG4gICAgICAgICAgICAgICAgeTogcG9pbnRbMV0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBjcCA9IHRoaXMuZGF0YUFycmF5W2ldO1xuICAgICAgICB2YXIgcCA9IGNwLnBvaW50cztcbiAgICAgICAgc3dpdGNoIChjcC5jb21tYW5kKSB7XG4gICAgICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gUGF0aC5nZXRQb2ludE9uTGluZShsZW5ndGgsIGNwLnN0YXJ0LngsIGNwLnN0YXJ0LnksIHBbMF0sIHBbMV0pO1xuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhdGguZ2V0UG9pbnRPbkN1YmljQmV6aWVyKGxlbmd0aCAvIGNwLnBhdGhMZW5ndGgsIGNwLnN0YXJ0LngsIGNwLnN0YXJ0LnksIHBbMF0sIHBbMV0sIHBbMl0sIHBbM10sIHBbNF0sIHBbNV0pO1xuICAgICAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhdGguZ2V0UG9pbnRPblF1YWRyYXRpY0JlemllcihsZW5ndGggLyBjcC5wYXRoTGVuZ3RoLCBjcC5zdGFydC54LCBjcC5zdGFydC55LCBwWzBdLCBwWzFdLCBwWzJdLCBwWzNdKTtcbiAgICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgICAgIHZhciBjeCA9IHBbMF0sIGN5ID0gcFsxXSwgcnggPSBwWzJdLCByeSA9IHBbM10sIHRoZXRhID0gcFs0XSwgZFRoZXRhID0gcFs1XSwgcHNpID0gcFs2XTtcbiAgICAgICAgICAgICAgICB0aGV0YSArPSAoZFRoZXRhICogbGVuZ3RoKSAvIGNwLnBhdGhMZW5ndGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhdGguZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMoY3gsIGN5LCByeCwgcnksIHRoZXRhLCBwc2kpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TGluZUxlbmd0aCh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KCh4MiAtIHgxKSAqICh4MiAtIHgxKSArICh5MiAtIHkxKSAqICh5MiAtIHkxKSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRQb2ludE9uTGluZShkaXN0LCBQMXgsIFAxeSwgUDJ4LCBQMnksIGZyb21YLCBmcm9tWSkge1xuICAgICAgICBpZiAoZnJvbVggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZnJvbVggPSBQMXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21ZID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZyb21ZID0gUDF5O1xuICAgICAgICB9XG4gICAgICAgIHZhciBtID0gKFAyeSAtIFAxeSkgLyAoUDJ4IC0gUDF4ICsgMC4wMDAwMDAwMSk7XG4gICAgICAgIHZhciBydW4gPSBNYXRoLnNxcnQoKGRpc3QgKiBkaXN0KSAvICgxICsgbSAqIG0pKTtcbiAgICAgICAgaWYgKFAyeCA8IFAxeCkge1xuICAgICAgICAgICAgcnVuICo9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHZhciByaXNlID0gbSAqIHJ1bjtcbiAgICAgICAgdmFyIHB0O1xuICAgICAgICBpZiAoUDJ4ID09PSBQMXgpIHtcbiAgICAgICAgICAgIHB0ID0ge1xuICAgICAgICAgICAgICAgIHg6IGZyb21YLFxuICAgICAgICAgICAgICAgIHk6IGZyb21ZICsgcmlzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGZyb21ZIC0gUDF5KSAvIChmcm9tWCAtIFAxeCArIDAuMDAwMDAwMDEpID09PSBtKSB7XG4gICAgICAgICAgICBwdCA9IHtcbiAgICAgICAgICAgICAgICB4OiBmcm9tWCArIHJ1bixcbiAgICAgICAgICAgICAgICB5OiBmcm9tWSArIHJpc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGl4LCBpeTtcbiAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLmdldExpbmVMZW5ndGgoUDF4LCBQMXksIFAyeCwgUDJ5KTtcbiAgICAgICAgICAgIHZhciB1ID0gKGZyb21YIC0gUDF4KSAqIChQMnggLSBQMXgpICsgKGZyb21ZIC0gUDF5KSAqIChQMnkgLSBQMXkpO1xuICAgICAgICAgICAgdSA9IHUgLyAobGVuICogbGVuKTtcbiAgICAgICAgICAgIGl4ID0gUDF4ICsgdSAqIChQMnggLSBQMXgpO1xuICAgICAgICAgICAgaXkgPSBQMXkgKyB1ICogKFAyeSAtIFAxeSk7XG4gICAgICAgICAgICB2YXIgcFJpc2UgPSB0aGlzLmdldExpbmVMZW5ndGgoZnJvbVgsIGZyb21ZLCBpeCwgaXkpO1xuICAgICAgICAgICAgdmFyIHBSdW4gPSBNYXRoLnNxcnQoZGlzdCAqIGRpc3QgLSBwUmlzZSAqIHBSaXNlKTtcbiAgICAgICAgICAgIHJ1biA9IE1hdGguc3FydCgocFJ1biAqIHBSdW4pIC8gKDEgKyBtICogbSkpO1xuICAgICAgICAgICAgaWYgKFAyeCA8IFAxeCkge1xuICAgICAgICAgICAgICAgIHJ1biAqPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJpc2UgPSBtICogcnVuO1xuICAgICAgICAgICAgcHQgPSB7XG4gICAgICAgICAgICAgICAgeDogaXggKyBydW4sXG4gICAgICAgICAgICAgICAgeTogaXkgKyByaXNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHQ7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRQb2ludE9uQ3ViaWNCZXppZXIocGN0LCBQMXgsIFAxeSwgUDJ4LCBQMnksIFAzeCwgUDN5LCBQNHgsIFA0eSkge1xuICAgICAgICBmdW5jdGlvbiBDQjEodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQgKiB0ICogdDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBDQjIodCkge1xuICAgICAgICAgICAgcmV0dXJuIDMgKiB0ICogdCAqICgxIC0gdCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gQ0IzKHQpIHtcbiAgICAgICAgICAgIHJldHVybiAzICogdCAqICgxIC0gdCkgKiAoMSAtIHQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIENCNCh0KSB7XG4gICAgICAgICAgICByZXR1cm4gKDEgLSB0KSAqICgxIC0gdCkgKiAoMSAtIHQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB4ID0gUDR4ICogQ0IxKHBjdCkgKyBQM3ggKiBDQjIocGN0KSArIFAyeCAqIENCMyhwY3QpICsgUDF4ICogQ0I0KHBjdCk7XG4gICAgICAgIHZhciB5ID0gUDR5ICogQ0IxKHBjdCkgKyBQM3kgKiBDQjIocGN0KSArIFAyeSAqIENCMyhwY3QpICsgUDF5ICogQ0I0KHBjdCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGdldFBvaW50T25RdWFkcmF0aWNCZXppZXIocGN0LCBQMXgsIFAxeSwgUDJ4LCBQMnksIFAzeCwgUDN5KSB7XG4gICAgICAgIGZ1bmN0aW9uIFFCMSh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdCAqIHQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gUUIyKHQpIHtcbiAgICAgICAgICAgIHJldHVybiAyICogdCAqICgxIC0gdCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gUUIzKHQpIHtcbiAgICAgICAgICAgIHJldHVybiAoMSAtIHQpICogKDEgLSB0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeCA9IFAzeCAqIFFCMShwY3QpICsgUDJ4ICogUUIyKHBjdCkgKyBQMXggKiBRQjMocGN0KTtcbiAgICAgICAgdmFyIHkgPSBQM3kgKiBRQjEocGN0KSArIFAyeSAqIFFCMihwY3QpICsgUDF5ICogUUIzKHBjdCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGdldFBvaW50T25FbGxpcHRpY2FsQXJjKGN4LCBjeSwgcngsIHJ5LCB0aGV0YSwgcHNpKSB7XG4gICAgICAgIHZhciBjb3NQc2kgPSBNYXRoLmNvcyhwc2kpLCBzaW5Qc2kgPSBNYXRoLnNpbihwc2kpO1xuICAgICAgICB2YXIgcHQgPSB7XG4gICAgICAgICAgICB4OiByeCAqIE1hdGguY29zKHRoZXRhKSxcbiAgICAgICAgICAgIHk6IHJ5ICogTWF0aC5zaW4odGhldGEpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogY3ggKyAocHQueCAqIGNvc1BzaSAtIHB0LnkgKiBzaW5Qc2kpLFxuICAgICAgICAgICAgeTogY3kgKyAocHQueCAqIHNpblBzaSArIHB0LnkgKiBjb3NQc2kpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2VQYXRoRGF0YShkYXRhKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjcyA9IGRhdGE7XG4gICAgICAgIHZhciBjYyA9IFtcbiAgICAgICAgICAgICdtJyxcbiAgICAgICAgICAgICdNJyxcbiAgICAgICAgICAgICdsJyxcbiAgICAgICAgICAgICdMJyxcbiAgICAgICAgICAgICd2JyxcbiAgICAgICAgICAgICdWJyxcbiAgICAgICAgICAgICdoJyxcbiAgICAgICAgICAgICdIJyxcbiAgICAgICAgICAgICd6JyxcbiAgICAgICAgICAgICdaJyxcbiAgICAgICAgICAgICdjJyxcbiAgICAgICAgICAgICdDJyxcbiAgICAgICAgICAgICdxJyxcbiAgICAgICAgICAgICdRJyxcbiAgICAgICAgICAgICd0JyxcbiAgICAgICAgICAgICdUJyxcbiAgICAgICAgICAgICdzJyxcbiAgICAgICAgICAgICdTJyxcbiAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICdBJyxcbiAgICAgICAgXTtcbiAgICAgICAgY3MgPSBjcy5yZXBsYWNlKG5ldyBSZWdFeHAoJyAnLCAnZycpLCAnLCcpO1xuICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGNjLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICBjcyA9IGNzLnJlcGxhY2UobmV3IFJlZ0V4cChjY1tuXSwgJ2cnKSwgJ3wnICsgY2Nbbl0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhcnIgPSBjcy5zcGxpdCgnfCcpO1xuICAgICAgICB2YXIgY2EgPSBbXTtcbiAgICAgICAgdmFyIGNvb3JkcyA9IFtdO1xuICAgICAgICB2YXIgY3B4ID0gMDtcbiAgICAgICAgdmFyIGNweSA9IDA7XG4gICAgICAgIHZhciByZSA9IC8oWy0rXT8oKFxcZCtcXC5cXGQrKXwoKFxcZCspfChcXC5cXGQrKSkpKD86ZVstK10/XFxkKyk/KS9naTtcbiAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICBmb3IgKG4gPSAxOyBuIDwgYXJyLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICB2YXIgc3RyID0gYXJyW25dO1xuICAgICAgICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KDApO1xuICAgICAgICAgICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuICAgICAgICAgICAgY29vcmRzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gcmUuZXhlYyhzdHIpKSkge1xuICAgICAgICAgICAgICAgIGNvb3Jkcy5wdXNoKG1hdGNoWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGNvb3Jkcy5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY29vcmRzW2pdID09PSAnMDAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHAucHVzaCgwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwYXJzZWQgPSBwYXJzZUZsb2F0KGNvb3Jkc1tqXSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihwYXJzZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHAucHVzaChwYXJzZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcC5wdXNoKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChwLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4ocFswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjbWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRYID0gY3B4LCBzdGFydFkgPSBjcHk7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZDbWQsIGN0bFB0eCwgY3RsUHR5O1xuICAgICAgICAgICAgICAgIHZhciByeCwgcnksIHBzaSwgZmEsIGZzLCB4MSwgeTE7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnTCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gZHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnTSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2EubGVuZ3RoID4gMiAmJiBjYVtjYS5sZW5ndGggLSAxXS5jb21tYW5kID09PSAneicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpZHggPSBjYS5sZW5ndGggLSAyOyBpZHggPj0gMDsgaWR4LS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhW2lkeF0uY29tbWFuZCA9PT0gJ00nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBjYVtpZHhdLnBvaW50c1swXSArIGR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gY2FbaWR4XS5wb2ludHNbMV0gKyBkeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9ICdsJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdNJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAnTCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ0wnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ0wnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdMJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdMJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHAuc2hpZnQoKSwgcC5zaGlmdCgpLCBwLnNoaWZ0KCksIHAuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHggKyBwLnNoaWZ0KCksIGNweSArIHAuc2hpZnQoKSwgY3B4ICsgcC5zaGlmdCgpLCBjcHkgKyBwLnNoaWZ0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnQyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Q21kID0gY2FbY2EubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldkNtZC5jb21tYW5kID09PSAnQycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHggKyAoY3B4IC0gcHJldkNtZC5wb2ludHNbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweSArIChjcHkgLSBwcmV2Q21kLnBvaW50c1szXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjdGxQdHgsIGN0bFB0eSwgcC5zaGlmdCgpLCBwLnNoaWZ0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ0MnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldkNtZCA9IGNhW2NhLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZDbWQuY29tbWFuZCA9PT0gJ0MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4ICsgKGNweCAtIHByZXZDbWQucG9pbnRzWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHkgKyAoY3B5IC0gcHJldkNtZC5wb2ludHNbM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3RsUHR4LCBjdGxQdHksIGNweCArIHAuc2hpZnQoKSwgY3B5ICsgcC5zaGlmdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ0MnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gocC5zaGlmdCgpLCBwLnNoaWZ0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4ICsgcC5zaGlmdCgpLCBjcHkgKyBwLnNoaWZ0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnUSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Q21kID0gY2FbY2EubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldkNtZC5jb21tYW5kID09PSAnUScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHggKyAoY3B4IC0gcHJldkNtZC5wb2ludHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweSArIChjcHkgLSBwcmV2Q21kLnBvaW50c1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnUSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldkNtZCA9IGNhW2NhLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZDbWQuY29tbWFuZCA9PT0gJ1EnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4ICsgKGNweCAtIHByZXZDbWQucG9pbnRzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHkgKyAoY3B5IC0gcHJldkNtZC5wb2ludHNbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnUSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcnggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByeSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBzaSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnMgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9IGNweDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ0EnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gdGhpcy5jb252ZXJ0RW5kcG9pbnRUb0NlbnRlclBhcmFtZXRlcml6YXRpb24oeDEsIHkxLCBjcHgsIGNweSwgZmEsIGZzLCByeCwgcnksIHBzaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByeCA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ5ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHNpID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmEgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcyA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gY3B4O1xuICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdBJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IHRoaXMuY29udmVydEVuZHBvaW50VG9DZW50ZXJQYXJhbWV0ZXJpemF0aW9uKHgxLCB5MSwgY3B4LCBjcHksIGZhLCBmcywgcngsIHJ5LCBwc2kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBjbWQgfHwgYyxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBzdGFydFgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBzdGFydFksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBhdGhMZW5ndGg6IHRoaXMuY2FsY0xlbmd0aChzdGFydFgsIHN0YXJ0WSwgY21kIHx8IGMsIHBvaW50cyksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gJ3onIHx8IGMgPT09ICdaJykge1xuICAgICAgICAgICAgICAgIGNhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiAneicsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50czogW10sXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHBhdGhMZW5ndGg6IDAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhO1xuICAgIH1cbiAgICBzdGF0aWMgY2FsY0xlbmd0aCh4LCB5LCBjbWQsIHBvaW50cykge1xuICAgICAgICB2YXIgbGVuLCBwMSwgcDIsIHQ7XG4gICAgICAgIHZhciBwYXRoID0gUGF0aDtcbiAgICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoLmdldExpbmVMZW5ndGgoeCwgeSwgcG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgbGVuID0gMC4wO1xuICAgICAgICAgICAgICAgIHAxID0gcGF0aC5nZXRQb2ludE9uQ3ViaWNCZXppZXIoMCwgeCwgeSwgcG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCBwb2ludHNbNF0sIHBvaW50c1s1XSk7XG4gICAgICAgICAgICAgICAgZm9yICh0ID0gMC4wMTsgdCA8PSAxOyB0ICs9IDAuMDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcDIgPSBwYXRoLmdldFBvaW50T25DdWJpY0Jlemllcih0LCB4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHBvaW50c1s0XSwgcG9pbnRzWzVdKTtcbiAgICAgICAgICAgICAgICAgICAgbGVuICs9IHBhdGguZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcbiAgICAgICAgICAgICAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbjtcbiAgICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgICAgIGxlbiA9IDAuMDtcbiAgICAgICAgICAgICAgICBwMSA9IHBhdGguZ2V0UG9pbnRPblF1YWRyYXRpY0JlemllcigwLCB4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10pO1xuICAgICAgICAgICAgICAgIGZvciAodCA9IDAuMDE7IHQgPD0gMTsgdCArPSAwLjAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHAyID0gcGF0aC5nZXRQb2ludE9uUXVhZHJhdGljQmV6aWVyKHQsIHgsIHksIHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSk7XG4gICAgICAgICAgICAgICAgICAgIGxlbiArPSBwYXRoLmdldExpbmVMZW5ndGgocDEueCwgcDEueSwgcDIueCwgcDIueSk7XG4gICAgICAgICAgICAgICAgICAgIHAxID0gcDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBsZW47XG4gICAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgICAgICBsZW4gPSAwLjA7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gcG9pbnRzWzRdO1xuICAgICAgICAgICAgICAgIHZhciBkVGhldGEgPSBwb2ludHNbNV07XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IHBvaW50c1s0XSArIGRUaGV0YTtcbiAgICAgICAgICAgICAgICB2YXIgaW5jID0gTWF0aC5QSSAvIDE4MC4wO1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhzdGFydCAtIGVuZCkgPCBpbmMpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jID0gTWF0aC5hYnMoc3RhcnQgLSBlbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwMSA9IHBhdGguZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCBzdGFydCwgMCk7XG4gICAgICAgICAgICAgICAgaWYgKGRUaGV0YSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh0ID0gc3RhcnQgLSBpbmM7IHQgPiBlbmQ7IHQgLT0gaW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwMiA9IHBhdGguZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCB0LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbiArPSBwYXRoLmdldExpbmVMZW5ndGgocDEueCwgcDEueSwgcDIueCwgcDIueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHQgPSBzdGFydCArIGluYzsgdCA8IGVuZDsgdCArPSBpbmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAyID0gcGF0aC5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHQsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuICs9IHBhdGguZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAxID0gcDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcDIgPSBwYXRoLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgZW5kLCAwKTtcbiAgICAgICAgICAgICAgICBsZW4gKz0gcGF0aC5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBsZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHN0YXRpYyBjb252ZXJ0RW5kcG9pbnRUb0NlbnRlclBhcmFtZXRlcml6YXRpb24oeDEsIHkxLCB4MiwgeTIsIGZhLCBmcywgcngsIHJ5LCBwc2lEZWcpIHtcbiAgICAgICAgdmFyIHBzaSA9IHBzaURlZyAqIChNYXRoLlBJIC8gMTgwLjApO1xuICAgICAgICB2YXIgeHAgPSAoTWF0aC5jb3MocHNpKSAqICh4MSAtIHgyKSkgLyAyLjAgKyAoTWF0aC5zaW4ocHNpKSAqICh5MSAtIHkyKSkgLyAyLjA7XG4gICAgICAgIHZhciB5cCA9ICgtMSAqIE1hdGguc2luKHBzaSkgKiAoeDEgLSB4MikpIC8gMi4wICtcbiAgICAgICAgICAgIChNYXRoLmNvcyhwc2kpICogKHkxIC0geTIpKSAvIDIuMDtcbiAgICAgICAgdmFyIGxhbWJkYSA9ICh4cCAqIHhwKSAvIChyeCAqIHJ4KSArICh5cCAqIHlwKSAvIChyeSAqIHJ5KTtcbiAgICAgICAgaWYgKGxhbWJkYSA+IDEpIHtcbiAgICAgICAgICAgIHJ4ICo9IE1hdGguc3FydChsYW1iZGEpO1xuICAgICAgICAgICAgcnkgKj0gTWF0aC5zcXJ0KGxhbWJkYSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGYgPSBNYXRoLnNxcnQoKHJ4ICogcnggKiAocnkgKiByeSkgLSByeCAqIHJ4ICogKHlwICogeXApIC0gcnkgKiByeSAqICh4cCAqIHhwKSkgL1xuICAgICAgICAgICAgKHJ4ICogcnggKiAoeXAgKiB5cCkgKyByeSAqIHJ5ICogKHhwICogeHApKSk7XG4gICAgICAgIGlmIChmYSA9PT0gZnMpIHtcbiAgICAgICAgICAgIGYgKj0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKGYpKSB7XG4gICAgICAgICAgICBmID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3hwID0gKGYgKiByeCAqIHlwKSAvIHJ5O1xuICAgICAgICB2YXIgY3lwID0gKGYgKiAtcnkgKiB4cCkgLyByeDtcbiAgICAgICAgdmFyIGN4ID0gKHgxICsgeDIpIC8gMi4wICsgTWF0aC5jb3MocHNpKSAqIGN4cCAtIE1hdGguc2luKHBzaSkgKiBjeXA7XG4gICAgICAgIHZhciBjeSA9ICh5MSArIHkyKSAvIDIuMCArIE1hdGguc2luKHBzaSkgKiBjeHAgKyBNYXRoLmNvcyhwc2kpICogY3lwO1xuICAgICAgICB2YXIgdk1hZyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdlJhdGlvID0gZnVuY3Rpb24gKHUsIHYpIHtcbiAgICAgICAgICAgIHJldHVybiAodVswXSAqIHZbMF0gKyB1WzFdICogdlsxXSkgLyAodk1hZyh1KSAqIHZNYWcodikpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdkFuZ2xlID0gZnVuY3Rpb24gKHUsIHYpIHtcbiAgICAgICAgICAgIHJldHVybiAodVswXSAqIHZbMV0gPCB1WzFdICogdlswXSA/IC0xIDogMSkgKiBNYXRoLmFjb3ModlJhdGlvKHUsIHYpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRoZXRhID0gdkFuZ2xlKFsxLCAwXSwgWyh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5XSk7XG4gICAgICAgIHZhciB1ID0gWyh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5XTtcbiAgICAgICAgdmFyIHYgPSBbKC0xICogeHAgLSBjeHApIC8gcngsICgtMSAqIHlwIC0gY3lwKSAvIHJ5XTtcbiAgICAgICAgdmFyIGRUaGV0YSA9IHZBbmdsZSh1LCB2KTtcbiAgICAgICAgaWYgKHZSYXRpbyh1LCB2KSA8PSAtMSkge1xuICAgICAgICAgICAgZFRoZXRhID0gTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodlJhdGlvKHUsIHYpID49IDEpIHtcbiAgICAgICAgICAgIGRUaGV0YSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZzID09PSAwICYmIGRUaGV0YSA+IDApIHtcbiAgICAgICAgICAgIGRUaGV0YSA9IGRUaGV0YSAtIDIgKiBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcyA9PT0gMSAmJiBkVGhldGEgPCAwKSB7XG4gICAgICAgICAgICBkVGhldGEgPSBkVGhldGEgKyAyICogTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2N4LCBjeSwgcngsIHJ5LCB0aGV0YSwgZFRoZXRhLCBwc2ksIGZzXTtcbiAgICB9XG59XG5QYXRoLnByb3RvdHlwZS5jbGFzc05hbWUgPSAnUGF0aCc7XG5QYXRoLnByb3RvdHlwZS5fYXR0cnNBZmZlY3RpbmdTaXplID0gWydkYXRhJ107XG5fcmVnaXN0ZXJOb2RlKFBhdGgpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoUGF0aCwgJ2RhdGEnKTtcbiIsImltcG9ydCB7IEZhY3RvcnkgfSBmcm9tICcuLi9GYWN0b3J5LmpzJztcbmltcG9ydCB7IExpbmUgfSBmcm9tICcuL0xpbmUuanMnO1xuaW1wb3J0IHsgZ2V0TnVtYmVyVmFsaWRhdG9yIH0gZnJvbSAnLi4vVmFsaWRhdG9ycy5qcyc7XG5pbXBvcnQgeyBfcmVnaXN0ZXJOb2RlIH0gZnJvbSAnLi4vR2xvYmFsLmpzJztcbmltcG9ydCB7IFBhdGggfSBmcm9tICcuL1BhdGguanMnO1xuZXhwb3J0IGNsYXNzIEFycm93IGV4dGVuZHMgTGluZSB7XG4gICAgX3NjZW5lRnVuYyhjdHgpIHtcbiAgICAgICAgc3VwZXIuX3NjZW5lRnVuYyhjdHgpO1xuICAgICAgICB2YXIgUEkyID0gTWF0aC5QSSAqIDI7XG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cygpO1xuICAgICAgICB2YXIgdHAgPSBwb2ludHM7XG4gICAgICAgIHZhciBmcm9tVGVuc2lvbiA9IHRoaXMudGVuc2lvbigpICE9PSAwICYmIHBvaW50cy5sZW5ndGggPiA0O1xuICAgICAgICBpZiAoZnJvbVRlbnNpb24pIHtcbiAgICAgICAgICAgIHRwID0gdGhpcy5nZXRUZW5zaW9uUG9pbnRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMucG9pbnRlckxlbmd0aCgpO1xuICAgICAgICB2YXIgbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIHZhciBkeCwgZHk7XG4gICAgICAgIGlmIChmcm9tVGVuc2lvbikge1xuICAgICAgICAgICAgY29uc3QgbHAgPSBbXG4gICAgICAgICAgICAgICAgdHBbdHAubGVuZ3RoIC0gNF0sXG4gICAgICAgICAgICAgICAgdHBbdHAubGVuZ3RoIC0gM10sXG4gICAgICAgICAgICAgICAgdHBbdHAubGVuZ3RoIC0gMl0sXG4gICAgICAgICAgICAgICAgdHBbdHAubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICAgICAgcG9pbnRzW24gLSAyXSxcbiAgICAgICAgICAgICAgICBwb2ludHNbbiAtIDFdLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RMZW5ndGggPSBQYXRoLmNhbGNMZW5ndGgodHBbdHAubGVuZ3RoIC0gNF0sIHRwW3RwLmxlbmd0aCAtIDNdLCAnQycsIGxwKTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gUGF0aC5nZXRQb2ludE9uUXVhZHJhdGljQmV6aWVyKE1hdGgubWluKDEsIDEgLSBsZW5ndGggLyBsYXN0TGVuZ3RoKSwgbHBbMF0sIGxwWzFdLCBscFsyXSwgbHBbM10sIGxwWzRdLCBscFs1XSk7XG4gICAgICAgICAgICBkeCA9IHBvaW50c1tuIC0gMl0gLSBwcmV2aW91cy54O1xuICAgICAgICAgICAgZHkgPSBwb2ludHNbbiAtIDFdIC0gcHJldmlvdXMueTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGR4ID0gcG9pbnRzW24gLSAyXSAtIHBvaW50c1tuIC0gNF07XG4gICAgICAgICAgICBkeSA9IHBvaW50c1tuIC0gMV0gLSBwb2ludHNbbiAtIDNdO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYWRpYW5zID0gKE1hdGguYXRhbjIoZHksIGR4KSArIFBJMikgJSBQSTI7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMucG9pbnRlcldpZHRoKCk7XG4gICAgICAgIGlmICh0aGlzLnBvaW50ZXJBdEVuZGluZygpKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShwb2ludHNbbiAtIDJdLCBwb2ludHNbbiAtIDFdKTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUocmFkaWFucyk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKDAsIDApO1xuICAgICAgICAgICAgY3R4LmxpbmVUbygtbGVuZ3RoLCB3aWR0aCAvIDIpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbygtbGVuZ3RoLCAtd2lkdGggLyAyKTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB0aGlzLl9fZmlsbFN0cm9rZShjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBvaW50ZXJBdEJlZ2lubmluZygpKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gICAgICAgICAgICBpZiAoZnJvbVRlbnNpb24pIHtcbiAgICAgICAgICAgICAgICBkeCA9ICh0cFswXSArIHRwWzJdKSAvIDIgLSBwb2ludHNbMF07XG4gICAgICAgICAgICAgICAgZHkgPSAodHBbMV0gKyB0cFszXSkgLyAyIC0gcG9pbnRzWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZHggPSBwb2ludHNbMl0gLSBwb2ludHNbMF07XG4gICAgICAgICAgICAgICAgZHkgPSBwb2ludHNbM10gLSBwb2ludHNbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgucm90YXRlKChNYXRoLmF0YW4yKC1keSwgLWR4KSArIFBJMikgJSBQSTIpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbygwLCAwKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oLWxlbmd0aCwgd2lkdGggLyAyKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oLWxlbmd0aCwgLXdpZHRoIC8gMik7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgdGhpcy5fX2ZpbGxTdHJva2UoY3R4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfX2ZpbGxTdHJva2UoY3R4KSB7XG4gICAgICAgIHZhciBpc0Rhc2hFbmFibGVkID0gdGhpcy5kYXNoRW5hYmxlZCgpO1xuICAgICAgICBpZiAoaXNEYXNoRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5hdHRycy5kYXNoRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgICBpZiAoaXNEYXNoRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5hdHRycy5kYXNoRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0U2VsZlJlY3QoKSB7XG4gICAgICAgIGNvbnN0IGxpbmVSZWN0ID0gc3VwZXIuZ2V0U2VsZlJlY3QoKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5wb2ludGVyV2lkdGgoKSAvIDI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBsaW5lUmVjdC54IC0gb2Zmc2V0LFxuICAgICAgICAgICAgeTogbGluZVJlY3QueSAtIG9mZnNldCxcbiAgICAgICAgICAgIHdpZHRoOiBsaW5lUmVjdC53aWR0aCArIG9mZnNldCAqIDIsXG4gICAgICAgICAgICBoZWlnaHQ6IGxpbmVSZWN0LmhlaWdodCArIG9mZnNldCAqIDIsXG4gICAgICAgIH07XG4gICAgfVxufVxuQXJyb3cucHJvdG90eXBlLmNsYXNzTmFtZSA9ICdBcnJvdyc7XG5fcmVnaXN0ZXJOb2RlKEFycm93KTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEFycm93LCAncG9pbnRlckxlbmd0aCcsIDEwLCBnZXROdW1iZXJWYWxpZGF0b3IoKSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihBcnJvdywgJ3BvaW50ZXJXaWR0aCcsIDEwLCBnZXROdW1iZXJWYWxpZGF0b3IoKSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihBcnJvdywgJ3BvaW50ZXJBdEJlZ2lubmluZycsIGZhbHNlKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEFycm93LCAncG9pbnRlckF0RW5kaW5nJywgdHJ1ZSk7XG4iLCJpbXBvcnQgeyBGYWN0b3J5IH0gZnJvbSAnLi4vRmFjdG9yeS5qcyc7XG5pbXBvcnQgeyBTaGFwZSB9IGZyb20gJy4uL1NoYXBlLmpzJztcbmltcG9ydCB7IGdldE51bWJlclZhbGlkYXRvciB9IGZyb20gJy4uL1ZhbGlkYXRvcnMuanMnO1xuaW1wb3J0IHsgX3JlZ2lzdGVyTm9kZSB9IGZyb20gJy4uL0dsb2JhbC5qcyc7XG5leHBvcnQgY2xhc3MgQ2lyY2xlIGV4dGVuZHMgU2hhcGUge1xuICAgIF9zY2VuZUZ1bmMoY29udGV4dCkge1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0LmFyYygwLCAwLCB0aGlzLmF0dHJzLnJhZGl1cyB8fCAwLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICB9XG4gICAgZ2V0V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhZGl1cygpICogMjtcbiAgICB9XG4gICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYWRpdXMoKSAqIDI7XG4gICAgfVxuICAgIHNldFdpZHRoKHdpZHRoKSB7XG4gICAgICAgIGlmICh0aGlzLnJhZGl1cygpICE9PSB3aWR0aCAvIDIpIHtcbiAgICAgICAgICAgIHRoaXMucmFkaXVzKHdpZHRoIC8gMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICBpZiAodGhpcy5yYWRpdXMoKSAhPT0gaGVpZ2h0IC8gMikge1xuICAgICAgICAgICAgdGhpcy5yYWRpdXMoaGVpZ2h0IC8gMik7XG4gICAgICAgIH1cbiAgICB9XG59XG5DaXJjbGUucHJvdG90eXBlLl9jZW50cm9pZCA9IHRydWU7XG5DaXJjbGUucHJvdG90eXBlLmNsYXNzTmFtZSA9ICdDaXJjbGUnO1xuQ2lyY2xlLnByb3RvdHlwZS5fYXR0cnNBZmZlY3RpbmdTaXplID0gWydyYWRpdXMnXTtcbl9yZWdpc3Rlck5vZGUoQ2lyY2xlKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKENpcmNsZSwgJ3JhZGl1cycsIDAsIGdldE51bWJlclZhbGlkYXRvcigpKTtcbiIsImltcG9ydCB7IEZhY3RvcnkgfSBmcm9tICcuLi9GYWN0b3J5LmpzJztcbmltcG9ydCB7IFNoYXBlIH0gZnJvbSAnLi4vU2hhcGUuanMnO1xuaW1wb3J0IHsgZ2V0TnVtYmVyVmFsaWRhdG9yIH0gZnJvbSAnLi4vVmFsaWRhdG9ycy5qcyc7XG5pbXBvcnQgeyBfcmVnaXN0ZXJOb2RlIH0gZnJvbSAnLi4vR2xvYmFsLmpzJztcbmV4cG9ydCBjbGFzcyBFbGxpcHNlIGV4dGVuZHMgU2hhcGUge1xuICAgIF9zY2VuZUZ1bmMoY29udGV4dCkge1xuICAgICAgICB2YXIgcnggPSB0aGlzLnJhZGl1c1goKSwgcnkgPSB0aGlzLnJhZGl1c1koKTtcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGlmIChyeCAhPT0gcnkpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2NhbGUoMSwgcnkgLyByeCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgcngsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICB9XG4gICAgZ2V0V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhZGl1c1goKSAqIDI7XG4gICAgfVxuICAgIGdldEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFkaXVzWSgpICogMjtcbiAgICB9XG4gICAgc2V0V2lkdGgod2lkdGgpIHtcbiAgICAgICAgdGhpcy5yYWRpdXNYKHdpZHRoIC8gMik7XG4gICAgfVxuICAgIHNldEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5yYWRpdXNZKGhlaWdodCAvIDIpO1xuICAgIH1cbn1cbkVsbGlwc2UucHJvdG90eXBlLmNsYXNzTmFtZSA9ICdFbGxpcHNlJztcbkVsbGlwc2UucHJvdG90eXBlLl9jZW50cm9pZCA9IHRydWU7XG5FbGxpcHNlLnByb3RvdHlwZS5fYXR0cnNBZmZlY3RpbmdTaXplID0gWydyYWRpdXNYJywgJ3JhZGl1c1knXTtcbl9yZWdpc3Rlck5vZGUoRWxsaXBzZSk7XG5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoRWxsaXBzZSwgJ3JhZGl1cycsIFsneCcsICd5J10pO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoRWxsaXBzZSwgJ3JhZGl1c1gnLCAwLCBnZXROdW1iZXJWYWxpZGF0b3IoKSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihFbGxpcHNlLCAncmFkaXVzWScsIDAsIGdldE51bWJlclZhbGlkYXRvcigpKTtcbiIsImltcG9ydCB7IFV0aWwgfSBmcm9tICcuLi9VdGlsLmpzJztcbmltcG9ydCB7IEZhY3RvcnkgfSBmcm9tICcuLi9GYWN0b3J5LmpzJztcbmltcG9ydCB7IFNoYXBlIH0gZnJvbSAnLi4vU2hhcGUuanMnO1xuaW1wb3J0IHsgZ2V0TnVtYmVyVmFsaWRhdG9yIH0gZnJvbSAnLi4vVmFsaWRhdG9ycy5qcyc7XG5pbXBvcnQgeyBfcmVnaXN0ZXJOb2RlIH0gZnJvbSAnLi4vR2xvYmFsLmpzJztcbmV4cG9ydCBjbGFzcyBJbWFnZSBleHRlbmRzIFNoYXBlIHtcbiAgICBjb25zdHJ1Y3RvcihhdHRycykge1xuICAgICAgICBzdXBlcihhdHRycyk7XG4gICAgICAgIHRoaXMub24oJ2ltYWdlQ2hhbmdlLmtvbnZhJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fc2V0SW1hZ2VMb2FkKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zZXRJbWFnZUxvYWQoKTtcbiAgICB9XG4gICAgX3NldEltYWdlTG9hZCgpIHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSB0aGlzLmltYWdlKCk7XG4gICAgICAgIGlmIChpbWFnZSAmJiBpbWFnZS5jb21wbGV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbWFnZSAmJiBpbWFnZS5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltYWdlICYmIGltYWdlWydhZGRFdmVudExpc3RlbmVyJ10pIHtcbiAgICAgICAgICAgIGltYWdlWydhZGRFdmVudExpc3RlbmVyJ10oJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWVzdERyYXcoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIF91c2VCdWZmZXJDYW52YXMoKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5fdXNlQnVmZmVyQ2FudmFzKHRydWUpO1xuICAgIH1cbiAgICBfc2NlbmVGdW5jKGNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIGNvbnN0IGltYWdlID0gdGhpcy5hdHRycy5pbWFnZTtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBjcm9wV2lkdGggPSB0aGlzLmF0dHJzLmNyb3BXaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGNyb3BIZWlnaHQgPSB0aGlzLmF0dHJzLmNyb3BIZWlnaHQ7XG4gICAgICAgICAgICBpZiAoY3JvcFdpZHRoICYmIGNyb3BIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBbXG4gICAgICAgICAgICAgICAgICAgIGltYWdlLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyb3BYKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JvcFkoKSxcbiAgICAgICAgICAgICAgICAgICAgY3JvcFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBjcm9wSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBbaW1hZ2UsIDAsIDAsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc0ZpbGwoKSB8fCB0aGlzLmhhc1N0cm9rZSgpKSB7XG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5yZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbWFnZSkge1xuICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UuYXBwbHkoY29udGV4dCwgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaGl0RnVuYyhjb250ZXh0KSB7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGgoKSwgaGVpZ2h0ID0gdGhpcy5oZWlnaHQoKTtcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgY29udGV4dC5yZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICB9XG4gICAgZ2V0V2lkdGgoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmF0dHJzLndpZHRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2IgPSB0aGlzLmltYWdlKCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi53aWR0aDtcbiAgICB9XG4gICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5hdHRycy5oZWlnaHQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYiA9IHRoaXMuaW1hZ2UoKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhlaWdodDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21VUkwodXJsLCBjYWxsYmFjaywgb25FcnJvciA9IG51bGwpIHtcbiAgICAgICAgdmFyIGltZyA9IFV0aWwuY3JlYXRlSW1hZ2VFbGVtZW50KCk7XG4gICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2Uoe1xuICAgICAgICAgICAgICAgIGltYWdlOiBpbWcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGltYWdlKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW1nLm9uZXJyb3IgPSBvbkVycm9yO1xuICAgICAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnQW5vbnltb3VzJztcbiAgICAgICAgaW1nLnNyYyA9IHVybDtcbiAgICB9XG59XG5JbWFnZS5wcm90b3R5cGUuY2xhc3NOYW1lID0gJ0ltYWdlJztcbl9yZWdpc3Rlck5vZGUoSW1hZ2UpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoSW1hZ2UsICdpbWFnZScpO1xuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKEltYWdlLCAnY3JvcCcsIFsneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCddKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEltYWdlLCAnY3JvcFgnLCAwLCBnZXROdW1iZXJWYWxpZGF0b3IoKSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihJbWFnZSwgJ2Nyb3BZJywgMCwgZ2V0TnVtYmVyVmFsaWRhdG9yKCkpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoSW1hZ2UsICdjcm9wV2lkdGgnLCAwLCBnZXROdW1iZXJWYWxpZGF0b3IoKSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihJbWFnZSwgJ2Nyb3BIZWlnaHQnLCAwLCBnZXROdW1iZXJWYWxpZGF0b3IoKSk7XG4iLCJpbXBvcnQgeyBGYWN0b3J5IH0gZnJvbSAnLi4vRmFjdG9yeS5qcyc7XG5pbXBvcnQgeyBTaGFwZSB9IGZyb20gJy4uL1NoYXBlLmpzJztcbmltcG9ydCB7IEdyb3VwIH0gZnJvbSAnLi4vR3JvdXAuanMnO1xuaW1wb3J0IHsgZ2V0TnVtYmVyT3JBcnJheU9mTnVtYmVyc1ZhbGlkYXRvciwgZ2V0TnVtYmVyVmFsaWRhdG9yLCB9IGZyb20gJy4uL1ZhbGlkYXRvcnMuanMnO1xuaW1wb3J0IHsgX3JlZ2lzdGVyTm9kZSB9IGZyb20gJy4uL0dsb2JhbC5qcyc7XG52YXIgQVRUUl9DSEFOR0VfTElTVCA9IFtcbiAgICAnZm9udEZhbWlseScsXG4gICAgJ2ZvbnRTaXplJyxcbiAgICAnZm9udFN0eWxlJyxcbiAgICAncGFkZGluZycsXG4gICAgJ2xpbmVIZWlnaHQnLFxuICAgICd0ZXh0JyxcbiAgICAnd2lkdGgnLFxuICAgICdoZWlnaHQnLFxuXSwgQ0hBTkdFX0tPTlZBID0gJ0NoYW5nZS5rb252YScsIE5PTkUgPSAnbm9uZScsIFVQID0gJ3VwJywgUklHSFQgPSAncmlnaHQnLCBET1dOID0gJ2Rvd24nLCBMRUZUID0gJ2xlZnQnLCBhdHRyQ2hhbmdlTGlzdExlbiA9IEFUVFJfQ0hBTkdFX0xJU1QubGVuZ3RoO1xuZXhwb3J0IGNsYXNzIExhYmVsIGV4dGVuZHMgR3JvdXAge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgICAgICB0aGlzLm9uKCdhZGQua29udmEnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRMaXN0ZW5lcnMoZXZ0LmNoaWxkKTtcbiAgICAgICAgICAgIHRoaXMuX3N5bmMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmQoJ1RleHQnKVswXTtcbiAgICB9XG4gICAgZ2V0VGFnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kKCdUYWcnKVswXTtcbiAgICB9XG4gICAgX2FkZExpc3RlbmVycyh0ZXh0KSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcywgbjtcbiAgICAgICAgdmFyIGZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0Ll9zeW5jKCk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAobiA9IDA7IG4gPCBhdHRyQ2hhbmdlTGlzdExlbjsgbisrKSB7XG4gICAgICAgICAgICB0ZXh0Lm9uKEFUVFJfQ0hBTkdFX0xJU1Rbbl0gKyBDSEFOR0VfS09OVkEsIGZ1bmMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUZXh0KCkud2lkdGgoKTtcbiAgICB9XG4gICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUZXh0KCkuaGVpZ2h0KCk7XG4gICAgfVxuICAgIF9zeW5jKCkge1xuICAgICAgICB2YXIgdGV4dCA9IHRoaXMuZ2V0VGV4dCgpLCB0YWcgPSB0aGlzLmdldFRhZygpLCB3aWR0aCwgaGVpZ2h0LCBwb2ludGVyRGlyZWN0aW9uLCBwb2ludGVyV2lkdGgsIHgsIHksIHBvaW50ZXJIZWlnaHQ7XG4gICAgICAgIGlmICh0ZXh0ICYmIHRhZykge1xuICAgICAgICAgICAgd2lkdGggPSB0ZXh0LndpZHRoKCk7XG4gICAgICAgICAgICBoZWlnaHQgPSB0ZXh0LmhlaWdodCgpO1xuICAgICAgICAgICAgcG9pbnRlckRpcmVjdGlvbiA9IHRhZy5wb2ludGVyRGlyZWN0aW9uKCk7XG4gICAgICAgICAgICBwb2ludGVyV2lkdGggPSB0YWcucG9pbnRlcldpZHRoKCk7XG4gICAgICAgICAgICBwb2ludGVySGVpZ2h0ID0gdGFnLnBvaW50ZXJIZWlnaHQoKTtcbiAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgICBzd2l0Y2ggKHBvaW50ZXJEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlIFVQOlxuICAgICAgICAgICAgICAgICAgICB4ID0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICB5ID0gLTEgKiBwb2ludGVySGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFJJR0hUOlxuICAgICAgICAgICAgICAgICAgICB4ID0gd2lkdGggKyBwb2ludGVyV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBoZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIERPV046XG4gICAgICAgICAgICAgICAgICAgIHggPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBoZWlnaHQgKyBwb2ludGVySGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIExFRlQ6XG4gICAgICAgICAgICAgICAgICAgIHggPSAtMSAqIHBvaW50ZXJXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFnLnNldEF0dHJzKHtcbiAgICAgICAgICAgICAgICB4OiAtMSAqIHgsXG4gICAgICAgICAgICAgICAgeTogLTEgKiB5LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGV4dC5zZXRBdHRycyh7XG4gICAgICAgICAgICAgICAgeDogLTEgKiB4LFxuICAgICAgICAgICAgICAgIHk6IC0xICogeSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuTGFiZWwucHJvdG90eXBlLmNsYXNzTmFtZSA9ICdMYWJlbCc7XG5fcmVnaXN0ZXJOb2RlKExhYmVsKTtcbmV4cG9ydCBjbGFzcyBUYWcgZXh0ZW5kcyBTaGFwZSB7XG4gICAgX3NjZW5lRnVuYyhjb250ZXh0KSB7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGgoKSwgaGVpZ2h0ID0gdGhpcy5oZWlnaHQoKSwgcG9pbnRlckRpcmVjdGlvbiA9IHRoaXMucG9pbnRlckRpcmVjdGlvbigpLCBwb2ludGVyV2lkdGggPSB0aGlzLnBvaW50ZXJXaWR0aCgpLCBwb2ludGVySGVpZ2h0ID0gdGhpcy5wb2ludGVySGVpZ2h0KCksIGNvcm5lclJhZGl1cyA9IHRoaXMuY29ybmVyUmFkaXVzKCk7XG4gICAgICAgIGxldCB0b3BMZWZ0ID0gMDtcbiAgICAgICAgbGV0IHRvcFJpZ2h0ID0gMDtcbiAgICAgICAgbGV0IGJvdHRvbUxlZnQgPSAwO1xuICAgICAgICBsZXQgYm90dG9tUmlnaHQgPSAwO1xuICAgICAgICBpZiAodHlwZW9mIGNvcm5lclJhZGl1cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRvcExlZnQgPSB0b3BSaWdodCA9IGJvdHRvbUxlZnQgPSBib3R0b21SaWdodCA9IE1hdGgubWluKGNvcm5lclJhZGl1cywgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRvcExlZnQgPSBNYXRoLm1pbihjb3JuZXJSYWRpdXNbMF0gfHwgMCwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIHRvcFJpZ2h0ID0gTWF0aC5taW4oY29ybmVyUmFkaXVzWzFdIHx8IDAsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICBib3R0b21SaWdodCA9IE1hdGgubWluKGNvcm5lclJhZGl1c1syXSB8fCAwLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgICAgICAgICAgYm90dG9tTGVmdCA9IE1hdGgubWluKGNvcm5lclJhZGl1c1szXSB8fCAwLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHRvcExlZnQsIDApO1xuICAgICAgICBpZiAocG9pbnRlckRpcmVjdGlvbiA9PT0gVVApIHtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKCh3aWR0aCAtIHBvaW50ZXJXaWR0aCkgLyAyLCAwKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHdpZHRoIC8gMiwgLTEgKiBwb2ludGVySGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKCh3aWR0aCArIHBvaW50ZXJXaWR0aCkgLyAyLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCAtIHRvcFJpZ2h0LCAwKTtcbiAgICAgICAgY29udGV4dC5hcmMod2lkdGggLSB0b3BSaWdodCwgdG9wUmlnaHQsIHRvcFJpZ2h0LCAoTWF0aC5QSSAqIDMpIC8gMiwgMCwgZmFsc2UpO1xuICAgICAgICBpZiAocG9pbnRlckRpcmVjdGlvbiA9PT0gUklHSFQpIHtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHdpZHRoLCAoaGVpZ2h0IC0gcG9pbnRlckhlaWdodCkgLyAyKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHdpZHRoICsgcG9pbnRlcldpZHRoLCBoZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHdpZHRoLCAoaGVpZ2h0ICsgcG9pbnRlckhlaWdodCkgLyAyKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCwgaGVpZ2h0IC0gYm90dG9tUmlnaHQpO1xuICAgICAgICBjb250ZXh0LmFyYyh3aWR0aCAtIGJvdHRvbVJpZ2h0LCBoZWlnaHQgLSBib3R0b21SaWdodCwgYm90dG9tUmlnaHQsIDAsIE1hdGguUEkgLyAyLCBmYWxzZSk7XG4gICAgICAgIGlmIChwb2ludGVyRGlyZWN0aW9uID09PSBET1dOKSB7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbygod2lkdGggKyBwb2ludGVyV2lkdGgpIC8gMiwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHdpZHRoIC8gMiwgaGVpZ2h0ICsgcG9pbnRlckhlaWdodCk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbygod2lkdGggLSBwb2ludGVyV2lkdGgpIC8gMiwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmxpbmVUbyhib3R0b21MZWZ0LCBoZWlnaHQpO1xuICAgICAgICBjb250ZXh0LmFyYyhib3R0b21MZWZ0LCBoZWlnaHQgLSBib3R0b21MZWZ0LCBib3R0b21MZWZ0LCBNYXRoLlBJIC8gMiwgTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICBpZiAocG9pbnRlckRpcmVjdGlvbiA9PT0gTEVGVCkge1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oMCwgKGhlaWdodCArIHBvaW50ZXJIZWlnaHQpIC8gMik7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbygtMSAqIHBvaW50ZXJXaWR0aCwgaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbygwLCAoaGVpZ2h0IC0gcG9pbnRlckhlaWdodCkgLyAyKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmxpbmVUbygwLCB0b3BMZWZ0KTtcbiAgICAgICAgY29udGV4dC5hcmModG9wTGVmdCwgdG9wTGVmdCwgdG9wTGVmdCwgTWF0aC5QSSwgKE1hdGguUEkgKiAzKSAvIDIsIGZhbHNlKTtcbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgfVxuICAgIGdldFNlbGZSZWN0KCkge1xuICAgICAgICB2YXIgeCA9IDAsIHkgPSAwLCBwb2ludGVyV2lkdGggPSB0aGlzLnBvaW50ZXJXaWR0aCgpLCBwb2ludGVySGVpZ2h0ID0gdGhpcy5wb2ludGVySGVpZ2h0KCksIGRpcmVjdGlvbiA9IHRoaXMucG9pbnRlckRpcmVjdGlvbigpLCB3aWR0aCA9IHRoaXMud2lkdGgoKSwgaGVpZ2h0ID0gdGhpcy5oZWlnaHQoKTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gVVApIHtcbiAgICAgICAgICAgIHkgLT0gcG9pbnRlckhlaWdodDtcbiAgICAgICAgICAgIGhlaWdodCArPSBwb2ludGVySGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gRE9XTikge1xuICAgICAgICAgICAgaGVpZ2h0ICs9IHBvaW50ZXJIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uID09PSBMRUZUKSB7XG4gICAgICAgICAgICB4IC09IHBvaW50ZXJXaWR0aCAqIDEuNTtcbiAgICAgICAgICAgIHdpZHRoICs9IHBvaW50ZXJXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFJJR0hUKSB7XG4gICAgICAgICAgICB3aWR0aCArPSBwb2ludGVyV2lkdGggKiAxLjU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIH07XG4gICAgfVxufVxuVGFnLnByb3RvdHlwZS5jbGFzc05hbWUgPSAnVGFnJztcbl9yZWdpc3Rlck5vZGUoVGFnKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFRhZywgJ3BvaW50ZXJEaXJlY3Rpb24nLCBOT05FKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFRhZywgJ3BvaW50ZXJXaWR0aCcsIDAsIGdldE51bWJlclZhbGlkYXRvcigpKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFRhZywgJ3BvaW50ZXJIZWlnaHQnLCAwLCBnZXROdW1iZXJWYWxpZGF0b3IoKSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihUYWcsICdjb3JuZXJSYWRpdXMnLCAwLCBnZXROdW1iZXJPckFycmF5T2ZOdW1iZXJzVmFsaWRhdG9yKDQpKTtcbiIsImltcG9ydCB7IEZhY3RvcnkgfSBmcm9tICcuLi9GYWN0b3J5LmpzJztcbmltcG9ydCB7IFNoYXBlIH0gZnJvbSAnLi4vU2hhcGUuanMnO1xuaW1wb3J0IHsgX3JlZ2lzdGVyTm9kZSB9IGZyb20gJy4uL0dsb2JhbC5qcyc7XG5pbXBvcnQgeyBnZXROdW1iZXJPckFycmF5T2ZOdW1iZXJzVmFsaWRhdG9yIH0gZnJvbSAnLi4vVmFsaWRhdG9ycy5qcyc7XG5leHBvcnQgY2xhc3MgUmVjdCBleHRlbmRzIFNoYXBlIHtcbiAgICBfc2NlbmVGdW5jKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGNvcm5lclJhZGl1cyA9IHRoaXMuY29ybmVyUmFkaXVzKCksIHdpZHRoID0gdGhpcy53aWR0aCgpLCBoZWlnaHQgPSB0aGlzLmhlaWdodCgpO1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBpZiAoIWNvcm5lclJhZGl1cykge1xuICAgICAgICAgICAgY29udGV4dC5yZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHRvcExlZnQgPSAwO1xuICAgICAgICAgICAgbGV0IHRvcFJpZ2h0ID0gMDtcbiAgICAgICAgICAgIGxldCBib3R0b21MZWZ0ID0gMDtcbiAgICAgICAgICAgIGxldCBib3R0b21SaWdodCA9IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvcm5lclJhZGl1cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0b3BMZWZ0ID0gdG9wUmlnaHQgPSBib3R0b21MZWZ0ID0gYm90dG9tUmlnaHQgPSBNYXRoLm1pbihjb3JuZXJSYWRpdXMsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b3BMZWZ0ID0gTWF0aC5taW4oY29ybmVyUmFkaXVzWzBdIHx8IDAsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAgICAgdG9wUmlnaHQgPSBNYXRoLm1pbihjb3JuZXJSYWRpdXNbMV0gfHwgMCwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgICAgICAgICAgICAgICBib3R0b21SaWdodCA9IE1hdGgubWluKGNvcm5lclJhZGl1c1syXSB8fCAwLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICAgIGJvdHRvbUxlZnQgPSBNYXRoLm1pbihjb3JuZXJSYWRpdXNbM10gfHwgMCwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHRvcExlZnQsIDApO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8od2lkdGggLSB0b3BSaWdodCwgMCk7XG4gICAgICAgICAgICBjb250ZXh0LmFyYyh3aWR0aCAtIHRvcFJpZ2h0LCB0b3BSaWdodCwgdG9wUmlnaHQsIChNYXRoLlBJICogMykgLyAyLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCwgaGVpZ2h0IC0gYm90dG9tUmlnaHQpO1xuICAgICAgICAgICAgY29udGV4dC5hcmMod2lkdGggLSBib3R0b21SaWdodCwgaGVpZ2h0IC0gYm90dG9tUmlnaHQsIGJvdHRvbVJpZ2h0LCAwLCBNYXRoLlBJIC8gMiwgZmFsc2UpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oYm90dG9tTGVmdCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnRleHQuYXJjKGJvdHRvbUxlZnQsIGhlaWdodCAtIGJvdHRvbUxlZnQsIGJvdHRvbUxlZnQsIE1hdGguUEkgLyAyLCBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbygwLCB0b3BMZWZ0KTtcbiAgICAgICAgICAgIGNvbnRleHQuYXJjKHRvcExlZnQsIHRvcExlZnQsIHRvcExlZnQsIE1hdGguUEksIChNYXRoLlBJICogMykgLyAyLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgfVxufVxuUmVjdC5wcm90b3R5cGUuY2xhc3NOYW1lID0gJ1JlY3QnO1xuX3JlZ2lzdGVyTm9kZShSZWN0KTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFJlY3QsICdjb3JuZXJSYWRpdXMnLCAwLCBnZXROdW1iZXJPckFycmF5T2ZOdW1iZXJzVmFsaWRhdG9yKDQpKTtcbiIsImltcG9ydCB7IEZhY3RvcnkgfSBmcm9tICcuLi9GYWN0b3J5LmpzJztcbmltcG9ydCB7IFNoYXBlIH0gZnJvbSAnLi4vU2hhcGUuanMnO1xuaW1wb3J0IHsgZ2V0TnVtYmVyVmFsaWRhdG9yIH0gZnJvbSAnLi4vVmFsaWRhdG9ycy5qcyc7XG5pbXBvcnQgeyBfcmVnaXN0ZXJOb2RlIH0gZnJvbSAnLi4vR2xvYmFsLmpzJztcbmV4cG9ydCBjbGFzcyBSZWd1bGFyUG9seWdvbiBleHRlbmRzIFNoYXBlIHtcbiAgICBfc2NlbmVGdW5jKGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gdGhpcy5fZ2V0UG9pbnRzKCk7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHBvaW50c1swXS54LCBwb2ludHNbMF0ueSk7XG4gICAgICAgIGZvciAodmFyIG4gPSAxOyBuIDwgcG9pbnRzLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwb2ludHNbbl0ueCwgcG9pbnRzW25dLnkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgIH1cbiAgICBfZ2V0UG9pbnRzKCkge1xuICAgICAgICBjb25zdCBzaWRlcyA9IHRoaXMuYXR0cnMuc2lkZXM7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IHRoaXMuYXR0cnMucmFkaXVzIHx8IDA7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHNpZGVzOyBuKyspIHtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB4OiByYWRpdXMgKiBNYXRoLnNpbigobiAqIDIgKiBNYXRoLlBJKSAvIHNpZGVzKSxcbiAgICAgICAgICAgICAgICB5OiAtMSAqIHJhZGl1cyAqIE1hdGguY29zKChuICogMiAqIE1hdGguUEkpIC8gc2lkZXMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG4gICAgZ2V0U2VsZlJlY3QoKSB7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuX2dldFBvaW50cygpO1xuICAgICAgICB2YXIgbWluWCA9IHBvaW50c1swXS54O1xuICAgICAgICB2YXIgbWF4WCA9IHBvaW50c1swXS55O1xuICAgICAgICB2YXIgbWluWSA9IHBvaW50c1swXS54O1xuICAgICAgICB2YXIgbWF4WSA9IHBvaW50c1swXS55O1xuICAgICAgICBwb2ludHMuZm9yRWFjaCgocG9pbnQpID0+IHtcbiAgICAgICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCBwb2ludC54KTtcbiAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBwb2ludC54KTtcbiAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBwb2ludC55KTtcbiAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCBwb2ludC55KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBtaW5YLFxuICAgICAgICAgICAgeTogbWluWSxcbiAgICAgICAgICAgIHdpZHRoOiBtYXhYIC0gbWluWCxcbiAgICAgICAgICAgIGhlaWdodDogbWF4WSAtIG1pblksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYWRpdXMoKSAqIDI7XG4gICAgfVxuICAgIGdldEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFkaXVzKCkgKiAyO1xuICAgIH1cbiAgICBzZXRXaWR0aCh3aWR0aCkge1xuICAgICAgICB0aGlzLnJhZGl1cyh3aWR0aCAvIDIpO1xuICAgIH1cbiAgICBzZXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMucmFkaXVzKGhlaWdodCAvIDIpO1xuICAgIH1cbn1cblJlZ3VsYXJQb2x5Z29uLnByb3RvdHlwZS5jbGFzc05hbWUgPSAnUmVndWxhclBvbHlnb24nO1xuUmVndWxhclBvbHlnb24ucHJvdG90eXBlLl9jZW50cm9pZCA9IHRydWU7XG5SZWd1bGFyUG9seWdvbi5wcm90b3R5cGUuX2F0dHJzQWZmZWN0aW5nU2l6ZSA9IFsncmFkaXVzJ107XG5fcmVnaXN0ZXJOb2RlKFJlZ3VsYXJQb2x5Z29uKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFJlZ3VsYXJQb2x5Z29uLCAncmFkaXVzJywgMCwgZ2V0TnVtYmVyVmFsaWRhdG9yKCkpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoUmVndWxhclBvbHlnb24sICdzaWRlcycsIDAsIGdldE51bWJlclZhbGlkYXRvcigpKTtcbiIsImltcG9ydCB7IEZhY3RvcnkgfSBmcm9tICcuLi9GYWN0b3J5LmpzJztcbmltcG9ydCB7IFNoYXBlIH0gZnJvbSAnLi4vU2hhcGUuanMnO1xuaW1wb3J0IHsgZ2V0TnVtYmVyVmFsaWRhdG9yIH0gZnJvbSAnLi4vVmFsaWRhdG9ycy5qcyc7XG5pbXBvcnQgeyBfcmVnaXN0ZXJOb2RlIH0gZnJvbSAnLi4vR2xvYmFsLmpzJztcbnZhciBQSXgyID0gTWF0aC5QSSAqIDI7XG5leHBvcnQgY2xhc3MgUmluZyBleHRlbmRzIFNoYXBlIHtcbiAgICBfc2NlbmVGdW5jKGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgdGhpcy5pbm5lclJhZGl1cygpLCAwLCBQSXgyLCBmYWxzZSk7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHRoaXMub3V0ZXJSYWRpdXMoKSwgMCk7XG4gICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHRoaXMub3V0ZXJSYWRpdXMoKSwgUEl4MiwgMCwgdHJ1ZSk7XG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgIH1cbiAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0ZXJSYWRpdXMoKSAqIDI7XG4gICAgfVxuICAgIGdldEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0ZXJSYWRpdXMoKSAqIDI7XG4gICAgfVxuICAgIHNldFdpZHRoKHdpZHRoKSB7XG4gICAgICAgIHRoaXMub3V0ZXJSYWRpdXMod2lkdGggLyAyKTtcbiAgICB9XG4gICAgc2V0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICB0aGlzLm91dGVyUmFkaXVzKGhlaWdodCAvIDIpO1xuICAgIH1cbn1cblJpbmcucHJvdG90eXBlLmNsYXNzTmFtZSA9ICdSaW5nJztcblJpbmcucHJvdG90eXBlLl9jZW50cm9pZCA9IHRydWU7XG5SaW5nLnByb3RvdHlwZS5fYXR0cnNBZmZlY3RpbmdTaXplID0gWydpbm5lclJhZGl1cycsICdvdXRlclJhZGl1cyddO1xuX3JlZ2lzdGVyTm9kZShSaW5nKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFJpbmcsICdpbm5lclJhZGl1cycsIDAsIGdldE51bWJlclZhbGlkYXRvcigpKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFJpbmcsICdvdXRlclJhZGl1cycsIDAsIGdldE51bWJlclZhbGlkYXRvcigpKTtcbiIsImltcG9ydCB7IEZhY3RvcnkgfSBmcm9tICcuLi9GYWN0b3J5LmpzJztcbmltcG9ydCB7IFNoYXBlIH0gZnJvbSAnLi4vU2hhcGUuanMnO1xuaW1wb3J0IHsgQW5pbWF0aW9uIH0gZnJvbSAnLi4vQW5pbWF0aW9uLmpzJztcbmltcG9ydCB7IGdldE51bWJlclZhbGlkYXRvciB9IGZyb20gJy4uL1ZhbGlkYXRvcnMuanMnO1xuaW1wb3J0IHsgX3JlZ2lzdGVyTm9kZSB9IGZyb20gJy4uL0dsb2JhbC5qcyc7XG5leHBvcnQgY2xhc3MgU3ByaXRlIGV4dGVuZHMgU2hhcGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgICAgICB0aGlzLl91cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hbmltID0gbmV3IEFuaW1hdGlvbigoKSA9PiB7XG4gICAgICAgICAgICB2YXIgdXBkYXRlZCA9IHRoaXMuX3VwZGF0ZWQ7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oJ2FuaW1hdGlvbkNoYW5nZS5rb252YScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZnJhbWVJbmRleCgwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oJ2ZyYW1lSW5kZXhDaGFuZ2Uua29udmEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oJ2ZyYW1lUmF0ZUNoYW5nZS5rb252YScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hbmltLmlzUnVubmluZygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAgICAgICAgICAgIHRoaXMuX3NldEludGVydmFsKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfc2NlbmVGdW5jKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGFuaW0gPSB0aGlzLmFuaW1hdGlvbigpLCBpbmRleCA9IHRoaXMuZnJhbWVJbmRleCgpLCBpeDQgPSBpbmRleCAqIDQsIHNldCA9IHRoaXMuYW5pbWF0aW9ucygpW2FuaW1dLCBvZmZzZXRzID0gdGhpcy5mcmFtZU9mZnNldHMoKSwgeCA9IHNldFtpeDQgKyAwXSwgeSA9IHNldFtpeDQgKyAxXSwgd2lkdGggPSBzZXRbaXg0ICsgMl0sIGhlaWdodCA9IHNldFtpeDQgKyAzXSwgaW1hZ2UgPSB0aGlzLmltYWdlKCk7XG4gICAgICAgIGlmICh0aGlzLmhhc0ZpbGwoKSB8fCB0aGlzLmhhc1N0cm9rZSgpKSB7XG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5yZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbWFnZSkge1xuICAgICAgICAgICAgaWYgKG9mZnNldHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0c1thbmltXSwgaXgyID0gaW5kZXggKiAyO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBvZmZzZXRbaXgyICsgMF0sIG9mZnNldFtpeDIgKyAxXSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2hpdEZ1bmMoY29udGV4dCkge1xuICAgICAgICB2YXIgYW5pbSA9IHRoaXMuYW5pbWF0aW9uKCksIGluZGV4ID0gdGhpcy5mcmFtZUluZGV4KCksIGl4NCA9IGluZGV4ICogNCwgc2V0ID0gdGhpcy5hbmltYXRpb25zKClbYW5pbV0sIG9mZnNldHMgPSB0aGlzLmZyYW1lT2Zmc2V0cygpLCB3aWR0aCA9IHNldFtpeDQgKyAyXSwgaGVpZ2h0ID0gc2V0W2l4NCArIDNdO1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBpZiAob2Zmc2V0cykge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IG9mZnNldHNbYW5pbV07XG4gICAgICAgICAgICB2YXIgaXgyID0gaW5kZXggKiAyO1xuICAgICAgICAgICAgY29udGV4dC5yZWN0KG9mZnNldFtpeDIgKyAwXSwgb2Zmc2V0W2l4MiArIDFdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQucmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBjb250ZXh0LmZpbGxTaGFwZSh0aGlzKTtcbiAgICB9XG4gICAgX3VzZUJ1ZmZlckNhbnZhcygpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLl91c2VCdWZmZXJDYW52YXModHJ1ZSk7XG4gICAgfVxuICAgIF9zZXRJbnRlcnZhbCgpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5fdXBkYXRlSW5kZXgoKTtcbiAgICAgICAgfSwgMTAwMCAvIHRoaXMuZnJhbWVSYXRlKCkpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSdW5uaW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgICAgIHRoaXMuYW5pbS5zZXRMYXllcnMobGF5ZXIpO1xuICAgICAgICB0aGlzLl9zZXRJbnRlcnZhbCgpO1xuICAgICAgICB0aGlzLmFuaW0uc3RhcnQoKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5hbmltLnN0b3AoKTtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAgICB9XG4gICAgaXNSdW5uaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmltLmlzUnVubmluZygpO1xuICAgIH1cbiAgICBfdXBkYXRlSW5kZXgoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZnJhbWVJbmRleCgpLCBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbigpLCBhbmltYXRpb25zID0gdGhpcy5hbmltYXRpb25zKCksIGFuaW0gPSBhbmltYXRpb25zW2FuaW1hdGlvbl0sIGxlbiA9IGFuaW0ubGVuZ3RoIC8gNDtcbiAgICAgICAgaWYgKGluZGV4IDwgbGVuIC0gMSkge1xuICAgICAgICAgICAgdGhpcy5mcmFtZUluZGV4KGluZGV4ICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZyYW1lSW5kZXgoMCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5TcHJpdGUucHJvdG90eXBlLmNsYXNzTmFtZSA9ICdTcHJpdGUnO1xuX3JlZ2lzdGVyTm9kZShTcHJpdGUpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoU3ByaXRlLCAnYW5pbWF0aW9uJyk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihTcHJpdGUsICdhbmltYXRpb25zJyk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihTcHJpdGUsICdmcmFtZU9mZnNldHMnKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFNwcml0ZSwgJ2ltYWdlJyk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihTcHJpdGUsICdmcmFtZUluZGV4JywgMCwgZ2V0TnVtYmVyVmFsaWRhdG9yKCkpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoU3ByaXRlLCAnZnJhbWVSYXRlJywgMTcsIGdldE51bWJlclZhbGlkYXRvcigpKTtcbkZhY3RvcnkuYmFja0NvbXBhdChTcHJpdGUsIHtcbiAgICBpbmRleDogJ2ZyYW1lSW5kZXgnLFxuICAgIGdldEluZGV4OiAnZ2V0RnJhbWVJbmRleCcsXG4gICAgc2V0SW5kZXg6ICdzZXRGcmFtZUluZGV4Jyxcbn0pO1xuIiwiaW1wb3J0IHsgRmFjdG9yeSB9IGZyb20gJy4uL0ZhY3RvcnkuanMnO1xuaW1wb3J0IHsgU2hhcGUgfSBmcm9tICcuLi9TaGFwZS5qcyc7XG5pbXBvcnQgeyBnZXROdW1iZXJWYWxpZGF0b3IgfSBmcm9tICcuLi9WYWxpZGF0b3JzLmpzJztcbmltcG9ydCB7IF9yZWdpc3Rlck5vZGUgfSBmcm9tICcuLi9HbG9iYWwuanMnO1xuZXhwb3J0IGNsYXNzIFN0YXIgZXh0ZW5kcyBTaGFwZSB7XG4gICAgX3NjZW5lRnVuYyhjb250ZXh0KSB7XG4gICAgICAgIHZhciBpbm5lclJhZGl1cyA9IHRoaXMuaW5uZXJSYWRpdXMoKSwgb3V0ZXJSYWRpdXMgPSB0aGlzLm91dGVyUmFkaXVzKCksIG51bVBvaW50cyA9IHRoaXMubnVtUG9pbnRzKCk7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKDAsIDAgLSBvdXRlclJhZGl1cyk7XG4gICAgICAgIGZvciAodmFyIG4gPSAxOyBuIDwgbnVtUG9pbnRzICogMjsgbisrKSB7XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gbiAlIDIgPT09IDAgPyBvdXRlclJhZGl1cyA6IGlubmVyUmFkaXVzO1xuICAgICAgICAgICAgdmFyIHggPSByYWRpdXMgKiBNYXRoLnNpbigobiAqIE1hdGguUEkpIC8gbnVtUG9pbnRzKTtcbiAgICAgICAgICAgIHZhciB5ID0gLTEgKiByYWRpdXMgKiBNYXRoLmNvcygobiAqIE1hdGguUEkpIC8gbnVtUG9pbnRzKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgIH1cbiAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0ZXJSYWRpdXMoKSAqIDI7XG4gICAgfVxuICAgIGdldEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0ZXJSYWRpdXMoKSAqIDI7XG4gICAgfVxuICAgIHNldFdpZHRoKHdpZHRoKSB7XG4gICAgICAgIHRoaXMub3V0ZXJSYWRpdXMod2lkdGggLyAyKTtcbiAgICB9XG4gICAgc2V0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICB0aGlzLm91dGVyUmFkaXVzKGhlaWdodCAvIDIpO1xuICAgIH1cbn1cblN0YXIucHJvdG90eXBlLmNsYXNzTmFtZSA9ICdTdGFyJztcblN0YXIucHJvdG90eXBlLl9jZW50cm9pZCA9IHRydWU7XG5TdGFyLnByb3RvdHlwZS5fYXR0cnNBZmZlY3RpbmdTaXplID0gWydpbm5lclJhZGl1cycsICdvdXRlclJhZGl1cyddO1xuX3JlZ2lzdGVyTm9kZShTdGFyKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFN0YXIsICdudW1Qb2ludHMnLCA1LCBnZXROdW1iZXJWYWxpZGF0b3IoKSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihTdGFyLCAnaW5uZXJSYWRpdXMnLCAwLCBnZXROdW1iZXJWYWxpZGF0b3IoKSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihTdGFyLCAnb3V0ZXJSYWRpdXMnLCAwLCBnZXROdW1iZXJWYWxpZGF0b3IoKSk7XG4iLCJpbXBvcnQgeyBVdGlsIH0gZnJvbSAnLi4vVXRpbC5qcyc7XG5pbXBvcnQgeyBGYWN0b3J5IH0gZnJvbSAnLi4vRmFjdG9yeS5qcyc7XG5pbXBvcnQgeyBTaGFwZSB9IGZyb20gJy4uL1NoYXBlLmpzJztcbmltcG9ydCB7IGdldE51bWJlclZhbGlkYXRvciwgZ2V0U3RyaW5nVmFsaWRhdG9yLCBnZXROdW1iZXJPckF1dG9WYWxpZGF0b3IsIGdldEJvb2xlYW5WYWxpZGF0b3IsIH0gZnJvbSAnLi4vVmFsaWRhdG9ycy5qcyc7XG5pbXBvcnQgeyBfcmVnaXN0ZXJOb2RlIH0gZnJvbSAnLi4vR2xvYmFsLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdUb0FycmF5KHN0cmluZykge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHN0cmluZyk7XG59XG52YXIgQVVUTyA9ICdhdXRvJywgQ0VOVEVSID0gJ2NlbnRlcicsIEpVU1RJRlkgPSAnanVzdGlmeScsIENIQU5HRV9LT05WQSA9ICdDaGFuZ2Uua29udmEnLCBDT05URVhUXzJEID0gJzJkJywgREFTSCA9ICctJywgTEVGVCA9ICdsZWZ0JywgVEVYVCA9ICd0ZXh0JywgVEVYVF9VUFBFUiA9ICdUZXh0JywgVE9QID0gJ3RvcCcsIEJPVFRPTSA9ICdib3R0b20nLCBNSURETEUgPSAnbWlkZGxlJywgTk9STUFMID0gJ25vcm1hbCcsIFBYX1NQQUNFID0gJ3B4ICcsIFNQQUNFID0gJyAnLCBSSUdIVCA9ICdyaWdodCcsIFdPUkQgPSAnd29yZCcsIENIQVIgPSAnY2hhcicsIE5PTkUgPSAnbm9uZScsIEVMTElQU0lTID0gJ+KApicsIEFUVFJfQ0hBTkdFX0xJU1QgPSBbXG4gICAgJ2ZvbnRGYW1pbHknLFxuICAgICdmb250U2l6ZScsXG4gICAgJ2ZvbnRTdHlsZScsXG4gICAgJ2ZvbnRWYXJpYW50JyxcbiAgICAncGFkZGluZycsXG4gICAgJ2FsaWduJyxcbiAgICAndmVydGljYWxBbGlnbicsXG4gICAgJ2xpbmVIZWlnaHQnLFxuICAgICd0ZXh0JyxcbiAgICAnd2lkdGgnLFxuICAgICdoZWlnaHQnLFxuICAgICd3cmFwJyxcbiAgICAnZWxsaXBzaXMnLFxuICAgICdsZXR0ZXJTcGFjaW5nJyxcbl0sIGF0dHJDaGFuZ2VMaXN0TGVuID0gQVRUUl9DSEFOR0VfTElTVC5sZW5ndGg7XG5mdW5jdGlvbiBub3JtYWxpemVGb250RmFtaWx5KGZvbnRGYW1pbHkpIHtcbiAgICByZXR1cm4gZm9udEZhbWlseVxuICAgICAgICAuc3BsaXQoJywnKVxuICAgICAgICAubWFwKChmYW1pbHkpID0+IHtcbiAgICAgICAgZmFtaWx5ID0gZmFtaWx5LnRyaW0oKTtcbiAgICAgICAgY29uc3QgaGFzU3BhY2UgPSBmYW1pbHkuaW5kZXhPZignICcpID49IDA7XG4gICAgICAgIGNvbnN0IGhhc1F1b3RlcyA9IGZhbWlseS5pbmRleE9mKCdcIicpID49IDAgfHwgZmFtaWx5LmluZGV4T2YoXCInXCIpID49IDA7XG4gICAgICAgIGlmIChoYXNTcGFjZSAmJiAhaGFzUXVvdGVzKSB7XG4gICAgICAgICAgICBmYW1pbHkgPSBgXCIke2ZhbWlseX1cImA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbWlseTtcbiAgICB9KVxuICAgICAgICAuam9pbignLCAnKTtcbn1cbnZhciBkdW1teUNvbnRleHQ7XG5mdW5jdGlvbiBnZXREdW1teUNvbnRleHQoKSB7XG4gICAgaWYgKGR1bW15Q29udGV4dCkge1xuICAgICAgICByZXR1cm4gZHVtbXlDb250ZXh0O1xuICAgIH1cbiAgICBkdW1teUNvbnRleHQgPSBVdGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKS5nZXRDb250ZXh0KENPTlRFWFRfMkQpO1xuICAgIHJldHVybiBkdW1teUNvbnRleHQ7XG59XG5mdW5jdGlvbiBfZmlsbEZ1bmMoY29udGV4dCkge1xuICAgIGNvbnRleHQuZmlsbFRleHQodGhpcy5fcGFydGlhbFRleHQsIHRoaXMuX3BhcnRpYWxUZXh0WCwgdGhpcy5fcGFydGlhbFRleHRZKTtcbn1cbmZ1bmN0aW9uIF9zdHJva2VGdW5jKGNvbnRleHQpIHtcbiAgICBjb250ZXh0LnN0cm9rZVRleHQodGhpcy5fcGFydGlhbFRleHQsIHRoaXMuX3BhcnRpYWxUZXh0WCwgdGhpcy5fcGFydGlhbFRleHRZKTtcbn1cbmZ1bmN0aW9uIGNoZWNrRGVmYXVsdEZpbGwoY29uZmlnKSB7XG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgIGlmICghY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHMgJiZcbiAgICAgICAgIWNvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzICYmXG4gICAgICAgICFjb25maWcuZmlsbFBhdHRlcm5JbWFnZSkge1xuICAgICAgICBjb25maWcuZmlsbCA9IGNvbmZpZy5maWxsIHx8ICdibGFjayc7XG4gICAgfVxuICAgIHJldHVybiBjb25maWc7XG59XG5leHBvcnQgY2xhc3MgVGV4dCBleHRlbmRzIFNoYXBlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY2hlY2tEZWZhdWx0RmlsbChjb25maWcpKTtcbiAgICAgICAgdGhpcy5fcGFydGlhbFRleHRYID0gMDtcbiAgICAgICAgdGhpcy5fcGFydGlhbFRleHRZID0gMDtcbiAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBhdHRyQ2hhbmdlTGlzdExlbjsgbisrKSB7XG4gICAgICAgICAgICB0aGlzLm9uKEFUVFJfQ0hBTkdFX0xJU1Rbbl0gKyBDSEFOR0VfS09OVkEsIHRoaXMuX3NldFRleHREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRUZXh0RGF0YSgpO1xuICAgIH1cbiAgICBfc2NlbmVGdW5jKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHRleHRBcnIgPSB0aGlzLnRleHRBcnIsIHRleHRBcnJMZW4gPSB0ZXh0QXJyLmxlbmd0aDtcbiAgICAgICAgaWYgKCF0aGlzLnRleHQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy5wYWRkaW5nKCksIGZvbnRTaXplID0gdGhpcy5mb250U2l6ZSgpLCBsaW5lSGVpZ2h0UHggPSB0aGlzLmxpbmVIZWlnaHQoKSAqIGZvbnRTaXplLCB2ZXJ0aWNhbEFsaWduID0gdGhpcy52ZXJ0aWNhbEFsaWduKCksIGFsaWduWSA9IDAsIGFsaWduID0gdGhpcy5hbGlnbigpLCB0b3RhbFdpZHRoID0gdGhpcy5nZXRXaWR0aCgpLCBsZXR0ZXJTcGFjaW5nID0gdGhpcy5sZXR0ZXJTcGFjaW5nKCksIGZpbGwgPSB0aGlzLmZpbGwoKSwgdGV4dERlY29yYXRpb24gPSB0aGlzLnRleHREZWNvcmF0aW9uKCksIHNob3VsZFVuZGVybGluZSA9IHRleHREZWNvcmF0aW9uLmluZGV4T2YoJ3VuZGVybGluZScpICE9PSAtMSwgc2hvdWxkTGluZVRocm91Z2ggPSB0ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCdsaW5lLXRocm91Z2gnKSAhPT0gLTEsIG47XG4gICAgICAgIHZhciB0cmFuc2xhdGVZID0gMDtcbiAgICAgICAgdmFyIHRyYW5zbGF0ZVkgPSBsaW5lSGVpZ2h0UHggLyAyO1xuICAgICAgICB2YXIgbGluZVRyYW5zbGF0ZVggPSAwO1xuICAgICAgICB2YXIgbGluZVRyYW5zbGF0ZVkgPSAwO1xuICAgICAgICBjb250ZXh0LnNldEF0dHIoJ2ZvbnQnLCB0aGlzLl9nZXRDb250ZXh0Rm9udCgpKTtcbiAgICAgICAgY29udGV4dC5zZXRBdHRyKCd0ZXh0QmFzZWxpbmUnLCBNSURETEUpO1xuICAgICAgICBjb250ZXh0LnNldEF0dHIoJ3RleHRBbGlnbicsIExFRlQpO1xuICAgICAgICBpZiAodmVydGljYWxBbGlnbiA9PT0gTUlERExFKSB7XG4gICAgICAgICAgICBhbGlnblkgPSAodGhpcy5nZXRIZWlnaHQoKSAtIHRleHRBcnJMZW4gKiBsaW5lSGVpZ2h0UHggLSBwYWRkaW5nICogMikgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZlcnRpY2FsQWxpZ24gPT09IEJPVFRPTSkge1xuICAgICAgICAgICAgYWxpZ25ZID0gdGhpcy5nZXRIZWlnaHQoKSAtIHRleHRBcnJMZW4gKiBsaW5lSGVpZ2h0UHggLSBwYWRkaW5nICogMjtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZShwYWRkaW5nLCBhbGlnblkgKyBwYWRkaW5nKTtcbiAgICAgICAgZm9yIChuID0gMDsgbiA8IHRleHRBcnJMZW47IG4rKykge1xuICAgICAgICAgICAgdmFyIGxpbmVUcmFuc2xhdGVYID0gMDtcbiAgICAgICAgICAgIHZhciBsaW5lVHJhbnNsYXRlWSA9IDA7XG4gICAgICAgICAgICB2YXIgb2JqID0gdGV4dEFycltuXSwgdGV4dCA9IG9iai50ZXh0LCB3aWR0aCA9IG9iai53aWR0aCwgbGFzdExpbmUgPSBvYmoubGFzdEluUGFyYWdyYXBoLCBzcGFjZXNOdW1iZXIsIG9uZVdvcmQsIGxpbmVXaWR0aDtcbiAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgaWYgKGFsaWduID09PSBSSUdIVCkge1xuICAgICAgICAgICAgICAgIGxpbmVUcmFuc2xhdGVYICs9IHRvdGFsV2lkdGggLSB3aWR0aCAtIHBhZGRpbmcgKiAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWxpZ24gPT09IENFTlRFUikge1xuICAgICAgICAgICAgICAgIGxpbmVUcmFuc2xhdGVYICs9ICh0b3RhbFdpZHRoIC0gd2lkdGggLSBwYWRkaW5nICogMikgLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3VsZFVuZGVybGluZSkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8obGluZVRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVkgKyBsaW5lVHJhbnNsYXRlWSArIE1hdGgucm91bmQoZm9udFNpemUgLyAyKSk7XG4gICAgICAgICAgICAgICAgc3BhY2VzTnVtYmVyID0gdGV4dC5zcGxpdCgnICcpLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgb25lV29yZCA9IHNwYWNlc051bWJlciA9PT0gMDtcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGggPVxuICAgICAgICAgICAgICAgICAgICBhbGlnbiA9PT0gSlVTVElGWSAmJiBsYXN0TGluZSAmJiAhb25lV29yZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0b3RhbFdpZHRoIC0gcGFkZGluZyAqIDJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogd2lkdGg7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGluZVRyYW5zbGF0ZVggKyBNYXRoLnJvdW5kKGxpbmVXaWR0aCksIHRyYW5zbGF0ZVkgKyBsaW5lVHJhbnNsYXRlWSArIE1hdGgucm91bmQoZm9udFNpemUgLyAyKSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBmb250U2l6ZSAvIDE1O1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBmaWxsO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvdWxkTGluZVRocm91Z2gpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKGxpbmVUcmFuc2xhdGVYLCB0cmFuc2xhdGVZICsgbGluZVRyYW5zbGF0ZVkpO1xuICAgICAgICAgICAgICAgIHNwYWNlc051bWJlciA9IHRleHQuc3BsaXQoJyAnKS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIG9uZVdvcmQgPSBzcGFjZXNOdW1iZXIgPT09IDA7XG4gICAgICAgICAgICAgICAgbGluZVdpZHRoID1cbiAgICAgICAgICAgICAgICAgICAgYWxpZ24gPT09IEpVU1RJRlkgJiYgbGFzdExpbmUgJiYgIW9uZVdvcmRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdG90YWxXaWR0aCAtIHBhZGRpbmcgKiAyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHdpZHRoO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxpbmVUcmFuc2xhdGVYICsgTWF0aC5yb3VuZChsaW5lV2lkdGgpLCB0cmFuc2xhdGVZICsgbGluZVRyYW5zbGF0ZVkpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gZm9udFNpemUgLyAxNTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gZmlsbDtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxldHRlclNwYWNpbmcgIT09IDAgfHwgYWxpZ24gPT09IEpVU1RJRlkpIHtcbiAgICAgICAgICAgICAgICBzcGFjZXNOdW1iZXIgPSB0ZXh0LnNwbGl0KCcgJykubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB2YXIgYXJyYXkgPSBzdHJpbmdUb0FycmF5KHRleHQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGxpID0gMDsgbGkgPCBhcnJheS5sZW5ndGg7IGxpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxldHRlciA9IGFycmF5W2xpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxldHRlciA9PT0gJyAnICYmICFsYXN0TGluZSAmJiBhbGlnbiA9PT0gSlVTVElGWSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZVRyYW5zbGF0ZVggKz0gKHRvdGFsV2lkdGggLSBwYWRkaW5nICogMiAtIHdpZHRoKSAvIHNwYWNlc051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJ0aWFsVGV4dFggPSBsaW5lVHJhbnNsYXRlWDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFydGlhbFRleHRZID0gdHJhbnNsYXRlWSArIGxpbmVUcmFuc2xhdGVZO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJ0aWFsVGV4dCA9IGxldHRlcjtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVUcmFuc2xhdGVYICs9IHRoaXMubWVhc3VyZVNpemUobGV0dGVyKS53aWR0aCArIGxldHRlclNwYWNpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFydGlhbFRleHRYID0gbGluZVRyYW5zbGF0ZVg7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFydGlhbFRleHRZID0gdHJhbnNsYXRlWSArIGxpbmVUcmFuc2xhdGVZO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnRpYWxUZXh0ID0gdGV4dDtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgICAgaWYgKHRleHRBcnJMZW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWSArPSBsaW5lSGVpZ2h0UHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2hpdEZ1bmMoY29udGV4dCkge1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdldFdpZHRoKCksIGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnRleHQucmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgfVxuICAgIHNldFRleHQodGV4dCkge1xuICAgICAgICB2YXIgc3RyID0gVXRpbC5faXNTdHJpbmcodGV4dClcbiAgICAgICAgICAgID8gdGV4dFxuICAgICAgICAgICAgOiB0ZXh0ID09PSBudWxsIHx8IHRleHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gJydcbiAgICAgICAgICAgICAgICA6IHRleHQgKyAnJztcbiAgICAgICAgdGhpcy5fc2V0QXR0cihURVhULCBzdHIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0V2lkdGgoKSB7XG4gICAgICAgIHZhciBpc0F1dG8gPSB0aGlzLmF0dHJzLndpZHRoID09PSBBVVRPIHx8IHRoaXMuYXR0cnMud2lkdGggPT09IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGlzQXV0byA/IHRoaXMuZ2V0VGV4dFdpZHRoKCkgKyB0aGlzLnBhZGRpbmcoKSAqIDIgOiB0aGlzLmF0dHJzLndpZHRoO1xuICAgIH1cbiAgICBnZXRIZWlnaHQoKSB7XG4gICAgICAgIHZhciBpc0F1dG8gPSB0aGlzLmF0dHJzLmhlaWdodCA9PT0gQVVUTyB8fCB0aGlzLmF0dHJzLmhlaWdodCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gaXNBdXRvXG4gICAgICAgICAgICA/IHRoaXMuZm9udFNpemUoKSAqIHRoaXMudGV4dEFyci5sZW5ndGggKiB0aGlzLmxpbmVIZWlnaHQoKSArXG4gICAgICAgICAgICAgICAgdGhpcy5wYWRkaW5nKCkgKiAyXG4gICAgICAgICAgICA6IHRoaXMuYXR0cnMuaGVpZ2h0O1xuICAgIH1cbiAgICBnZXRUZXh0V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHRXaWR0aDtcbiAgICB9XG4gICAgZ2V0VGV4dEhlaWdodCgpIHtcbiAgICAgICAgVXRpbC53YXJuKCd0ZXh0LmdldFRleHRIZWlnaHQoKSBtZXRob2QgaXMgZGVwcmVjYXRlZC4gVXNlIHRleHQuaGVpZ2h0KCkgLSBmb3IgZnVsbCBoZWlnaHQgYW5kIHRleHQuZm9udFNpemUoKSAtIGZvciBvbmUgbGluZSBoZWlnaHQuJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHRIZWlnaHQ7XG4gICAgfVxuICAgIG1lYXN1cmVTaXplKHRleHQpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0ID0gZ2V0RHVtbXlDb250ZXh0KCksIGZvbnRTaXplID0gdGhpcy5mb250U2l6ZSgpLCBtZXRyaWNzO1xuICAgICAgICBfY29udGV4dC5zYXZlKCk7XG4gICAgICAgIF9jb250ZXh0LmZvbnQgPSB0aGlzLl9nZXRDb250ZXh0Rm9udCgpO1xuICAgICAgICBtZXRyaWNzID0gX2NvbnRleHQubWVhc3VyZVRleHQodGV4dCk7XG4gICAgICAgIF9jb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBtZXRyaWNzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBmb250U2l6ZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2dldENvbnRleHRGb250KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZm9udFN0eWxlKCkgK1xuICAgICAgICAgICAgU1BBQ0UgK1xuICAgICAgICAgICAgdGhpcy5mb250VmFyaWFudCgpICtcbiAgICAgICAgICAgIFNQQUNFICtcbiAgICAgICAgICAgICh0aGlzLmZvbnRTaXplKCkgKyBQWF9TUEFDRSkgK1xuICAgICAgICAgICAgbm9ybWFsaXplRm9udEZhbWlseSh0aGlzLmZvbnRGYW1pbHkoKSkpO1xuICAgIH1cbiAgICBfYWRkVGV4dExpbmUobGluZSkge1xuICAgICAgICBpZiAodGhpcy5hbGlnbigpID09PSBKVVNUSUZZKSB7XG4gICAgICAgICAgICBsaW5lID0gbGluZS50cmltKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5fZ2V0VGV4dFdpZHRoKGxpbmUpO1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0QXJyLnB1c2goe1xuICAgICAgICAgICAgdGV4dDogbGluZSxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGxhc3RJblBhcmFncmFwaDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0VGV4dFdpZHRoKHRleHQpIHtcbiAgICAgICAgdmFyIGxldHRlclNwYWNpbmcgPSB0aGlzLmxldHRlclNwYWNpbmcoKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRleHQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gKGdldER1bW15Q29udGV4dCgpLm1lYXN1cmVUZXh0KHRleHQpLndpZHRoICtcbiAgICAgICAgICAgIChsZW5ndGggPyBsZXR0ZXJTcGFjaW5nICogKGxlbmd0aCAtIDEpIDogMCkpO1xuICAgIH1cbiAgICBfc2V0VGV4dERhdGEoKSB7XG4gICAgICAgIHZhciBsaW5lcyA9IHRoaXMudGV4dCgpLnNwbGl0KCdcXG4nKSwgZm9udFNpemUgPSArdGhpcy5mb250U2l6ZSgpLCB0ZXh0V2lkdGggPSAwLCBsaW5lSGVpZ2h0UHggPSB0aGlzLmxpbmVIZWlnaHQoKSAqIGZvbnRTaXplLCB3aWR0aCA9IHRoaXMuYXR0cnMud2lkdGgsIGhlaWdodCA9IHRoaXMuYXR0cnMuaGVpZ2h0LCBmaXhlZFdpZHRoID0gd2lkdGggIT09IEFVVE8gJiYgd2lkdGggIT09IHVuZGVmaW5lZCwgZml4ZWRIZWlnaHQgPSBoZWlnaHQgIT09IEFVVE8gJiYgaGVpZ2h0ICE9PSB1bmRlZmluZWQsIHBhZGRpbmcgPSB0aGlzLnBhZGRpbmcoKSwgbWF4V2lkdGggPSB3aWR0aCAtIHBhZGRpbmcgKiAyLCBtYXhIZWlnaHRQeCA9IGhlaWdodCAtIHBhZGRpbmcgKiAyLCBjdXJyZW50SGVpZ2h0UHggPSAwLCB3cmFwID0gdGhpcy53cmFwKCksIHNob3VsZFdyYXAgPSB3cmFwICE9PSBOT05FLCB3cmFwQXRXb3JkID0gd3JhcCAhPT0gQ0hBUiAmJiBzaG91bGRXcmFwLCBzaG91bGRBZGRFbGxpcHNpcyA9IHRoaXMuZWxsaXBzaXMoKTtcbiAgICAgICAgdGhpcy50ZXh0QXJyID0gW107XG4gICAgICAgIGdldER1bW15Q29udGV4dCgpLmZvbnQgPSB0aGlzLl9nZXRDb250ZXh0Rm9udCgpO1xuICAgICAgICB2YXIgYWRkaXRpb25hbFdpZHRoID0gc2hvdWxkQWRkRWxsaXBzaXMgPyB0aGlzLl9nZXRUZXh0V2lkdGgoRUxMSVBTSVMpIDogMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG1heCA9IGxpbmVzLmxlbmd0aDsgaSA8IG1heDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHRoaXMuX2dldFRleHRXaWR0aChsaW5lKTtcbiAgICAgICAgICAgIGlmIChmaXhlZFdpZHRoICYmIGxpbmVXaWR0aCA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGxpbmUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGxpbmUubGVuZ3RoLCBtYXRjaCA9ICcnLCBtYXRjaFdpZHRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaWQgPSAobG93ICsgaGlnaCkgPj4+IDEsIHN1YnN0ciA9IGxpbmUuc2xpY2UoMCwgbWlkICsgMSksIHN1YnN0cldpZHRoID0gdGhpcy5fZ2V0VGV4dFdpZHRoKHN1YnN0cikgKyBhZGRpdGlvbmFsV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic3RyV2lkdGggPD0gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gc3Vic3RyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoV2lkdGggPSBzdWJzdHJXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod3JhcEF0V29yZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3cmFwSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRDaGFyID0gbGluZVttYXRjaC5sZW5ndGhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0SXNTcGFjZU9yRGFzaCA9IG5leHRDaGFyID09PSBTUEFDRSB8fCBuZXh0Q2hhciA9PT0gREFTSDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dElzU3BhY2VPckRhc2ggJiYgbWF0Y2hXaWR0aCA8PSBtYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cmFwSW5kZXggPSBtYXRjaC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cmFwSW5kZXggPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgobWF0Y2gubGFzdEluZGV4T2YoU1BBQ0UpLCBtYXRjaC5sYXN0SW5kZXhPZihEQVNIKSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3cmFwSW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvdyA9IHdyYXBJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaC5zbGljZSgwLCBsb3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFdpZHRoID0gdGhpcy5fZ2V0VGV4dFdpZHRoKG1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IG1hdGNoLnRyaW1SaWdodCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkVGV4dExpbmUobWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFdpZHRoID0gTWF0aC5tYXgodGV4dFdpZHRoLCBtYXRjaFdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRIZWlnaHRQeCArPSBsaW5lSGVpZ2h0UHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZFdyYXAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZml4ZWRIZWlnaHQgJiYgY3VycmVudEhlaWdodFB4ICsgbGluZUhlaWdodFB4ID4gbWF4SGVpZ2h0UHgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RMaW5lID0gdGhpcy50ZXh0QXJyW3RoaXMudGV4dEFyci5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdExpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZEFkZEVsbGlwc2lzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGF2ZVNwYWNlID0gdGhpcy5fZ2V0VGV4dFdpZHRoKGxhc3RMaW5lLnRleHQgKyBFTExJUFNJUykgPCBtYXhXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGF2ZVNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdExpbmUudGV4dCA9IGxhc3RMaW5lLnRleHQuc2xpY2UoMCwgbGFzdExpbmUudGV4dC5sZW5ndGggLSAzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dEFyci5zcGxpY2UodGhpcy50ZXh0QXJyLmxlbmd0aCAtIDEsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkVGV4dExpbmUobGFzdExpbmUudGV4dCArIEVMTElQU0lTKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKGxvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gbGluZS50cmltTGVmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCA9IHRoaXMuX2dldFRleHRXaWR0aChsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZVdpZHRoIDw9IG1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRleHRMaW5lKGxpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50SGVpZ2h0UHggKz0gbGluZUhlaWdodFB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0V2lkdGggPSBNYXRoLm1heCh0ZXh0V2lkdGgsIGxpbmVXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkVGV4dExpbmUobGluZSk7XG4gICAgICAgICAgICAgICAgY3VycmVudEhlaWdodFB4ICs9IGxpbmVIZWlnaHRQeDtcbiAgICAgICAgICAgICAgICB0ZXh0V2lkdGggPSBNYXRoLm1heCh0ZXh0V2lkdGgsIGxpbmVXaWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZml4ZWRIZWlnaHQgJiYgY3VycmVudEhlaWdodFB4ICsgbGluZUhlaWdodFB4ID4gbWF4SGVpZ2h0UHgpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnRleHRBcnJbdGhpcy50ZXh0QXJyLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0QXJyW3RoaXMudGV4dEFyci5sZW5ndGggLSAxXS5sYXN0SW5QYXJhZ3JhcGggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dEhlaWdodCA9IGZvbnRTaXplO1xuICAgICAgICB0aGlzLnRleHRXaWR0aCA9IHRleHRXaWR0aDtcbiAgICB9XG4gICAgZ2V0U3Ryb2tlU2NhbGVFbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5UZXh0LnByb3RvdHlwZS5fZmlsbEZ1bmMgPSBfZmlsbEZ1bmM7XG5UZXh0LnByb3RvdHlwZS5fc3Ryb2tlRnVuYyA9IF9zdHJva2VGdW5jO1xuVGV4dC5wcm90b3R5cGUuY2xhc3NOYW1lID0gVEVYVF9VUFBFUjtcblRleHQucHJvdG90eXBlLl9hdHRyc0FmZmVjdGluZ1NpemUgPSBbXG4gICAgJ3RleHQnLFxuICAgICdmb250U2l6ZScsXG4gICAgJ3BhZGRpbmcnLFxuICAgICd3cmFwJyxcbiAgICAnbGluZUhlaWdodCcsXG4gICAgJ2xldHRlclNwYWNpbmcnLFxuXTtcbl9yZWdpc3Rlck5vZGUoVGV4dCk7XG5GYWN0b3J5Lm92ZXJXcml0ZVNldHRlcihUZXh0LCAnd2lkdGgnLCBnZXROdW1iZXJPckF1dG9WYWxpZGF0b3IoKSk7XG5GYWN0b3J5Lm92ZXJXcml0ZVNldHRlcihUZXh0LCAnaGVpZ2h0JywgZ2V0TnVtYmVyT3JBdXRvVmFsaWRhdG9yKCkpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoVGV4dCwgJ2ZvbnRGYW1pbHknLCAnQXJpYWwnKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFRleHQsICdmb250U2l6ZScsIDEyLCBnZXROdW1iZXJWYWxpZGF0b3IoKSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihUZXh0LCAnZm9udFN0eWxlJywgTk9STUFMKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFRleHQsICdmb250VmFyaWFudCcsIE5PUk1BTCk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihUZXh0LCAncGFkZGluZycsIDAsIGdldE51bWJlclZhbGlkYXRvcigpKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFRleHQsICdhbGlnbicsIExFRlQpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoVGV4dCwgJ3ZlcnRpY2FsQWxpZ24nLCBUT1ApO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoVGV4dCwgJ2xpbmVIZWlnaHQnLCAxLCBnZXROdW1iZXJWYWxpZGF0b3IoKSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihUZXh0LCAnd3JhcCcsIFdPUkQpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoVGV4dCwgJ2VsbGlwc2lzJywgZmFsc2UsIGdldEJvb2xlYW5WYWxpZGF0b3IoKSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihUZXh0LCAnbGV0dGVyU3BhY2luZycsIDAsIGdldE51bWJlclZhbGlkYXRvcigpKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFRleHQsICd0ZXh0JywgJycsIGdldFN0cmluZ1ZhbGlkYXRvcigpKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFRleHQsICd0ZXh0RGVjb3JhdGlvbicsICcnKTtcbiIsImltcG9ydCB7IFV0aWwgfSBmcm9tICcuLi9VdGlsLmpzJztcbmltcG9ydCB7IEZhY3RvcnkgfSBmcm9tICcuLi9GYWN0b3J5LmpzJztcbmltcG9ydCB7IFNoYXBlIH0gZnJvbSAnLi4vU2hhcGUuanMnO1xuaW1wb3J0IHsgUGF0aCB9IGZyb20gJy4vUGF0aC5qcyc7XG5pbXBvcnQgeyBUZXh0LCBzdHJpbmdUb0FycmF5IH0gZnJvbSAnLi9UZXh0LmpzJztcbmltcG9ydCB7IGdldE51bWJlclZhbGlkYXRvciB9IGZyb20gJy4uL1ZhbGlkYXRvcnMuanMnO1xuaW1wb3J0IHsgX3JlZ2lzdGVyTm9kZSB9IGZyb20gJy4uL0dsb2JhbC5qcyc7XG52YXIgRU1QVFlfU1RSSU5HID0gJycsIE5PUk1BTCA9ICdub3JtYWwnO1xuZnVuY3Rpb24gX2ZpbGxGdW5jKGNvbnRleHQpIHtcbiAgICBjb250ZXh0LmZpbGxUZXh0KHRoaXMucGFydGlhbFRleHQsIDAsIDApO1xufVxuZnVuY3Rpb24gX3N0cm9rZUZ1bmMoY29udGV4dCkge1xuICAgIGNvbnRleHQuc3Ryb2tlVGV4dCh0aGlzLnBhcnRpYWxUZXh0LCAwLCAwKTtcbn1cbmV4cG9ydCBjbGFzcyBUZXh0UGF0aCBleHRlbmRzIFNoYXBlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcbiAgICAgICAgdGhpcy5kdW1teUNhbnZhcyA9IFV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgICB0aGlzLmRhdGFBcnJheSA9IFtdO1xuICAgICAgICB0aGlzLmRhdGFBcnJheSA9IFBhdGgucGFyc2VQYXRoRGF0YSh0aGlzLmF0dHJzLmRhdGEpO1xuICAgICAgICB0aGlzLm9uKCdkYXRhQ2hhbmdlLmtvbnZhJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhQXJyYXkgPSBQYXRoLnBhcnNlUGF0aERhdGEodGhpcy5hdHRycy5kYXRhKTtcbiAgICAgICAgICAgIHRoaXMuX3NldFRleHREYXRhKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uKCd0ZXh0Q2hhbmdlLmtvbnZhIGFsaWduQ2hhbmdlLmtvbnZhIGxldHRlclNwYWNpbmdDaGFuZ2Uua29udmEga2VybmluZ0Z1bmNDaGFuZ2Uua29udmEgZm9udFNpemVDaGFuZ2Uua29udmEgZm9udEZhbWlseUNoYW5nZS5rb252YScsIHRoaXMuX3NldFRleHREYXRhKTtcbiAgICAgICAgdGhpcy5fc2V0VGV4dERhdGEoKTtcbiAgICB9XG4gICAgX3NjZW5lRnVuYyhjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQuc2V0QXR0cignZm9udCcsIHRoaXMuX2dldENvbnRleHRGb250KCkpO1xuICAgICAgICBjb250ZXh0LnNldEF0dHIoJ3RleHRCYXNlbGluZScsIHRoaXMudGV4dEJhc2VsaW5lKCkpO1xuICAgICAgICBjb250ZXh0LnNldEF0dHIoJ3RleHRBbGlnbicsICdsZWZ0Jyk7XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICB2YXIgdGV4dERlY29yYXRpb24gPSB0aGlzLnRleHREZWNvcmF0aW9uKCk7XG4gICAgICAgIHZhciBmaWxsID0gdGhpcy5maWxsKCk7XG4gICAgICAgIHZhciBmb250U2l6ZSA9IHRoaXMuZm9udFNpemUoKTtcbiAgICAgICAgdmFyIGdseXBoSW5mbyA9IHRoaXMuZ2x5cGhJbmZvO1xuICAgICAgICBpZiAodGV4dERlY29yYXRpb24gPT09ICd1bmRlcmxpbmUnKSB7XG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhJbmZvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgIHZhciBwMCA9IGdseXBoSW5mb1tpXS5wMDtcbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKHAwLngsIHAwLnkpO1xuICAgICAgICAgICAgY29udGV4dC5yb3RhdGUoZ2x5cGhJbmZvW2ldLnJvdGF0aW9uKTtcbiAgICAgICAgICAgIHRoaXMucGFydGlhbFRleHQgPSBnbHlwaEluZm9baV0udGV4dDtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRleHREZWNvcmF0aW9uID09PSAndW5kZXJsaW5lJykge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKDAsIGZvbnRTaXplIC8gMiArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhmb250U2l6ZSwgZm9udFNpemUgLyAyICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dERlY29yYXRpb24gPT09ICd1bmRlcmxpbmUnKSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gZmlsbDtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gZm9udFNpemUgLyAyMDtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIF9oaXRGdW5jKGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgdmFyIGdseXBoSW5mbyA9IHRoaXMuZ2x5cGhJbmZvO1xuICAgICAgICBpZiAoZ2x5cGhJbmZvLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgICB2YXIgcDAgPSBnbHlwaEluZm9bMF0ucDA7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhwMC54LCBwMC55KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBoSW5mby5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHAxID0gZ2x5cGhJbmZvW2ldLnAxO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocDEueCwgcDEueSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5zZXRBdHRyKCdsaW5lV2lkdGgnLCB0aGlzLmZvbnRTaXplKCkpO1xuICAgICAgICBjb250ZXh0LnNldEF0dHIoJ3N0cm9rZVN0eWxlJywgdGhpcy5jb2xvcktleSk7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICAgIGdldFRleHRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dFdpZHRoO1xuICAgIH1cbiAgICBnZXRUZXh0SGVpZ2h0KCkge1xuICAgICAgICBVdGlsLndhcm4oJ3RleHQuZ2V0VGV4dEhlaWdodCgpIG1ldGhvZCBpcyBkZXByZWNhdGVkLiBVc2UgdGV4dC5oZWlnaHQoKSAtIGZvciBmdWxsIGhlaWdodCBhbmQgdGV4dC5mb250U2l6ZSgpIC0gZm9yIG9uZSBsaW5lIGhlaWdodC4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dEhlaWdodDtcbiAgICB9XG4gICAgc2V0VGV4dCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBUZXh0LnByb3RvdHlwZS5zZXRUZXh0LmNhbGwodGhpcywgdGV4dCk7XG4gICAgfVxuICAgIF9nZXRDb250ZXh0Rm9udCgpIHtcbiAgICAgICAgcmV0dXJuIFRleHQucHJvdG90eXBlLl9nZXRDb250ZXh0Rm9udC5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICBfZ2V0VGV4dFNpemUodGV4dCkge1xuICAgICAgICB2YXIgZHVtbXlDYW52YXMgPSB0aGlzLmR1bW15Q2FudmFzO1xuICAgICAgICB2YXIgX2NvbnRleHQgPSBkdW1teUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBfY29udGV4dC5zYXZlKCk7XG4gICAgICAgIF9jb250ZXh0LmZvbnQgPSB0aGlzLl9nZXRDb250ZXh0Rm9udCgpO1xuICAgICAgICB2YXIgbWV0cmljcyA9IF9jb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpO1xuICAgICAgICBfY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogbWV0cmljcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogcGFyc2VJbnQodGhpcy5hdHRycy5mb250U2l6ZSwgMTApLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfc2V0VGV4dERhdGEoKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLl9nZXRUZXh0U2l6ZSh0aGlzLmF0dHJzLnRleHQpO1xuICAgICAgICB2YXIgbGV0dGVyU3BhY2luZyA9IHRoaXMubGV0dGVyU3BhY2luZygpO1xuICAgICAgICB2YXIgYWxpZ24gPSB0aGlzLmFsaWduKCk7XG4gICAgICAgIHZhciBrZXJuaW5nRnVuYyA9IHRoaXMua2VybmluZ0Z1bmMoKTtcbiAgICAgICAgdGhpcy50ZXh0V2lkdGggPSBzaXplLndpZHRoO1xuICAgICAgICB0aGlzLnRleHRIZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgICAgdmFyIHRleHRGdWxsV2lkdGggPSBNYXRoLm1heCh0aGlzLnRleHRXaWR0aCArICgodGhpcy5hdHRycy50ZXh0IHx8ICcnKS5sZW5ndGggLSAxKSAqIGxldHRlclNwYWNpbmcsIDApO1xuICAgICAgICB0aGlzLmdseXBoSW5mbyA9IFtdO1xuICAgICAgICB2YXIgZnVsbFBhdGhXaWR0aCA9IDA7XG4gICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgdGhhdC5kYXRhQXJyYXkubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgIGlmICh0aGF0LmRhdGFBcnJheVtsXS5wYXRoTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZ1bGxQYXRoV2lkdGggKz0gdGhhdC5kYXRhQXJyYXlbbF0ucGF0aExlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgoMCwgZnVsbFBhdGhXaWR0aCAvIDIgLSB0ZXh0RnVsbFdpZHRoIC8gMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBNYXRoLm1heCgwLCBmdWxsUGF0aFdpZHRoIC0gdGV4dEZ1bGxXaWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYXJBcnIgPSBzdHJpbmdUb0FycmF5KHRoaXMudGV4dCgpKTtcbiAgICAgICAgdmFyIHNwYWNlc051bWJlciA9IHRoaXMudGV4dCgpLnNwbGl0KCcgJykubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIHAwLCBwMSwgcGF0aENtZDtcbiAgICAgICAgdmFyIHBJbmRleCA9IC0xO1xuICAgICAgICB2YXIgY3VycmVudFQgPSAwO1xuICAgICAgICB2YXIgZ2V0TmV4dFBhdGhTZWdtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3VycmVudFQgPSAwO1xuICAgICAgICAgICAgdmFyIHBhdGhEYXRhID0gdGhhdC5kYXRhQXJyYXk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gcEluZGV4ICsgMTsgaiA8IHBhdGhEYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGhEYXRhW2pdLnBhdGhMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBJbmRleCA9IGo7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoRGF0YVtqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGF0aERhdGFbal0uY29tbWFuZCA9PT0gJ00nKSB7XG4gICAgICAgICAgICAgICAgICAgIHAwID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogcGF0aERhdGFbal0ucG9pbnRzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogcGF0aERhdGFbal0ucG9pbnRzWzFdLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGZpbmRTZWdtZW50VG9GaXRDaGFyYWN0ZXIgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgdmFyIGdseXBoV2lkdGggPSB0aGF0Ll9nZXRUZXh0U2l6ZShjKS53aWR0aCArIGxldHRlclNwYWNpbmc7XG4gICAgICAgICAgICBpZiAoYyA9PT0gJyAnICYmIGFsaWduID09PSAnanVzdGlmeScpIHtcbiAgICAgICAgICAgICAgICBnbHlwaFdpZHRoICs9IChmdWxsUGF0aFdpZHRoIC0gdGV4dEZ1bGxXaWR0aCkgLyBzcGFjZXNOdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3VyckxlbiA9IDA7XG4gICAgICAgICAgICB2YXIgYXR0ZW1wdHMgPSAwO1xuICAgICAgICAgICAgcDEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB3aGlsZSAoTWF0aC5hYnMoZ2x5cGhXaWR0aCAtIGN1cnJMZW4pIC8gZ2x5cGhXaWR0aCA+IDAuMDEgJiZcbiAgICAgICAgICAgICAgICBhdHRlbXB0cyA8IDIwKSB7XG4gICAgICAgICAgICAgICAgYXR0ZW1wdHMrKztcbiAgICAgICAgICAgICAgICB2YXIgY3VtdWxhdGl2ZVBhdGhMZW5ndGggPSBjdXJyTGVuO1xuICAgICAgICAgICAgICAgIHdoaWxlIChwYXRoQ21kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aENtZCA9IGdldE5leHRQYXRoU2VnbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aENtZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY3VtdWxhdGl2ZVBhdGhMZW5ndGggKyBwYXRoQ21kLnBhdGhMZW5ndGggPCBnbHlwaFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdW11bGF0aXZlUGF0aExlbmd0aCArPSBwYXRoQ21kLnBhdGhMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoQ21kID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXRoQ21kID09PSB7fSB8fCBwMCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuZWVkTmV3U2VnbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocGF0aENtZC5jb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFBhdGguZ2V0TGluZUxlbmd0aChwMC54LCBwMC55LCBwYXRoQ21kLnBvaW50c1swXSwgcGF0aENtZC5wb2ludHNbMV0pID4gZ2x5cGhXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAxID0gUGF0aC5nZXRQb2ludE9uTGluZShnbHlwaFdpZHRoLCBwMC54LCBwMC55LCBwYXRoQ21kLnBvaW50c1swXSwgcGF0aENtZC5wb2ludHNbMV0sIHAwLngsIHAwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aENtZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHBhdGhDbWQucG9pbnRzWzRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRUaGV0YSA9IHBhdGhDbWQucG9pbnRzWzVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZCA9IHBhdGhDbWQucG9pbnRzWzRdICsgZFRoZXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRUID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFQgPSBzdGFydCArIDAuMDAwMDAwMDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChnbHlwaFdpZHRoID4gY3Vyckxlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUICs9ICgoTWF0aC5QSSAvIDE4MC4wKSAqIGRUaGV0YSkgLyBNYXRoLmFicyhkVGhldGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFQgLT0gKChNYXRoLlBJIC8gMzYwLjApICogZFRoZXRhKSAvIE1hdGguYWJzKGRUaGV0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGRUaGV0YSA8IDAgJiYgY3VycmVudFQgPCBlbmQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRUaGV0YSA+PSAwICYmIGN1cnJlbnRUID4gZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lZWROZXdTZWdtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHAxID0gUGF0aC5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhwYXRoQ21kLnBvaW50c1swXSwgcGF0aENtZC5wb2ludHNbMV0sIHBhdGhDbWQucG9pbnRzWzJdLCBwYXRoQ21kLnBvaW50c1szXSwgY3VycmVudFQsIHBhdGhDbWQucG9pbnRzWzZdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnbHlwaFdpZHRoID4gcGF0aENtZC5wYXRoTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gMC4wMDAwMDAwMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gZ2x5cGhXaWR0aCAvIHBhdGhDbWQucGF0aExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChnbHlwaFdpZHRoID4gY3Vyckxlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUICs9IChnbHlwaFdpZHRoIC0gY3VyckxlbikgLyBwYXRoQ21kLnBhdGhMZW5ndGggLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFQgPSBNYXRoLm1heChjdXJyZW50VCAtIChjdXJyTGVuIC0gZ2x5cGhXaWR0aCkgLyBwYXRoQ21kLnBhdGhMZW5ndGggLyAyLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VCA+IDEuMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gMS4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lZWROZXdTZWdtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHAxID0gUGF0aC5nZXRQb2ludE9uQ3ViaWNCZXppZXIoY3VycmVudFQsIHBhdGhDbWQuc3RhcnQueCwgcGF0aENtZC5zdGFydC55LCBwYXRoQ21kLnBvaW50c1swXSwgcGF0aENtZC5wb2ludHNbMV0sIHBhdGhDbWQucG9pbnRzWzJdLCBwYXRoQ21kLnBvaW50c1szXSwgcGF0aENtZC5wb2ludHNbNF0sIHBhdGhDbWQucG9pbnRzWzVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gZ2x5cGhXaWR0aCAvIHBhdGhDbWQucGF0aExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGdseXBoV2lkdGggPiBjdXJyTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFQgKz0gKGdseXBoV2lkdGggLSBjdXJyTGVuKSAvIHBhdGhDbWQucGF0aExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUIC09IChjdXJyTGVuIC0gZ2x5cGhXaWR0aCkgLyBwYXRoQ21kLnBhdGhMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFQgPiAxLjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCA9IDEuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZWVkTmV3U2VnbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwMSA9IFBhdGguZ2V0UG9pbnRPblF1YWRyYXRpY0JlemllcihjdXJyZW50VCwgcGF0aENtZC5zdGFydC54LCBwYXRoQ21kLnN0YXJ0LnksIHBhdGhDbWQucG9pbnRzWzBdLCBwYXRoQ21kLnBvaW50c1sxXSwgcGF0aENtZC5wb2ludHNbMl0sIHBhdGhDbWQucG9pbnRzWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocDEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyTGVuID0gUGF0aC5nZXRMaW5lTGVuZ3RoKHAwLngsIHAwLnksIHAxLngsIHAxLnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmVlZE5ld1NlZ21lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmVlZE5ld1NlZ21lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aENtZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0ZXN0Q2hhciA9ICdDJztcbiAgICAgICAgdmFyIGdseXBoV2lkdGggPSB0aGF0Ll9nZXRUZXh0U2l6ZSh0ZXN0Q2hhcikud2lkdGggKyBsZXR0ZXJTcGFjaW5nO1xuICAgICAgICB2YXIgbGV0dGVyc0luT2Zmc2V0ID0gb2Zmc2V0IC8gZ2x5cGhXaWR0aCAtIDE7XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGV0dGVyc0luT2Zmc2V0OyBrKyspIHtcbiAgICAgICAgICAgIGZpbmRTZWdtZW50VG9GaXRDaGFyYWN0ZXIodGVzdENoYXIpO1xuICAgICAgICAgICAgaWYgKHAwID09PSB1bmRlZmluZWQgfHwgcDEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcDAgPSBwMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZpbmRTZWdtZW50VG9GaXRDaGFyYWN0ZXIoY2hhckFycltpXSk7XG4gICAgICAgICAgICBpZiAocDAgPT09IHVuZGVmaW5lZCB8fCBwMSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBQYXRoLmdldExpbmVMZW5ndGgocDAueCwgcDAueSwgcDEueCwgcDEueSk7XG4gICAgICAgICAgICB2YXIga2VybiA9IDA7XG4gICAgICAgICAgICBpZiAoa2VybmluZ0Z1bmMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBrZXJuID0ga2VybmluZ0Z1bmMoY2hhckFycltpIC0gMV0sIGNoYXJBcnJbaV0pICogdGhpcy5mb250U2l6ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBrZXJuID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwMC54ICs9IGtlcm47XG4gICAgICAgICAgICBwMS54ICs9IGtlcm47XG4gICAgICAgICAgICB0aGlzLnRleHRXaWR0aCArPSBrZXJuO1xuICAgICAgICAgICAgdmFyIG1pZHBvaW50ID0gUGF0aC5nZXRQb2ludE9uTGluZShrZXJuICsgd2lkdGggLyAyLjAsIHAwLngsIHAwLnksIHAxLngsIHAxLnkpO1xuICAgICAgICAgICAgdmFyIHJvdGF0aW9uID0gTWF0aC5hdGFuMihwMS55IC0gcDAueSwgcDEueCAtIHAwLngpO1xuICAgICAgICAgICAgdGhpcy5nbHlwaEluZm8ucHVzaCh7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3NlWDogbWlkcG9pbnQueCxcbiAgICAgICAgICAgICAgICB0cmFuc3Bvc2VZOiBtaWRwb2ludC55LFxuICAgICAgICAgICAgICAgIHRleHQ6IGNoYXJBcnJbaV0sXG4gICAgICAgICAgICAgICAgcm90YXRpb246IHJvdGF0aW9uLFxuICAgICAgICAgICAgICAgIHAwOiBwMCxcbiAgICAgICAgICAgICAgICBwMTogcDEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHAwID0gcDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0U2VsZlJlY3QoKSB7XG4gICAgICAgIGlmICghdGhpcy5nbHlwaEluZm8ubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICAgICAgdGhpcy5nbHlwaEluZm8uZm9yRWFjaChmdW5jdGlvbiAoaW5mbykge1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goaW5mby5wMC54KTtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGluZm8ucDAueSk7XG4gICAgICAgICAgICBwb2ludHMucHVzaChpbmZvLnAxLngpO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goaW5mby5wMS55KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBtaW5YID0gcG9pbnRzWzBdIHx8IDA7XG4gICAgICAgIHZhciBtYXhYID0gcG9pbnRzWzBdIHx8IDA7XG4gICAgICAgIHZhciBtaW5ZID0gcG9pbnRzWzFdIHx8IDA7XG4gICAgICAgIHZhciBtYXhZID0gcG9pbnRzWzFdIHx8IDA7XG4gICAgICAgIHZhciB4LCB5O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgICAgIHggPSBwb2ludHNbaSAqIDJdO1xuICAgICAgICAgICAgeSA9IHBvaW50c1tpICogMiArIDFdO1xuICAgICAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHgpO1xuICAgICAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHgpO1xuICAgICAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHkpO1xuICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb250U2l6ZSA9IHRoaXMuZm9udFNpemUoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IG1pblggLSBmb250U2l6ZSAvIDIsXG4gICAgICAgICAgICB5OiBtaW5ZIC0gZm9udFNpemUgLyAyLFxuICAgICAgICAgICAgd2lkdGg6IG1heFggLSBtaW5YICsgZm9udFNpemUsXG4gICAgICAgICAgICBoZWlnaHQ6IG1heFkgLSBtaW5ZICsgZm9udFNpemUsXG4gICAgICAgIH07XG4gICAgfVxufVxuVGV4dFBhdGgucHJvdG90eXBlLl9maWxsRnVuYyA9IF9maWxsRnVuYztcblRleHRQYXRoLnByb3RvdHlwZS5fc3Ryb2tlRnVuYyA9IF9zdHJva2VGdW5jO1xuVGV4dFBhdGgucHJvdG90eXBlLl9maWxsRnVuY0hpdCA9IF9maWxsRnVuYztcblRleHRQYXRoLnByb3RvdHlwZS5fc3Ryb2tlRnVuY0hpdCA9IF9zdHJva2VGdW5jO1xuVGV4dFBhdGgucHJvdG90eXBlLmNsYXNzTmFtZSA9ICdUZXh0UGF0aCc7XG5UZXh0UGF0aC5wcm90b3R5cGUuX2F0dHJzQWZmZWN0aW5nU2l6ZSA9IFsndGV4dCcsICdmb250U2l6ZScsICdkYXRhJ107XG5fcmVnaXN0ZXJOb2RlKFRleHRQYXRoKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFRleHRQYXRoLCAnZGF0YScpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoVGV4dFBhdGgsICdmb250RmFtaWx5JywgJ0FyaWFsJyk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihUZXh0UGF0aCwgJ2ZvbnRTaXplJywgMTIsIGdldE51bWJlclZhbGlkYXRvcigpKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFRleHRQYXRoLCAnZm9udFN0eWxlJywgTk9STUFMKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFRleHRQYXRoLCAnYWxpZ24nLCAnbGVmdCcpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoVGV4dFBhdGgsICdsZXR0ZXJTcGFjaW5nJywgMCwgZ2V0TnVtYmVyVmFsaWRhdG9yKCkpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoVGV4dFBhdGgsICd0ZXh0QmFzZWxpbmUnLCAnbWlkZGxlJyk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihUZXh0UGF0aCwgJ2ZvbnRWYXJpYW50JywgTk9STUFMKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFRleHRQYXRoLCAndGV4dCcsIEVNUFRZX1NUUklORyk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihUZXh0UGF0aCwgJ3RleHREZWNvcmF0aW9uJywgbnVsbCk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihUZXh0UGF0aCwgJ2tlcm5pbmdGdW5jJywgbnVsbCk7XG4iLCJpbXBvcnQgeyBVdGlsLCBUcmFuc2Zvcm0gfSBmcm9tICcuLi9VdGlsLmpzJztcbmltcG9ydCB7IEZhY3RvcnkgfSBmcm9tICcuLi9GYWN0b3J5LmpzJztcbmltcG9ydCB7IE5vZGUgfSBmcm9tICcuLi9Ob2RlLmpzJztcbmltcG9ydCB7IFNoYXBlIH0gZnJvbSAnLi4vU2hhcGUuanMnO1xuaW1wb3J0IHsgUmVjdCB9IGZyb20gJy4vUmVjdC5qcyc7XG5pbXBvcnQgeyBHcm91cCB9IGZyb20gJy4uL0dyb3VwLmpzJztcbmltcG9ydCB7IEtvbnZhIH0gZnJvbSAnLi4vR2xvYmFsLmpzJztcbmltcG9ydCB7IGdldEJvb2xlYW5WYWxpZGF0b3IsIGdldE51bWJlclZhbGlkYXRvciB9IGZyb20gJy4uL1ZhbGlkYXRvcnMuanMnO1xuaW1wb3J0IHsgX3JlZ2lzdGVyTm9kZSB9IGZyb20gJy4uL0dsb2JhbC5qcyc7XG52YXIgRVZFTlRTX05BTUUgPSAndHIta29udmEnO1xudmFyIEFUVFJfQ0hBTkdFX0xJU1QgPSBbXG4gICAgJ3Jlc2l6ZUVuYWJsZWRDaGFuZ2UnLFxuICAgICdyb3RhdGVBbmNob3JPZmZzZXRDaGFuZ2UnLFxuICAgICdyb3RhdGVFbmFibGVkQ2hhbmdlJyxcbiAgICAnZW5hYmxlZEFuY2hvcnNDaGFuZ2UnLFxuICAgICdhbmNob3JTaXplQ2hhbmdlJyxcbiAgICAnYm9yZGVyRW5hYmxlZENoYW5nZScsXG4gICAgJ2JvcmRlclN0cm9rZUNoYW5nZScsXG4gICAgJ2JvcmRlclN0cm9rZVdpZHRoQ2hhbmdlJyxcbiAgICAnYm9yZGVyRGFzaENoYW5nZScsXG4gICAgJ2FuY2hvclN0cm9rZUNoYW5nZScsXG4gICAgJ2FuY2hvclN0cm9rZVdpZHRoQ2hhbmdlJyxcbiAgICAnYW5jaG9yRmlsbENoYW5nZScsXG4gICAgJ2FuY2hvckNvcm5lclJhZGl1c0NoYW5nZScsXG4gICAgJ2lnbm9yZVN0cm9rZUNoYW5nZScsXG5dXG4gICAgLm1hcCgoZSkgPT4gZSArIGAuJHtFVkVOVFNfTkFNRX1gKVxuICAgIC5qb2luKCcgJyk7XG52YXIgTk9ERVNfUkVDVCA9ICdub2Rlc1JlY3QnO1xudmFyIFRSQU5TRk9STV9DSEFOR0VfU1RSID0gW1xuICAgICd3aWR0aENoYW5nZScsXG4gICAgJ2hlaWdodENoYW5nZScsXG4gICAgJ3NjYWxlWENoYW5nZScsXG4gICAgJ3NjYWxlWUNoYW5nZScsXG4gICAgJ3NrZXdYQ2hhbmdlJyxcbiAgICAnc2tld1lDaGFuZ2UnLFxuICAgICdyb3RhdGlvbkNoYW5nZScsXG4gICAgJ29mZnNldFhDaGFuZ2UnLFxuICAgICdvZmZzZXRZQ2hhbmdlJyxcbiAgICAndHJhbnNmb3Jtc0VuYWJsZWRDaGFuZ2UnLFxuICAgICdzdHJva2VXaWR0aENoYW5nZScsXG5dO1xudmFyIEFOR0xFUyA9IHtcbiAgICAndG9wLWxlZnQnOiAtNDUsXG4gICAgJ3RvcC1jZW50ZXInOiAwLFxuICAgICd0b3AtcmlnaHQnOiA0NSxcbiAgICAnbWlkZGxlLXJpZ2h0JzogLTkwLFxuICAgICdtaWRkbGUtbGVmdCc6IDkwLFxuICAgICdib3R0b20tbGVmdCc6IC0xMzUsXG4gICAgJ2JvdHRvbS1jZW50ZXInOiAxODAsXG4gICAgJ2JvdHRvbS1yaWdodCc6IDEzNSxcbn07XG5jb25zdCBUT1VDSF9ERVZJQ0UgPSAnb250b3VjaHN0YXJ0JyBpbiBLb252YS5fZ2xvYmFsO1xuZnVuY3Rpb24gZ2V0Q3Vyc29yKGFuY2hvck5hbWUsIHJhZCkge1xuICAgIGlmIChhbmNob3JOYW1lID09PSAncm90YXRlcicpIHtcbiAgICAgICAgcmV0dXJuICdjcm9zc2hhaXInO1xuICAgIH1cbiAgICByYWQgKz0gVXRpbC5kZWdUb1JhZChBTkdMRVNbYW5jaG9yTmFtZV0gfHwgMCk7XG4gICAgdmFyIGFuZ2xlID0gKChVdGlsLnJhZFRvRGVnKHJhZCkgJSAzNjApICsgMzYwKSAlIDM2MDtcbiAgICBpZiAoVXRpbC5faW5SYW5nZShhbmdsZSwgMzE1ICsgMjIuNSwgMzYwKSB8fCBVdGlsLl9pblJhbmdlKGFuZ2xlLCAwLCAyMi41KSkge1xuICAgICAgICByZXR1cm4gJ25zLXJlc2l6ZSc7XG4gICAgfVxuICAgIGVsc2UgaWYgKFV0aWwuX2luUmFuZ2UoYW5nbGUsIDQ1IC0gMjIuNSwgNDUgKyAyMi41KSkge1xuICAgICAgICByZXR1cm4gJ25lc3ctcmVzaXplJztcbiAgICB9XG4gICAgZWxzZSBpZiAoVXRpbC5faW5SYW5nZShhbmdsZSwgOTAgLSAyMi41LCA5MCArIDIyLjUpKSB7XG4gICAgICAgIHJldHVybiAnZXctcmVzaXplJztcbiAgICB9XG4gICAgZWxzZSBpZiAoVXRpbC5faW5SYW5nZShhbmdsZSwgMTM1IC0gMjIuNSwgMTM1ICsgMjIuNSkpIHtcbiAgICAgICAgcmV0dXJuICdud3NlLXJlc2l6ZSc7XG4gICAgfVxuICAgIGVsc2UgaWYgKFV0aWwuX2luUmFuZ2UoYW5nbGUsIDE4MCAtIDIyLjUsIDE4MCArIDIyLjUpKSB7XG4gICAgICAgIHJldHVybiAnbnMtcmVzaXplJztcbiAgICB9XG4gICAgZWxzZSBpZiAoVXRpbC5faW5SYW5nZShhbmdsZSwgMjI1IC0gMjIuNSwgMjI1ICsgMjIuNSkpIHtcbiAgICAgICAgcmV0dXJuICduZXN3LXJlc2l6ZSc7XG4gICAgfVxuICAgIGVsc2UgaWYgKFV0aWwuX2luUmFuZ2UoYW5nbGUsIDI3MCAtIDIyLjUsIDI3MCArIDIyLjUpKSB7XG4gICAgICAgIHJldHVybiAnZXctcmVzaXplJztcbiAgICB9XG4gICAgZWxzZSBpZiAoVXRpbC5faW5SYW5nZShhbmdsZSwgMzE1IC0gMjIuNSwgMzE1ICsgMjIuNSkpIHtcbiAgICAgICAgcmV0dXJuICdud3NlLXJlc2l6ZSc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBVdGlsLmVycm9yKCdUcmFuc2Zvcm1lciBoYXMgdW5rbm93biBhbmdsZSBmb3IgY3Vyc29yIGRldGVjdGlvbjogJyArIGFuZ2xlKTtcbiAgICAgICAgcmV0dXJuICdwb2ludGVyJztcbiAgICB9XG59XG52YXIgQU5DSE9SU19OQU1FUyA9IFtcbiAgICAndG9wLWxlZnQnLFxuICAgICd0b3AtY2VudGVyJyxcbiAgICAndG9wLXJpZ2h0JyxcbiAgICAnbWlkZGxlLXJpZ2h0JyxcbiAgICAnbWlkZGxlLWxlZnQnLFxuICAgICdib3R0b20tbGVmdCcsXG4gICAgJ2JvdHRvbS1jZW50ZXInLFxuICAgICdib3R0b20tcmlnaHQnLFxuXTtcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gMTAwMDAwMDAwO1xuZnVuY3Rpb24gZ2V0Q2VudGVyKHNoYXBlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogc2hhcGUueCArXG4gICAgICAgICAgICAoc2hhcGUud2lkdGggLyAyKSAqIE1hdGguY29zKHNoYXBlLnJvdGF0aW9uKSArXG4gICAgICAgICAgICAoc2hhcGUuaGVpZ2h0IC8gMikgKiBNYXRoLnNpbigtc2hhcGUucm90YXRpb24pLFxuICAgICAgICB5OiBzaGFwZS55ICtcbiAgICAgICAgICAgIChzaGFwZS5oZWlnaHQgLyAyKSAqIE1hdGguY29zKHNoYXBlLnJvdGF0aW9uKSArXG4gICAgICAgICAgICAoc2hhcGUud2lkdGggLyAyKSAqIE1hdGguc2luKHNoYXBlLnJvdGF0aW9uKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcm90YXRlQXJvdW5kUG9pbnQoc2hhcGUsIGFuZ2xlUmFkLCBwb2ludCkge1xuICAgIGNvbnN0IHggPSBwb2ludC54ICtcbiAgICAgICAgKHNoYXBlLnggLSBwb2ludC54KSAqIE1hdGguY29zKGFuZ2xlUmFkKSAtXG4gICAgICAgIChzaGFwZS55IC0gcG9pbnQueSkgKiBNYXRoLnNpbihhbmdsZVJhZCk7XG4gICAgY29uc3QgeSA9IHBvaW50LnkgK1xuICAgICAgICAoc2hhcGUueCAtIHBvaW50LngpICogTWF0aC5zaW4oYW5nbGVSYWQpICtcbiAgICAgICAgKHNoYXBlLnkgLSBwb2ludC55KSAqIE1hdGguY29zKGFuZ2xlUmFkKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzaGFwZSksIHsgcm90YXRpb246IHNoYXBlLnJvdGF0aW9uICsgYW5nbGVSYWQsIHgsXG4gICAgICAgIHkgfSk7XG59XG5mdW5jdGlvbiByb3RhdGVBcm91bmRDZW50ZXIoc2hhcGUsIGRlbHRhUmFkKSB7XG4gICAgY29uc3QgY2VudGVyID0gZ2V0Q2VudGVyKHNoYXBlKTtcbiAgICByZXR1cm4gcm90YXRlQXJvdW5kUG9pbnQoc2hhcGUsIGRlbHRhUmFkLCBjZW50ZXIpO1xufVxuZnVuY3Rpb24gZ2V0U25hcChzbmFwcywgbmV3Um90YXRpb25SYWQsIHRvbCkge1xuICAgIGxldCBzbmFwcGVkID0gbmV3Um90YXRpb25SYWQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbmFwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhbmdsZSA9IEtvbnZhLmdldEFuZ2xlKHNuYXBzW2ldKTtcbiAgICAgICAgY29uc3QgYWJzRGlmZiA9IE1hdGguYWJzKGFuZ2xlIC0gbmV3Um90YXRpb25SYWQpICUgKE1hdGguUEkgKiAyKTtcbiAgICAgICAgY29uc3QgZGlmID0gTWF0aC5taW4oYWJzRGlmZiwgTWF0aC5QSSAqIDIgLSBhYnNEaWZmKTtcbiAgICAgICAgaWYgKGRpZiA8IHRvbCkge1xuICAgICAgICAgICAgc25hcHBlZCA9IGFuZ2xlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzbmFwcGVkO1xufVxuZXhwb3J0IGNsYXNzIFRyYW5zZm9ybWVyIGV4dGVuZHMgR3JvdXAge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY3JlYXRlRWxlbWVudHMoKTtcbiAgICAgICAgdGhpcy5faGFuZGxlTW91c2VNb3ZlID0gdGhpcy5faGFuZGxlTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZU1vdXNlVXAgPSB0aGlzLl9oYW5kbGVNb3VzZVVwLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudXBkYXRlID0gdGhpcy51cGRhdGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbihBVFRSX0NIQU5HRV9MSVNULCB0aGlzLnVwZGF0ZSk7XG4gICAgICAgIGlmICh0aGlzLmdldE5vZGUoKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhdHRhY2hUbyhub2RlKSB7XG4gICAgICAgIHRoaXMuc2V0Tm9kZShub2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldE5vZGUobm9kZSkge1xuICAgICAgICBVdGlsLndhcm4oJ3RyLnNldE5vZGUoc2hhcGUpLCB0ci5ub2RlKHNoYXBlKSBhbmQgdHIuYXR0YWNoVG8oc2hhcGUpIG1ldGhvZHMgYXJlIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdHIubm9kZXMobm9kZXNBcnJheSkgaW5zdGVhZC4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0Tm9kZXMoW25vZGVdKTtcbiAgICB9XG4gICAgZ2V0Tm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vZGVzICYmIHRoaXMuX25vZGVzWzBdO1xuICAgIH1cbiAgICBfZ2V0RXZlbnROYW1lc3BhY2UoKSB7XG4gICAgICAgIHJldHVybiBFVkVOVFNfTkFNRSArIHRoaXMuX2lkO1xuICAgIH1cbiAgICBzZXROb2Rlcyhub2RlcyA9IFtdKSB7XG4gICAgICAgIGlmICh0aGlzLl9ub2RlcyAmJiB0aGlzLl9ub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbm9kZXMgPSBub2RlcztcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLnVzZVNpbmdsZU5vZGVSb3RhdGlvbigpKSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uKG5vZGVzWzBdLmdldEFic29sdXRlUm90YXRpb24oKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uKDApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9uQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vZGVzKCkubGVuZ3RoID09PSAxICYmIHRoaXMudXNlU2luZ2xlTm9kZVJvdGF0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3RhdGlvbih0aGlzLm5vZGVzKClbMF0uZ2V0QWJzb2x1dGVSb3RhdGlvbigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1DYWNoZSgpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fdHJhbnNmb3JtaW5nICYmICF0aGlzLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBhZGRpdGlvbmFsRXZlbnRzID0gbm9kZS5fYXR0cnNBZmZlY3RpbmdTaXplXG4gICAgICAgICAgICAgICAgLm1hcCgocHJvcCkgPT4gcHJvcCArICdDaGFuZ2UuJyArIHRoaXMuX2dldEV2ZW50TmFtZXNwYWNlKCkpXG4gICAgICAgICAgICAgICAgLmpvaW4oJyAnKTtcbiAgICAgICAgICAgIG5vZGUub24oYWRkaXRpb25hbEV2ZW50cywgb25DaGFuZ2UpO1xuICAgICAgICAgICAgbm9kZS5vbihUUkFOU0ZPUk1fQ0hBTkdFX1NUUi5tYXAoKGUpID0+IGUgKyBgLiR7dGhpcy5fZ2V0RXZlbnROYW1lc3BhY2UoKX1gKS5qb2luKCcgJyksIG9uQ2hhbmdlKTtcbiAgICAgICAgICAgIG5vZGUub24oYGFic29sdXRlVHJhbnNmb3JtQ2hhbmdlLiR7dGhpcy5fZ2V0RXZlbnROYW1lc3BhY2UoKX1gLCBvbkNoYW5nZSk7XG4gICAgICAgICAgICB0aGlzLl9wcm94eURyYWcobm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUNhY2hlKCk7XG4gICAgICAgIHZhciBlbGVtZW50c0NyZWF0ZWQgPSAhIXRoaXMuZmluZE9uZSgnLnRvcC1sZWZ0Jyk7XG4gICAgICAgIGlmIChlbGVtZW50c0NyZWF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIF9wcm94eURyYWcobm9kZSkge1xuICAgICAgICBsZXQgbGFzdFBvcztcbiAgICAgICAgbm9kZS5vbihgZHJhZ3N0YXJ0LiR7dGhpcy5fZ2V0RXZlbnROYW1lc3BhY2UoKX1gLCAoZSkgPT4ge1xuICAgICAgICAgICAgbGFzdFBvcyA9IG5vZGUuZ2V0QWJzb2x1dGVQb3NpdGlvbigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcoKSAmJiBub2RlICE9PSB0aGlzLmZpbmRPbmUoJy5iYWNrJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RHJhZyhlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBub2RlLm9uKGBkcmFnbW92ZS4ke3RoaXMuX2dldEV2ZW50TmFtZXNwYWNlKCl9YCwgKGUpID0+IHtcbiAgICAgICAgICAgIGlmICghbGFzdFBvcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFicyA9IG5vZGUuZ2V0QWJzb2x1dGVQb3NpdGlvbigpO1xuICAgICAgICAgICAgY29uc3QgZHggPSBhYnMueCAtIGxhc3RQb3MueDtcbiAgICAgICAgICAgIGNvbnN0IGR5ID0gYWJzLnkgLSBsYXN0UG9zLnk7XG4gICAgICAgICAgICB0aGlzLm5vZGVzKCkuZm9yRWFjaCgob3RoZXJOb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG90aGVyTm9kZSA9PT0gbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvdGhlck5vZGUuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJBYnMgPSBvdGhlck5vZGUuZ2V0QWJzb2x1dGVQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIG90aGVyTm9kZS5zZXRBYnNvbHV0ZVBvc2l0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgeDogb3RoZXJBYnMueCArIGR4LFxuICAgICAgICAgICAgICAgICAgICB5OiBvdGhlckFicy55ICsgZHksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb3RoZXJOb2RlLnN0YXJ0RHJhZyhlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGFzdFBvcyA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXROb2RlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vZGVzIHx8IFtdO1xuICAgIH1cbiAgICBnZXRBY3RpdmVBbmNob3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb3ZpbmdBbmNob3JOYW1lO1xuICAgIH1cbiAgICBkZXRhY2goKSB7XG4gICAgICAgIGlmICh0aGlzLl9ub2Rlcykge1xuICAgICAgICAgICAgdGhpcy5fbm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIG5vZGUub2ZmKCcuJyArIHRoaXMuX2dldEV2ZW50TmFtZXNwYWNlKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1DYWNoZSgpO1xuICAgIH1cbiAgICBfcmVzZXRUcmFuc2Zvcm1DYWNoZSgpIHtcbiAgICAgICAgdGhpcy5fY2xlYXJDYWNoZShOT0RFU19SRUNUKTtcbiAgICAgICAgdGhpcy5fY2xlYXJDYWNoZSgndHJhbnNmb3JtJyk7XG4gICAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZSgnYWJzb2x1dGVUcmFuc2Zvcm0nKTtcbiAgICB9XG4gICAgX2dldE5vZGVSZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUoTk9ERVNfUkVDVCwgdGhpcy5fX2dldE5vZGVSZWN0KTtcbiAgICB9XG4gICAgX19nZXROb2RlU2hhcGUobm9kZSwgcm90ID0gdGhpcy5yb3RhdGlvbigpLCByZWxhdGl2ZSkge1xuICAgICAgICB2YXIgcmVjdCA9IG5vZGUuZ2V0Q2xpZW50UmVjdCh7XG4gICAgICAgICAgICBza2lwVHJhbnNmb3JtOiB0cnVlLFxuICAgICAgICAgICAgc2tpcFNoYWRvdzogdHJ1ZSxcbiAgICAgICAgICAgIHNraXBTdHJva2U6IHRoaXMuaWdub3JlU3Ryb2tlKCksXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgYWJzU2NhbGUgPSBub2RlLmdldEFic29sdXRlU2NhbGUocmVsYXRpdmUpO1xuICAgICAgICB2YXIgYWJzUG9zID0gbm9kZS5nZXRBYnNvbHV0ZVBvc2l0aW9uKHJlbGF0aXZlKTtcbiAgICAgICAgdmFyIGR4ID0gcmVjdC54ICogYWJzU2NhbGUueCAtIG5vZGUub2Zmc2V0WCgpICogYWJzU2NhbGUueDtcbiAgICAgICAgdmFyIGR5ID0gcmVjdC55ICogYWJzU2NhbGUueSAtIG5vZGUub2Zmc2V0WSgpICogYWJzU2NhbGUueTtcbiAgICAgICAgY29uc3Qgcm90YXRpb24gPSAoS29udmEuZ2V0QW5nbGUobm9kZS5nZXRBYnNvbHV0ZVJvdGF0aW9uKCkpICsgTWF0aC5QSSAqIDIpICVcbiAgICAgICAgICAgIChNYXRoLlBJICogMik7XG4gICAgICAgIGNvbnN0IGJveCA9IHtcbiAgICAgICAgICAgIHg6IGFic1Bvcy54ICsgZHggKiBNYXRoLmNvcyhyb3RhdGlvbikgKyBkeSAqIE1hdGguc2luKC1yb3RhdGlvbiksXG4gICAgICAgICAgICB5OiBhYnNQb3MueSArIGR5ICogTWF0aC5jb3Mocm90YXRpb24pICsgZHggKiBNYXRoLnNpbihyb3RhdGlvbiksXG4gICAgICAgICAgICB3aWR0aDogcmVjdC53aWR0aCAqIGFic1NjYWxlLngsXG4gICAgICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0ICogYWJzU2NhbGUueSxcbiAgICAgICAgICAgIHJvdGF0aW9uOiByb3RhdGlvbixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJvdGF0ZUFyb3VuZFBvaW50KGJveCwgLUtvbnZhLmdldEFuZ2xlKHJvdCksIHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX19nZXROb2RlUmVjdCgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldE5vZGUoKTtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IC1NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgICAgICAgICAgIHk6IC1NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG90YWxQb2ludHMgPSBbXTtcbiAgICAgICAgdGhpcy5ub2RlcygpLm1hcCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYm94ID0gbm9kZS5nZXRDbGllbnRSZWN0KHtcbiAgICAgICAgICAgICAgICBza2lwVHJhbnNmb3JtOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNraXBTaGFkb3c6IHRydWUsXG4gICAgICAgICAgICAgICAgc2tpcFN0cm9rZTogdGhpcy5pZ25vcmVTdHJva2UoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtcbiAgICAgICAgICAgICAgICB7IHg6IGJveC54LCB5OiBib3gueSB9LFxuICAgICAgICAgICAgICAgIHsgeDogYm94LnggKyBib3gud2lkdGgsIHk6IGJveC55IH0sXG4gICAgICAgICAgICAgICAgeyB4OiBib3gueCArIGJveC53aWR0aCwgeTogYm94LnkgKyBib3guaGVpZ2h0IH0sXG4gICAgICAgICAgICAgICAgeyB4OiBib3gueCwgeTogYm94LnkgKyBib3guaGVpZ2h0IH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdmFyIHRyYW5zID0gbm9kZS5nZXRBYnNvbHV0ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgcG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkID0gdHJhbnMucG9pbnQocG9pbnQpO1xuICAgICAgICAgICAgICAgIHRvdGFsUG9pbnRzLnB1c2godHJhbnNmb3JtZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0ciA9IG5ldyBUcmFuc2Zvcm0oKTtcbiAgICAgICAgdHIucm90YXRlKC1Lb252YS5nZXRBbmdsZSh0aGlzLnJvdGF0aW9uKCkpKTtcbiAgICAgICAgdmFyIG1pblgsIG1pblksIG1heFgsIG1heFk7XG4gICAgICAgIHRvdGFsUG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWQgPSB0ci5wb2ludChwb2ludCk7XG4gICAgICAgICAgICBpZiAobWluWCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWluWCA9IG1heFggPSB0cmFuc2Zvcm1lZC54O1xuICAgICAgICAgICAgICAgIG1pblkgPSBtYXhZID0gdHJhbnNmb3JtZWQueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB0cmFuc2Zvcm1lZC54KTtcbiAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB0cmFuc2Zvcm1lZC55KTtcbiAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB0cmFuc2Zvcm1lZC54KTtcbiAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB0cmFuc2Zvcm1lZC55KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyLmludmVydCgpO1xuICAgICAgICBjb25zdCBwID0gdHIucG9pbnQoeyB4OiBtaW5YLCB5OiBtaW5ZIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogcC54LFxuICAgICAgICAgICAgeTogcC55LFxuICAgICAgICAgICAgd2lkdGg6IG1heFggLSBtaW5YLFxuICAgICAgICAgICAgaGVpZ2h0OiBtYXhZIC0gbWluWSxcbiAgICAgICAgICAgIHJvdGF0aW9uOiBLb252YS5nZXRBbmdsZSh0aGlzLnJvdGF0aW9uKCkpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Tm9kZVJlY3QoKS54O1xuICAgIH1cbiAgICBnZXRZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Tm9kZVJlY3QoKS55O1xuICAgIH1cbiAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE5vZGVSZWN0KCkud2lkdGg7XG4gICAgfVxuICAgIGdldEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE5vZGVSZWN0KCkuaGVpZ2h0O1xuICAgIH1cbiAgICBfY3JlYXRlRWxlbWVudHMoKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUJhY2soKTtcbiAgICAgICAgQU5DSE9SU19OQU1FUy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVBbmNob3IobmFtZSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUFuY2hvcigncm90YXRlcicpO1xuICAgIH1cbiAgICBfY3JlYXRlQW5jaG9yKG5hbWUpIHtcbiAgICAgICAgdmFyIGFuY2hvciA9IG5ldyBSZWN0KHtcbiAgICAgICAgICAgIHN0cm9rZTogJ3JnYigwLCAxNjEsIDI1NSknLFxuICAgICAgICAgICAgZmlsbDogJ3doaXRlJyxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICAgICAgbmFtZTogbmFtZSArICcgX2FuY2hvcicsXG4gICAgICAgICAgICBkcmFnRGlzdGFuY2U6IDAsXG4gICAgICAgICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICAgICAgICBoaXRTdHJva2VXaWR0aDogVE9VQ0hfREVWSUNFID8gMTAgOiAnYXV0bycsXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGFuY2hvci5vbignbW91c2Vkb3duIHRvdWNoc3RhcnQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgc2VsZi5faGFuZGxlTW91c2VEb3duKGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgYW5jaG9yLm9uKCdkcmFnc3RhcnQnLCAoZSkgPT4ge1xuICAgICAgICAgICAgYW5jaG9yLnN0b3BEcmFnKCk7XG4gICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBhbmNob3Iub24oJ2RyYWdlbmQnLCAoZSkgPT4ge1xuICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgYW5jaG9yLm9uKCdtb3VzZWVudGVyJywgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIHJhZCA9IEtvbnZhLmdldEFuZ2xlKHRoaXMucm90YXRpb24oKSk7XG4gICAgICAgICAgICB2YXIgY3Vyc29yID0gZ2V0Q3Vyc29yKG5hbWUsIHJhZCk7XG4gICAgICAgICAgICBhbmNob3IuZ2V0U3RhZ2UoKS5jb250ZW50ICYmXG4gICAgICAgICAgICAgICAgKGFuY2hvci5nZXRTdGFnZSgpLmNvbnRlbnQuc3R5bGUuY3Vyc29yID0gY3Vyc29yKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvckNoYW5nZSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBhbmNob3Iub24oJ21vdXNlb3V0JywgKCkgPT4ge1xuICAgICAgICAgICAgYW5jaG9yLmdldFN0YWdlKCkuY29udGVudCAmJlxuICAgICAgICAgICAgICAgIChhbmNob3IuZ2V0U3RhZ2UoKS5jb250ZW50LnN0eWxlLmN1cnNvciA9ICcnKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvckNoYW5nZSA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZGQoYW5jaG9yKTtcbiAgICB9XG4gICAgX2NyZWF0ZUJhY2soKSB7XG4gICAgICAgIHZhciBiYWNrID0gbmV3IFNoYXBlKHtcbiAgICAgICAgICAgIG5hbWU6ICdiYWNrJyxcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgICAgICAgICAgc2NlbmVGdW5jKGN0eCkge1xuICAgICAgICAgICAgICAgIHZhciB0ciA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSB0ci5wYWRkaW5nKCk7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5yZWN0KC1wYWRkaW5nLCAtcGFkZGluZywgdGhpcy53aWR0aCgpICsgcGFkZGluZyAqIDIsIHRoaXMuaGVpZ2h0KCkgKyBwYWRkaW5nICogMik7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLndpZHRoKCkgLyAyLCAtcGFkZGluZyk7XG4gICAgICAgICAgICAgICAgaWYgKHRyLnJvdGF0ZUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHRoaXMud2lkdGgoKSAvIDIsIC10ci5yb3RhdGVBbmNob3JPZmZzZXQoKSAqIFV0aWwuX3NpZ24odGhpcy5oZWlnaHQoKSkgLSBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoaXRGdW5jOiAoY3R4LCBzaGFwZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRPdmVyZHJhd1dob2xlQXJlYSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSB0aGlzLnBhZGRpbmcoKTtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LnJlY3QoLXBhZGRpbmcsIC1wYWRkaW5nLCBzaGFwZS53aWR0aCgpICsgcGFkZGluZyAqIDIsIHNoYXBlLmhlaWdodCgpICsgcGFkZGluZyAqIDIpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3Ryb2tlU2hhcGUoc2hhcGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWRkKGJhY2spO1xuICAgICAgICB0aGlzLl9wcm94eURyYWcoYmFjayk7XG4gICAgICAgIGJhY2sub24oJ2RyYWdzdGFydCcsIChlKSA9PiB7XG4gICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBiYWNrLm9uKCdkcmFnbW92ZScsIChlKSA9PiB7XG4gICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBiYWNrLm9uKCdkcmFnZW5kJywgKGUpID0+IHtcbiAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oJ2RyYWdtb3ZlJywgKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfaGFuZGxlTW91c2VEb3duKGUpIHtcbiAgICAgICAgdGhpcy5fbW92aW5nQW5jaG9yTmFtZSA9IGUudGFyZ2V0Lm5hbWUoKS5zcGxpdCgnICcpWzBdO1xuICAgICAgICB2YXIgYXR0cnMgPSB0aGlzLl9nZXROb2RlUmVjdCgpO1xuICAgICAgICB2YXIgd2lkdGggPSBhdHRycy53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGF0dHJzLmhlaWdodDtcbiAgICAgICAgdmFyIGh5cG90ZW51c2UgPSBNYXRoLnNxcnQoTWF0aC5wb3cod2lkdGgsIDIpICsgTWF0aC5wb3coaGVpZ2h0LCAyKSk7XG4gICAgICAgIHRoaXMuc2luID0gTWF0aC5hYnMoaGVpZ2h0IC8gaHlwb3RlbnVzZSk7XG4gICAgICAgIHRoaXMuY29zID0gTWF0aC5hYnMod2lkdGggLyBoeXBvdGVudXNlKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5faGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9oYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9oYW5kbGVNb3VzZVVwLCB0cnVlKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2hhbmRsZU1vdXNlVXAsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgICAgIHZhciBhcCA9IGUudGFyZ2V0LmdldEFic29sdXRlUG9zaXRpb24oKTtcbiAgICAgICAgdmFyIHBvcyA9IGUudGFyZ2V0LmdldFN0YWdlKCkuZ2V0UG9pbnRlclBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMuX2FuY2hvckRyYWdPZmZzZXQgPSB7XG4gICAgICAgICAgICB4OiBwb3MueCAtIGFwLngsXG4gICAgICAgICAgICB5OiBwb3MueSAtIGFwLnksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2ZpcmUoJ3RyYW5zZm9ybXN0YXJ0JywgeyBldnQ6IGUuZXZ0LCB0YXJnZXQ6IHRoaXMuZ2V0Tm9kZSgpIH0pO1xuICAgICAgICB0aGlzLl9ub2Rlcy5mb3JFYWNoKCh0YXJnZXQpID0+IHtcbiAgICAgICAgICAgIHRhcmdldC5fZmlyZSgndHJhbnNmb3Jtc3RhcnQnLCB7IGV2dDogZS5ldnQsIHRhcmdldCB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9oYW5kbGVNb3VzZU1vdmUoZSkge1xuICAgICAgICB2YXIgeCwgeSwgbmV3SHlwb3RlbnVzZTtcbiAgICAgICAgdmFyIGFuY2hvck5vZGUgPSB0aGlzLmZpbmRPbmUoJy4nICsgdGhpcy5fbW92aW5nQW5jaG9yTmFtZSk7XG4gICAgICAgIHZhciBzdGFnZSA9IGFuY2hvck5vZGUuZ2V0U3RhZ2UoKTtcbiAgICAgICAgc3RhZ2Uuc2V0UG9pbnRlcnNQb3NpdGlvbnMoZSk7XG4gICAgICAgIGNvbnN0IHBwID0gc3RhZ2UuZ2V0UG9pbnRlclBvc2l0aW9uKCk7XG4gICAgICAgIGxldCBuZXdOb2RlUG9zID0ge1xuICAgICAgICAgICAgeDogcHAueCAtIHRoaXMuX2FuY2hvckRyYWdPZmZzZXQueCxcbiAgICAgICAgICAgIHk6IHBwLnkgLSB0aGlzLl9hbmNob3JEcmFnT2Zmc2V0LnksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9sZEFicyA9IGFuY2hvck5vZGUuZ2V0QWJzb2x1dGVQb3NpdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5hbmNob3JEcmFnQm91bmRGdW5jKCkpIHtcbiAgICAgICAgICAgIG5ld05vZGVQb3MgPSB0aGlzLmFuY2hvckRyYWdCb3VuZEZ1bmMoKShvbGRBYnMsIG5ld05vZGVQb3MsIGUpO1xuICAgICAgICB9XG4gICAgICAgIGFuY2hvck5vZGUuc2V0QWJzb2x1dGVQb3NpdGlvbihuZXdOb2RlUG9zKTtcbiAgICAgICAgY29uc3QgbmV3QWJzID0gYW5jaG9yTm9kZS5nZXRBYnNvbHV0ZVBvc2l0aW9uKCk7XG4gICAgICAgIGlmIChvbGRBYnMueCA9PT0gbmV3QWJzLnggJiYgb2xkQWJzLnkgPT09IG5ld0Ficy55KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX21vdmluZ0FuY2hvck5hbWUgPT09ICdyb3RhdGVyJykge1xuICAgICAgICAgICAgdmFyIGF0dHJzID0gdGhpcy5fZ2V0Tm9kZVJlY3QoKTtcbiAgICAgICAgICAgIHggPSBhbmNob3JOb2RlLngoKSAtIGF0dHJzLndpZHRoIC8gMjtcbiAgICAgICAgICAgIHkgPSAtYW5jaG9yTm9kZS55KCkgKyBhdHRycy5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgbGV0IGRlbHRhID0gTWF0aC5hdGFuMigteSwgeCkgKyBNYXRoLlBJIC8gMjtcbiAgICAgICAgICAgIGlmIChhdHRycy5oZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgZGVsdGEgLT0gTWF0aC5QSTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvbGRSb3RhdGlvbiA9IEtvbnZhLmdldEFuZ2xlKHRoaXMucm90YXRpb24oKSk7XG4gICAgICAgICAgICBjb25zdCBuZXdSb3RhdGlvbiA9IG9sZFJvdGF0aW9uICsgZGVsdGE7XG4gICAgICAgICAgICBjb25zdCB0b2wgPSBLb252YS5nZXRBbmdsZSh0aGlzLnJvdGF0aW9uU25hcFRvbGVyYW5jZSgpKTtcbiAgICAgICAgICAgIGNvbnN0IHNuYXBwZWRSb3QgPSBnZXRTbmFwKHRoaXMucm90YXRpb25TbmFwcygpLCBuZXdSb3RhdGlvbiwgdG9sKTtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBzbmFwcGVkUm90IC0gYXR0cnMucm90YXRpb247XG4gICAgICAgICAgICBjb25zdCBzaGFwZSA9IHJvdGF0ZUFyb3VuZENlbnRlcihhdHRycywgZGlmZik7XG4gICAgICAgICAgICB0aGlzLl9maXROb2Rlc0ludG8oc2hhcGUsIGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZWVwUHJvcG9ydGlvbiA9IHRoaXMua2VlcFJhdGlvKCkgfHwgZS5zaGlmdEtleTtcbiAgICAgICAgdmFyIGNlbnRlcmVkU2NhbGluZyA9IHRoaXMuY2VudGVyZWRTY2FsaW5nKCkgfHwgZS5hbHRLZXk7XG4gICAgICAgIGlmICh0aGlzLl9tb3ZpbmdBbmNob3JOYW1lID09PSAndG9wLWxlZnQnKSB7XG4gICAgICAgICAgICBpZiAoa2VlcFByb3BvcnRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcGFyZVBvaW50ID0gY2VudGVyZWRTY2FsaW5nXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogdGhpcy53aWR0aCgpIC8gMixcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHRoaXMuaGVpZ2h0KCkgLyAyLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogdGhpcy5maW5kT25lKCcuYm90dG9tLXJpZ2h0JykueCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogdGhpcy5maW5kT25lKCcuYm90dG9tLXJpZ2h0JykueSgpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG5ld0h5cG90ZW51c2UgPSBNYXRoLnNxcnQoTWF0aC5wb3coY29tcGFyZVBvaW50LnggLSBhbmNob3JOb2RlLngoKSwgMikgK1xuICAgICAgICAgICAgICAgICAgICBNYXRoLnBvdyhjb21wYXJlUG9pbnQueSAtIGFuY2hvck5vZGUueSgpLCAyKSk7XG4gICAgICAgICAgICAgICAgdmFyIHJldmVyc2VYID0gdGhpcy5maW5kT25lKCcudG9wLWxlZnQnKS54KCkgPiBjb21wYXJlUG9pbnQueCA/IC0xIDogMTtcbiAgICAgICAgICAgICAgICB2YXIgcmV2ZXJzZVkgPSB0aGlzLmZpbmRPbmUoJy50b3AtbGVmdCcpLnkoKSA+IGNvbXBhcmVQb2ludC55ID8gLTEgOiAxO1xuICAgICAgICAgICAgICAgIHggPSBuZXdIeXBvdGVudXNlICogdGhpcy5jb3MgKiByZXZlcnNlWDtcbiAgICAgICAgICAgICAgICB5ID0gbmV3SHlwb3RlbnVzZSAqIHRoaXMuc2luICogcmV2ZXJzZVk7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5kT25lKCcudG9wLWxlZnQnKS54KGNvbXBhcmVQb2ludC54IC0geCk7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5kT25lKCcudG9wLWxlZnQnKS55KGNvbXBhcmVQb2ludC55IC0geSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fbW92aW5nQW5jaG9yTmFtZSA9PT0gJ3RvcC1jZW50ZXInKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRPbmUoJy50b3AtbGVmdCcpLnkoYW5jaG9yTm9kZS55KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX21vdmluZ0FuY2hvck5hbWUgPT09ICd0b3AtcmlnaHQnKSB7XG4gICAgICAgICAgICBpZiAoa2VlcFByb3BvcnRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcGFyZVBvaW50ID0gY2VudGVyZWRTY2FsaW5nXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogdGhpcy53aWR0aCgpIC8gMixcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHRoaXMuaGVpZ2h0KCkgLyAyLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogdGhpcy5maW5kT25lKCcuYm90dG9tLWxlZnQnKS54KCksXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB0aGlzLmZpbmRPbmUoJy5ib3R0b20tbGVmdCcpLnkoKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBuZXdIeXBvdGVudXNlID0gTWF0aC5zcXJ0KE1hdGgucG93KGFuY2hvck5vZGUueCgpIC0gY29tcGFyZVBvaW50LngsIDIpICtcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5wb3coY29tcGFyZVBvaW50LnkgLSBhbmNob3JOb2RlLnkoKSwgMikpO1xuICAgICAgICAgICAgICAgIHZhciByZXZlcnNlWCA9IHRoaXMuZmluZE9uZSgnLnRvcC1yaWdodCcpLngoKSA8IGNvbXBhcmVQb2ludC54ID8gLTEgOiAxO1xuICAgICAgICAgICAgICAgIHZhciByZXZlcnNlWSA9IHRoaXMuZmluZE9uZSgnLnRvcC1yaWdodCcpLnkoKSA+IGNvbXBhcmVQb2ludC55ID8gLTEgOiAxO1xuICAgICAgICAgICAgICAgIHggPSBuZXdIeXBvdGVudXNlICogdGhpcy5jb3MgKiByZXZlcnNlWDtcbiAgICAgICAgICAgICAgICB5ID0gbmV3SHlwb3RlbnVzZSAqIHRoaXMuc2luICogcmV2ZXJzZVk7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5kT25lKCcudG9wLXJpZ2h0JykueChjb21wYXJlUG9pbnQueCArIHgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmluZE9uZSgnLnRvcC1yaWdodCcpLnkoY29tcGFyZVBvaW50LnkgLSB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwb3MgPSBhbmNob3JOb2RlLnBvc2l0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLmZpbmRPbmUoJy50b3AtbGVmdCcpLnkocG9zLnkpO1xuICAgICAgICAgICAgdGhpcy5maW5kT25lKCcuYm90dG9tLXJpZ2h0JykueChwb3MueCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fbW92aW5nQW5jaG9yTmFtZSA9PT0gJ21pZGRsZS1sZWZ0Jykge1xuICAgICAgICAgICAgdGhpcy5maW5kT25lKCcudG9wLWxlZnQnKS54KGFuY2hvck5vZGUueCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9tb3ZpbmdBbmNob3JOYW1lID09PSAnbWlkZGxlLXJpZ2h0Jykge1xuICAgICAgICAgICAgdGhpcy5maW5kT25lKCcuYm90dG9tLXJpZ2h0JykueChhbmNob3JOb2RlLngoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fbW92aW5nQW5jaG9yTmFtZSA9PT0gJ2JvdHRvbS1sZWZ0Jykge1xuICAgICAgICAgICAgaWYgKGtlZXBQcm9wb3J0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBhcmVQb2ludCA9IGNlbnRlcmVkU2NhbGluZ1xuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHRoaXMud2lkdGgoKSAvIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB0aGlzLmhlaWdodCgpIC8gMixcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHRoaXMuZmluZE9uZSgnLnRvcC1yaWdodCcpLngoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHRoaXMuZmluZE9uZSgnLnRvcC1yaWdodCcpLnkoKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBuZXdIeXBvdGVudXNlID0gTWF0aC5zcXJ0KE1hdGgucG93KGNvbXBhcmVQb2ludC54IC0gYW5jaG9yTm9kZS54KCksIDIpICtcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5wb3coYW5jaG9yTm9kZS55KCkgLSBjb21wYXJlUG9pbnQueSwgMikpO1xuICAgICAgICAgICAgICAgIHZhciByZXZlcnNlWCA9IGNvbXBhcmVQb2ludC54IDwgYW5jaG9yTm9kZS54KCkgPyAtMSA6IDE7XG4gICAgICAgICAgICAgICAgdmFyIHJldmVyc2VZID0gYW5jaG9yTm9kZS55KCkgPCBjb21wYXJlUG9pbnQueSA/IC0xIDogMTtcbiAgICAgICAgICAgICAgICB4ID0gbmV3SHlwb3RlbnVzZSAqIHRoaXMuY29zICogcmV2ZXJzZVg7XG4gICAgICAgICAgICAgICAgeSA9IG5ld0h5cG90ZW51c2UgKiB0aGlzLnNpbiAqIHJldmVyc2VZO1xuICAgICAgICAgICAgICAgIGFuY2hvck5vZGUueChjb21wYXJlUG9pbnQueCAtIHgpO1xuICAgICAgICAgICAgICAgIGFuY2hvck5vZGUueShjb21wYXJlUG9pbnQueSArIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gYW5jaG9yTm9kZS5wb3NpdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5maW5kT25lKCcudG9wLWxlZnQnKS54KHBvcy54KTtcbiAgICAgICAgICAgIHRoaXMuZmluZE9uZSgnLmJvdHRvbS1yaWdodCcpLnkocG9zLnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX21vdmluZ0FuY2hvck5hbWUgPT09ICdib3R0b20tY2VudGVyJykge1xuICAgICAgICAgICAgdGhpcy5maW5kT25lKCcuYm90dG9tLXJpZ2h0JykueShhbmNob3JOb2RlLnkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fbW92aW5nQW5jaG9yTmFtZSA9PT0gJ2JvdHRvbS1yaWdodCcpIHtcbiAgICAgICAgICAgIGlmIChrZWVwUHJvcG9ydGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBjb21wYXJlUG9pbnQgPSBjZW50ZXJlZFNjYWxpbmdcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB0aGlzLndpZHRoKCkgLyAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogdGhpcy5oZWlnaHQoKSAvIDIsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB0aGlzLmZpbmRPbmUoJy50b3AtbGVmdCcpLngoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHRoaXMuZmluZE9uZSgnLnRvcC1sZWZ0JykueSgpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG5ld0h5cG90ZW51c2UgPSBNYXRoLnNxcnQoTWF0aC5wb3coYW5jaG9yTm9kZS54KCkgLSBjb21wYXJlUG9pbnQueCwgMikgK1xuICAgICAgICAgICAgICAgICAgICBNYXRoLnBvdyhhbmNob3JOb2RlLnkoKSAtIGNvbXBhcmVQb2ludC55LCAyKSk7XG4gICAgICAgICAgICAgICAgdmFyIHJldmVyc2VYID0gdGhpcy5maW5kT25lKCcuYm90dG9tLXJpZ2h0JykueCgpIDwgY29tcGFyZVBvaW50LnggPyAtMSA6IDE7XG4gICAgICAgICAgICAgICAgdmFyIHJldmVyc2VZID0gdGhpcy5maW5kT25lKCcuYm90dG9tLXJpZ2h0JykueSgpIDwgY29tcGFyZVBvaW50LnkgPyAtMSA6IDE7XG4gICAgICAgICAgICAgICAgeCA9IG5ld0h5cG90ZW51c2UgKiB0aGlzLmNvcyAqIHJldmVyc2VYO1xuICAgICAgICAgICAgICAgIHkgPSBuZXdIeXBvdGVudXNlICogdGhpcy5zaW4gKiByZXZlcnNlWTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmRPbmUoJy5ib3R0b20tcmlnaHQnKS54KGNvbXBhcmVQb2ludC54ICsgeCk7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5kT25lKCcuYm90dG9tLXJpZ2h0JykueShjb21wYXJlUG9pbnQueSArIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihuZXcgRXJyb3IoJ1dyb25nIHBvc2l0aW9uIGFyZ3VtZW50IG9mIHNlbGVjdGlvbiByZXNpemVyOiAnICtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3ZpbmdBbmNob3JOYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNlbnRlcmVkU2NhbGluZyA9IHRoaXMuY2VudGVyZWRTY2FsaW5nKCkgfHwgZS5hbHRLZXk7XG4gICAgICAgIGlmIChjZW50ZXJlZFNjYWxpbmcpIHtcbiAgICAgICAgICAgIHZhciB0b3BMZWZ0ID0gdGhpcy5maW5kT25lKCcudG9wLWxlZnQnKTtcbiAgICAgICAgICAgIHZhciBib3R0b21SaWdodCA9IHRoaXMuZmluZE9uZSgnLmJvdHRvbS1yaWdodCcpO1xuICAgICAgICAgICAgdmFyIHRvcE9mZnNldFggPSB0b3BMZWZ0LngoKTtcbiAgICAgICAgICAgIHZhciB0b3BPZmZzZXRZID0gdG9wTGVmdC55KCk7XG4gICAgICAgICAgICB2YXIgYm90dG9tT2Zmc2V0WCA9IHRoaXMuZ2V0V2lkdGgoKSAtIGJvdHRvbVJpZ2h0LngoKTtcbiAgICAgICAgICAgIHZhciBib3R0b21PZmZzZXRZID0gdGhpcy5nZXRIZWlnaHQoKSAtIGJvdHRvbVJpZ2h0LnkoKTtcbiAgICAgICAgICAgIGJvdHRvbVJpZ2h0Lm1vdmUoe1xuICAgICAgICAgICAgICAgIHg6IC10b3BPZmZzZXRYLFxuICAgICAgICAgICAgICAgIHk6IC10b3BPZmZzZXRZLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0b3BMZWZ0Lm1vdmUoe1xuICAgICAgICAgICAgICAgIHg6IGJvdHRvbU9mZnNldFgsXG4gICAgICAgICAgICAgICAgeTogYm90dG9tT2Zmc2V0WSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhYnNQb3MgPSB0aGlzLmZpbmRPbmUoJy50b3AtbGVmdCcpLmdldEFic29sdXRlUG9zaXRpb24oKTtcbiAgICAgICAgeCA9IGFic1Bvcy54O1xuICAgICAgICB5ID0gYWJzUG9zLnk7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZmluZE9uZSgnLmJvdHRvbS1yaWdodCcpLngoKSAtIHRoaXMuZmluZE9uZSgnLnRvcC1sZWZ0JykueCgpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5maW5kT25lKCcuYm90dG9tLXJpZ2h0JykueSgpIC0gdGhpcy5maW5kT25lKCcudG9wLWxlZnQnKS55KCk7XG4gICAgICAgIHRoaXMuX2ZpdE5vZGVzSW50byh7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgcm90YXRpb246IEtvbnZhLmdldEFuZ2xlKHRoaXMucm90YXRpb24oKSksXG4gICAgICAgIH0sIGUpO1xuICAgIH1cbiAgICBfaGFuZGxlTW91c2VVcChlKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50cyhlKTtcbiAgICB9XG4gICAgZ2V0QWJzb2x1dGVUcmFuc2Zvcm0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFRyYW5zZm9ybSgpO1xuICAgIH1cbiAgICBfcmVtb3ZlRXZlbnRzKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zZm9ybWluZykge1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5faGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX2hhbmRsZU1vdXNlVXAsIHRydWUpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2hhbmRsZU1vdXNlVXAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldE5vZGUoKTtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmUoJ3RyYW5zZm9ybWVuZCcsIHsgZXZ0OiBlLCB0YXJnZXQ6IG5vZGUgfSk7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25vZGVzLmZvckVhY2goKHRhcmdldCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuX2ZpcmUoJ3RyYW5zZm9ybWVuZCcsIHsgZXZ0OiBlLCB0YXJnZXQgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tb3ZpbmdBbmNob3JOYW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZml0Tm9kZXNJbnRvKG5ld0F0dHJzLCBldnQpIHtcbiAgICAgICAgdmFyIG9sZEF0dHJzID0gdGhpcy5fZ2V0Tm9kZVJlY3QoKTtcbiAgICAgICAgY29uc3QgbWluU2l6ZSA9IDE7XG4gICAgICAgIGlmIChVdGlsLl9pblJhbmdlKG5ld0F0dHJzLndpZHRoLCAtdGhpcy5wYWRkaW5nKCkgKiAyIC0gbWluU2l6ZSwgbWluU2l6ZSkpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFV0aWwuX2luUmFuZ2UobmV3QXR0cnMuaGVpZ2h0LCAtdGhpcy5wYWRkaW5nKCkgKiAyIC0gbWluU2l6ZSwgbWluU2l6ZSkpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsb3dOZWdhdGl2ZVNjYWxlID0gdGhpcy5mbGlwRW5hYmxlZCgpO1xuICAgICAgICB2YXIgdCA9IG5ldyBUcmFuc2Zvcm0oKTtcbiAgICAgICAgdC5yb3RhdGUoS29udmEuZ2V0QW5nbGUodGhpcy5yb3RhdGlvbigpKSk7XG4gICAgICAgIGlmICh0aGlzLl9tb3ZpbmdBbmNob3JOYW1lICYmXG4gICAgICAgICAgICBuZXdBdHRycy53aWR0aCA8IDAgJiZcbiAgICAgICAgICAgIHRoaXMuX21vdmluZ0FuY2hvck5hbWUuaW5kZXhPZignbGVmdCcpID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHQucG9pbnQoe1xuICAgICAgICAgICAgICAgIHg6IC10aGlzLnBhZGRpbmcoKSAqIDIsXG4gICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV3QXR0cnMueCArPSBvZmZzZXQueDtcbiAgICAgICAgICAgIG5ld0F0dHJzLnkgKz0gb2Zmc2V0Lnk7XG4gICAgICAgICAgICBuZXdBdHRycy53aWR0aCArPSB0aGlzLnBhZGRpbmcoKSAqIDI7XG4gICAgICAgICAgICB0aGlzLl9tb3ZpbmdBbmNob3JOYW1lID0gdGhpcy5fbW92aW5nQW5jaG9yTmFtZS5yZXBsYWNlKCdsZWZ0JywgJ3JpZ2h0Jyk7XG4gICAgICAgICAgICB0aGlzLl9hbmNob3JEcmFnT2Zmc2V0LnggLT0gb2Zmc2V0Lng7XG4gICAgICAgICAgICB0aGlzLl9hbmNob3JEcmFnT2Zmc2V0LnkgLT0gb2Zmc2V0Lnk7XG4gICAgICAgICAgICBpZiAoIWFsbG93TmVnYXRpdmVTY2FsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX21vdmluZ0FuY2hvck5hbWUgJiZcbiAgICAgICAgICAgIG5ld0F0dHJzLndpZHRoIDwgMCAmJlxuICAgICAgICAgICAgdGhpcy5fbW92aW5nQW5jaG9yTmFtZS5pbmRleE9mKCdyaWdodCcpID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHQucG9pbnQoe1xuICAgICAgICAgICAgICAgIHg6IHRoaXMucGFkZGluZygpICogMixcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9tb3ZpbmdBbmNob3JOYW1lID0gdGhpcy5fbW92aW5nQW5jaG9yTmFtZS5yZXBsYWNlKCdyaWdodCcsICdsZWZ0Jyk7XG4gICAgICAgICAgICB0aGlzLl9hbmNob3JEcmFnT2Zmc2V0LnggLT0gb2Zmc2V0Lng7XG4gICAgICAgICAgICB0aGlzLl9hbmNob3JEcmFnT2Zmc2V0LnkgLT0gb2Zmc2V0Lnk7XG4gICAgICAgICAgICBuZXdBdHRycy53aWR0aCArPSB0aGlzLnBhZGRpbmcoKSAqIDI7XG4gICAgICAgICAgICBpZiAoIWFsbG93TmVnYXRpdmVTY2FsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9tb3ZpbmdBbmNob3JOYW1lICYmXG4gICAgICAgICAgICBuZXdBdHRycy5oZWlnaHQgPCAwICYmXG4gICAgICAgICAgICB0aGlzLl9tb3ZpbmdBbmNob3JOYW1lLmluZGV4T2YoJ3RvcCcpID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHQucG9pbnQoe1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogLXRoaXMucGFkZGluZygpICogMixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV3QXR0cnMueCArPSBvZmZzZXQueDtcbiAgICAgICAgICAgIG5ld0F0dHJzLnkgKz0gb2Zmc2V0Lnk7XG4gICAgICAgICAgICB0aGlzLl9tb3ZpbmdBbmNob3JOYW1lID0gdGhpcy5fbW92aW5nQW5jaG9yTmFtZS5yZXBsYWNlKCd0b3AnLCAnYm90dG9tJyk7XG4gICAgICAgICAgICB0aGlzLl9hbmNob3JEcmFnT2Zmc2V0LnggLT0gb2Zmc2V0Lng7XG4gICAgICAgICAgICB0aGlzLl9hbmNob3JEcmFnT2Zmc2V0LnkgLT0gb2Zmc2V0Lnk7XG4gICAgICAgICAgICBuZXdBdHRycy5oZWlnaHQgKz0gdGhpcy5wYWRkaW5nKCkgKiAyO1xuICAgICAgICAgICAgaWYgKCFhbGxvd05lZ2F0aXZlU2NhbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9tb3ZpbmdBbmNob3JOYW1lICYmXG4gICAgICAgICAgICBuZXdBdHRycy5oZWlnaHQgPCAwICYmXG4gICAgICAgICAgICB0aGlzLl9tb3ZpbmdBbmNob3JOYW1lLmluZGV4T2YoJ2JvdHRvbScpID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHQucG9pbnQoe1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogdGhpcy5wYWRkaW5nKCkgKiAyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9tb3ZpbmdBbmNob3JOYW1lID0gdGhpcy5fbW92aW5nQW5jaG9yTmFtZS5yZXBsYWNlKCdib3R0b20nLCAndG9wJyk7XG4gICAgICAgICAgICB0aGlzLl9hbmNob3JEcmFnT2Zmc2V0LnggLT0gb2Zmc2V0Lng7XG4gICAgICAgICAgICB0aGlzLl9hbmNob3JEcmFnT2Zmc2V0LnkgLT0gb2Zmc2V0Lnk7XG4gICAgICAgICAgICBuZXdBdHRycy5oZWlnaHQgKz0gdGhpcy5wYWRkaW5nKCkgKiAyO1xuICAgICAgICAgICAgaWYgKCFhbGxvd05lZ2F0aXZlU2NhbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ib3VuZEJveEZ1bmMoKSkge1xuICAgICAgICAgICAgY29uc3QgYm91bmRlZCA9IHRoaXMuYm91bmRCb3hGdW5jKCkob2xkQXR0cnMsIG5ld0F0dHJzKTtcbiAgICAgICAgICAgIGlmIChib3VuZGVkKSB7XG4gICAgICAgICAgICAgICAgbmV3QXR0cnMgPSBib3VuZGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgVXRpbC53YXJuKCdib3VuZEJveEZ1bmMgcmV0dXJuZWQgZmFsc3kuIFlvdSBzaG91bGQgcmV0dXJuIG5ldyBib3VuZCByZWN0IGZyb20gaXQhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFzZVNpemUgPSAxMDAwMDAwMDtcbiAgICAgICAgY29uc3Qgb2xkVHIgPSBuZXcgVHJhbnNmb3JtKCk7XG4gICAgICAgIG9sZFRyLnRyYW5zbGF0ZShvbGRBdHRycy54LCBvbGRBdHRycy55KTtcbiAgICAgICAgb2xkVHIucm90YXRlKG9sZEF0dHJzLnJvdGF0aW9uKTtcbiAgICAgICAgb2xkVHIuc2NhbGUob2xkQXR0cnMud2lkdGggLyBiYXNlU2l6ZSwgb2xkQXR0cnMuaGVpZ2h0IC8gYmFzZVNpemUpO1xuICAgICAgICBjb25zdCBuZXdUciA9IG5ldyBUcmFuc2Zvcm0oKTtcbiAgICAgICAgbmV3VHIudHJhbnNsYXRlKG5ld0F0dHJzLngsIG5ld0F0dHJzLnkpO1xuICAgICAgICBuZXdUci5yb3RhdGUobmV3QXR0cnMucm90YXRpb24pO1xuICAgICAgICBuZXdUci5zY2FsZShuZXdBdHRycy53aWR0aCAvIGJhc2VTaXplLCBuZXdBdHRycy5oZWlnaHQgLyBiYXNlU2l6ZSk7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gbmV3VHIubXVsdGlwbHkob2xkVHIuaW52ZXJ0KCkpO1xuICAgICAgICB0aGlzLl9ub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRUcmFuc2Zvcm0gPSBub2RlLmdldFBhcmVudCgpLmdldEFic29sdXRlVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFRyYW5zZm9ybSA9IG5vZGUuZ2V0VHJhbnNmb3JtKCkuY29weSgpO1xuICAgICAgICAgICAgbG9jYWxUcmFuc2Zvcm0udHJhbnNsYXRlKG5vZGUub2Zmc2V0WCgpLCBub2RlLm9mZnNldFkoKSk7XG4gICAgICAgICAgICBjb25zdCBuZXdMb2NhbFRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIG5ld0xvY2FsVHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgLm11bHRpcGx5KHBhcmVudFRyYW5zZm9ybS5jb3B5KCkuaW52ZXJ0KCkpXG4gICAgICAgICAgICAgICAgLm11bHRpcGx5KGRlbHRhKVxuICAgICAgICAgICAgICAgIC5tdWx0aXBseShwYXJlbnRUcmFuc2Zvcm0pXG4gICAgICAgICAgICAgICAgLm11bHRpcGx5KGxvY2FsVHJhbnNmb3JtKTtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJzID0gbmV3TG9jYWxUcmFuc2Zvcm0uZGVjb21wb3NlKCk7XG4gICAgICAgICAgICBub2RlLnNldEF0dHJzKGF0dHJzKTtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmUoJ3RyYW5zZm9ybScsIHsgZXZ0OiBldnQsIHRhcmdldDogbm9kZSB9KTtcbiAgICAgICAgICAgIG5vZGUuX2ZpcmUoJ3RyYW5zZm9ybScsIHsgZXZ0OiBldnQsIHRhcmdldDogbm9kZSB9KTtcbiAgICAgICAgICAgIChfYSA9IG5vZGUuZ2V0TGF5ZXIoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJhdGNoRHJhdygpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yb3RhdGlvbihVdGlsLl9nZXRSb3RhdGlvbihuZXdBdHRycy5yb3RhdGlvbikpO1xuICAgICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUNhY2hlKCk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIHRoaXMuZ2V0TGF5ZXIoKS5iYXRjaERyYXcoKTtcbiAgICB9XG4gICAgZm9yY2VVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtQ2FjaGUoKTtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gICAgX2JhdGNoQ2hhbmdlQ2hpbGQoc2VsZWN0b3IsIGF0dHJzKSB7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuZmluZE9uZShzZWxlY3Rvcik7XG4gICAgICAgIGFuY2hvci5zZXRBdHRycyhhdHRycyk7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgYXR0cnMgPSB0aGlzLl9nZXROb2RlUmVjdCgpO1xuICAgICAgICB0aGlzLnJvdGF0aW9uKFV0aWwuX2dldFJvdGF0aW9uKGF0dHJzLnJvdGF0aW9uKSk7XG4gICAgICAgIHZhciB3aWR0aCA9IGF0dHJzLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gYXR0cnMuaGVpZ2h0O1xuICAgICAgICB2YXIgZW5hYmxlZEFuY2hvcnMgPSB0aGlzLmVuYWJsZWRBbmNob3JzKCk7XG4gICAgICAgIHZhciByZXNpemVFbmFibGVkID0gdGhpcy5yZXNpemVFbmFibGVkKCk7XG4gICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy5wYWRkaW5nKCk7XG4gICAgICAgIHZhciBhbmNob3JTaXplID0gdGhpcy5hbmNob3JTaXplKCk7XG4gICAgICAgIHRoaXMuZmluZCgnLl9hbmNob3InKS5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgICBub2RlLnNldEF0dHJzKHtcbiAgICAgICAgICAgICAgICB3aWR0aDogYW5jaG9yU2l6ZSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGFuY2hvclNpemUsXG4gICAgICAgICAgICAgICAgb2Zmc2V0WDogYW5jaG9yU2l6ZSAvIDIsXG4gICAgICAgICAgICAgICAgb2Zmc2V0WTogYW5jaG9yU2l6ZSAvIDIsXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiB0aGlzLmFuY2hvclN0cm9rZSgpLFxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLmFuY2hvclN0cm9rZVdpZHRoKCksXG4gICAgICAgICAgICAgICAgZmlsbDogdGhpcy5hbmNob3JGaWxsKCksXG4gICAgICAgICAgICAgICAgY29ybmVyUmFkaXVzOiB0aGlzLmFuY2hvckNvcm5lclJhZGl1cygpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9iYXRjaENoYW5nZUNoaWxkKCcudG9wLWxlZnQnLCB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIG9mZnNldFg6IGFuY2hvclNpemUgLyAyICsgcGFkZGluZyxcbiAgICAgICAgICAgIG9mZnNldFk6IGFuY2hvclNpemUgLyAyICsgcGFkZGluZyxcbiAgICAgICAgICAgIHZpc2libGU6IHJlc2l6ZUVuYWJsZWQgJiYgZW5hYmxlZEFuY2hvcnMuaW5kZXhPZigndG9wLWxlZnQnKSA+PSAwLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fYmF0Y2hDaGFuZ2VDaGlsZCgnLnRvcC1jZW50ZXInLCB7XG4gICAgICAgICAgICB4OiB3aWR0aCAvIDIsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgb2Zmc2V0WTogYW5jaG9yU2l6ZSAvIDIgKyBwYWRkaW5nLFxuICAgICAgICAgICAgdmlzaWJsZTogcmVzaXplRW5hYmxlZCAmJiBlbmFibGVkQW5jaG9ycy5pbmRleE9mKCd0b3AtY2VudGVyJykgPj0gMCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2JhdGNoQ2hhbmdlQ2hpbGQoJy50b3AtcmlnaHQnLCB7XG4gICAgICAgICAgICB4OiB3aWR0aCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICBvZmZzZXRYOiBhbmNob3JTaXplIC8gMiAtIHBhZGRpbmcsXG4gICAgICAgICAgICBvZmZzZXRZOiBhbmNob3JTaXplIC8gMiArIHBhZGRpbmcsXG4gICAgICAgICAgICB2aXNpYmxlOiByZXNpemVFbmFibGVkICYmIGVuYWJsZWRBbmNob3JzLmluZGV4T2YoJ3RvcC1yaWdodCcpID49IDAsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9iYXRjaENoYW5nZUNoaWxkKCcubWlkZGxlLWxlZnQnLCB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogaGVpZ2h0IC8gMixcbiAgICAgICAgICAgIG9mZnNldFg6IGFuY2hvclNpemUgLyAyICsgcGFkZGluZyxcbiAgICAgICAgICAgIHZpc2libGU6IHJlc2l6ZUVuYWJsZWQgJiYgZW5hYmxlZEFuY2hvcnMuaW5kZXhPZignbWlkZGxlLWxlZnQnKSA+PSAwLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fYmF0Y2hDaGFuZ2VDaGlsZCgnLm1pZGRsZS1yaWdodCcsIHtcbiAgICAgICAgICAgIHg6IHdpZHRoLFxuICAgICAgICAgICAgeTogaGVpZ2h0IC8gMixcbiAgICAgICAgICAgIG9mZnNldFg6IGFuY2hvclNpemUgLyAyIC0gcGFkZGluZyxcbiAgICAgICAgICAgIHZpc2libGU6IHJlc2l6ZUVuYWJsZWQgJiYgZW5hYmxlZEFuY2hvcnMuaW5kZXhPZignbWlkZGxlLXJpZ2h0JykgPj0gMCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2JhdGNoQ2hhbmdlQ2hpbGQoJy5ib3R0b20tbGVmdCcsIHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiBoZWlnaHQsXG4gICAgICAgICAgICBvZmZzZXRYOiBhbmNob3JTaXplIC8gMiArIHBhZGRpbmcsXG4gICAgICAgICAgICBvZmZzZXRZOiBhbmNob3JTaXplIC8gMiAtIHBhZGRpbmcsXG4gICAgICAgICAgICB2aXNpYmxlOiByZXNpemVFbmFibGVkICYmIGVuYWJsZWRBbmNob3JzLmluZGV4T2YoJ2JvdHRvbS1sZWZ0JykgPj0gMCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2JhdGNoQ2hhbmdlQ2hpbGQoJy5ib3R0b20tY2VudGVyJywge1xuICAgICAgICAgICAgeDogd2lkdGggLyAyLFxuICAgICAgICAgICAgeTogaGVpZ2h0LFxuICAgICAgICAgICAgb2Zmc2V0WTogYW5jaG9yU2l6ZSAvIDIgLSBwYWRkaW5nLFxuICAgICAgICAgICAgdmlzaWJsZTogcmVzaXplRW5hYmxlZCAmJiBlbmFibGVkQW5jaG9ycy5pbmRleE9mKCdib3R0b20tY2VudGVyJykgPj0gMCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2JhdGNoQ2hhbmdlQ2hpbGQoJy5ib3R0b20tcmlnaHQnLCB7XG4gICAgICAgICAgICB4OiB3aWR0aCxcbiAgICAgICAgICAgIHk6IGhlaWdodCxcbiAgICAgICAgICAgIG9mZnNldFg6IGFuY2hvclNpemUgLyAyIC0gcGFkZGluZyxcbiAgICAgICAgICAgIG9mZnNldFk6IGFuY2hvclNpemUgLyAyIC0gcGFkZGluZyxcbiAgICAgICAgICAgIHZpc2libGU6IHJlc2l6ZUVuYWJsZWQgJiYgZW5hYmxlZEFuY2hvcnMuaW5kZXhPZignYm90dG9tLXJpZ2h0JykgPj0gMCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2JhdGNoQ2hhbmdlQ2hpbGQoJy5yb3RhdGVyJywge1xuICAgICAgICAgICAgeDogd2lkdGggLyAyLFxuICAgICAgICAgICAgeTogLXRoaXMucm90YXRlQW5jaG9yT2Zmc2V0KCkgKiBVdGlsLl9zaWduKGhlaWdodCkgLSBwYWRkaW5nLFxuICAgICAgICAgICAgdmlzaWJsZTogdGhpcy5yb3RhdGVFbmFibGVkKCksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9iYXRjaENoYW5nZUNoaWxkKCcuYmFjaycsIHtcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgdmlzaWJsZTogdGhpcy5ib3JkZXJFbmFibGVkKCksXG4gICAgICAgICAgICBzdHJva2U6IHRoaXMuYm9yZGVyU3Ryb2tlKCksXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogdGhpcy5ib3JkZXJTdHJva2VXaWR0aCgpLFxuICAgICAgICAgICAgZGFzaDogdGhpcy5ib3JkZXJEYXNoKCksXG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgfSk7XG4gICAgICAgIChfYSA9IHRoaXMuZ2V0TGF5ZXIoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJhdGNoRHJhdygpO1xuICAgIH1cbiAgICBpc1RyYW5zZm9ybWluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybWluZztcbiAgICB9XG4gICAgc3RvcFRyYW5zZm9ybSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zZm9ybWluZykge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRzKCk7XG4gICAgICAgICAgICB2YXIgYW5jaG9yTm9kZSA9IHRoaXMuZmluZE9uZSgnLicgKyB0aGlzLl9tb3ZpbmdBbmNob3JOYW1lKTtcbiAgICAgICAgICAgIGlmIChhbmNob3JOb2RlKSB7XG4gICAgICAgICAgICAgICAgYW5jaG9yTm9kZS5zdG9wRHJhZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmdldFN0YWdlKCkgJiYgdGhpcy5fY3Vyc29yQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLmdldFN0YWdlKCkuY29udGVudCAmJiAodGhpcy5nZXRTdGFnZSgpLmNvbnRlbnQuc3R5bGUuY3Vyc29yID0gJycpO1xuICAgICAgICB9XG4gICAgICAgIEdyb3VwLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50cygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9PYmplY3QoKSB7XG4gICAgICAgIHJldHVybiBOb2RlLnByb3RvdHlwZS50b09iamVjdC5jYWxsKHRoaXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQW5jaG9ycyh2YWwpIHtcbiAgICBpZiAoISh2YWwgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgVXRpbC53YXJuKCdlbmFibGVkQW5jaG9ycyB2YWx1ZSBzaG91bGQgYmUgYW4gYXJyYXknKTtcbiAgICB9XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHZhbC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBpZiAoQU5DSE9SU19OQU1FUy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIFV0aWwud2FybignVW5rbm93biBhbmNob3IgbmFtZTogJyArXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAnLiBBdmFpbGFibGUgbmFtZXMgYXJlOiAnICtcbiAgICAgICAgICAgICAgICAgICAgQU5DSE9SU19OQU1FUy5qb2luKCcsICcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB2YWwgfHwgW107XG59XG5UcmFuc2Zvcm1lci5wcm90b3R5cGUuY2xhc3NOYW1lID0gJ1RyYW5zZm9ybWVyJztcbl9yZWdpc3Rlck5vZGUoVHJhbnNmb3JtZXIpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoVHJhbnNmb3JtZXIsICdlbmFibGVkQW5jaG9ycycsIEFOQ0hPUlNfTkFNRVMsIHZhbGlkYXRlQW5jaG9ycyk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihUcmFuc2Zvcm1lciwgJ2ZsaXBFbmFibGVkJywgdHJ1ZSwgZ2V0Qm9vbGVhblZhbGlkYXRvcigpKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFRyYW5zZm9ybWVyLCAncmVzaXplRW5hYmxlZCcsIHRydWUpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoVHJhbnNmb3JtZXIsICdhbmNob3JTaXplJywgMTAsIGdldE51bWJlclZhbGlkYXRvcigpKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFRyYW5zZm9ybWVyLCAncm90YXRlRW5hYmxlZCcsIHRydWUpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoVHJhbnNmb3JtZXIsICdyb3RhdGlvblNuYXBzJywgW10pO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoVHJhbnNmb3JtZXIsICdyb3RhdGVBbmNob3JPZmZzZXQnLCA1MCwgZ2V0TnVtYmVyVmFsaWRhdG9yKCkpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoVHJhbnNmb3JtZXIsICdyb3RhdGlvblNuYXBUb2xlcmFuY2UnLCA1LCBnZXROdW1iZXJWYWxpZGF0b3IoKSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihUcmFuc2Zvcm1lciwgJ2JvcmRlckVuYWJsZWQnLCB0cnVlKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFRyYW5zZm9ybWVyLCAnYW5jaG9yU3Ryb2tlJywgJ3JnYigwLCAxNjEsIDI1NSknKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFRyYW5zZm9ybWVyLCAnYW5jaG9yU3Ryb2tlV2lkdGgnLCAxLCBnZXROdW1iZXJWYWxpZGF0b3IoKSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihUcmFuc2Zvcm1lciwgJ2FuY2hvckZpbGwnLCAnd2hpdGUnKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFRyYW5zZm9ybWVyLCAnYW5jaG9yQ29ybmVyUmFkaXVzJywgMCwgZ2V0TnVtYmVyVmFsaWRhdG9yKCkpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoVHJhbnNmb3JtZXIsICdib3JkZXJTdHJva2UnLCAncmdiKDAsIDE2MSwgMjU1KScpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoVHJhbnNmb3JtZXIsICdib3JkZXJTdHJva2VXaWR0aCcsIDEsIGdldE51bWJlclZhbGlkYXRvcigpKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFRyYW5zZm9ybWVyLCAnYm9yZGVyRGFzaCcpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoVHJhbnNmb3JtZXIsICdrZWVwUmF0aW8nLCB0cnVlKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFRyYW5zZm9ybWVyLCAnY2VudGVyZWRTY2FsaW5nJywgZmFsc2UpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoVHJhbnNmb3JtZXIsICdpZ25vcmVTdHJva2UnLCBmYWxzZSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihUcmFuc2Zvcm1lciwgJ3BhZGRpbmcnLCAwLCBnZXROdW1iZXJWYWxpZGF0b3IoKSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihUcmFuc2Zvcm1lciwgJ25vZGUnKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFRyYW5zZm9ybWVyLCAnbm9kZXMnKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFRyYW5zZm9ybWVyLCAnYm91bmRCb3hGdW5jJyk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihUcmFuc2Zvcm1lciwgJ2FuY2hvckRyYWdCb3VuZEZ1bmMnKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFRyYW5zZm9ybWVyLCAnc2hvdWxkT3ZlcmRyYXdXaG9sZUFyZWEnLCBmYWxzZSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihUcmFuc2Zvcm1lciwgJ3VzZVNpbmdsZU5vZGVSb3RhdGlvbicsIHRydWUpO1xuRmFjdG9yeS5iYWNrQ29tcGF0KFRyYW5zZm9ybWVyLCB7XG4gICAgbGluZUVuYWJsZWQ6ICdib3JkZXJFbmFibGVkJyxcbiAgICByb3RhdGVIYW5kbGVyT2Zmc2V0OiAncm90YXRlQW5jaG9yT2Zmc2V0JyxcbiAgICBlbmFibGVkSGFuZGxlcnM6ICdlbmFibGVkQW5jaG9ycycsXG59KTtcbiIsImltcG9ydCB7IEZhY3RvcnkgfSBmcm9tICcuLi9GYWN0b3J5LmpzJztcbmltcG9ydCB7IFNoYXBlIH0gZnJvbSAnLi4vU2hhcGUuanMnO1xuaW1wb3J0IHsgS29udmEgfSBmcm9tICcuLi9HbG9iYWwuanMnO1xuaW1wb3J0IHsgZ2V0TnVtYmVyVmFsaWRhdG9yIH0gZnJvbSAnLi4vVmFsaWRhdG9ycy5qcyc7XG5pbXBvcnQgeyBfcmVnaXN0ZXJOb2RlIH0gZnJvbSAnLi4vR2xvYmFsLmpzJztcbmV4cG9ydCBjbGFzcyBXZWRnZSBleHRlbmRzIFNoYXBlIHtcbiAgICBfc2NlbmVGdW5jKGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgdGhpcy5yYWRpdXMoKSwgMCwgS29udmEuZ2V0QW5nbGUodGhpcy5hbmdsZSgpKSwgdGhpcy5jbG9ja3dpc2UoKSk7XG4gICAgICAgIGNvbnRleHQubGluZVRvKDAsIDApO1xuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICB9XG4gICAgZ2V0V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhZGl1cygpICogMjtcbiAgICB9XG4gICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYWRpdXMoKSAqIDI7XG4gICAgfVxuICAgIHNldFdpZHRoKHdpZHRoKSB7XG4gICAgICAgIHRoaXMucmFkaXVzKHdpZHRoIC8gMik7XG4gICAgfVxuICAgIHNldEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5yYWRpdXMoaGVpZ2h0IC8gMik7XG4gICAgfVxufVxuV2VkZ2UucHJvdG90eXBlLmNsYXNzTmFtZSA9ICdXZWRnZSc7XG5XZWRnZS5wcm90b3R5cGUuX2NlbnRyb2lkID0gdHJ1ZTtcbldlZGdlLnByb3RvdHlwZS5fYXR0cnNBZmZlY3RpbmdTaXplID0gWydyYWRpdXMnXTtcbl9yZWdpc3Rlck5vZGUoV2VkZ2UpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoV2VkZ2UsICdyYWRpdXMnLCAwLCBnZXROdW1iZXJWYWxpZGF0b3IoKSk7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihXZWRnZSwgJ2FuZ2xlJywgMCwgZ2V0TnVtYmVyVmFsaWRhdG9yKCkpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoV2VkZ2UsICdjbG9ja3dpc2UnLCBmYWxzZSk7XG5GYWN0b3J5LmJhY2tDb21wYXQoV2VkZ2UsIHtcbiAgICBhbmdsZURlZzogJ2FuZ2xlJyxcbiAgICBnZXRBbmdsZURlZzogJ2dldEFuZ2xlJyxcbiAgICBzZXRBbmdsZURlZzogJ3NldEFuZ2xlJyxcbn0pO1xuIiwiaW1wb3J0IHsgRmFjdG9yeSB9IGZyb20gJy4uL0ZhY3RvcnkuanMnO1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4uL05vZGUuanMnO1xuaW1wb3J0IHsgZ2V0TnVtYmVyVmFsaWRhdG9yIH0gZnJvbSAnLi4vVmFsaWRhdG9ycy5qcyc7XG5mdW5jdGlvbiBCbHVyU3RhY2soKSB7XG4gICAgdGhpcy5yID0gMDtcbiAgICB0aGlzLmcgPSAwO1xuICAgIHRoaXMuYiA9IDA7XG4gICAgdGhpcy5hID0gMDtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xufVxudmFyIG11bF90YWJsZSA9IFtcbiAgICA1MTIsXG4gICAgNTEyLFxuICAgIDQ1NixcbiAgICA1MTIsXG4gICAgMzI4LFxuICAgIDQ1NixcbiAgICAzMzUsXG4gICAgNTEyLFxuICAgIDQwNSxcbiAgICAzMjgsXG4gICAgMjcxLFxuICAgIDQ1NixcbiAgICAzODgsXG4gICAgMzM1LFxuICAgIDI5MixcbiAgICA1MTIsXG4gICAgNDU0LFxuICAgIDQwNSxcbiAgICAzNjQsXG4gICAgMzI4LFxuICAgIDI5OCxcbiAgICAyNzEsXG4gICAgNDk2LFxuICAgIDQ1NixcbiAgICA0MjAsXG4gICAgMzg4LFxuICAgIDM2MCxcbiAgICAzMzUsXG4gICAgMzEyLFxuICAgIDI5MixcbiAgICAyNzMsXG4gICAgNTEyLFxuICAgIDQ4MixcbiAgICA0NTQsXG4gICAgNDI4LFxuICAgIDQwNSxcbiAgICAzODMsXG4gICAgMzY0LFxuICAgIDM0NSxcbiAgICAzMjgsXG4gICAgMzEyLFxuICAgIDI5OCxcbiAgICAyODQsXG4gICAgMjcxLFxuICAgIDI1OSxcbiAgICA0OTYsXG4gICAgNDc1LFxuICAgIDQ1NixcbiAgICA0MzcsXG4gICAgNDIwLFxuICAgIDQwNCxcbiAgICAzODgsXG4gICAgMzc0LFxuICAgIDM2MCxcbiAgICAzNDcsXG4gICAgMzM1LFxuICAgIDMyMyxcbiAgICAzMTIsXG4gICAgMzAyLFxuICAgIDI5MixcbiAgICAyODIsXG4gICAgMjczLFxuICAgIDI2NSxcbiAgICA1MTIsXG4gICAgNDk3LFxuICAgIDQ4MixcbiAgICA0NjgsXG4gICAgNDU0LFxuICAgIDQ0MSxcbiAgICA0MjgsXG4gICAgNDE3LFxuICAgIDQwNSxcbiAgICAzOTQsXG4gICAgMzgzLFxuICAgIDM3MyxcbiAgICAzNjQsXG4gICAgMzU0LFxuICAgIDM0NSxcbiAgICAzMzcsXG4gICAgMzI4LFxuICAgIDMyMCxcbiAgICAzMTIsXG4gICAgMzA1LFxuICAgIDI5OCxcbiAgICAyOTEsXG4gICAgMjg0LFxuICAgIDI3OCxcbiAgICAyNzEsXG4gICAgMjY1LFxuICAgIDI1OSxcbiAgICA1MDcsXG4gICAgNDk2LFxuICAgIDQ4NSxcbiAgICA0NzUsXG4gICAgNDY1LFxuICAgIDQ1NixcbiAgICA0NDYsXG4gICAgNDM3LFxuICAgIDQyOCxcbiAgICA0MjAsXG4gICAgNDEyLFxuICAgIDQwNCxcbiAgICAzOTYsXG4gICAgMzg4LFxuICAgIDM4MSxcbiAgICAzNzQsXG4gICAgMzY3LFxuICAgIDM2MCxcbiAgICAzNTQsXG4gICAgMzQ3LFxuICAgIDM0MSxcbiAgICAzMzUsXG4gICAgMzI5LFxuICAgIDMyMyxcbiAgICAzMTgsXG4gICAgMzEyLFxuICAgIDMwNyxcbiAgICAzMDIsXG4gICAgMjk3LFxuICAgIDI5MixcbiAgICAyODcsXG4gICAgMjgyLFxuICAgIDI3OCxcbiAgICAyNzMsXG4gICAgMjY5LFxuICAgIDI2NSxcbiAgICAyNjEsXG4gICAgNTEyLFxuICAgIDUwNSxcbiAgICA0OTcsXG4gICAgNDg5LFxuICAgIDQ4MixcbiAgICA0NzUsXG4gICAgNDY4LFxuICAgIDQ2MSxcbiAgICA0NTQsXG4gICAgNDQ3LFxuICAgIDQ0MSxcbiAgICA0MzUsXG4gICAgNDI4LFxuICAgIDQyMixcbiAgICA0MTcsXG4gICAgNDExLFxuICAgIDQwNSxcbiAgICAzOTksXG4gICAgMzk0LFxuICAgIDM4OSxcbiAgICAzODMsXG4gICAgMzc4LFxuICAgIDM3MyxcbiAgICAzNjgsXG4gICAgMzY0LFxuICAgIDM1OSxcbiAgICAzNTQsXG4gICAgMzUwLFxuICAgIDM0NSxcbiAgICAzNDEsXG4gICAgMzM3LFxuICAgIDMzMixcbiAgICAzMjgsXG4gICAgMzI0LFxuICAgIDMyMCxcbiAgICAzMTYsXG4gICAgMzEyLFxuICAgIDMwOSxcbiAgICAzMDUsXG4gICAgMzAxLFxuICAgIDI5OCxcbiAgICAyOTQsXG4gICAgMjkxLFxuICAgIDI4NyxcbiAgICAyODQsXG4gICAgMjgxLFxuICAgIDI3OCxcbiAgICAyNzQsXG4gICAgMjcxLFxuICAgIDI2OCxcbiAgICAyNjUsXG4gICAgMjYyLFxuICAgIDI1OSxcbiAgICAyNTcsXG4gICAgNTA3LFxuICAgIDUwMSxcbiAgICA0OTYsXG4gICAgNDkxLFxuICAgIDQ4NSxcbiAgICA0ODAsXG4gICAgNDc1LFxuICAgIDQ3MCxcbiAgICA0NjUsXG4gICAgNDYwLFxuICAgIDQ1NixcbiAgICA0NTEsXG4gICAgNDQ2LFxuICAgIDQ0MixcbiAgICA0MzcsXG4gICAgNDMzLFxuICAgIDQyOCxcbiAgICA0MjQsXG4gICAgNDIwLFxuICAgIDQxNixcbiAgICA0MTIsXG4gICAgNDA4LFxuICAgIDQwNCxcbiAgICA0MDAsXG4gICAgMzk2LFxuICAgIDM5MixcbiAgICAzODgsXG4gICAgMzg1LFxuICAgIDM4MSxcbiAgICAzNzcsXG4gICAgMzc0LFxuICAgIDM3MCxcbiAgICAzNjcsXG4gICAgMzYzLFxuICAgIDM2MCxcbiAgICAzNTcsXG4gICAgMzU0LFxuICAgIDM1MCxcbiAgICAzNDcsXG4gICAgMzQ0LFxuICAgIDM0MSxcbiAgICAzMzgsXG4gICAgMzM1LFxuICAgIDMzMixcbiAgICAzMjksXG4gICAgMzI2LFxuICAgIDMyMyxcbiAgICAzMjAsXG4gICAgMzE4LFxuICAgIDMxNSxcbiAgICAzMTIsXG4gICAgMzEwLFxuICAgIDMwNyxcbiAgICAzMDQsXG4gICAgMzAyLFxuICAgIDI5OSxcbiAgICAyOTcsXG4gICAgMjk0LFxuICAgIDI5MixcbiAgICAyODksXG4gICAgMjg3LFxuICAgIDI4NSxcbiAgICAyODIsXG4gICAgMjgwLFxuICAgIDI3OCxcbiAgICAyNzUsXG4gICAgMjczLFxuICAgIDI3MSxcbiAgICAyNjksXG4gICAgMjY3LFxuICAgIDI2NSxcbiAgICAyNjMsXG4gICAgMjYxLFxuICAgIDI1OSxcbl07XG52YXIgc2hnX3RhYmxlID0gW1xuICAgIDksXG4gICAgMTEsXG4gICAgMTIsXG4gICAgMTMsXG4gICAgMTMsXG4gICAgMTQsXG4gICAgMTQsXG4gICAgMTUsXG4gICAgMTUsXG4gICAgMTUsXG4gICAgMTUsXG4gICAgMTYsXG4gICAgMTYsXG4gICAgMTYsXG4gICAgMTYsXG4gICAgMTcsXG4gICAgMTcsXG4gICAgMTcsXG4gICAgMTcsXG4gICAgMTcsXG4gICAgMTcsXG4gICAgMTcsXG4gICAgMTgsXG4gICAgMTgsXG4gICAgMTgsXG4gICAgMTgsXG4gICAgMTgsXG4gICAgMTgsXG4gICAgMTgsXG4gICAgMTgsXG4gICAgMTgsXG4gICAgMTksXG4gICAgMTksXG4gICAgMTksXG4gICAgMTksXG4gICAgMTksXG4gICAgMTksXG4gICAgMTksXG4gICAgMTksXG4gICAgMTksXG4gICAgMTksXG4gICAgMTksXG4gICAgMTksXG4gICAgMTksXG4gICAgMTksXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG5dO1xuZnVuY3Rpb24gZmlsdGVyR2F1c3NCbHVyUkdCQShpbWFnZURhdGEsIHJhZGl1cykge1xuICAgIHZhciBwaXhlbHMgPSBpbWFnZURhdGEuZGF0YSwgd2lkdGggPSBpbWFnZURhdGEud2lkdGgsIGhlaWdodCA9IGltYWdlRGF0YS5oZWlnaHQ7XG4gICAgdmFyIHgsIHksIGksIHAsIHlwLCB5aSwgeXcsIHJfc3VtLCBnX3N1bSwgYl9zdW0sIGFfc3VtLCByX291dF9zdW0sIGdfb3V0X3N1bSwgYl9vdXRfc3VtLCBhX291dF9zdW0sIHJfaW5fc3VtLCBnX2luX3N1bSwgYl9pbl9zdW0sIGFfaW5fc3VtLCBwciwgcGcsIHBiLCBwYSwgcmJzO1xuICAgIHZhciBkaXYgPSByYWRpdXMgKyByYWRpdXMgKyAxLCB3aWR0aE1pbnVzMSA9IHdpZHRoIC0gMSwgaGVpZ2h0TWludXMxID0gaGVpZ2h0IC0gMSwgcmFkaXVzUGx1czEgPSByYWRpdXMgKyAxLCBzdW1GYWN0b3IgPSAocmFkaXVzUGx1czEgKiAocmFkaXVzUGx1czEgKyAxKSkgLyAyLCBzdGFja1N0YXJ0ID0gbmV3IEJsdXJTdGFjaygpLCBzdGFja0VuZCA9IG51bGwsIHN0YWNrID0gc3RhY2tTdGFydCwgc3RhY2tJbiA9IG51bGwsIHN0YWNrT3V0ID0gbnVsbCwgbXVsX3N1bSA9IG11bF90YWJsZVtyYWRpdXNdLCBzaGdfc3VtID0gc2hnX3RhYmxlW3JhZGl1c107XG4gICAgZm9yIChpID0gMTsgaSA8IGRpdjsgaSsrKSB7XG4gICAgICAgIHN0YWNrID0gc3RhY2submV4dCA9IG5ldyBCbHVyU3RhY2soKTtcbiAgICAgICAgaWYgKGkgPT09IHJhZGl1c1BsdXMxKSB7XG4gICAgICAgICAgICBzdGFja0VuZCA9IHN0YWNrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YWNrLm5leHQgPSBzdGFja1N0YXJ0O1xuICAgIHl3ID0geWkgPSAwO1xuICAgIGZvciAoeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICByX2luX3N1bSA9IGdfaW5fc3VtID0gYl9pbl9zdW0gPSBhX2luX3N1bSA9IHJfc3VtID0gZ19zdW0gPSBiX3N1bSA9IGFfc3VtID0gMDtcbiAgICAgICAgcl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAocHIgPSBwaXhlbHNbeWldKTtcbiAgICAgICAgZ19vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAocGcgPSBwaXhlbHNbeWkgKyAxXSk7XG4gICAgICAgIGJfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKHBiID0gcGl4ZWxzW3lpICsgMl0pO1xuICAgICAgICBhX291dF9zdW0gPSByYWRpdXNQbHVzMSAqIChwYSA9IHBpeGVsc1t5aSArIDNdKTtcbiAgICAgICAgcl9zdW0gKz0gc3VtRmFjdG9yICogcHI7XG4gICAgICAgIGdfc3VtICs9IHN1bUZhY3RvciAqIHBnO1xuICAgICAgICBiX3N1bSArPSBzdW1GYWN0b3IgKiBwYjtcbiAgICAgICAgYV9zdW0gKz0gc3VtRmFjdG9yICogcGE7XG4gICAgICAgIHN0YWNrID0gc3RhY2tTdGFydDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJhZGl1c1BsdXMxOyBpKyspIHtcbiAgICAgICAgICAgIHN0YWNrLnIgPSBwcjtcbiAgICAgICAgICAgIHN0YWNrLmcgPSBwZztcbiAgICAgICAgICAgIHN0YWNrLmIgPSBwYjtcbiAgICAgICAgICAgIHN0YWNrLmEgPSBwYTtcbiAgICAgICAgICAgIHN0YWNrID0gc3RhY2submV4dDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgcmFkaXVzUGx1czE7IGkrKykge1xuICAgICAgICAgICAgcCA9IHlpICsgKCh3aWR0aE1pbnVzMSA8IGkgPyB3aWR0aE1pbnVzMSA6IGkpIDw8IDIpO1xuICAgICAgICAgICAgcl9zdW0gKz0gKHN0YWNrLnIgPSBwciA9IHBpeGVsc1twXSkgKiAocmJzID0gcmFkaXVzUGx1czEgLSBpKTtcbiAgICAgICAgICAgIGdfc3VtICs9IChzdGFjay5nID0gcGcgPSBwaXhlbHNbcCArIDFdKSAqIHJicztcbiAgICAgICAgICAgIGJfc3VtICs9IChzdGFjay5iID0gcGIgPSBwaXhlbHNbcCArIDJdKSAqIHJicztcbiAgICAgICAgICAgIGFfc3VtICs9IChzdGFjay5hID0gcGEgPSBwaXhlbHNbcCArIDNdKSAqIHJicztcbiAgICAgICAgICAgIHJfaW5fc3VtICs9IHByO1xuICAgICAgICAgICAgZ19pbl9zdW0gKz0gcGc7XG4gICAgICAgICAgICBiX2luX3N1bSArPSBwYjtcbiAgICAgICAgICAgIGFfaW5fc3VtICs9IHBhO1xuICAgICAgICAgICAgc3RhY2sgPSBzdGFjay5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrSW4gPSBzdGFja1N0YXJ0O1xuICAgICAgICBzdGFja091dCA9IHN0YWNrRW5kO1xuICAgICAgICBmb3IgKHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgcGl4ZWxzW3lpICsgM10gPSBwYSA9IChhX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW07XG4gICAgICAgICAgICBpZiAocGEgIT09IDApIHtcbiAgICAgICAgICAgICAgICBwYSA9IDI1NSAvIHBhO1xuICAgICAgICAgICAgICAgIHBpeGVsc1t5aV0gPSAoKHJfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSkgKiBwYTtcbiAgICAgICAgICAgICAgICBwaXhlbHNbeWkgKyAxXSA9ICgoZ19zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtKSAqIHBhO1xuICAgICAgICAgICAgICAgIHBpeGVsc1t5aSArIDJdID0gKChiX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0pICogcGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwaXhlbHNbeWldID0gcGl4ZWxzW3lpICsgMV0gPSBwaXhlbHNbeWkgKyAyXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByX3N1bSAtPSByX291dF9zdW07XG4gICAgICAgICAgICBnX3N1bSAtPSBnX291dF9zdW07XG4gICAgICAgICAgICBiX3N1bSAtPSBiX291dF9zdW07XG4gICAgICAgICAgICBhX3N1bSAtPSBhX291dF9zdW07XG4gICAgICAgICAgICByX291dF9zdW0gLT0gc3RhY2tJbi5yO1xuICAgICAgICAgICAgZ19vdXRfc3VtIC09IHN0YWNrSW4uZztcbiAgICAgICAgICAgIGJfb3V0X3N1bSAtPSBzdGFja0luLmI7XG4gICAgICAgICAgICBhX291dF9zdW0gLT0gc3RhY2tJbi5hO1xuICAgICAgICAgICAgcCA9ICh5dyArICgocCA9IHggKyByYWRpdXMgKyAxKSA8IHdpZHRoTWludXMxID8gcCA6IHdpZHRoTWludXMxKSkgPDwgMjtcbiAgICAgICAgICAgIHJfaW5fc3VtICs9IHN0YWNrSW4uciA9IHBpeGVsc1twXTtcbiAgICAgICAgICAgIGdfaW5fc3VtICs9IHN0YWNrSW4uZyA9IHBpeGVsc1twICsgMV07XG4gICAgICAgICAgICBiX2luX3N1bSArPSBzdGFja0luLmIgPSBwaXhlbHNbcCArIDJdO1xuICAgICAgICAgICAgYV9pbl9zdW0gKz0gc3RhY2tJbi5hID0gcGl4ZWxzW3AgKyAzXTtcbiAgICAgICAgICAgIHJfc3VtICs9IHJfaW5fc3VtO1xuICAgICAgICAgICAgZ19zdW0gKz0gZ19pbl9zdW07XG4gICAgICAgICAgICBiX3N1bSArPSBiX2luX3N1bTtcbiAgICAgICAgICAgIGFfc3VtICs9IGFfaW5fc3VtO1xuICAgICAgICAgICAgc3RhY2tJbiA9IHN0YWNrSW4ubmV4dDtcbiAgICAgICAgICAgIHJfb3V0X3N1bSArPSBwciA9IHN0YWNrT3V0LnI7XG4gICAgICAgICAgICBnX291dF9zdW0gKz0gcGcgPSBzdGFja091dC5nO1xuICAgICAgICAgICAgYl9vdXRfc3VtICs9IHBiID0gc3RhY2tPdXQuYjtcbiAgICAgICAgICAgIGFfb3V0X3N1bSArPSBwYSA9IHN0YWNrT3V0LmE7XG4gICAgICAgICAgICByX2luX3N1bSAtPSBwcjtcbiAgICAgICAgICAgIGdfaW5fc3VtIC09IHBnO1xuICAgICAgICAgICAgYl9pbl9zdW0gLT0gcGI7XG4gICAgICAgICAgICBhX2luX3N1bSAtPSBwYTtcbiAgICAgICAgICAgIHN0YWNrT3V0ID0gc3RhY2tPdXQubmV4dDtcbiAgICAgICAgICAgIHlpICs9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgeXcgKz0gd2lkdGg7XG4gICAgfVxuICAgIGZvciAoeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgIGdfaW5fc3VtID0gYl9pbl9zdW0gPSBhX2luX3N1bSA9IHJfaW5fc3VtID0gZ19zdW0gPSBiX3N1bSA9IGFfc3VtID0gcl9zdW0gPSAwO1xuICAgICAgICB5aSA9IHggPDwgMjtcbiAgICAgICAgcl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAocHIgPSBwaXhlbHNbeWldKTtcbiAgICAgICAgZ19vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAocGcgPSBwaXhlbHNbeWkgKyAxXSk7XG4gICAgICAgIGJfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKHBiID0gcGl4ZWxzW3lpICsgMl0pO1xuICAgICAgICBhX291dF9zdW0gPSByYWRpdXNQbHVzMSAqIChwYSA9IHBpeGVsc1t5aSArIDNdKTtcbiAgICAgICAgcl9zdW0gKz0gc3VtRmFjdG9yICogcHI7XG4gICAgICAgIGdfc3VtICs9IHN1bUZhY3RvciAqIHBnO1xuICAgICAgICBiX3N1bSArPSBzdW1GYWN0b3IgKiBwYjtcbiAgICAgICAgYV9zdW0gKz0gc3VtRmFjdG9yICogcGE7XG4gICAgICAgIHN0YWNrID0gc3RhY2tTdGFydDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJhZGl1c1BsdXMxOyBpKyspIHtcbiAgICAgICAgICAgIHN0YWNrLnIgPSBwcjtcbiAgICAgICAgICAgIHN0YWNrLmcgPSBwZztcbiAgICAgICAgICAgIHN0YWNrLmIgPSBwYjtcbiAgICAgICAgICAgIHN0YWNrLmEgPSBwYTtcbiAgICAgICAgICAgIHN0YWNrID0gc3RhY2submV4dDtcbiAgICAgICAgfVxuICAgICAgICB5cCA9IHdpZHRoO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IHJhZGl1czsgaSsrKSB7XG4gICAgICAgICAgICB5aSA9ICh5cCArIHgpIDw8IDI7XG4gICAgICAgICAgICByX3N1bSArPSAoc3RhY2suciA9IHByID0gcGl4ZWxzW3lpXSkgKiAocmJzID0gcmFkaXVzUGx1czEgLSBpKTtcbiAgICAgICAgICAgIGdfc3VtICs9IChzdGFjay5nID0gcGcgPSBwaXhlbHNbeWkgKyAxXSkgKiByYnM7XG4gICAgICAgICAgICBiX3N1bSArPSAoc3RhY2suYiA9IHBiID0gcGl4ZWxzW3lpICsgMl0pICogcmJzO1xuICAgICAgICAgICAgYV9zdW0gKz0gKHN0YWNrLmEgPSBwYSA9IHBpeGVsc1t5aSArIDNdKSAqIHJicztcbiAgICAgICAgICAgIHJfaW5fc3VtICs9IHByO1xuICAgICAgICAgICAgZ19pbl9zdW0gKz0gcGc7XG4gICAgICAgICAgICBiX2luX3N1bSArPSBwYjtcbiAgICAgICAgICAgIGFfaW5fc3VtICs9IHBhO1xuICAgICAgICAgICAgc3RhY2sgPSBzdGFjay5uZXh0O1xuICAgICAgICAgICAgaWYgKGkgPCBoZWlnaHRNaW51czEpIHtcbiAgICAgICAgICAgICAgICB5cCArPSB3aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB5aSA9IHg7XG4gICAgICAgIHN0YWNrSW4gPSBzdGFja1N0YXJ0O1xuICAgICAgICBzdGFja091dCA9IHN0YWNrRW5kO1xuICAgICAgICBmb3IgKHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIHAgPSB5aSA8PCAyO1xuICAgICAgICAgICAgcGl4ZWxzW3AgKyAzXSA9IHBhID0gKGFfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bTtcbiAgICAgICAgICAgIGlmIChwYSA+IDApIHtcbiAgICAgICAgICAgICAgICBwYSA9IDI1NSAvIHBhO1xuICAgICAgICAgICAgICAgIHBpeGVsc1twXSA9ICgocl9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtKSAqIHBhO1xuICAgICAgICAgICAgICAgIHBpeGVsc1twICsgMV0gPSAoKGdfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSkgKiBwYTtcbiAgICAgICAgICAgICAgICBwaXhlbHNbcCArIDJdID0gKChiX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0pICogcGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwaXhlbHNbcF0gPSBwaXhlbHNbcCArIDFdID0gcGl4ZWxzW3AgKyAyXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByX3N1bSAtPSByX291dF9zdW07XG4gICAgICAgICAgICBnX3N1bSAtPSBnX291dF9zdW07XG4gICAgICAgICAgICBiX3N1bSAtPSBiX291dF9zdW07XG4gICAgICAgICAgICBhX3N1bSAtPSBhX291dF9zdW07XG4gICAgICAgICAgICByX291dF9zdW0gLT0gc3RhY2tJbi5yO1xuICAgICAgICAgICAgZ19vdXRfc3VtIC09IHN0YWNrSW4uZztcbiAgICAgICAgICAgIGJfb3V0X3N1bSAtPSBzdGFja0luLmI7XG4gICAgICAgICAgICBhX291dF9zdW0gLT0gc3RhY2tJbi5hO1xuICAgICAgICAgICAgcCA9XG4gICAgICAgICAgICAgICAgKHggK1xuICAgICAgICAgICAgICAgICAgICAoKHAgPSB5ICsgcmFkaXVzUGx1czEpIDwgaGVpZ2h0TWludXMxID8gcCA6IGhlaWdodE1pbnVzMSkgKiB3aWR0aCkgPDxcbiAgICAgICAgICAgICAgICAgICAgMjtcbiAgICAgICAgICAgIHJfc3VtICs9IHJfaW5fc3VtICs9IHN0YWNrSW4uciA9IHBpeGVsc1twXTtcbiAgICAgICAgICAgIGdfc3VtICs9IGdfaW5fc3VtICs9IHN0YWNrSW4uZyA9IHBpeGVsc1twICsgMV07XG4gICAgICAgICAgICBiX3N1bSArPSBiX2luX3N1bSArPSBzdGFja0luLmIgPSBwaXhlbHNbcCArIDJdO1xuICAgICAgICAgICAgYV9zdW0gKz0gYV9pbl9zdW0gKz0gc3RhY2tJbi5hID0gcGl4ZWxzW3AgKyAzXTtcbiAgICAgICAgICAgIHN0YWNrSW4gPSBzdGFja0luLm5leHQ7XG4gICAgICAgICAgICByX291dF9zdW0gKz0gcHIgPSBzdGFja091dC5yO1xuICAgICAgICAgICAgZ19vdXRfc3VtICs9IHBnID0gc3RhY2tPdXQuZztcbiAgICAgICAgICAgIGJfb3V0X3N1bSArPSBwYiA9IHN0YWNrT3V0LmI7XG4gICAgICAgICAgICBhX291dF9zdW0gKz0gcGEgPSBzdGFja091dC5hO1xuICAgICAgICAgICAgcl9pbl9zdW0gLT0gcHI7XG4gICAgICAgICAgICBnX2luX3N1bSAtPSBwZztcbiAgICAgICAgICAgIGJfaW5fc3VtIC09IHBiO1xuICAgICAgICAgICAgYV9pbl9zdW0gLT0gcGE7XG4gICAgICAgICAgICBzdGFja091dCA9IHN0YWNrT3V0Lm5leHQ7XG4gICAgICAgICAgICB5aSArPSB3aWR0aDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBCbHVyID0gZnVuY3Rpb24gQmx1cihpbWFnZURhdGEpIHtcbiAgICB2YXIgcmFkaXVzID0gTWF0aC5yb3VuZCh0aGlzLmJsdXJSYWRpdXMoKSk7XG4gICAgaWYgKHJhZGl1cyA+IDApIHtcbiAgICAgICAgZmlsdGVyR2F1c3NCbHVyUkdCQShpbWFnZURhdGEsIHJhZGl1cyk7XG4gICAgfVxufTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKE5vZGUsICdibHVyUmFkaXVzJywgMCwgZ2V0TnVtYmVyVmFsaWRhdG9yKCksIEZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuIiwiaW1wb3J0IHsgRmFjdG9yeSB9IGZyb20gJy4uL0ZhY3RvcnkuanMnO1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4uL05vZGUuanMnO1xuaW1wb3J0IHsgZ2V0TnVtYmVyVmFsaWRhdG9yIH0gZnJvbSAnLi4vVmFsaWRhdG9ycy5qcyc7XG5leHBvcnQgY29uc3QgQnJpZ2h0ZW4gPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XG4gICAgdmFyIGJyaWdodG5lc3MgPSB0aGlzLmJyaWdodG5lc3MoKSAqIDI1NSwgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBsZW4gPSBkYXRhLmxlbmd0aCwgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgZGF0YVtpXSArPSBicmlnaHRuZXNzO1xuICAgICAgICBkYXRhW2kgKyAxXSArPSBicmlnaHRuZXNzO1xuICAgICAgICBkYXRhW2kgKyAyXSArPSBicmlnaHRuZXNzO1xuICAgIH1cbn07XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihOb2RlLCAnYnJpZ2h0bmVzcycsIDAsIGdldE51bWJlclZhbGlkYXRvcigpLCBGYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcbiIsImltcG9ydCB7IEZhY3RvcnkgfSBmcm9tICcuLi9GYWN0b3J5LmpzJztcbmltcG9ydCB7IE5vZGUgfSBmcm9tICcuLi9Ob2RlLmpzJztcbmltcG9ydCB7IGdldE51bWJlclZhbGlkYXRvciB9IGZyb20gJy4uL1ZhbGlkYXRvcnMuanMnO1xuZXhwb3J0IGNvbnN0IENvbnRyYXN0ID0gZnVuY3Rpb24gKGltYWdlRGF0YSkge1xuICAgIHZhciBhZGp1c3QgPSBNYXRoLnBvdygodGhpcy5jb250cmFzdCgpICsgMTAwKSAvIDEwMCwgMik7XG4gICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgblBpeGVscyA9IGRhdGEubGVuZ3RoLCByZWQgPSAxNTAsIGdyZWVuID0gMTUwLCBibHVlID0gMTUwLCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuUGl4ZWxzOyBpICs9IDQpIHtcbiAgICAgICAgcmVkID0gZGF0YVtpXTtcbiAgICAgICAgZ3JlZW4gPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgYmx1ZSA9IGRhdGFbaSArIDJdO1xuICAgICAgICByZWQgLz0gMjU1O1xuICAgICAgICByZWQgLT0gMC41O1xuICAgICAgICByZWQgKj0gYWRqdXN0O1xuICAgICAgICByZWQgKz0gMC41O1xuICAgICAgICByZWQgKj0gMjU1O1xuICAgICAgICBncmVlbiAvPSAyNTU7XG4gICAgICAgIGdyZWVuIC09IDAuNTtcbiAgICAgICAgZ3JlZW4gKj0gYWRqdXN0O1xuICAgICAgICBncmVlbiArPSAwLjU7XG4gICAgICAgIGdyZWVuICo9IDI1NTtcbiAgICAgICAgYmx1ZSAvPSAyNTU7XG4gICAgICAgIGJsdWUgLT0gMC41O1xuICAgICAgICBibHVlICo9IGFkanVzdDtcbiAgICAgICAgYmx1ZSArPSAwLjU7XG4gICAgICAgIGJsdWUgKj0gMjU1O1xuICAgICAgICByZWQgPSByZWQgPCAwID8gMCA6IHJlZCA+IDI1NSA/IDI1NSA6IHJlZDtcbiAgICAgICAgZ3JlZW4gPSBncmVlbiA8IDAgPyAwIDogZ3JlZW4gPiAyNTUgPyAyNTUgOiBncmVlbjtcbiAgICAgICAgYmx1ZSA9IGJsdWUgPCAwID8gMCA6IGJsdWUgPiAyNTUgPyAyNTUgOiBibHVlO1xuICAgICAgICBkYXRhW2ldID0gcmVkO1xuICAgICAgICBkYXRhW2kgKyAxXSA9IGdyZWVuO1xuICAgICAgICBkYXRhW2kgKyAyXSA9IGJsdWU7XG4gICAgfVxufTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKE5vZGUsICdjb250cmFzdCcsIDAsIGdldE51bWJlclZhbGlkYXRvcigpLCBGYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcbiIsImltcG9ydCB7IEZhY3RvcnkgfSBmcm9tICcuLi9GYWN0b3J5LmpzJztcbmltcG9ydCB7IE5vZGUgfSBmcm9tICcuLi9Ob2RlLmpzJztcbmltcG9ydCB7IFV0aWwgfSBmcm9tICcuLi9VdGlsLmpzJztcbmltcG9ydCB7IGdldE51bWJlclZhbGlkYXRvciB9IGZyb20gJy4uL1ZhbGlkYXRvcnMuanMnO1xuZXhwb3J0IGNvbnN0IEVtYm9zcyA9IGZ1bmN0aW9uIChpbWFnZURhdGEpIHtcbiAgICB2YXIgc3RyZW5ndGggPSB0aGlzLmVtYm9zc1N0cmVuZ3RoKCkgKiAxMCwgZ3JleUxldmVsID0gdGhpcy5lbWJvc3NXaGl0ZUxldmVsKCkgKiAyNTUsIGRpcmVjdGlvbiA9IHRoaXMuZW1ib3NzRGlyZWN0aW9uKCksIGJsZW5kID0gdGhpcy5lbWJvc3NCbGVuZCgpLCBkaXJZID0gMCwgZGlyWCA9IDAsIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgdyA9IGltYWdlRGF0YS53aWR0aCwgaCA9IGltYWdlRGF0YS5oZWlnaHQsIHc0ID0gdyAqIDQsIHkgPSBoO1xuICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgIGNhc2UgJ3RvcC1sZWZ0JzpcbiAgICAgICAgICAgIGRpclkgPSAtMTtcbiAgICAgICAgICAgIGRpclggPSAtMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgZGlyWSA9IC0xO1xuICAgICAgICAgICAgZGlyWCA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndG9wLXJpZ2h0JzpcbiAgICAgICAgICAgIGRpclkgPSAtMTtcbiAgICAgICAgICAgIGRpclggPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIGRpclkgPSAwO1xuICAgICAgICAgICAgZGlyWCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tLXJpZ2h0JzpcbiAgICAgICAgICAgIGRpclkgPSAxO1xuICAgICAgICAgICAgZGlyWCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIGRpclkgPSAxO1xuICAgICAgICAgICAgZGlyWCA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tLWxlZnQnOlxuICAgICAgICAgICAgZGlyWSA9IDE7XG4gICAgICAgICAgICBkaXJYID0gLTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICBkaXJZID0gMDtcbiAgICAgICAgICAgIGRpclggPSAtMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgVXRpbC5lcnJvcignVW5rbm93biBlbWJvc3MgZGlyZWN0aW9uOiAnICsgZGlyZWN0aW9uKTtcbiAgICB9XG4gICAgZG8ge1xuICAgICAgICB2YXIgb2Zmc2V0WSA9ICh5IC0gMSkgKiB3NDtcbiAgICAgICAgdmFyIG90aGVyWSA9IGRpclk7XG4gICAgICAgIGlmICh5ICsgb3RoZXJZIDwgMSkge1xuICAgICAgICAgICAgb3RoZXJZID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSArIG90aGVyWSA+IGgpIHtcbiAgICAgICAgICAgIG90aGVyWSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9mZnNldFlPdGhlciA9ICh5IC0gMSArIG90aGVyWSkgKiB3ICogNDtcbiAgICAgICAgdmFyIHggPSB3O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0WSArICh4IC0gMSkgKiA0O1xuICAgICAgICAgICAgdmFyIG90aGVyWCA9IGRpclg7XG4gICAgICAgICAgICBpZiAoeCArIG90aGVyWCA8IDEpIHtcbiAgICAgICAgICAgICAgICBvdGhlclggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHggKyBvdGhlclggPiB3KSB7XG4gICAgICAgICAgICAgICAgb3RoZXJYID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvZmZzZXRPdGhlciA9IG9mZnNldFlPdGhlciArICh4IC0gMSArIG90aGVyWCkgKiA0O1xuICAgICAgICAgICAgdmFyIGRSID0gZGF0YVtvZmZzZXRdIC0gZGF0YVtvZmZzZXRPdGhlcl07XG4gICAgICAgICAgICB2YXIgZEcgPSBkYXRhW29mZnNldCArIDFdIC0gZGF0YVtvZmZzZXRPdGhlciArIDFdO1xuICAgICAgICAgICAgdmFyIGRCID0gZGF0YVtvZmZzZXQgKyAyXSAtIGRhdGFbb2Zmc2V0T3RoZXIgKyAyXTtcbiAgICAgICAgICAgIHZhciBkaWYgPSBkUjtcbiAgICAgICAgICAgIHZhciBhYnNEaWYgPSBkaWYgPiAwID8gZGlmIDogLWRpZjtcbiAgICAgICAgICAgIHZhciBhYnNHID0gZEcgPiAwID8gZEcgOiAtZEc7XG4gICAgICAgICAgICB2YXIgYWJzQiA9IGRCID4gMCA/IGRCIDogLWRCO1xuICAgICAgICAgICAgaWYgKGFic0cgPiBhYnNEaWYpIHtcbiAgICAgICAgICAgICAgICBkaWYgPSBkRztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhYnNCID4gYWJzRGlmKSB7XG4gICAgICAgICAgICAgICAgZGlmID0gZEI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaWYgKj0gc3RyZW5ndGg7XG4gICAgICAgICAgICBpZiAoYmxlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IGRhdGFbb2Zmc2V0XSArIGRpZjtcbiAgICAgICAgICAgICAgICB2YXIgZyA9IGRhdGFbb2Zmc2V0ICsgMV0gKyBkaWY7XG4gICAgICAgICAgICAgICAgdmFyIGIgPSBkYXRhW29mZnNldCArIDJdICsgZGlmO1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9IHIgPiAyNTUgPyAyNTUgOiByIDwgMCA/IDAgOiByO1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgMV0gPSBnID4gMjU1ID8gMjU1IDogZyA8IDAgPyAwIDogZztcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCArIDJdID0gYiA+IDI1NSA/IDI1NSA6IGIgPCAwID8gMCA6IGI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JleSA9IGdyZXlMZXZlbCAtIGRpZjtcbiAgICAgICAgICAgICAgICBpZiAoZ3JleSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JleSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGdyZXkgPiAyNTUpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JleSA9IDI1NTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXRdID0gZGF0YVtvZmZzZXQgKyAxXSA9IGRhdGFbb2Zmc2V0ICsgMl0gPSBncmV5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICgtLXgpO1xuICAgIH0gd2hpbGUgKC0teSk7XG59O1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoTm9kZSwgJ2VtYm9zc1N0cmVuZ3RoJywgMC41LCBnZXROdW1iZXJWYWxpZGF0b3IoKSwgRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihOb2RlLCAnZW1ib3NzV2hpdGVMZXZlbCcsIDAuNSwgZ2V0TnVtYmVyVmFsaWRhdG9yKCksIEZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoTm9kZSwgJ2VtYm9zc0RpcmVjdGlvbicsICd0b3AtbGVmdCcsIG51bGwsIEZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoTm9kZSwgJ2VtYm9zc0JsZW5kJywgZmFsc2UsIG51bGwsIEZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuIiwiaW1wb3J0IHsgRmFjdG9yeSB9IGZyb20gJy4uL0ZhY3RvcnkuanMnO1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4uL05vZGUuanMnO1xuaW1wb3J0IHsgZ2V0TnVtYmVyVmFsaWRhdG9yIH0gZnJvbSAnLi4vVmFsaWRhdG9ycy5qcyc7XG5mdW5jdGlvbiByZW1hcChmcm9tVmFsdWUsIGZyb21NaW4sIGZyb21NYXgsIHRvTWluLCB0b01heCkge1xuICAgIHZhciBmcm9tUmFuZ2UgPSBmcm9tTWF4IC0gZnJvbU1pbiwgdG9SYW5nZSA9IHRvTWF4IC0gdG9NaW4sIHRvVmFsdWU7XG4gICAgaWYgKGZyb21SYW5nZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdG9NaW4gKyB0b1JhbmdlIC8gMjtcbiAgICB9XG4gICAgaWYgKHRvUmFuZ2UgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRvTWluO1xuICAgIH1cbiAgICB0b1ZhbHVlID0gKGZyb21WYWx1ZSAtIGZyb21NaW4pIC8gZnJvbVJhbmdlO1xuICAgIHRvVmFsdWUgPSB0b1JhbmdlICogdG9WYWx1ZSArIHRvTWluO1xuICAgIHJldHVybiB0b1ZhbHVlO1xufVxuZXhwb3J0IGNvbnN0IEVuaGFuY2UgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XG4gICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgblN1YlBpeGVscyA9IGRhdGEubGVuZ3RoLCByTWluID0gZGF0YVswXSwgck1heCA9IHJNaW4sIHIsIGdNaW4gPSBkYXRhWzFdLCBnTWF4ID0gZ01pbiwgZywgYk1pbiA9IGRhdGFbMl0sIGJNYXggPSBiTWluLCBiLCBpO1xuICAgIHZhciBlbmhhbmNlQW1vdW50ID0gdGhpcy5lbmhhbmNlKCk7XG4gICAgaWYgKGVuaGFuY2VBbW91bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgblN1YlBpeGVsczsgaSArPSA0KSB7XG4gICAgICAgIHIgPSBkYXRhW2kgKyAwXTtcbiAgICAgICAgaWYgKHIgPCByTWluKSB7XG4gICAgICAgICAgICByTWluID0gcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyID4gck1heCkge1xuICAgICAgICAgICAgck1heCA9IHI7XG4gICAgICAgIH1cbiAgICAgICAgZyA9IGRhdGFbaSArIDFdO1xuICAgICAgICBpZiAoZyA8IGdNaW4pIHtcbiAgICAgICAgICAgIGdNaW4gPSBnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGcgPiBnTWF4KSB7XG4gICAgICAgICAgICBnTWF4ID0gZztcbiAgICAgICAgfVxuICAgICAgICBiID0gZGF0YVtpICsgMl07XG4gICAgICAgIGlmIChiIDwgYk1pbikge1xuICAgICAgICAgICAgYk1pbiA9IGI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYiA+IGJNYXgpIHtcbiAgICAgICAgICAgIGJNYXggPSBiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyTWF4ID09PSByTWluKSB7XG4gICAgICAgIHJNYXggPSAyNTU7XG4gICAgICAgIHJNaW4gPSAwO1xuICAgIH1cbiAgICBpZiAoZ01heCA9PT0gZ01pbikge1xuICAgICAgICBnTWF4ID0gMjU1O1xuICAgICAgICBnTWluID0gMDtcbiAgICB9XG4gICAgaWYgKGJNYXggPT09IGJNaW4pIHtcbiAgICAgICAgYk1heCA9IDI1NTtcbiAgICAgICAgYk1pbiA9IDA7XG4gICAgfVxuICAgIHZhciByTWlkLCByR29hbE1heCwgckdvYWxNaW4sIGdNaWQsIGdHb2FsTWF4LCBnR29hbE1pbiwgYk1pZCwgYkdvYWxNYXgsIGJHb2FsTWluO1xuICAgIGlmIChlbmhhbmNlQW1vdW50ID4gMCkge1xuICAgICAgICByR29hbE1heCA9IHJNYXggKyBlbmhhbmNlQW1vdW50ICogKDI1NSAtIHJNYXgpO1xuICAgICAgICByR29hbE1pbiA9IHJNaW4gLSBlbmhhbmNlQW1vdW50ICogKHJNaW4gLSAwKTtcbiAgICAgICAgZ0dvYWxNYXggPSBnTWF4ICsgZW5oYW5jZUFtb3VudCAqICgyNTUgLSBnTWF4KTtcbiAgICAgICAgZ0dvYWxNaW4gPSBnTWluIC0gZW5oYW5jZUFtb3VudCAqIChnTWluIC0gMCk7XG4gICAgICAgIGJHb2FsTWF4ID0gYk1heCArIGVuaGFuY2VBbW91bnQgKiAoMjU1IC0gYk1heCk7XG4gICAgICAgIGJHb2FsTWluID0gYk1pbiAtIGVuaGFuY2VBbW91bnQgKiAoYk1pbiAtIDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgck1pZCA9IChyTWF4ICsgck1pbikgKiAwLjU7XG4gICAgICAgIHJHb2FsTWF4ID0gck1heCArIGVuaGFuY2VBbW91bnQgKiAock1heCAtIHJNaWQpO1xuICAgICAgICByR29hbE1pbiA9IHJNaW4gKyBlbmhhbmNlQW1vdW50ICogKHJNaW4gLSByTWlkKTtcbiAgICAgICAgZ01pZCA9IChnTWF4ICsgZ01pbikgKiAwLjU7XG4gICAgICAgIGdHb2FsTWF4ID0gZ01heCArIGVuaGFuY2VBbW91bnQgKiAoZ01heCAtIGdNaWQpO1xuICAgICAgICBnR29hbE1pbiA9IGdNaW4gKyBlbmhhbmNlQW1vdW50ICogKGdNaW4gLSBnTWlkKTtcbiAgICAgICAgYk1pZCA9IChiTWF4ICsgYk1pbikgKiAwLjU7XG4gICAgICAgIGJHb2FsTWF4ID0gYk1heCArIGVuaGFuY2VBbW91bnQgKiAoYk1heCAtIGJNaWQpO1xuICAgICAgICBiR29hbE1pbiA9IGJNaW4gKyBlbmhhbmNlQW1vdW50ICogKGJNaW4gLSBiTWlkKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IG5TdWJQaXhlbHM7IGkgKz0gNCkge1xuICAgICAgICBkYXRhW2kgKyAwXSA9IHJlbWFwKGRhdGFbaSArIDBdLCByTWluLCByTWF4LCByR29hbE1pbiwgckdvYWxNYXgpO1xuICAgICAgICBkYXRhW2kgKyAxXSA9IHJlbWFwKGRhdGFbaSArIDFdLCBnTWluLCBnTWF4LCBnR29hbE1pbiwgZ0dvYWxNYXgpO1xuICAgICAgICBkYXRhW2kgKyAyXSA9IHJlbWFwKGRhdGFbaSArIDJdLCBiTWluLCBiTWF4LCBiR29hbE1pbiwgYkdvYWxNYXgpO1xuICAgIH1cbn07XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihOb2RlLCAnZW5oYW5jZScsIDAsIGdldE51bWJlclZhbGlkYXRvcigpLCBGYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcbiIsImV4cG9ydCBjb25zdCBHcmF5c2NhbGUgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XG4gICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgbGVuID0gZGF0YS5sZW5ndGgsIGksIGJyaWdodG5lc3M7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIGJyaWdodG5lc3MgPSAwLjM0ICogZGF0YVtpXSArIDAuNSAqIGRhdGFbaSArIDFdICsgMC4xNiAqIGRhdGFbaSArIDJdO1xuICAgICAgICBkYXRhW2ldID0gYnJpZ2h0bmVzcztcbiAgICAgICAgZGF0YVtpICsgMV0gPSBicmlnaHRuZXNzO1xuICAgICAgICBkYXRhW2kgKyAyXSA9IGJyaWdodG5lc3M7XG4gICAgfVxufTtcbiIsImltcG9ydCB7IEZhY3RvcnkgfSBmcm9tICcuLi9GYWN0b3J5LmpzJztcbmltcG9ydCB7IE5vZGUgfSBmcm9tICcuLi9Ob2RlLmpzJztcbmltcG9ydCB7IGdldE51bWJlclZhbGlkYXRvciB9IGZyb20gJy4uL1ZhbGlkYXRvcnMuanMnO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoTm9kZSwgJ2h1ZScsIDAsIGdldE51bWJlclZhbGlkYXRvcigpLCBGYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKE5vZGUsICdzYXR1cmF0aW9uJywgMCwgZ2V0TnVtYmVyVmFsaWRhdG9yKCksIEZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoTm9kZSwgJ2x1bWluYW5jZScsIDAsIGdldE51bWJlclZhbGlkYXRvcigpLCBGYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcbmV4cG9ydCBjb25zdCBIU0wgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XG4gICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgblBpeGVscyA9IGRhdGEubGVuZ3RoLCB2ID0gMSwgcyA9IE1hdGgucG93KDIsIHRoaXMuc2F0dXJhdGlvbigpKSwgaCA9IE1hdGguYWJzKHRoaXMuaHVlKCkgKyAzNjApICUgMzYwLCBsID0gdGhpcy5sdW1pbmFuY2UoKSAqIDEyNywgaTtcbiAgICB2YXIgdnN1ID0gdiAqIHMgKiBNYXRoLmNvcygoaCAqIE1hdGguUEkpIC8gMTgwKSwgdnN3ID0gdiAqIHMgKiBNYXRoLnNpbigoaCAqIE1hdGguUEkpIC8gMTgwKTtcbiAgICB2YXIgcnIgPSAwLjI5OSAqIHYgKyAwLjcwMSAqIHZzdSArIDAuMTY3ICogdnN3LCByZyA9IDAuNTg3ICogdiAtIDAuNTg3ICogdnN1ICsgMC4zMyAqIHZzdywgcmIgPSAwLjExNCAqIHYgLSAwLjExNCAqIHZzdSAtIDAuNDk3ICogdnN3O1xuICAgIHZhciBnciA9IDAuMjk5ICogdiAtIDAuMjk5ICogdnN1IC0gMC4zMjggKiB2c3csIGdnID0gMC41ODcgKiB2ICsgMC40MTMgKiB2c3UgKyAwLjAzNSAqIHZzdywgZ2IgPSAwLjExNCAqIHYgLSAwLjExNCAqIHZzdSArIDAuMjkzICogdnN3O1xuICAgIHZhciBiciA9IDAuMjk5ICogdiAtIDAuMyAqIHZzdSArIDEuMjUgKiB2c3csIGJnID0gMC41ODcgKiB2IC0gMC41ODYgKiB2c3UgLSAxLjA1ICogdnN3LCBiYiA9IDAuMTE0ICogdiArIDAuODg2ICogdnN1IC0gMC4yICogdnN3O1xuICAgIHZhciByLCBnLCBiLCBhO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuUGl4ZWxzOyBpICs9IDQpIHtcbiAgICAgICAgciA9IGRhdGFbaSArIDBdO1xuICAgICAgICBnID0gZGF0YVtpICsgMV07XG4gICAgICAgIGIgPSBkYXRhW2kgKyAyXTtcbiAgICAgICAgYSA9IGRhdGFbaSArIDNdO1xuICAgICAgICBkYXRhW2kgKyAwXSA9IHJyICogciArIHJnICogZyArIHJiICogYiArIGw7XG4gICAgICAgIGRhdGFbaSArIDFdID0gZ3IgKiByICsgZ2cgKiBnICsgZ2IgKiBiICsgbDtcbiAgICAgICAgZGF0YVtpICsgMl0gPSBiciAqIHIgKyBiZyAqIGcgKyBiYiAqIGIgKyBsO1xuICAgICAgICBkYXRhW2kgKyAzXSA9IGE7XG4gICAgfVxufTtcbiIsImltcG9ydCB7IEZhY3RvcnkgfSBmcm9tICcuLi9GYWN0b3J5LmpzJztcbmltcG9ydCB7IE5vZGUgfSBmcm9tICcuLi9Ob2RlLmpzJztcbmltcG9ydCB7IGdldE51bWJlclZhbGlkYXRvciB9IGZyb20gJy4uL1ZhbGlkYXRvcnMuanMnO1xuZXhwb3J0IGNvbnN0IEhTViA9IGZ1bmN0aW9uIChpbWFnZURhdGEpIHtcbiAgICB2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBuUGl4ZWxzID0gZGF0YS5sZW5ndGgsIHYgPSBNYXRoLnBvdygyLCB0aGlzLnZhbHVlKCkpLCBzID0gTWF0aC5wb3coMiwgdGhpcy5zYXR1cmF0aW9uKCkpLCBoID0gTWF0aC5hYnModGhpcy5odWUoKSArIDM2MCkgJSAzNjAsIGk7XG4gICAgdmFyIHZzdSA9IHYgKiBzICogTWF0aC5jb3MoKGggKiBNYXRoLlBJKSAvIDE4MCksIHZzdyA9IHYgKiBzICogTWF0aC5zaW4oKGggKiBNYXRoLlBJKSAvIDE4MCk7XG4gICAgdmFyIHJyID0gMC4yOTkgKiB2ICsgMC43MDEgKiB2c3UgKyAwLjE2NyAqIHZzdywgcmcgPSAwLjU4NyAqIHYgLSAwLjU4NyAqIHZzdSArIDAuMzMgKiB2c3csIHJiID0gMC4xMTQgKiB2IC0gMC4xMTQgKiB2c3UgLSAwLjQ5NyAqIHZzdztcbiAgICB2YXIgZ3IgPSAwLjI5OSAqIHYgLSAwLjI5OSAqIHZzdSAtIDAuMzI4ICogdnN3LCBnZyA9IDAuNTg3ICogdiArIDAuNDEzICogdnN1ICsgMC4wMzUgKiB2c3csIGdiID0gMC4xMTQgKiB2IC0gMC4xMTQgKiB2c3UgKyAwLjI5MyAqIHZzdztcbiAgICB2YXIgYnIgPSAwLjI5OSAqIHYgLSAwLjMgKiB2c3UgKyAxLjI1ICogdnN3LCBiZyA9IDAuNTg3ICogdiAtIDAuNTg2ICogdnN1IC0gMS4wNSAqIHZzdywgYmIgPSAwLjExNCAqIHYgKyAwLjg4NiAqIHZzdSAtIDAuMiAqIHZzdztcbiAgICB2YXIgciwgZywgYiwgYTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgblBpeGVsczsgaSArPSA0KSB7XG4gICAgICAgIHIgPSBkYXRhW2kgKyAwXTtcbiAgICAgICAgZyA9IGRhdGFbaSArIDFdO1xuICAgICAgICBiID0gZGF0YVtpICsgMl07XG4gICAgICAgIGEgPSBkYXRhW2kgKyAzXTtcbiAgICAgICAgZGF0YVtpICsgMF0gPSByciAqIHIgKyByZyAqIGcgKyByYiAqIGI7XG4gICAgICAgIGRhdGFbaSArIDFdID0gZ3IgKiByICsgZ2cgKiBnICsgZ2IgKiBiO1xuICAgICAgICBkYXRhW2kgKyAyXSA9IGJyICogciArIGJnICogZyArIGJiICogYjtcbiAgICAgICAgZGF0YVtpICsgM10gPSBhO1xuICAgIH1cbn07XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihOb2RlLCAnaHVlJywgMCwgZ2V0TnVtYmVyVmFsaWRhdG9yKCksIEZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoTm9kZSwgJ3NhdHVyYXRpb24nLCAwLCBnZXROdW1iZXJWYWxpZGF0b3IoKSwgRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihOb2RlLCAndmFsdWUnLCAwLCBnZXROdW1iZXJWYWxpZGF0b3IoKSwgRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XG4iLCJleHBvcnQgY29uc3QgSW52ZXJ0ID0gZnVuY3Rpb24gKGltYWdlRGF0YSkge1xuICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGxlbiA9IGRhdGEubGVuZ3RoLCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICBkYXRhW2ldID0gMjU1IC0gZGF0YVtpXTtcbiAgICAgICAgZGF0YVtpICsgMV0gPSAyNTUgLSBkYXRhW2kgKyAxXTtcbiAgICAgICAgZGF0YVtpICsgMl0gPSAyNTUgLSBkYXRhW2kgKyAyXTtcbiAgICB9XG59O1xuIiwiaW1wb3J0IHsgRmFjdG9yeSB9IGZyb20gJy4uL0ZhY3RvcnkuanMnO1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4uL05vZGUuanMnO1xuaW1wb3J0IHsgVXRpbCB9IGZyb20gJy4uL1V0aWwuanMnO1xuaW1wb3J0IHsgZ2V0TnVtYmVyVmFsaWRhdG9yIH0gZnJvbSAnLi4vVmFsaWRhdG9ycy5qcyc7XG52YXIgVG9Qb2xhciA9IGZ1bmN0aW9uIChzcmMsIGRzdCwgb3B0KSB7XG4gICAgdmFyIHNyY1BpeGVscyA9IHNyYy5kYXRhLCBkc3RQaXhlbHMgPSBkc3QuZGF0YSwgeFNpemUgPSBzcmMud2lkdGgsIHlTaXplID0gc3JjLmhlaWdodCwgeE1pZCA9IG9wdC5wb2xhckNlbnRlclggfHwgeFNpemUgLyAyLCB5TWlkID0gb3B0LnBvbGFyQ2VudGVyWSB8fCB5U2l6ZSAvIDIsIGksIHgsIHksIHIgPSAwLCBnID0gMCwgYiA9IDAsIGEgPSAwO1xuICAgIHZhciByYWQsIHJNYXggPSBNYXRoLnNxcnQoeE1pZCAqIHhNaWQgKyB5TWlkICogeU1pZCk7XG4gICAgeCA9IHhTaXplIC0geE1pZDtcbiAgICB5ID0geVNpemUgLSB5TWlkO1xuICAgIHJhZCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICByTWF4ID0gcmFkID4gck1heCA/IHJhZCA6IHJNYXg7XG4gICAgdmFyIHJTaXplID0geVNpemUsIHRTaXplID0geFNpemUsIHJhZGl1cywgdGhldGE7XG4gICAgdmFyIGNvbnZlcnNpb24gPSAoKDM2MCAvIHRTaXplKSAqIE1hdGguUEkpIC8gMTgwLCBzaW4sIGNvcztcbiAgICBmb3IgKHRoZXRhID0gMDsgdGhldGEgPCB0U2l6ZTsgdGhldGEgKz0gMSkge1xuICAgICAgICBzaW4gPSBNYXRoLnNpbih0aGV0YSAqIGNvbnZlcnNpb24pO1xuICAgICAgICBjb3MgPSBNYXRoLmNvcyh0aGV0YSAqIGNvbnZlcnNpb24pO1xuICAgICAgICBmb3IgKHJhZGl1cyA9IDA7IHJhZGl1cyA8IHJTaXplOyByYWRpdXMgKz0gMSkge1xuICAgICAgICAgICAgeCA9IE1hdGguZmxvb3IoeE1pZCArICgock1heCAqIHJhZGl1cykgLyByU2l6ZSkgKiBjb3MpO1xuICAgICAgICAgICAgeSA9IE1hdGguZmxvb3IoeU1pZCArICgock1heCAqIHJhZGl1cykgLyByU2l6ZSkgKiBzaW4pO1xuICAgICAgICAgICAgaSA9ICh5ICogeFNpemUgKyB4KSAqIDQ7XG4gICAgICAgICAgICByID0gc3JjUGl4ZWxzW2kgKyAwXTtcbiAgICAgICAgICAgIGcgPSBzcmNQaXhlbHNbaSArIDFdO1xuICAgICAgICAgICAgYiA9IHNyY1BpeGVsc1tpICsgMl07XG4gICAgICAgICAgICBhID0gc3JjUGl4ZWxzW2kgKyAzXTtcbiAgICAgICAgICAgIGkgPSAodGhldGEgKyByYWRpdXMgKiB4U2l6ZSkgKiA0O1xuICAgICAgICAgICAgZHN0UGl4ZWxzW2kgKyAwXSA9IHI7XG4gICAgICAgICAgICBkc3RQaXhlbHNbaSArIDFdID0gZztcbiAgICAgICAgICAgIGRzdFBpeGVsc1tpICsgMl0gPSBiO1xuICAgICAgICAgICAgZHN0UGl4ZWxzW2kgKyAzXSA9IGE7XG4gICAgICAgIH1cbiAgICB9XG59O1xudmFyIEZyb21Qb2xhciA9IGZ1bmN0aW9uIChzcmMsIGRzdCwgb3B0KSB7XG4gICAgdmFyIHNyY1BpeGVscyA9IHNyYy5kYXRhLCBkc3RQaXhlbHMgPSBkc3QuZGF0YSwgeFNpemUgPSBzcmMud2lkdGgsIHlTaXplID0gc3JjLmhlaWdodCwgeE1pZCA9IG9wdC5wb2xhckNlbnRlclggfHwgeFNpemUgLyAyLCB5TWlkID0gb3B0LnBvbGFyQ2VudGVyWSB8fCB5U2l6ZSAvIDIsIGksIHgsIHksIGR4LCBkeSwgciA9IDAsIGcgPSAwLCBiID0gMCwgYSA9IDA7XG4gICAgdmFyIHJhZCwgck1heCA9IE1hdGguc3FydCh4TWlkICogeE1pZCArIHlNaWQgKiB5TWlkKTtcbiAgICB4ID0geFNpemUgLSB4TWlkO1xuICAgIHkgPSB5U2l6ZSAtIHlNaWQ7XG4gICAgcmFkID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgIHJNYXggPSByYWQgPiByTWF4ID8gcmFkIDogck1heDtcbiAgICB2YXIgclNpemUgPSB5U2l6ZSwgdFNpemUgPSB4U2l6ZSwgcmFkaXVzLCB0aGV0YSwgcGhhc2VTaGlmdCA9IG9wdC5wb2xhclJvdGF0aW9uIHx8IDA7XG4gICAgdmFyIHgxLCB5MTtcbiAgICBmb3IgKHggPSAwOyB4IDwgeFNpemU7IHggKz0gMSkge1xuICAgICAgICBmb3IgKHkgPSAwOyB5IDwgeVNpemU7IHkgKz0gMSkge1xuICAgICAgICAgICAgZHggPSB4IC0geE1pZDtcbiAgICAgICAgICAgIGR5ID0geSAtIHlNaWQ7XG4gICAgICAgICAgICByYWRpdXMgPSAoTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSAqIHJTaXplKSAvIHJNYXg7XG4gICAgICAgICAgICB0aGV0YSA9ICgoTWF0aC5hdGFuMihkeSwgZHgpICogMTgwKSAvIE1hdGguUEkgKyAzNjAgKyBwaGFzZVNoaWZ0KSAlIDM2MDtcbiAgICAgICAgICAgIHRoZXRhID0gKHRoZXRhICogdFNpemUpIC8gMzYwO1xuICAgICAgICAgICAgeDEgPSBNYXRoLmZsb29yKHRoZXRhKTtcbiAgICAgICAgICAgIHkxID0gTWF0aC5mbG9vcihyYWRpdXMpO1xuICAgICAgICAgICAgaSA9ICh5MSAqIHhTaXplICsgeDEpICogNDtcbiAgICAgICAgICAgIHIgPSBzcmNQaXhlbHNbaSArIDBdO1xuICAgICAgICAgICAgZyA9IHNyY1BpeGVsc1tpICsgMV07XG4gICAgICAgICAgICBiID0gc3JjUGl4ZWxzW2kgKyAyXTtcbiAgICAgICAgICAgIGEgPSBzcmNQaXhlbHNbaSArIDNdO1xuICAgICAgICAgICAgaSA9ICh5ICogeFNpemUgKyB4KSAqIDQ7XG4gICAgICAgICAgICBkc3RQaXhlbHNbaSArIDBdID0gcjtcbiAgICAgICAgICAgIGRzdFBpeGVsc1tpICsgMV0gPSBnO1xuICAgICAgICAgICAgZHN0UGl4ZWxzW2kgKyAyXSA9IGI7XG4gICAgICAgICAgICBkc3RQaXhlbHNbaSArIDNdID0gYTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgS2FsZWlkb3Njb3BlID0gZnVuY3Rpb24gKGltYWdlRGF0YSkge1xuICAgIHZhciB4U2l6ZSA9IGltYWdlRGF0YS53aWR0aCwgeVNpemUgPSBpbWFnZURhdGEuaGVpZ2h0O1xuICAgIHZhciB4LCB5LCB4b2ZmLCBpLCByLCBnLCBiLCBhLCBzcmNQb3MsIGRzdFBvcztcbiAgICB2YXIgcG93ZXIgPSBNYXRoLnJvdW5kKHRoaXMua2FsZWlkb3Njb3BlUG93ZXIoKSk7XG4gICAgdmFyIGFuZ2xlID0gTWF0aC5yb3VuZCh0aGlzLmthbGVpZG9zY29wZUFuZ2xlKCkpO1xuICAgIHZhciBvZmZzZXQgPSBNYXRoLmZsb29yKCh4U2l6ZSAqIChhbmdsZSAlIDM2MCkpIC8gMzYwKTtcbiAgICBpZiAocG93ZXIgPCAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRlbXBDYW52YXMgPSBVdGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICB0ZW1wQ2FudmFzLndpZHRoID0geFNpemU7XG4gICAgdGVtcENhbnZhcy5oZWlnaHQgPSB5U2l6ZTtcbiAgICB2YXIgc2NyYXRjaERhdGEgPSB0ZW1wQ2FudmFzXG4gICAgICAgIC5nZXRDb250ZXh0KCcyZCcpXG4gICAgICAgIC5nZXRJbWFnZURhdGEoMCwgMCwgeFNpemUsIHlTaXplKTtcbiAgICBUb1BvbGFyKGltYWdlRGF0YSwgc2NyYXRjaERhdGEsIHtcbiAgICAgICAgcG9sYXJDZW50ZXJYOiB4U2l6ZSAvIDIsXG4gICAgICAgIHBvbGFyQ2VudGVyWTogeVNpemUgLyAyLFxuICAgIH0pO1xuICAgIHZhciBtaW5TZWN0aW9uU2l6ZSA9IHhTaXplIC8gTWF0aC5wb3coMiwgcG93ZXIpO1xuICAgIHdoaWxlIChtaW5TZWN0aW9uU2l6ZSA8PSA4KSB7XG4gICAgICAgIG1pblNlY3Rpb25TaXplID0gbWluU2VjdGlvblNpemUgKiAyO1xuICAgICAgICBwb3dlciAtPSAxO1xuICAgIH1cbiAgICBtaW5TZWN0aW9uU2l6ZSA9IE1hdGguY2VpbChtaW5TZWN0aW9uU2l6ZSk7XG4gICAgdmFyIHNlY3Rpb25TaXplID0gbWluU2VjdGlvblNpemU7XG4gICAgdmFyIHhTdGFydCA9IDAsIHhFbmQgPSBzZWN0aW9uU2l6ZSwgeERlbHRhID0gMTtcbiAgICBpZiAob2Zmc2V0ICsgbWluU2VjdGlvblNpemUgPiB4U2l6ZSkge1xuICAgICAgICB4U3RhcnQgPSBzZWN0aW9uU2l6ZTtcbiAgICAgICAgeEVuZCA9IDA7XG4gICAgICAgIHhEZWx0YSA9IC0xO1xuICAgIH1cbiAgICBmb3IgKHkgPSAwOyB5IDwgeVNpemU7IHkgKz0gMSkge1xuICAgICAgICBmb3IgKHggPSB4U3RhcnQ7IHggIT09IHhFbmQ7IHggKz0geERlbHRhKSB7XG4gICAgICAgICAgICB4b2ZmID0gTWF0aC5yb3VuZCh4ICsgb2Zmc2V0KSAlIHhTaXplO1xuICAgICAgICAgICAgc3JjUG9zID0gKHhTaXplICogeSArIHhvZmYpICogNDtcbiAgICAgICAgICAgIHIgPSBzY3JhdGNoRGF0YS5kYXRhW3NyY1BvcyArIDBdO1xuICAgICAgICAgICAgZyA9IHNjcmF0Y2hEYXRhLmRhdGFbc3JjUG9zICsgMV07XG4gICAgICAgICAgICBiID0gc2NyYXRjaERhdGEuZGF0YVtzcmNQb3MgKyAyXTtcbiAgICAgICAgICAgIGEgPSBzY3JhdGNoRGF0YS5kYXRhW3NyY1BvcyArIDNdO1xuICAgICAgICAgICAgZHN0UG9zID0gKHhTaXplICogeSArIHgpICogNDtcbiAgICAgICAgICAgIHNjcmF0Y2hEYXRhLmRhdGFbZHN0UG9zICsgMF0gPSByO1xuICAgICAgICAgICAgc2NyYXRjaERhdGEuZGF0YVtkc3RQb3MgKyAxXSA9IGc7XG4gICAgICAgICAgICBzY3JhdGNoRGF0YS5kYXRhW2RzdFBvcyArIDJdID0gYjtcbiAgICAgICAgICAgIHNjcmF0Y2hEYXRhLmRhdGFbZHN0UG9zICsgM10gPSBhO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoeSA9IDA7IHkgPCB5U2l6ZTsgeSArPSAxKSB7XG4gICAgICAgIHNlY3Rpb25TaXplID0gTWF0aC5mbG9vcihtaW5TZWN0aW9uU2l6ZSk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwb3dlcjsgaSArPSAxKSB7XG4gICAgICAgICAgICBmb3IgKHggPSAwOyB4IDwgc2VjdGlvblNpemUgKyAxOyB4ICs9IDEpIHtcbiAgICAgICAgICAgICAgICBzcmNQb3MgPSAoeFNpemUgKiB5ICsgeCkgKiA0O1xuICAgICAgICAgICAgICAgIHIgPSBzY3JhdGNoRGF0YS5kYXRhW3NyY1BvcyArIDBdO1xuICAgICAgICAgICAgICAgIGcgPSBzY3JhdGNoRGF0YS5kYXRhW3NyY1BvcyArIDFdO1xuICAgICAgICAgICAgICAgIGIgPSBzY3JhdGNoRGF0YS5kYXRhW3NyY1BvcyArIDJdO1xuICAgICAgICAgICAgICAgIGEgPSBzY3JhdGNoRGF0YS5kYXRhW3NyY1BvcyArIDNdO1xuICAgICAgICAgICAgICAgIGRzdFBvcyA9ICh4U2l6ZSAqIHkgKyBzZWN0aW9uU2l6ZSAqIDIgLSB4IC0gMSkgKiA0O1xuICAgICAgICAgICAgICAgIHNjcmF0Y2hEYXRhLmRhdGFbZHN0UG9zICsgMF0gPSByO1xuICAgICAgICAgICAgICAgIHNjcmF0Y2hEYXRhLmRhdGFbZHN0UG9zICsgMV0gPSBnO1xuICAgICAgICAgICAgICAgIHNjcmF0Y2hEYXRhLmRhdGFbZHN0UG9zICsgMl0gPSBiO1xuICAgICAgICAgICAgICAgIHNjcmF0Y2hEYXRhLmRhdGFbZHN0UG9zICsgM10gPSBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VjdGlvblNpemUgKj0gMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBGcm9tUG9sYXIoc2NyYXRjaERhdGEsIGltYWdlRGF0YSwgeyBwb2xhclJvdGF0aW9uOiAwIH0pO1xufTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKE5vZGUsICdrYWxlaWRvc2NvcGVQb3dlcicsIDIsIGdldE51bWJlclZhbGlkYXRvcigpLCBGYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKE5vZGUsICdrYWxlaWRvc2NvcGVBbmdsZScsIDAsIGdldE51bWJlclZhbGlkYXRvcigpLCBGYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcbiIsImltcG9ydCB7IEZhY3RvcnkgfSBmcm9tICcuLi9GYWN0b3J5LmpzJztcbmltcG9ydCB7IE5vZGUgfSBmcm9tICcuLi9Ob2RlLmpzJztcbmltcG9ydCB7IGdldE51bWJlclZhbGlkYXRvciB9IGZyb20gJy4uL1ZhbGlkYXRvcnMuanMnO1xuZnVuY3Rpb24gcGl4ZWxBdChpZGF0YSwgeCwgeSkge1xuICAgIHZhciBpZHggPSAoeSAqIGlkYXRhLndpZHRoICsgeCkgKiA0O1xuICAgIHZhciBkID0gW107XG4gICAgZC5wdXNoKGlkYXRhLmRhdGFbaWR4KytdLCBpZGF0YS5kYXRhW2lkeCsrXSwgaWRhdGEuZGF0YVtpZHgrK10sIGlkYXRhLmRhdGFbaWR4KytdKTtcbiAgICByZXR1cm4gZDtcbn1cbmZ1bmN0aW9uIHJnYkRpc3RhbmNlKHAxLCBwMikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocDFbMF0gLSBwMlswXSwgMikgK1xuICAgICAgICBNYXRoLnBvdyhwMVsxXSAtIHAyWzFdLCAyKSArXG4gICAgICAgIE1hdGgucG93KHAxWzJdIC0gcDJbMl0sIDIpKTtcbn1cbmZ1bmN0aW9uIHJnYk1lYW4ocFRhYikge1xuICAgIHZhciBtID0gWzAsIDAsIDBdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcFRhYi5sZW5ndGg7IGkrKykge1xuICAgICAgICBtWzBdICs9IHBUYWJbaV1bMF07XG4gICAgICAgIG1bMV0gKz0gcFRhYltpXVsxXTtcbiAgICAgICAgbVsyXSArPSBwVGFiW2ldWzJdO1xuICAgIH1cbiAgICBtWzBdIC89IHBUYWIubGVuZ3RoO1xuICAgIG1bMV0gLz0gcFRhYi5sZW5ndGg7XG4gICAgbVsyXSAvPSBwVGFiLmxlbmd0aDtcbiAgICByZXR1cm4gbTtcbn1cbmZ1bmN0aW9uIGJhY2tncm91bmRNYXNrKGlkYXRhLCB0aHJlc2hvbGQpIHtcbiAgICB2YXIgcmdidl9ubyA9IHBpeGVsQXQoaWRhdGEsIDAsIDApO1xuICAgIHZhciByZ2J2X25lID0gcGl4ZWxBdChpZGF0YSwgaWRhdGEud2lkdGggLSAxLCAwKTtcbiAgICB2YXIgcmdidl9zbyA9IHBpeGVsQXQoaWRhdGEsIDAsIGlkYXRhLmhlaWdodCAtIDEpO1xuICAgIHZhciByZ2J2X3NlID0gcGl4ZWxBdChpZGF0YSwgaWRhdGEud2lkdGggLSAxLCBpZGF0YS5oZWlnaHQgLSAxKTtcbiAgICB2YXIgdGhyZXMgPSB0aHJlc2hvbGQgfHwgMTA7XG4gICAgaWYgKHJnYkRpc3RhbmNlKHJnYnZfbm8sIHJnYnZfbmUpIDwgdGhyZXMgJiZcbiAgICAgICAgcmdiRGlzdGFuY2Uocmdidl9uZSwgcmdidl9zZSkgPCB0aHJlcyAmJlxuICAgICAgICByZ2JEaXN0YW5jZShyZ2J2X3NlLCByZ2J2X3NvKSA8IHRocmVzICYmXG4gICAgICAgIHJnYkRpc3RhbmNlKHJnYnZfc28sIHJnYnZfbm8pIDwgdGhyZXMpIHtcbiAgICAgICAgdmFyIG1lYW4gPSByZ2JNZWFuKFtyZ2J2X25lLCByZ2J2X25vLCByZ2J2X3NlLCByZ2J2X3NvXSk7XG4gICAgICAgIHZhciBtYXNrID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRhdGEud2lkdGggKiBpZGF0YS5oZWlnaHQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIGQgPSByZ2JEaXN0YW5jZShtZWFuLCBbXG4gICAgICAgICAgICAgICAgaWRhdGEuZGF0YVtpICogNF0sXG4gICAgICAgICAgICAgICAgaWRhdGEuZGF0YVtpICogNCArIDFdLFxuICAgICAgICAgICAgICAgIGlkYXRhLmRhdGFbaSAqIDQgKyAyXSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgbWFza1tpXSA9IGQgPCB0aHJlcyA/IDAgOiAyNTU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hc2s7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlNYXNrKGlkYXRhLCBtYXNrKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZGF0YS53aWR0aCAqIGlkYXRhLmhlaWdodDsgaSsrKSB7XG4gICAgICAgIGlkYXRhLmRhdGFbNCAqIGkgKyAzXSA9IG1hc2tbaV07XG4gICAgfVxufVxuZnVuY3Rpb24gZXJvZGVNYXNrKG1hc2ssIHN3LCBzaCkge1xuICAgIHZhciB3ZWlnaHRzID0gWzEsIDEsIDEsIDEsIDAsIDEsIDEsIDEsIDFdO1xuICAgIHZhciBzaWRlID0gTWF0aC5yb3VuZChNYXRoLnNxcnQod2VpZ2h0cy5sZW5ndGgpKTtcbiAgICB2YXIgaGFsZlNpZGUgPSBNYXRoLmZsb29yKHNpZGUgLyAyKTtcbiAgICB2YXIgbWFza1Jlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgc2g7IHkrKykge1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHN3OyB4KyspIHtcbiAgICAgICAgICAgIHZhciBzbyA9IHkgKiBzdyArIHg7XG4gICAgICAgICAgICB2YXIgYSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBjeSA9IDA7IGN5IDwgc2lkZTsgY3krKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGN4ID0gMDsgY3ggPCBzaWRlOyBjeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3kgPSB5ICsgY3kgLSBoYWxmU2lkZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjeCA9IHggKyBjeCAtIGhhbGZTaWRlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2N5ID49IDAgJiYgc2N5IDwgc2ggJiYgc2N4ID49IDAgJiYgc2N4IDwgc3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcmNPZmYgPSBzY3kgKiBzdyArIHNjeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3dCA9IHdlaWdodHNbY3kgKiBzaWRlICsgY3hdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYSArPSBtYXNrW3NyY09mZl0gKiB3dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hc2tSZXN1bHRbc29dID0gYSA9PT0gMjU1ICogOCA/IDI1NSA6IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hc2tSZXN1bHQ7XG59XG5mdW5jdGlvbiBkaWxhdGVNYXNrKG1hc2ssIHN3LCBzaCkge1xuICAgIHZhciB3ZWlnaHRzID0gWzEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDFdO1xuICAgIHZhciBzaWRlID0gTWF0aC5yb3VuZChNYXRoLnNxcnQod2VpZ2h0cy5sZW5ndGgpKTtcbiAgICB2YXIgaGFsZlNpZGUgPSBNYXRoLmZsb29yKHNpZGUgLyAyKTtcbiAgICB2YXIgbWFza1Jlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgc2g7IHkrKykge1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHN3OyB4KyspIHtcbiAgICAgICAgICAgIHZhciBzbyA9IHkgKiBzdyArIHg7XG4gICAgICAgICAgICB2YXIgYSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBjeSA9IDA7IGN5IDwgc2lkZTsgY3krKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGN4ID0gMDsgY3ggPCBzaWRlOyBjeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3kgPSB5ICsgY3kgLSBoYWxmU2lkZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjeCA9IHggKyBjeCAtIGhhbGZTaWRlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2N5ID49IDAgJiYgc2N5IDwgc2ggJiYgc2N4ID49IDAgJiYgc2N4IDwgc3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcmNPZmYgPSBzY3kgKiBzdyArIHNjeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3dCA9IHdlaWdodHNbY3kgKiBzaWRlICsgY3hdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYSArPSBtYXNrW3NyY09mZl0gKiB3dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hc2tSZXN1bHRbc29dID0gYSA+PSAyNTUgKiA0ID8gMjU1IDogMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFza1Jlc3VsdDtcbn1cbmZ1bmN0aW9uIHNtb290aEVkZ2VNYXNrKG1hc2ssIHN3LCBzaCkge1xuICAgIHZhciB3ZWlnaHRzID0gWzEgLyA5LCAxIC8gOSwgMSAvIDksIDEgLyA5LCAxIC8gOSwgMSAvIDksIDEgLyA5LCAxIC8gOSwgMSAvIDldO1xuICAgIHZhciBzaWRlID0gTWF0aC5yb3VuZChNYXRoLnNxcnQod2VpZ2h0cy5sZW5ndGgpKTtcbiAgICB2YXIgaGFsZlNpZGUgPSBNYXRoLmZsb29yKHNpZGUgLyAyKTtcbiAgICB2YXIgbWFza1Jlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgc2g7IHkrKykge1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHN3OyB4KyspIHtcbiAgICAgICAgICAgIHZhciBzbyA9IHkgKiBzdyArIHg7XG4gICAgICAgICAgICB2YXIgYSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBjeSA9IDA7IGN5IDwgc2lkZTsgY3krKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGN4ID0gMDsgY3ggPCBzaWRlOyBjeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3kgPSB5ICsgY3kgLSBoYWxmU2lkZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjeCA9IHggKyBjeCAtIGhhbGZTaWRlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2N5ID49IDAgJiYgc2N5IDwgc2ggJiYgc2N4ID49IDAgJiYgc2N4IDwgc3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcmNPZmYgPSBzY3kgKiBzdyArIHNjeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3dCA9IHdlaWdodHNbY3kgKiBzaWRlICsgY3hdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYSArPSBtYXNrW3NyY09mZl0gKiB3dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hc2tSZXN1bHRbc29dID0gYTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFza1Jlc3VsdDtcbn1cbmV4cG9ydCBjb25zdCBNYXNrID0gZnVuY3Rpb24gKGltYWdlRGF0YSkge1xuICAgIHZhciB0aHJlc2hvbGQgPSB0aGlzLnRocmVzaG9sZCgpLCBtYXNrID0gYmFja2dyb3VuZE1hc2soaW1hZ2VEYXRhLCB0aHJlc2hvbGQpO1xuICAgIGlmIChtYXNrKSB7XG4gICAgICAgIG1hc2sgPSBlcm9kZU1hc2sobWFzaywgaW1hZ2VEYXRhLndpZHRoLCBpbWFnZURhdGEuaGVpZ2h0KTtcbiAgICAgICAgbWFzayA9IGRpbGF0ZU1hc2sobWFzaywgaW1hZ2VEYXRhLndpZHRoLCBpbWFnZURhdGEuaGVpZ2h0KTtcbiAgICAgICAgbWFzayA9IHNtb290aEVkZ2VNYXNrKG1hc2ssIGltYWdlRGF0YS53aWR0aCwgaW1hZ2VEYXRhLmhlaWdodCk7XG4gICAgICAgIGFwcGx5TWFzayhpbWFnZURhdGEsIG1hc2spO1xuICAgIH1cbiAgICByZXR1cm4gaW1hZ2VEYXRhO1xufTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKE5vZGUsICd0aHJlc2hvbGQnLCAwLCBnZXROdW1iZXJWYWxpZGF0b3IoKSwgRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XG4iLCJpbXBvcnQgeyBGYWN0b3J5IH0gZnJvbSAnLi4vRmFjdG9yeS5qcyc7XG5pbXBvcnQgeyBOb2RlIH0gZnJvbSAnLi4vTm9kZS5qcyc7XG5pbXBvcnQgeyBnZXROdW1iZXJWYWxpZGF0b3IgfSBmcm9tICcuLi9WYWxpZGF0b3JzLmpzJztcbmV4cG9ydCBjb25zdCBOb2lzZSA9IGZ1bmN0aW9uIChpbWFnZURhdGEpIHtcbiAgICB2YXIgYW1vdW50ID0gdGhpcy5ub2lzZSgpICogMjU1LCBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIG5QaXhlbHMgPSBkYXRhLmxlbmd0aCwgaGFsZiA9IGFtb3VudCAvIDIsIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IG5QaXhlbHM7IGkgKz0gNCkge1xuICAgICAgICBkYXRhW2kgKyAwXSArPSBoYWxmIC0gMiAqIGhhbGYgKiBNYXRoLnJhbmRvbSgpO1xuICAgICAgICBkYXRhW2kgKyAxXSArPSBoYWxmIC0gMiAqIGhhbGYgKiBNYXRoLnJhbmRvbSgpO1xuICAgICAgICBkYXRhW2kgKyAyXSArPSBoYWxmIC0gMiAqIGhhbGYgKiBNYXRoLnJhbmRvbSgpO1xuICAgIH1cbn07XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihOb2RlLCAnbm9pc2UnLCAwLjIsIGdldE51bWJlclZhbGlkYXRvcigpLCBGYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcbiIsImltcG9ydCB7IEZhY3RvcnkgfSBmcm9tICcuLi9GYWN0b3J5LmpzJztcbmltcG9ydCB7IFV0aWwgfSBmcm9tICcuLi9VdGlsLmpzJztcbmltcG9ydCB7IE5vZGUgfSBmcm9tICcuLi9Ob2RlLmpzJztcbmltcG9ydCB7IGdldE51bWJlclZhbGlkYXRvciB9IGZyb20gJy4uL1ZhbGlkYXRvcnMuanMnO1xuZXhwb3J0IGNvbnN0IFBpeGVsYXRlID0gZnVuY3Rpb24gKGltYWdlRGF0YSkge1xuICAgIHZhciBwaXhlbFNpemUgPSBNYXRoLmNlaWwodGhpcy5waXhlbFNpemUoKSksIHdpZHRoID0gaW1hZ2VEYXRhLndpZHRoLCBoZWlnaHQgPSBpbWFnZURhdGEuaGVpZ2h0LCB4LCB5LCBpLCByZWQsIGdyZWVuLCBibHVlLCBhbHBoYSwgbkJpbnNYID0gTWF0aC5jZWlsKHdpZHRoIC8gcGl4ZWxTaXplKSwgbkJpbnNZID0gTWF0aC5jZWlsKGhlaWdodCAvIHBpeGVsU2l6ZSksIHhCaW5TdGFydCwgeEJpbkVuZCwgeUJpblN0YXJ0LCB5QmluRW5kLCB4QmluLCB5QmluLCBwaXhlbHNJbkJpbiwgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuICAgIGlmIChwaXhlbFNpemUgPD0gMCkge1xuICAgICAgICBVdGlsLmVycm9yKCdwaXhlbFNpemUgdmFsdWUgY2FuIG5vdCBiZSA8PSAwJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh4QmluID0gMDsgeEJpbiA8IG5CaW5zWDsgeEJpbiArPSAxKSB7XG4gICAgICAgIGZvciAoeUJpbiA9IDA7IHlCaW4gPCBuQmluc1k7IHlCaW4gKz0gMSkge1xuICAgICAgICAgICAgcmVkID0gMDtcbiAgICAgICAgICAgIGdyZWVuID0gMDtcbiAgICAgICAgICAgIGJsdWUgPSAwO1xuICAgICAgICAgICAgYWxwaGEgPSAwO1xuICAgICAgICAgICAgeEJpblN0YXJ0ID0geEJpbiAqIHBpeGVsU2l6ZTtcbiAgICAgICAgICAgIHhCaW5FbmQgPSB4QmluU3RhcnQgKyBwaXhlbFNpemU7XG4gICAgICAgICAgICB5QmluU3RhcnQgPSB5QmluICogcGl4ZWxTaXplO1xuICAgICAgICAgICAgeUJpbkVuZCA9IHlCaW5TdGFydCArIHBpeGVsU2l6ZTtcbiAgICAgICAgICAgIHBpeGVsc0luQmluID0gMDtcbiAgICAgICAgICAgIGZvciAoeCA9IHhCaW5TdGFydDsgeCA8IHhCaW5FbmQ7IHggKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmICh4ID49IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHkgPSB5QmluU3RhcnQ7IHkgPCB5QmluRW5kOyB5ICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHkgPj0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpID0gKHdpZHRoICogeSArIHgpICogNDtcbiAgICAgICAgICAgICAgICAgICAgcmVkICs9IGRhdGFbaSArIDBdO1xuICAgICAgICAgICAgICAgICAgICBncmVlbiArPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgYmx1ZSArPSBkYXRhW2kgKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgYWxwaGEgKz0gZGF0YVtpICsgM107XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsc0luQmluICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVkID0gcmVkIC8gcGl4ZWxzSW5CaW47XG4gICAgICAgICAgICBncmVlbiA9IGdyZWVuIC8gcGl4ZWxzSW5CaW47XG4gICAgICAgICAgICBibHVlID0gYmx1ZSAvIHBpeGVsc0luQmluO1xuICAgICAgICAgICAgYWxwaGEgPSBhbHBoYSAvIHBpeGVsc0luQmluO1xuICAgICAgICAgICAgZm9yICh4ID0geEJpblN0YXJ0OyB4IDwgeEJpbkVuZDsgeCArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHggPj0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoeSA9IHlCaW5TdGFydDsgeSA8IHlCaW5FbmQ7IHkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeSA+PSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGkgPSAod2lkdGggKiB5ICsgeCkgKiA0O1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2kgKyAwXSA9IHJlZDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBncmVlbjtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBibHVlO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2kgKyAzXSA9IGFscGhhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5GYWN0b3J5LmFkZEdldHRlclNldHRlcihOb2RlLCAncGl4ZWxTaXplJywgOCwgZ2V0TnVtYmVyVmFsaWRhdG9yKCksIEZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuIiwiaW1wb3J0IHsgRmFjdG9yeSB9IGZyb20gJy4uL0ZhY3RvcnkuanMnO1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4uL05vZGUuanMnO1xuaW1wb3J0IHsgZ2V0TnVtYmVyVmFsaWRhdG9yIH0gZnJvbSAnLi4vVmFsaWRhdG9ycy5qcyc7XG5leHBvcnQgY29uc3QgUG9zdGVyaXplID0gZnVuY3Rpb24gKGltYWdlRGF0YSkge1xuICAgIHZhciBsZXZlbHMgPSBNYXRoLnJvdW5kKHRoaXMubGV2ZWxzKCkgKiAyNTQpICsgMSwgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBsZW4gPSBkYXRhLmxlbmd0aCwgc2NhbGUgPSAyNTUgLyBsZXZlbHMsIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGRhdGFbaV0gPSBNYXRoLmZsb29yKGRhdGFbaV0gLyBzY2FsZSkgKiBzY2FsZTtcbiAgICB9XG59O1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoTm9kZSwgJ2xldmVscycsIDAuNSwgZ2V0TnVtYmVyVmFsaWRhdG9yKCksIEZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuIiwiaW1wb3J0IHsgRmFjdG9yeSB9IGZyb20gJy4uL0ZhY3RvcnkuanMnO1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4uL05vZGUuanMnO1xuaW1wb3J0IHsgUkdCQ29tcG9uZW50IH0gZnJvbSAnLi4vVmFsaWRhdG9ycy5qcyc7XG5leHBvcnQgY29uc3QgUkdCID0gZnVuY3Rpb24gKGltYWdlRGF0YSkge1xuICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIG5QaXhlbHMgPSBkYXRhLmxlbmd0aCwgcmVkID0gdGhpcy5yZWQoKSwgZ3JlZW4gPSB0aGlzLmdyZWVuKCksIGJsdWUgPSB0aGlzLmJsdWUoKSwgaSwgYnJpZ2h0bmVzcztcbiAgICBmb3IgKGkgPSAwOyBpIDwgblBpeGVsczsgaSArPSA0KSB7XG4gICAgICAgIGJyaWdodG5lc3MgPVxuICAgICAgICAgICAgKDAuMzQgKiBkYXRhW2ldICsgMC41ICogZGF0YVtpICsgMV0gKyAwLjE2ICogZGF0YVtpICsgMl0pIC8gMjU1O1xuICAgICAgICBkYXRhW2ldID0gYnJpZ2h0bmVzcyAqIHJlZDtcbiAgICAgICAgZGF0YVtpICsgMV0gPSBicmlnaHRuZXNzICogZ3JlZW47XG4gICAgICAgIGRhdGFbaSArIDJdID0gYnJpZ2h0bmVzcyAqIGJsdWU7XG4gICAgICAgIGRhdGFbaSArIDNdID0gZGF0YVtpICsgM107XG4gICAgfVxufTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKE5vZGUsICdyZWQnLCAwLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICBpZiAodmFsID4gMjU1KSB7XG4gICAgICAgIHJldHVybiAyNTU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbCA8IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWwpO1xuICAgIH1cbn0pO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoTm9kZSwgJ2dyZWVuJywgMCwgZnVuY3Rpb24gKHZhbCkge1xuICAgIHRoaXMuX2ZpbHRlclVwVG9EYXRlID0gZmFsc2U7XG4gICAgaWYgKHZhbCA+IDI1NSkge1xuICAgICAgICByZXR1cm4gMjU1O1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWwgPCAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsKTtcbiAgICB9XG59KTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKE5vZGUsICdibHVlJywgMCwgUkdCQ29tcG9uZW50LCBGYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcbiIsImltcG9ydCB7IEZhY3RvcnkgfSBmcm9tICcuLi9GYWN0b3J5LmpzJztcbmltcG9ydCB7IE5vZGUgfSBmcm9tICcuLi9Ob2RlLmpzJztcbmltcG9ydCB7IFJHQkNvbXBvbmVudCB9IGZyb20gJy4uL1ZhbGlkYXRvcnMuanMnO1xuZXhwb3J0IGNvbnN0IFJHQkEgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XG4gICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgblBpeGVscyA9IGRhdGEubGVuZ3RoLCByZWQgPSB0aGlzLnJlZCgpLCBncmVlbiA9IHRoaXMuZ3JlZW4oKSwgYmx1ZSA9IHRoaXMuYmx1ZSgpLCBhbHBoYSA9IHRoaXMuYWxwaGEoKSwgaSwgaWE7XG4gICAgZm9yIChpID0gMDsgaSA8IG5QaXhlbHM7IGkgKz0gNCkge1xuICAgICAgICBpYSA9IDEgLSBhbHBoYTtcbiAgICAgICAgZGF0YVtpXSA9IHJlZCAqIGFscGhhICsgZGF0YVtpXSAqIGlhO1xuICAgICAgICBkYXRhW2kgKyAxXSA9IGdyZWVuICogYWxwaGEgKyBkYXRhW2kgKyAxXSAqIGlhO1xuICAgICAgICBkYXRhW2kgKyAyXSA9IGJsdWUgKiBhbHBoYSArIGRhdGFbaSArIDJdICogaWE7XG4gICAgfVxufTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKE5vZGUsICdyZWQnLCAwLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICBpZiAodmFsID4gMjU1KSB7XG4gICAgICAgIHJldHVybiAyNTU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbCA8IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWwpO1xuICAgIH1cbn0pO1xuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoTm9kZSwgJ2dyZWVuJywgMCwgZnVuY3Rpb24gKHZhbCkge1xuICAgIHRoaXMuX2ZpbHRlclVwVG9EYXRlID0gZmFsc2U7XG4gICAgaWYgKHZhbCA+IDI1NSkge1xuICAgICAgICByZXR1cm4gMjU1O1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWwgPCAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsKTtcbiAgICB9XG59KTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKE5vZGUsICdibHVlJywgMCwgUkdCQ29tcG9uZW50LCBGYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKE5vZGUsICdhbHBoYScsIDEsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLl9maWx0ZXJVcFRvRGF0ZSA9IGZhbHNlO1xuICAgIGlmICh2YWwgPiAxKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWwgPCAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG59KTtcbiIsImV4cG9ydCBjb25zdCBTZXBpYSA9IGZ1bmN0aW9uIChpbWFnZURhdGEpIHtcbiAgICB2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBuUGl4ZWxzID0gZGF0YS5sZW5ndGgsIGksIHIsIGcsIGI7XG4gICAgZm9yIChpID0gMDsgaSA8IG5QaXhlbHM7IGkgKz0gNCkge1xuICAgICAgICByID0gZGF0YVtpICsgMF07XG4gICAgICAgIGcgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgYiA9IGRhdGFbaSArIDJdO1xuICAgICAgICBkYXRhW2kgKyAwXSA9IE1hdGgubWluKDI1NSwgciAqIDAuMzkzICsgZyAqIDAuNzY5ICsgYiAqIDAuMTg5KTtcbiAgICAgICAgZGF0YVtpICsgMV0gPSBNYXRoLm1pbigyNTUsIHIgKiAwLjM0OSArIGcgKiAwLjY4NiArIGIgKiAwLjE2OCk7XG4gICAgICAgIGRhdGFbaSArIDJdID0gTWF0aC5taW4oMjU1LCByICogMC4yNzIgKyBnICogMC41MzQgKyBiICogMC4xMzEpO1xuICAgIH1cbn07XG4iLCJleHBvcnQgY29uc3QgU29sYXJpemUgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XG4gICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgdyA9IGltYWdlRGF0YS53aWR0aCwgaCA9IGltYWdlRGF0YS5oZWlnaHQsIHc0ID0gdyAqIDQsIHkgPSBoO1xuICAgIGRvIHtcbiAgICAgICAgdmFyIG9mZnNldFkgPSAoeSAtIDEpICogdzQ7XG4gICAgICAgIHZhciB4ID0gdztcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IG9mZnNldFkgKyAoeCAtIDEpICogNDtcbiAgICAgICAgICAgIHZhciByID0gZGF0YVtvZmZzZXRdO1xuICAgICAgICAgICAgdmFyIGcgPSBkYXRhW29mZnNldCArIDFdO1xuICAgICAgICAgICAgdmFyIGIgPSBkYXRhW29mZnNldCArIDJdO1xuICAgICAgICAgICAgaWYgKHIgPiAxMjcpIHtcbiAgICAgICAgICAgICAgICByID0gMjU1IC0gcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnID4gMTI3KSB7XG4gICAgICAgICAgICAgICAgZyA9IDI1NSAtIGc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYiA+IDEyNykge1xuICAgICAgICAgICAgICAgIGIgPSAyNTUgLSBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YVtvZmZzZXRdID0gcjtcbiAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgMV0gPSBnO1xuICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAyXSA9IGI7XG4gICAgICAgIH0gd2hpbGUgKC0teCk7XG4gICAgfSB3aGlsZSAoLS15KTtcbn07XG4iLCJpbXBvcnQgeyBGYWN0b3J5IH0gZnJvbSAnLi4vRmFjdG9yeS5qcyc7XG5pbXBvcnQgeyBOb2RlIH0gZnJvbSAnLi4vTm9kZS5qcyc7XG5pbXBvcnQgeyBnZXROdW1iZXJWYWxpZGF0b3IgfSBmcm9tICcuLi9WYWxpZGF0b3JzLmpzJztcbmV4cG9ydCBjb25zdCBUaHJlc2hvbGQgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XG4gICAgdmFyIGxldmVsID0gdGhpcy50aHJlc2hvbGQoKSAqIDI1NSwgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBsZW4gPSBkYXRhLmxlbmd0aCwgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgZGF0YVtpXSA9IGRhdGFbaV0gPCBsZXZlbCA/IDAgOiAyNTU7XG4gICAgfVxufTtcbkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKE5vZGUsICd0aHJlc2hvbGQnLCAwLjUsIGdldE51bWJlclZhbGlkYXRvcigpLCBGYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcbiIsImltcG9ydCB7IEtvbnZhIGFzIENvcmUgfSBmcm9tICcuL19Db3JlSW50ZXJuYWxzLmpzJztcbmltcG9ydCB7IEFyYyB9IGZyb20gJy4vc2hhcGVzL0FyYy5qcyc7XG5pbXBvcnQgeyBBcnJvdyB9IGZyb20gJy4vc2hhcGVzL0Fycm93LmpzJztcbmltcG9ydCB7IENpcmNsZSB9IGZyb20gJy4vc2hhcGVzL0NpcmNsZS5qcyc7XG5pbXBvcnQgeyBFbGxpcHNlIH0gZnJvbSAnLi9zaGFwZXMvRWxsaXBzZS5qcyc7XG5pbXBvcnQgeyBJbWFnZSB9IGZyb20gJy4vc2hhcGVzL0ltYWdlLmpzJztcbmltcG9ydCB7IExhYmVsLCBUYWcgfSBmcm9tICcuL3NoYXBlcy9MYWJlbC5qcyc7XG5pbXBvcnQgeyBMaW5lIH0gZnJvbSAnLi9zaGFwZXMvTGluZS5qcyc7XG5pbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi9zaGFwZXMvUGF0aC5qcyc7XG5pbXBvcnQgeyBSZWN0IH0gZnJvbSAnLi9zaGFwZXMvUmVjdC5qcyc7XG5pbXBvcnQgeyBSZWd1bGFyUG9seWdvbiB9IGZyb20gJy4vc2hhcGVzL1JlZ3VsYXJQb2x5Z29uLmpzJztcbmltcG9ydCB7IFJpbmcgfSBmcm9tICcuL3NoYXBlcy9SaW5nLmpzJztcbmltcG9ydCB7IFNwcml0ZSB9IGZyb20gJy4vc2hhcGVzL1Nwcml0ZS5qcyc7XG5pbXBvcnQgeyBTdGFyIH0gZnJvbSAnLi9zaGFwZXMvU3Rhci5qcyc7XG5pbXBvcnQgeyBUZXh0IH0gZnJvbSAnLi9zaGFwZXMvVGV4dC5qcyc7XG5pbXBvcnQgeyBUZXh0UGF0aCB9IGZyb20gJy4vc2hhcGVzL1RleHRQYXRoLmpzJztcbmltcG9ydCB7IFRyYW5zZm9ybWVyIH0gZnJvbSAnLi9zaGFwZXMvVHJhbnNmb3JtZXIuanMnO1xuaW1wb3J0IHsgV2VkZ2UgfSBmcm9tICcuL3NoYXBlcy9XZWRnZS5qcyc7XG5pbXBvcnQgeyBCbHVyIH0gZnJvbSAnLi9maWx0ZXJzL0JsdXIuanMnO1xuaW1wb3J0IHsgQnJpZ2h0ZW4gfSBmcm9tICcuL2ZpbHRlcnMvQnJpZ2h0ZW4uanMnO1xuaW1wb3J0IHsgQ29udHJhc3QgfSBmcm9tICcuL2ZpbHRlcnMvQ29udHJhc3QuanMnO1xuaW1wb3J0IHsgRW1ib3NzIH0gZnJvbSAnLi9maWx0ZXJzL0VtYm9zcy5qcyc7XG5pbXBvcnQgeyBFbmhhbmNlIH0gZnJvbSAnLi9maWx0ZXJzL0VuaGFuY2UuanMnO1xuaW1wb3J0IHsgR3JheXNjYWxlIH0gZnJvbSAnLi9maWx0ZXJzL0dyYXlzY2FsZS5qcyc7XG5pbXBvcnQgeyBIU0wgfSBmcm9tICcuL2ZpbHRlcnMvSFNMLmpzJztcbmltcG9ydCB7IEhTViB9IGZyb20gJy4vZmlsdGVycy9IU1YuanMnO1xuaW1wb3J0IHsgSW52ZXJ0IH0gZnJvbSAnLi9maWx0ZXJzL0ludmVydC5qcyc7XG5pbXBvcnQgeyBLYWxlaWRvc2NvcGUgfSBmcm9tICcuL2ZpbHRlcnMvS2FsZWlkb3Njb3BlLmpzJztcbmltcG9ydCB7IE1hc2sgfSBmcm9tICcuL2ZpbHRlcnMvTWFzay5qcyc7XG5pbXBvcnQgeyBOb2lzZSB9IGZyb20gJy4vZmlsdGVycy9Ob2lzZS5qcyc7XG5pbXBvcnQgeyBQaXhlbGF0ZSB9IGZyb20gJy4vZmlsdGVycy9QaXhlbGF0ZS5qcyc7XG5pbXBvcnQgeyBQb3N0ZXJpemUgfSBmcm9tICcuL2ZpbHRlcnMvUG9zdGVyaXplLmpzJztcbmltcG9ydCB7IFJHQiB9IGZyb20gJy4vZmlsdGVycy9SR0IuanMnO1xuaW1wb3J0IHsgUkdCQSB9IGZyb20gJy4vZmlsdGVycy9SR0JBLmpzJztcbmltcG9ydCB7IFNlcGlhIH0gZnJvbSAnLi9maWx0ZXJzL1NlcGlhLmpzJztcbmltcG9ydCB7IFNvbGFyaXplIH0gZnJvbSAnLi9maWx0ZXJzL1NvbGFyaXplLmpzJztcbmltcG9ydCB7IFRocmVzaG9sZCB9IGZyb20gJy4vZmlsdGVycy9UaHJlc2hvbGQuanMnO1xuZXhwb3J0IGNvbnN0IEtvbnZhID0gQ29yZS5VdGlsLl9hc3NpZ24oQ29yZSwge1xuICAgIEFyYyxcbiAgICBBcnJvdyxcbiAgICBDaXJjbGUsXG4gICAgRWxsaXBzZSxcbiAgICBJbWFnZSxcbiAgICBMYWJlbCxcbiAgICBUYWcsXG4gICAgTGluZSxcbiAgICBQYXRoLFxuICAgIFJlY3QsXG4gICAgUmVndWxhclBvbHlnb24sXG4gICAgUmluZyxcbiAgICBTcHJpdGUsXG4gICAgU3RhcixcbiAgICBUZXh0LFxuICAgIFRleHRQYXRoLFxuICAgIFRyYW5zZm9ybWVyLFxuICAgIFdlZGdlLFxuICAgIEZpbHRlcnM6IHtcbiAgICAgICAgQmx1cixcbiAgICAgICAgQnJpZ2h0ZW4sXG4gICAgICAgIENvbnRyYXN0LFxuICAgICAgICBFbWJvc3MsXG4gICAgICAgIEVuaGFuY2UsXG4gICAgICAgIEdyYXlzY2FsZSxcbiAgICAgICAgSFNMLFxuICAgICAgICBIU1YsXG4gICAgICAgIEludmVydCxcbiAgICAgICAgS2FsZWlkb3Njb3BlLFxuICAgICAgICBNYXNrLFxuICAgICAgICBOb2lzZSxcbiAgICAgICAgUGl4ZWxhdGUsXG4gICAgICAgIFBvc3Rlcml6ZSxcbiAgICAgICAgUkdCLFxuICAgICAgICBSR0JBLFxuICAgICAgICBTZXBpYSxcbiAgICAgICAgU29sYXJpemUsXG4gICAgICAgIFRocmVzaG9sZCxcbiAgICB9LFxufSk7XG4iLCJpbXBvcnQgeyBLb252YSB9IGZyb20gJy4vX0Z1bGxJbnRlcm5hbHMuanMnO1xuZXhwb3J0IGRlZmF1bHQgS29udmE7XG4iLCJleHBvcnQgeyBLb252YSB9IGZyb20gJy4vX0NvcmVJbnRlcm5hbHMuanMnO1xuaW1wb3J0IHsgS29udmEgfSBmcm9tICcuL19Db3JlSW50ZXJuYWxzLmpzJztcbmV4cG9ydCBkZWZhdWx0IEtvbnZhO1xuIiwiaW1wb3J0IHsgS29udmEgfSBmcm9tICdrb252YS9saWIvR2xvYmFsJztcbmNvbnN0IHByb3BzVG9Ta2lwID0ge1xuICAgIGNoaWxkcmVuOiB0cnVlLFxuICAgIHJlZjogdHJ1ZSxcbiAgICBrZXk6IHRydWUsXG4gICAgc3R5bGU6IHRydWUsXG4gICAgZm9yd2FyZGVkUmVmOiB0cnVlLFxuICAgIHVuc3RhYmxlX2FwcGx5Q2FjaGU6IHRydWUsXG4gICAgdW5zdGFibGVfYXBwbHlEcmF3SGl0RnJvbUNhY2hlOiB0cnVlLFxufTtcbmxldCB6SW5kZXhXYXJuaW5nU2hvd2VkID0gZmFsc2U7XG5sZXQgZHJhZ1dhcm5pbmdTaG93ZWQgPSBmYWxzZTtcbmV4cG9ydCBjb25zdCBFVkVOVFNfTkFNRVNQQUNFID0gJy5yZWFjdC1rb252YS1ldmVudCc7XG5sZXQgdXNlU3RyaWN0TW9kZSA9IGZhbHNlO1xuZXhwb3J0IGZ1bmN0aW9uIHRvZ2dsZVN0cmljdE1vZGUodmFsdWUpIHtcbiAgICB1c2VTdHJpY3RNb2RlID0gdmFsdWU7XG59XG5jb25zdCBEUkFHR0FCTEVfV0FSTklORyA9IGBSZWFjdEtvbnZhOiBZb3UgaGF2ZSBhIEtvbnZhIG5vZGUgd2l0aCBkcmFnZ2FibGUgPSB0cnVlIGFuZCBwb3NpdGlvbiBkZWZpbmVkIGJ1dCBubyBvbkRyYWdNb3ZlIG9yIG9uRHJhZ0VuZCBldmVudHMgYXJlIGhhbmRsZWQuXG5Qb3NpdGlvbiBvZiBhIG5vZGUgd2lsbCBiZSBjaGFuZ2VkIGR1cmluZyBkcmFnJmRyb3AsIHNvIHlvdSBzaG91bGQgdXBkYXRlIHN0YXRlIG9mIHRoZSByZWFjdCBhcHAgYXMgd2VsbC5cbkNvbnNpZGVyIHRvIGFkZCBvbkRyYWdNb3ZlIG9yIG9uRHJhZ0VuZCBldmVudHMuXG5Gb3IgbW9yZSBpbmZvIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2tvbnZhanMvcmVhY3Qta29udmEvaXNzdWVzLzI1NlxuYDtcbmNvbnN0IFpfSU5ERVhfV0FSTklORyA9IGBSZWFjdEtvbnZhOiBZb3UgYXJlIHVzaW5nIFwiekluZGV4XCIgYXR0cmlidXRlIGZvciBhIEtvbnZhIG5vZGUuXG5yZWFjdC1rb252YSBtYXkgZ2V0IGNvbmZ1c2VkIHdpdGggb3JkZXJpbmcuIEp1c3QgZGVmaW5lIGNvcnJlY3Qgb3JkZXIgb2YgZWxlbWVudHMgaW4geW91ciByZW5kZXIgZnVuY3Rpb24gb2YgYSBjb21wb25lbnQuXG5Gb3IgbW9yZSBpbmZvIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2tvbnZhanMvcmVhY3Qta29udmEvaXNzdWVzLzE5NFxuYDtcbmNvbnN0IEVNUFRZX1BST1BTID0ge307XG5leHBvcnQgZnVuY3Rpb24gYXBwbHlOb2RlUHJvcHMoaW5zdGFuY2UsIHByb3BzLCBvbGRQcm9wcyA9IEVNUFRZX1BST1BTKSB7XG4gICAgaWYgKHByb3BzID09PSBvbGRQcm9wcykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdzYW1lIHByb3BzJyk7XG4gICAgfVxuICAgIC8vIGRvbid0IHVzZSB6SW5kZXggaW4gcmVhY3Qta29udmFcbiAgICBpZiAoIXpJbmRleFdhcm5pbmdTaG93ZWQgJiYgJ3pJbmRleCcgaW4gcHJvcHMpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFpfSU5ERVhfV0FSTklORyk7XG4gICAgICAgIHpJbmRleFdhcm5pbmdTaG93ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBjaGVjayBjb3JyZWN0IGRyYWdnYWJsZSB1c2FnZVxuICAgIGlmICghZHJhZ1dhcm5pbmdTaG93ZWQgJiYgcHJvcHMuZHJhZ2dhYmxlKSB7XG4gICAgICAgIHZhciBoYXNQb3NpdGlvbiA9IHByb3BzLnggIT09IHVuZGVmaW5lZCB8fCBwcm9wcy55ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBoYXNFdmVudHMgPSBwcm9wcy5vbkRyYWdFbmQgfHwgcHJvcHMub25EcmFnTW92ZTtcbiAgICAgICAgaWYgKGhhc1Bvc2l0aW9uICYmICFoYXNFdmVudHMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihEUkFHR0FCTEVfV0FSTklORyk7XG4gICAgICAgICAgICBkcmFnV2FybmluZ1Nob3dlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY2hlY2sgb2xkIHByb3BzXG4gICAgLy8gd2UgbmVlZCB0byB1bnNldCBwcm9wZXJ0aWVzIHRoYXQgYXJlIG5vdCBpbiBuZXcgcHJvcHNcbiAgICAvLyBhbmQgcmVtb3ZlIGFsbCBldmVudHNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzVG9Ta2lwW2tleV0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc0V2ZW50ID0ga2V5LnNsaWNlKDAsIDIpID09PSAnb24nO1xuICAgICAgICB2YXIgcHJvcENoYW5nZWQgPSBvbGRQcm9wc1trZXldICE9PSBwcm9wc1trZXldO1xuICAgICAgICAvLyBpZiB0aGF0IGlzIGEgY2hhbmdlZCBldmVudCwgd2UgbmVlZCB0byByZW12b2UgaXRcbiAgICAgICAgaWYgKGlzRXZlbnQgJiYgcHJvcENoYW5nZWQpIHtcbiAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSBrZXkuc3Vic3RyKDIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lLnN1YnN0cigwLCA3KSA9PT0gJ2NvbnRlbnQnKSB7XG4gICAgICAgICAgICAgICAgZXZlbnROYW1lID1cbiAgICAgICAgICAgICAgICAgICAgJ2NvbnRlbnQnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZS5zdWJzdHIoNywgMSkudG9VcHBlckNhc2UoKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudE5hbWUuc3Vic3RyKDgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdGFuY2Uub2ZmKGV2ZW50TmFtZSwgb2xkUHJvcHNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvUmVtb3ZlID0gIXByb3BzLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICAgIGlmICh0b1JlbW92ZSkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0QXR0cihrZXksIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHN0cmljdFVwZGF0ZSA9IHVzZVN0cmljdE1vZGUgfHwgcHJvcHMuX3VzZVN0cmljdE1vZGU7XG4gICAgdmFyIHVwZGF0ZWRQcm9wcyA9IHt9O1xuICAgIHZhciBoYXNVcGRhdGVzID0gZmFsc2U7XG4gICAgY29uc3QgbmV3RXZlbnRzID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1RvU2tpcFtrZXldKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNFdmVudCA9IGtleS5zbGljZSgwLCAyKSA9PT0gJ29uJztcbiAgICAgICAgdmFyIHRvQWRkID0gb2xkUHJvcHNba2V5XSAhPT0gcHJvcHNba2V5XTtcbiAgICAgICAgaWYgKGlzRXZlbnQgJiYgdG9BZGQpIHtcbiAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSBrZXkuc3Vic3RyKDIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lLnN1YnN0cigwLCA3KSA9PT0gJ2NvbnRlbnQnKSB7XG4gICAgICAgICAgICAgICAgZXZlbnROYW1lID1cbiAgICAgICAgICAgICAgICAgICAgJ2NvbnRlbnQnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZS5zdWJzdHIoNywgMSkudG9VcHBlckNhc2UoKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudE5hbWUuc3Vic3RyKDgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2hlY2sgdGhhdCBldmVudCBpcyBub3QgdW5kZWZpbmVkXG4gICAgICAgICAgICBpZiAocHJvcHNba2V5XSkge1xuICAgICAgICAgICAgICAgIG5ld0V2ZW50c1tldmVudE5hbWVdID0gcHJvcHNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRXZlbnQgJiZcbiAgICAgICAgICAgIChwcm9wc1trZXldICE9PSBvbGRQcm9wc1trZXldIHx8XG4gICAgICAgICAgICAgICAgKHN0cmljdFVwZGF0ZSAmJiBwcm9wc1trZXldICE9PSBpbnN0YW5jZS5nZXRBdHRyKGtleSkpKSkge1xuICAgICAgICAgICAgaGFzVXBkYXRlcyA9IHRydWU7XG4gICAgICAgICAgICB1cGRhdGVkUHJvcHNba2V5XSA9IHByb3BzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc1VwZGF0ZXMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0QXR0cnModXBkYXRlZFByb3BzKTtcbiAgICAgICAgdXBkYXRlUGljdHVyZShpbnN0YW5jZSk7XG4gICAgfVxuICAgIC8vIHN1YnNjcmliZSB0byBldmVudHMgQUZURVIgd2Ugc2V0IGF0dHJzXG4gICAgLy8gd2UgbmVlZCBpdCB0byBmaXggaHR0cHM6Ly9naXRodWIuY29tL2tvbnZhanMvcmVhY3Qta29udmEvaXNzdWVzLzQ3MVxuICAgIC8vIHNldHRpbmdzIGF0dHJzIG1heSBhZGQgZXZlbnRzLiBMaWtlIFwiZHJhZ2dhYmxlOiB0cnVlXCIgd2lsbCBhZGQgXCJtb3VzZWRvd25cIiBsaXN0ZW5lclxuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBuZXdFdmVudHMpIHtcbiAgICAgICAgaW5zdGFuY2Uub24oZXZlbnROYW1lICsgRVZFTlRTX05BTUVTUEFDRSwgbmV3RXZlbnRzW2V2ZW50TmFtZV0pO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVQaWN0dXJlKG5vZGUpIHtcbiAgICBpZiAoIUtvbnZhLmF1dG9EcmF3RW5hYmxlZCkge1xuICAgICAgICB2YXIgZHJhd2luZ05vZGUgPSBub2RlLmdldExheWVyKCkgfHwgbm9kZS5nZXRTdGFnZSgpO1xuICAgICAgICBkcmF3aW5nTm9kZSAmJiBkcmF3aW5nTm9kZS5iYXRjaERyYXcoKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgS29udmEgZnJvbSAna29udmEvbGliL0NvcmUnO1xuaW1wb3J0IHsgYXBwbHlOb2RlUHJvcHMsIHVwZGF0ZVBpY3R1cmUsIEVWRU5UU19OQU1FU1BBQ0UgfSBmcm9tICcuL21ha2VVcGRhdGVzJztcbmV4cG9ydCB7IHVuc3RhYmxlX25vdyBhcyBub3csIHVuc3RhYmxlX0lkbGVQcmlvcml0eSBhcyBpZGxlUHJpb3JpdHksIHVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSBhcyBydW4sIH0gZnJvbSAnc2NoZWR1bGVyJztcbmltcG9ydCB7IERlZmF1bHRFdmVudFByaW9yaXR5IH0gZnJvbSAncmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMnO1xuY29uc3QgTk9fQ09OVEVYVCA9IHt9O1xuY29uc3QgVVBEQVRFX1NJR05BTCA9IHt9O1xuLy8gZm9yIHJlYWN0LXNwcmluZyBjYXBhYmlsaXR5XG5Lb252YS5Ob2RlLnByb3RvdHlwZS5fYXBwbHlQcm9wcyA9IGFwcGx5Tm9kZVByb3BzO1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBOb29wIGZvciBzdHJpbmcgY2hpbGRyZW4gb2YgVGV4dCAoZWcgPFRleHQ+Zm9vPC9UZXh0PilcbiAgICAgICAgY29uc29sZS5lcnJvcihgRG8gbm90IHVzZSBwbGFpbiB0ZXh0IGFzIGNoaWxkIG9mIEtvbnZhLk5vZGUuIFlvdSBhcmUgdXNpbmcgdGV4dDogJHtjaGlsZH1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwYXJlbnRJbnN0YW5jZS5hZGQoY2hpbGQpO1xuICAgIHVwZGF0ZVBpY3R1cmUocGFyZW50SW5zdGFuY2UpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKHR5cGUsIHByb3BzLCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgbGV0IE5vZGVDbGFzcyA9IEtvbnZhW3R5cGVdO1xuICAgIGlmICghTm9kZUNsYXNzKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEtvbnZhIGhhcyBubyBub2RlIHdpdGggdGhlIHR5cGUgJHt0eXBlfS4gR3JvdXAgd2lsbCBiZSB1c2VkIGluc3RlYWQuIElmIHlvdSB1c2UgbWluaW1hbCB2ZXJzaW9uIG9mIHJlYWN0LWtvbnZhLCBqdXN0IGltcG9ydCByZXF1aXJlZCBub2RlcyBpbnRvIEtvbnZhOiBcImltcG9ydCBcImtvbnZhL2xpYi9zaGFwZXMvJHt0eXBlfVwiICBJZiB5b3Ugd2FudCB0byByZW5kZXIgRE9NIGVsZW1lbnRzIGFzIHBhcnQgb2YgY2FudmFzIHRyZWUgdGFrZSBhIGxvb2sgaW50byB0aGlzIGRlbW86IGh0dHBzOi8va29udmFqcy5naXRodWIuaW8vZG9jcy9yZWFjdC9ET01fUG9ydGFsLmh0bWxgKTtcbiAgICAgICAgTm9kZUNsYXNzID0gS29udmEuR3JvdXA7XG4gICAgfVxuICAgIC8vIHdlIG5lZWQgdG8gc3BsaXQgcHJvcHMgaW50byBldmVudHMgYW5kIG5vbiBldmVudHNcbiAgICAvLyB3ZSB3ZSBjYW4gcGFzcyBub24gZXZlbnRzIGludG8gY29uc3RydWN0b3IgZGlyZWN0bHlcbiAgICAvLyB0aGF0IHdheSB0aGUgcGVyZm9ybWFuY2Ugc2hvdWxkIGJlIGJldHRlclxuICAgIC8vIHdlIHdlIGFwcGx5IGNoYW5nZSBcImFwcGx5Tm9kZVByb3BzXCJcbiAgICAvLyB0aGVuIGl0IHdpbGwgdHJpZ2dlciBjaGFuZ2UgZXZlbnRzIG9uIGZpcnN0IHJ1blxuICAgIC8vIGJ1dCB3ZSBkb24ndCBuZWVkIHRoZW0hXG4gICAgY29uc3QgcHJvcHNXaXRob3V0RXZlbnRzID0ge307XG4gICAgY29uc3QgcHJvcHNXaXRoT25seUV2ZW50cyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgICB2YXIgaXNFdmVudCA9IGtleS5zbGljZSgwLCAyKSA9PT0gJ29uJztcbiAgICAgICAgaWYgKGlzRXZlbnQpIHtcbiAgICAgICAgICAgIHByb3BzV2l0aE9ubHlFdmVudHNba2V5XSA9IHByb3BzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcm9wc1dpdGhvdXRFdmVudHNba2V5XSA9IHByb3BzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgTm9kZUNsYXNzKHByb3BzV2l0aG91dEV2ZW50cyk7XG4gICAgYXBwbHlOb2RlUHJvcHMoaW5zdGFuY2UsIHByb3BzV2l0aE9ubHlFdmVudHMpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUZXh0SW5zdGFuY2UodGV4dCwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgY29uc29sZS5lcnJvcihgVGV4dCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBub3cgaW4gUmVhY3RLb252YS4gWW91ciB0ZXh0IGlzOiBcIiR7dGV4dH1cImApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKGRvbUVsZW1lbnQsIHR5cGUsIHByb3BzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFB1YmxpY0luc3RhbmNlKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVGb3JDb21taXQoKSB7XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZVBvcnRhbE1vdW50KCkge1xuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVVcGRhdGUoZG9tRWxlbWVudCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgcmV0dXJuIFVQREFURV9TSUdOQUw7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVzZXRBZnRlckNvbW1pdCgpIHtcbiAgICAvLyBOb29wXG59XG5leHBvcnQgZnVuY3Rpb24gcmVzZXRUZXh0Q29udGVudChkb21FbGVtZW50KSB7XG4gICAgLy8gTm9vcFxufVxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUodHlwZSwgcHJvcHMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Um9vdEhvc3RDb250ZXh0KCkge1xuICAgIHJldHVybiBOT19DT05URVhUO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldENoaWxkSG9zdENvbnRleHQoKSB7XG4gICAgcmV0dXJuIE5PX0NPTlRFWFQ7XG59XG5leHBvcnQgY29uc3Qgc2NoZWR1bGVUaW1lb3V0ID0gc2V0VGltZW91dDtcbmV4cG9ydCBjb25zdCBjYW5jZWxUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuZXhwb3J0IGNvbnN0IG5vVGltZW91dCA9IC0xO1xuLy8gZXhwb3J0IGNvbnN0IHNjaGVkdWxlUGFzc2l2ZUVmZmVjdHMgPSBzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2s7XG4vLyBleHBvcnQgY29uc3QgY2FuY2VsUGFzc2l2ZUVmZmVjdHMgPSBjYW5jZWxEZWZlcnJlZENhbGxiYWNrO1xuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIHByb3BzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gVGhlIEtvbnZhIHJlbmRlcmVyIGlzIHNlY29uZGFyeSB0byB0aGUgUmVhY3QgRE9NIHJlbmRlcmVyLlxuZXhwb3J0IGNvbnN0IGlzUHJpbWFyeVJlbmRlcmVyID0gZmFsc2U7XG5leHBvcnQgY29uc3Qgd2FybnNJZk5vdEFjdGluZyA9IHRydWU7XG5leHBvcnQgY29uc3Qgc3VwcG9ydHNNdXRhdGlvbiA9IHRydWU7XG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkLnBhcmVudCA9PT0gcGFyZW50SW5zdGFuY2UpIHtcbiAgICAgICAgY2hpbGQubW92ZVRvVG9wKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwYXJlbnRJbnN0YW5jZS5hZGQoY2hpbGQpO1xuICAgIH1cbiAgICB1cGRhdGVQaWN0dXJlKHBhcmVudEluc3RhbmNlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICAgIGlmIChjaGlsZC5wYXJlbnQgPT09IHBhcmVudEluc3RhbmNlKSB7XG4gICAgICAgIGNoaWxkLm1vdmVUb1RvcCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGFyZW50SW5zdGFuY2UuYWRkKGNoaWxkKTtcbiAgICB9XG4gICAgdXBkYXRlUGljdHVyZShwYXJlbnRJbnN0YW5jZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgICAvLyBjaGlsZC5fcmVtb3ZlKCkgd2lsbCBub3Qgc3RvcCBkcmFnZ2luZ1xuICAgIC8vIGJ1dCBjaGlsZC5yZW1vdmUoKSB3aWxsIHN0b3AgaXQsIGJ1dCB3ZSBkb24ndCBuZWVkIGl0XG4gICAgLy8gcmVtb3Zpbmcgd2lsbCByZXNldCB6SW5kZXhlc1xuICAgIGNoaWxkLl9yZW1vdmUoKTtcbiAgICBwYXJlbnRJbnN0YW5jZS5hZGQoY2hpbGQpO1xuICAgIGNoaWxkLnNldFpJbmRleChiZWZvcmVDaGlsZC5nZXRaSW5kZXgoKSk7XG4gICAgdXBkYXRlUGljdHVyZShwYXJlbnRJbnN0YW5jZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0SW5Db250YWluZXJCZWZvcmUocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICAgIGluc2VydEJlZm9yZShwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGJlZm9yZUNoaWxkKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDaGlsZChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgICBjaGlsZC5kZXN0cm95KCk7XG4gICAgY2hpbGQub2ZmKEVWRU5UU19OQU1FU1BBQ0UpO1xuICAgIHVwZGF0ZVBpY3R1cmUocGFyZW50SW5zdGFuY2UpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcihwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgICBjaGlsZC5kZXN0cm95KCk7XG4gICAgY2hpbGQub2ZmKEVWRU5UU19OQU1FU1BBQ0UpO1xuICAgIHVwZGF0ZVBpY3R1cmUocGFyZW50SW5zdGFuY2UpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbW1pdFRleHRVcGRhdGUodGV4dEluc3RhbmNlLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgY29uc29sZS5lcnJvcihgVGV4dCBjb21wb25lbnRzIGFyZSBub3QgeWV0IHN1cHBvcnRlZCBpbiBSZWFjdEtvbnZhLiBZb3UgdGV4dCBpczogXCIke25ld1RleHR9XCJgKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb21taXRNb3VudChpbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMpIHtcbiAgICAvLyBOb29wXG59XG5leHBvcnQgZnVuY3Rpb24gY29tbWl0VXBkYXRlKGluc3RhbmNlLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICBhcHBseU5vZGVQcm9wcyhpbnN0YW5jZSwgbmV3UHJvcHMsIG9sZFByb3BzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoaWRlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICBpbnN0YW5jZS5oaWRlKCk7XG4gICAgdXBkYXRlUGljdHVyZShpbnN0YW5jZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaGlkZVRleHRJbnN0YW5jZSh0ZXh0SW5zdGFuY2UpIHtcbiAgICAvLyBOb29wXG59XG5leHBvcnQgZnVuY3Rpb24gdW5oaWRlSW5zdGFuY2UoaW5zdGFuY2UsIHByb3BzKSB7XG4gICAgaWYgKHByb3BzLnZpc2libGUgPT0gbnVsbCB8fCBwcm9wcy52aXNpYmxlKSB7XG4gICAgICAgIGluc3RhbmNlLnNob3coKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gdW5oaWRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSwgdGV4dCkge1xuICAgIC8vIE5vb3Bcbn1cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICAvLyBOb29wXG59XG5leHBvcnQgZnVuY3Rpb24gZGV0YWNoRGVsZXRlZEluc3RhbmNlKCkgeyB9XG5leHBvcnQgY29uc3QgZ2V0Q3VycmVudEV2ZW50UHJpb3JpdHkgPSAoKSA9PiBEZWZhdWx0RXZlbnRQcmlvcml0eTtcbiIsIi8qKlxuICogQmFzZWQgb24gUmVhY3RBcnQuanNcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50IExhdnJlbm92IEFudG9uLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBNSVRcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBLb252YSBmcm9tICdrb252YS9saWIvQ29yZSc7XG5pbXBvcnQgUmVhY3RGaWJlclJlY29uY2lsZXIgZnJvbSAncmVhY3QtcmVjb25jaWxlcic7XG5pbXBvcnQgeyBDb25jdXJyZW50Um9vdCB9IGZyb20gJ3JlYWN0LXJlY29uY2lsZXIvY29uc3RhbnRzJztcbmltcG9ydCAqIGFzIEhvc3RDb25maWcgZnJvbSAnLi9SZWFjdEtvbnZhSG9zdENvbmZpZyc7XG5pbXBvcnQgeyBhcHBseU5vZGVQcm9wcywgdG9nZ2xlU3RyaWN0TW9kZSB9IGZyb20gJy4vbWFrZVVwZGF0ZXMnO1xuZnVuY3Rpb24gdXNlUHJldmlvdXModmFsdWUpIHtcbiAgICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZWYuY3VycmVudDtcbn1cbmNvbnN0IFN0YWdlV3JhcCA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IFJlYWN0LnVzZVJlZigpO1xuICAgIGNvbnN0IHN0YWdlID0gUmVhY3QudXNlUmVmKCk7XG4gICAgY29uc3QgZmliZXJSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgICBjb25zdCBvbGRQcm9wcyA9IHVzZVByZXZpb3VzKHByb3BzKTtcbiAgICBjb25zdCBfc2V0UmVmID0gKHN0YWdlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZm9yd2FyZGVkUmVmIH0gPSBwcm9wcztcbiAgICAgICAgaWYgKCFmb3J3YXJkZWRSZWYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZvcndhcmRlZFJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZm9yd2FyZGVkUmVmKHN0YWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvcndhcmRlZFJlZi5jdXJyZW50ID0gc3RhZ2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHN0YWdlLmN1cnJlbnQgPSBuZXcgS29udmEuU3RhZ2Uoe1xuICAgICAgICAgICAgd2lkdGg6IHByb3BzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBwcm9wcy5oZWlnaHQsXG4gICAgICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lci5jdXJyZW50LFxuICAgICAgICB9KTtcbiAgICAgICAgX3NldFJlZihzdGFnZS5jdXJyZW50KTtcbiAgICAgICAgZmliZXJSZWYuY3VycmVudCA9IEtvbnZhUmVuZGVyZXIuY3JlYXRlQ29udGFpbmVyKHN0YWdlLmN1cnJlbnQsIENvbmN1cnJlbnRSb290LCBmYWxzZSwgbnVsbCk7XG4gICAgICAgIEtvbnZhUmVuZGVyZXIudXBkYXRlQ29udGFpbmVyKHByb3BzLmNoaWxkcmVuLCBmaWJlclJlZi5jdXJyZW50KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlmICghS29udmEuaXNCcm93c2VyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3NldFJlZihudWxsKTtcbiAgICAgICAgICAgIEtvbnZhUmVuZGVyZXIudXBkYXRlQ29udGFpbmVyKG51bGwsIGZpYmVyUmVmLmN1cnJlbnQsIG51bGwpO1xuICAgICAgICAgICAgc3RhZ2UuY3VycmVudC5kZXN0cm95KCk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIF9zZXRSZWYoc3RhZ2UuY3VycmVudCk7XG4gICAgICAgIGFwcGx5Tm9kZVByb3BzKHN0YWdlLmN1cnJlbnQsIHByb3BzLCBvbGRQcm9wcyk7XG4gICAgICAgIEtvbnZhUmVuZGVyZXIudXBkYXRlQ29udGFpbmVyKHByb3BzLmNoaWxkcmVuLCBmaWJlclJlZi5jdXJyZW50LCBudWxsKTtcbiAgICB9KTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgICByZWY6IGNvbnRhaW5lcixcbiAgICAgICAgYWNjZXNzS2V5OiBwcm9wcy5hY2Nlc3NLZXksXG4gICAgICAgIGNsYXNzTmFtZTogcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgICByb2xlOiBwcm9wcy5yb2xlLFxuICAgICAgICBzdHlsZTogcHJvcHMuc3R5bGUsXG4gICAgICAgIHRhYkluZGV4OiBwcm9wcy50YWJJbmRleCxcbiAgICAgICAgdGl0bGU6IHByb3BzLnRpdGxlLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjb25zdCBMYXllciA9ICdMYXllcic7XG5leHBvcnQgY29uc3QgRmFzdExheWVyID0gJ0Zhc3RMYXllcic7XG5leHBvcnQgY29uc3QgR3JvdXAgPSAnR3JvdXAnO1xuZXhwb3J0IGNvbnN0IExhYmVsID0gJ0xhYmVsJztcbmV4cG9ydCBjb25zdCBSZWN0ID0gJ1JlY3QnO1xuZXhwb3J0IGNvbnN0IENpcmNsZSA9ICdDaXJjbGUnO1xuZXhwb3J0IGNvbnN0IEVsbGlwc2UgPSAnRWxsaXBzZSc7XG5leHBvcnQgY29uc3QgV2VkZ2UgPSAnV2VkZ2UnO1xuZXhwb3J0IGNvbnN0IExpbmUgPSAnTGluZSc7XG5leHBvcnQgY29uc3QgU3ByaXRlID0gJ1Nwcml0ZSc7XG5leHBvcnQgY29uc3QgSW1hZ2UgPSAnSW1hZ2UnO1xuZXhwb3J0IGNvbnN0IFRleHQgPSAnVGV4dCc7XG5leHBvcnQgY29uc3QgVGV4dFBhdGggPSAnVGV4dFBhdGgnO1xuZXhwb3J0IGNvbnN0IFN0YXIgPSAnU3Rhcic7XG5leHBvcnQgY29uc3QgUmluZyA9ICdSaW5nJztcbmV4cG9ydCBjb25zdCBBcmMgPSAnQXJjJztcbmV4cG9ydCBjb25zdCBUYWcgPSAnVGFnJztcbmV4cG9ydCBjb25zdCBQYXRoID0gJ1BhdGgnO1xuZXhwb3J0IGNvbnN0IFJlZ3VsYXJQb2x5Z29uID0gJ1JlZ3VsYXJQb2x5Z29uJztcbmV4cG9ydCBjb25zdCBBcnJvdyA9ICdBcnJvdyc7XG5leHBvcnQgY29uc3QgU2hhcGUgPSAnU2hhcGUnO1xuZXhwb3J0IGNvbnN0IFRyYW5zZm9ybWVyID0gJ1RyYW5zZm9ybWVyJztcbmV4cG9ydCBjb25zdCBLb252YVJlbmRlcmVyID0gUmVhY3RGaWJlclJlY29uY2lsZXIoSG9zdENvbmZpZyk7XG5Lb252YVJlbmRlcmVyLmluamVjdEludG9EZXZUb29scyh7XG4gICAgZmluZEhvc3RJbnN0YW5jZUJ5RmliZXI6ICgpID0+IG51bGwsXG4gICAgYnVuZGxlVHlwZTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IDEgOiAwLFxuICAgIHZlcnNpb246IFJlYWN0LnZlcnNpb24sXG4gICAgcmVuZGVyZXJQYWNrYWdlTmFtZTogJ3JlYWN0LWtvbnZhJyxcbn0pO1xuZXhwb3J0IGNvbnN0IFN0YWdlID0gUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFN0YWdlV3JhcCwgeyAuLi5wcm9wcywgZm9yd2FyZGVkUmVmOiByZWYgfSk7XG59KTtcbmV4cG9ydCBjb25zdCB1c2VTdHJpY3RNb2RlID0gdG9nZ2xlU3RyaWN0TW9kZTtcbiIsIi8qKlxuICogQmFzZWQgb24gUmVhY3RBcnQuanNcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50IExhdnJlbm92IEFudG9uLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBNSVRcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0ICdrb252YSc7XG5leHBvcnQgKiBmcm9tICcuL1JlYWN0S29udmFDb3JlJztcbiIsIi8qKlxuICogTUlUIExpY2Vuc2VcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIExlZSBCeXJvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cbnZhciBERUxFVEUgPSAnZGVsZXRlJztcblxuLy8gQ29uc3RhbnRzIGRlc2NyaWJpbmcgdGhlIHNpemUgb2YgdHJpZSBub2Rlcy5cbnZhciBTSElGVCA9IDU7IC8vIFJlc3VsdGVkIGluIGJlc3QgcGVyZm9ybWFuY2UgYWZ0ZXIgX19fX19fP1xudmFyIFNJWkUgPSAxIDw8IFNISUZUO1xudmFyIE1BU0sgPSBTSVpFIC0gMTtcblxuLy8gQSBjb25zaXN0ZW50IHNoYXJlZCB2YWx1ZSByZXByZXNlbnRpbmcgXCJub3Qgc2V0XCIgd2hpY2ggZXF1YWxzIG5vdGhpbmcgb3RoZXJcbi8vIHRoYW4gaXRzZWxmLCBhbmQgbm90aGluZyB0aGF0IGNvdWxkIGJlIHByb3ZpZGVkIGV4dGVybmFsbHkuXG52YXIgTk9UX1NFVCA9IHt9O1xuXG4vLyBCb29sZWFuIHJlZmVyZW5jZXMsIFJvdWdoIGVxdWl2YWxlbnQgb2YgYGJvb2wgJmAuXG5mdW5jdGlvbiBNYWtlUmVmKCkge1xuICByZXR1cm4geyB2YWx1ZTogZmFsc2UgfTtcbn1cblxuZnVuY3Rpb24gU2V0UmVmKHJlZikge1xuICBpZiAocmVmKSB7XG4gICAgcmVmLnZhbHVlID0gdHJ1ZTtcbiAgfVxufVxuXG4vLyBBIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSB2YWx1ZSByZXByZXNlbnRpbmcgYW4gXCJvd25lclwiIGZvciB0cmFuc2llbnQgd3JpdGVzXG4vLyB0byB0cmllcy4gVGhlIHJldHVybiB2YWx1ZSB3aWxsIG9ubHkgZXZlciBlcXVhbCBpdHNlbGYsIGFuZCB3aWxsIG5vdCBlcXVhbFxuLy8gdGhlIHJldHVybiBvZiBhbnkgc3Vic2VxdWVudCBjYWxsIG9mIHRoaXMgZnVuY3Rpb24uXG5mdW5jdGlvbiBPd25lcklEKCkge31cblxuZnVuY3Rpb24gZW5zdXJlU2l6ZShpdGVyKSB7XG4gIGlmIChpdGVyLnNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgIGl0ZXIuc2l6ZSA9IGl0ZXIuX19pdGVyYXRlKHJldHVyblRydWUpO1xuICB9XG4gIHJldHVybiBpdGVyLnNpemU7XG59XG5cbmZ1bmN0aW9uIHdyYXBJbmRleChpdGVyLCBpbmRleCkge1xuICAvLyBUaGlzIGltcGxlbWVudHMgXCJpcyBhcnJheSBpbmRleFwiIHdoaWNoIHRoZSBFQ01BU3RyaW5nIHNwZWMgZGVmaW5lcyBhczpcbiAgLy9cbiAgLy8gICAgIEEgU3RyaW5nIHByb3BlcnR5IG5hbWUgUCBpcyBhbiBhcnJheSBpbmRleCBpZiBhbmQgb25seSBpZlxuICAvLyAgICAgVG9TdHJpbmcoVG9VaW50MzIoUCkpIGlzIGVxdWFsIHRvIFAgYW5kIFRvVWludDMyKFApIGlzIG5vdCBlcXVhbFxuICAvLyAgICAgdG8gMl4zMuKIkjEuXG4gIC8vXG4gIC8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1hcnJheS1leG90aWMtb2JqZWN0c1xuICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgIHZhciB1aW50MzJJbmRleCA9IGluZGV4ID4+PiAwOyAvLyBOID4+PiAwIGlzIHNob3J0aGFuZCBmb3IgVG9VaW50MzJcbiAgICBpZiAoJycgKyB1aW50MzJJbmRleCAhPT0gaW5kZXggfHwgdWludDMySW5kZXggPT09IDQyOTQ5NjcyOTUpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGluZGV4ID0gdWludDMySW5kZXg7XG4gIH1cbiAgcmV0dXJuIGluZGV4IDwgMCA/IGVuc3VyZVNpemUoaXRlcikgKyBpbmRleCA6IGluZGV4O1xufVxuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gd2hvbGVTbGljZShiZWdpbiwgZW5kLCBzaXplKSB7XG4gIHJldHVybiAoXG4gICAgKChiZWdpbiA9PT0gMCAmJiAhaXNOZWcoYmVnaW4pKSB8fFxuICAgICAgKHNpemUgIT09IHVuZGVmaW5lZCAmJiBiZWdpbiA8PSAtc2l6ZSkpICYmXG4gICAgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IChzaXplICE9PSB1bmRlZmluZWQgJiYgZW5kID49IHNpemUpKVxuICApO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlQmVnaW4oYmVnaW4sIHNpemUpIHtcbiAgcmV0dXJuIHJlc29sdmVJbmRleChiZWdpbiwgc2l6ZSwgMCk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVFbmQoZW5kLCBzaXplKSB7XG4gIHJldHVybiByZXNvbHZlSW5kZXgoZW5kLCBzaXplLCBzaXplKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUluZGV4KGluZGV4LCBzaXplLCBkZWZhdWx0SW5kZXgpIHtcbiAgLy8gU2FuaXRpemUgaW5kaWNlcyB1c2luZyB0aGlzIHNob3J0aGFuZCBmb3IgVG9JbnQzMihhcmd1bWVudClcbiAgLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvaW50MzJcbiAgcmV0dXJuIGluZGV4ID09PSB1bmRlZmluZWRcbiAgICA/IGRlZmF1bHRJbmRleFxuICAgIDogaXNOZWcoaW5kZXgpXG4gICAgPyBzaXplID09PSBJbmZpbml0eVxuICAgICAgPyBzaXplXG4gICAgICA6IE1hdGgubWF4KDAsIHNpemUgKyBpbmRleCkgfCAwXG4gICAgOiBzaXplID09PSB1bmRlZmluZWQgfHwgc2l6ZSA9PT0gaW5kZXhcbiAgICA/IGluZGV4XG4gICAgOiBNYXRoLm1pbihzaXplLCBpbmRleCkgfCAwO1xufVxuXG5mdW5jdGlvbiBpc05lZyh2YWx1ZSkge1xuICAvLyBBY2NvdW50IGZvciAtMCB3aGljaCBpcyBuZWdhdGl2ZSwgYnV0IG5vdCBsZXNzIHRoYW4gMC5cbiAgcmV0dXJuIHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlID09PSAtSW5maW5pdHkpO1xufVxuXG52YXIgSVNfQ09MTEVDVElPTl9TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9JVEVSQUJMRV9fQEAnO1xuXG5mdW5jdGlvbiBpc0NvbGxlY3Rpb24obWF5YmVDb2xsZWN0aW9uKSB7XG4gIHJldHVybiBCb29sZWFuKG1heWJlQ29sbGVjdGlvbiAmJiBtYXliZUNvbGxlY3Rpb25bSVNfQ09MTEVDVElPTl9TWU1CT0xdKTtcbn1cblxudmFyIElTX0tFWUVEX1NZTUJPTCA9ICdAQF9fSU1NVVRBQkxFX0tFWUVEX19AQCc7XG5cbmZ1bmN0aW9uIGlzS2V5ZWQobWF5YmVLZXllZCkge1xuICByZXR1cm4gQm9vbGVhbihtYXliZUtleWVkICYmIG1heWJlS2V5ZWRbSVNfS0VZRURfU1lNQk9MXSk7XG59XG5cbnZhciBJU19JTkRFWEVEX1NZTUJPTCA9ICdAQF9fSU1NVVRBQkxFX0lOREVYRURfX0BAJztcblxuZnVuY3Rpb24gaXNJbmRleGVkKG1heWJlSW5kZXhlZCkge1xuICByZXR1cm4gQm9vbGVhbihtYXliZUluZGV4ZWQgJiYgbWF5YmVJbmRleGVkW0lTX0lOREVYRURfU1lNQk9MXSk7XG59XG5cbmZ1bmN0aW9uIGlzQXNzb2NpYXRpdmUobWF5YmVBc3NvY2lhdGl2ZSkge1xuICByZXR1cm4gaXNLZXllZChtYXliZUFzc29jaWF0aXZlKSB8fCBpc0luZGV4ZWQobWF5YmVBc3NvY2lhdGl2ZSk7XG59XG5cbnZhciBDb2xsZWN0aW9uID0gZnVuY3Rpb24gQ29sbGVjdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNDb2xsZWN0aW9uKHZhbHVlKSA/IHZhbHVlIDogU2VxKHZhbHVlKTtcbn07XG5cbnZhciBLZXllZENvbGxlY3Rpb24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChDb2xsZWN0aW9uKSB7XG4gIGZ1bmN0aW9uIEtleWVkQ29sbGVjdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBpc0tleWVkKHZhbHVlKSA/IHZhbHVlIDogS2V5ZWRTZXEodmFsdWUpO1xuICB9XG5cbiAgaWYgKCBDb2xsZWN0aW9uICkgS2V5ZWRDb2xsZWN0aW9uLl9fcHJvdG9fXyA9IENvbGxlY3Rpb247XG4gIEtleWVkQ29sbGVjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlICk7XG4gIEtleWVkQ29sbGVjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBLZXllZENvbGxlY3Rpb247XG5cbiAgcmV0dXJuIEtleWVkQ29sbGVjdGlvbjtcbn0oQ29sbGVjdGlvbikpO1xuXG52YXIgSW5kZXhlZENvbGxlY3Rpb24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChDb2xsZWN0aW9uKSB7XG4gIGZ1bmN0aW9uIEluZGV4ZWRDb2xsZWN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzSW5kZXhlZCh2YWx1ZSkgPyB2YWx1ZSA6IEluZGV4ZWRTZXEodmFsdWUpO1xuICB9XG5cbiAgaWYgKCBDb2xsZWN0aW9uICkgSW5kZXhlZENvbGxlY3Rpb24uX19wcm90b19fID0gQ29sbGVjdGlvbjtcbiAgSW5kZXhlZENvbGxlY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZSApO1xuICBJbmRleGVkQ29sbGVjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbmRleGVkQ29sbGVjdGlvbjtcblxuICByZXR1cm4gSW5kZXhlZENvbGxlY3Rpb247XG59KENvbGxlY3Rpb24pKTtcblxudmFyIFNldENvbGxlY3Rpb24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChDb2xsZWN0aW9uKSB7XG4gIGZ1bmN0aW9uIFNldENvbGxlY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gaXNDb2xsZWN0aW9uKHZhbHVlKSAmJiAhaXNBc3NvY2lhdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IFNldFNlcSh2YWx1ZSk7XG4gIH1cblxuICBpZiAoIENvbGxlY3Rpb24gKSBTZXRDb2xsZWN0aW9uLl9fcHJvdG9fXyA9IENvbGxlY3Rpb247XG4gIFNldENvbGxlY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZSApO1xuICBTZXRDb2xsZWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNldENvbGxlY3Rpb247XG5cbiAgcmV0dXJuIFNldENvbGxlY3Rpb247XG59KENvbGxlY3Rpb24pKTtcblxuQ29sbGVjdGlvbi5LZXllZCA9IEtleWVkQ29sbGVjdGlvbjtcbkNvbGxlY3Rpb24uSW5kZXhlZCA9IEluZGV4ZWRDb2xsZWN0aW9uO1xuQ29sbGVjdGlvbi5TZXQgPSBTZXRDb2xsZWN0aW9uO1xuXG52YXIgSVNfU0VRX1NZTUJPTCA9ICdAQF9fSU1NVVRBQkxFX1NFUV9fQEAnO1xuXG5mdW5jdGlvbiBpc1NlcShtYXliZVNlcSkge1xuICByZXR1cm4gQm9vbGVhbihtYXliZVNlcSAmJiBtYXliZVNlcVtJU19TRVFfU1lNQk9MXSk7XG59XG5cbnZhciBJU19SRUNPUkRfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfUkVDT1JEX19AQCc7XG5cbmZ1bmN0aW9uIGlzUmVjb3JkKG1heWJlUmVjb3JkKSB7XG4gIHJldHVybiBCb29sZWFuKG1heWJlUmVjb3JkICYmIG1heWJlUmVjb3JkW0lTX1JFQ09SRF9TWU1CT0xdKTtcbn1cblxuZnVuY3Rpb24gaXNJbW11dGFibGUobWF5YmVJbW11dGFibGUpIHtcbiAgcmV0dXJuIGlzQ29sbGVjdGlvbihtYXliZUltbXV0YWJsZSkgfHwgaXNSZWNvcmQobWF5YmVJbW11dGFibGUpO1xufVxuXG52YXIgSVNfT1JERVJFRF9TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9PUkRFUkVEX19AQCc7XG5cbmZ1bmN0aW9uIGlzT3JkZXJlZChtYXliZU9yZGVyZWQpIHtcbiAgcmV0dXJuIEJvb2xlYW4obWF5YmVPcmRlcmVkICYmIG1heWJlT3JkZXJlZFtJU19PUkRFUkVEX1NZTUJPTF0pO1xufVxuXG52YXIgSVRFUkFURV9LRVlTID0gMDtcbnZhciBJVEVSQVRFX1ZBTFVFUyA9IDE7XG52YXIgSVRFUkFURV9FTlRSSUVTID0gMjtcblxudmFyIFJFQUxfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5cbnZhciBJVEVSQVRPUl9TWU1CT0wgPSBSRUFMX0lURVJBVE9SX1NZTUJPTCB8fCBGQVVYX0lURVJBVE9SX1NZTUJPTDtcblxudmFyIEl0ZXJhdG9yID0gZnVuY3Rpb24gSXRlcmF0b3IobmV4dCkge1xuICB0aGlzLm5leHQgPSBuZXh0O1xufTtcblxuSXRlcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICByZXR1cm4gJ1tJdGVyYXRvcl0nO1xufTtcblxuSXRlcmF0b3IuS0VZUyA9IElURVJBVEVfS0VZUztcbkl0ZXJhdG9yLlZBTFVFUyA9IElURVJBVEVfVkFMVUVTO1xuSXRlcmF0b3IuRU5UUklFUyA9IElURVJBVEVfRU5UUklFUztcblxuSXRlcmF0b3IucHJvdG90eXBlLmluc3BlY3QgPSBJdGVyYXRvci5wcm90b3R5cGUudG9Tb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG59O1xuSXRlcmF0b3IucHJvdG90eXBlW0lURVJBVE9SX1NZTUJPTF0gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gaXRlcmF0b3JWYWx1ZSh0eXBlLCBrLCB2LCBpdGVyYXRvclJlc3VsdCkge1xuICB2YXIgdmFsdWUgPSB0eXBlID09PSAwID8gayA6IHR5cGUgPT09IDEgPyB2IDogW2ssIHZdO1xuICBpdGVyYXRvclJlc3VsdFxuICAgID8gKGl0ZXJhdG9yUmVzdWx0LnZhbHVlID0gdmFsdWUpXG4gICAgOiAoaXRlcmF0b3JSZXN1bHQgPSB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICB9KTtcbiAgcmV0dXJuIGl0ZXJhdG9yUmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpdGVyYXRvckRvbmUoKSB7XG4gIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbn1cblxuZnVuY3Rpb24gaGFzSXRlcmF0b3IobWF5YmVJdGVyYWJsZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShtYXliZUl0ZXJhYmxlKSkge1xuICAgIC8vIElFMTEgdHJpY2sgYXMgaXQgZG9lcyBub3Qgc3VwcG9ydCBgU3ltYm9sLml0ZXJhdG9yYFxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuICEhZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKTtcbn1cblxuZnVuY3Rpb24gaXNJdGVyYXRvcihtYXliZUl0ZXJhdG9yKSB7XG4gIHJldHVybiBtYXliZUl0ZXJhdG9yICYmIHR5cGVvZiBtYXliZUl0ZXJhdG9yLm5leHQgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yKGl0ZXJhYmxlKSB7XG4gIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihpdGVyYWJsZSk7XG4gIHJldHVybiBpdGVyYXRvckZuICYmIGl0ZXJhdG9yRm4uY2FsbChpdGVyYWJsZSk7XG59XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4oaXRlcmFibGUpIHtcbiAgdmFyIGl0ZXJhdG9yRm4gPVxuICAgIGl0ZXJhYmxlICYmXG4gICAgKChSRUFMX0lURVJBVE9SX1NZTUJPTCAmJiBpdGVyYWJsZVtSRUFMX0lURVJBVE9SX1NZTUJPTF0pIHx8XG4gICAgICBpdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0VudHJpZXNJdGVyYWJsZShtYXliZUl0ZXJhYmxlKSB7XG4gIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKTtcbiAgcmV0dXJuIGl0ZXJhdG9yRm4gJiYgaXRlcmF0b3JGbiA9PT0gbWF5YmVJdGVyYWJsZS5lbnRyaWVzO1xufVxuXG5mdW5jdGlvbiBpc0tleXNJdGVyYWJsZShtYXliZUl0ZXJhYmxlKSB7XG4gIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKTtcbiAgcmV0dXJuIGl0ZXJhdG9yRm4gJiYgaXRlcmF0b3JGbiA9PT0gbWF5YmVJdGVyYWJsZS5rZXlzO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICB2YWx1ZSAmJlxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlLmxlbmd0aCkgJiZcbiAgICB2YWx1ZS5sZW5ndGggPj0gMCAmJlxuICAgICh2YWx1ZS5sZW5ndGggPT09IDBcbiAgICAgID8gLy8gT25seSB7bGVuZ3RoOiAwfSBpcyBjb25zaWRlcmVkIEFycmF5LWxpa2UuXG4gICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPT09IDFcbiAgICAgIDogLy8gQW4gb2JqZWN0IGlzIG9ubHkgQXJyYXktbGlrZSBpZiBpdCBoYXMgYSBwcm9wZXJ0eSB3aGVyZSB0aGUgbGFzdCB2YWx1ZVxuICAgICAgICAvLyBpbiB0aGUgYXJyYXktbGlrZSBtYXkgYmUgZm91bmQgKHdoaWNoIGNvdWxkIGJlIHVuZGVmaW5lZCkuXG4gICAgICAgIHZhbHVlLmhhc093blByb3BlcnR5KHZhbHVlLmxlbmd0aCAtIDEpKVxuICApO1xufVxuXG52YXIgU2VxID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQ29sbGVjdGlvbikge1xuICBmdW5jdGlvbiBTZXEodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbFxuICAgICAgPyBlbXB0eVNlcXVlbmNlKClcbiAgICAgIDogaXNJbW11dGFibGUodmFsdWUpXG4gICAgICA/IHZhbHVlLnRvU2VxKClcbiAgICAgIDogc2VxRnJvbVZhbHVlKHZhbHVlKTtcbiAgfVxuXG4gIGlmICggQ29sbGVjdGlvbiApIFNlcS5fX3Byb3RvX18gPSBDb2xsZWN0aW9uO1xuICBTZXEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZSApO1xuICBTZXEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2VxO1xuXG4gIFNlcS5wcm90b3R5cGUudG9TZXEgPSBmdW5jdGlvbiB0b1NlcSAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgU2VxLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdTZXEgeycsICd9Jyk7XG4gIH07XG5cbiAgU2VxLnByb3RvdHlwZS5jYWNoZVJlc3VsdCA9IGZ1bmN0aW9uIGNhY2hlUmVzdWx0ICgpIHtcbiAgICBpZiAoIXRoaXMuX2NhY2hlICYmIHRoaXMuX19pdGVyYXRlVW5jYWNoZWQpIHtcbiAgICAgIHRoaXMuX2NhY2hlID0gdGhpcy5lbnRyeVNlcSgpLnRvQXJyYXkoKTtcbiAgICAgIHRoaXMuc2l6ZSA9IHRoaXMuX2NhY2hlLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gYWJzdHJhY3QgX19pdGVyYXRlVW5jYWNoZWQoZm4sIHJldmVyc2UpXG5cbiAgU2VxLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5fY2FjaGU7XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICB2YXIgc2l6ZSA9IGNhY2hlLmxlbmd0aDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChpICE9PSBzaXplKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGNhY2hlW3JldmVyc2UgPyBzaXplIC0gKytpIDogaSsrXTtcbiAgICAgICAgaWYgKGZuKGVudHJ5WzFdLCBlbnRyeVswXSwgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fX2l0ZXJhdGVVbmNhY2hlZChmbiwgcmV2ZXJzZSk7XG4gIH07XG5cbiAgLy8gYWJzdHJhY3QgX19pdGVyYXRvclVuY2FjaGVkKHR5cGUsIHJldmVyc2UpXG5cbiAgU2VxLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgIHZhciBjYWNoZSA9IHRoaXMuX2NhY2hlO1xuICAgIGlmIChjYWNoZSkge1xuICAgICAgdmFyIHNpemUgPSBjYWNoZS5sZW5ndGg7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGkgPT09IHNpemUpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVudHJ5ID0gY2FjaGVbcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKytdO1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9faXRlcmF0b3JVbmNhY2hlZCh0eXBlLCByZXZlcnNlKTtcbiAgfTtcblxuICByZXR1cm4gU2VxO1xufShDb2xsZWN0aW9uKSk7XG5cbnZhciBLZXllZFNlcSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNlcSkge1xuICBmdW5jdGlvbiBLZXllZFNlcSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsXG4gICAgICA/IGVtcHR5U2VxdWVuY2UoKS50b0tleWVkU2VxKClcbiAgICAgIDogaXNDb2xsZWN0aW9uKHZhbHVlKVxuICAgICAgPyBpc0tleWVkKHZhbHVlKVxuICAgICAgICA/IHZhbHVlLnRvU2VxKClcbiAgICAgICAgOiB2YWx1ZS5mcm9tRW50cnlTZXEoKVxuICAgICAgOiBpc1JlY29yZCh2YWx1ZSlcbiAgICAgID8gdmFsdWUudG9TZXEoKVxuICAgICAgOiBrZXllZFNlcUZyb21WYWx1ZSh2YWx1ZSk7XG4gIH1cblxuICBpZiAoIFNlcSApIEtleWVkU2VxLl9fcHJvdG9fXyA9IFNlcTtcbiAgS2V5ZWRTZXEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2VxICYmIFNlcS5wcm90b3R5cGUgKTtcbiAgS2V5ZWRTZXEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gS2V5ZWRTZXE7XG5cbiAgS2V5ZWRTZXEucHJvdG90eXBlLnRvS2V5ZWRTZXEgPSBmdW5jdGlvbiB0b0tleWVkU2VxICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gS2V5ZWRTZXE7XG59KFNlcSkpO1xuXG52YXIgSW5kZXhlZFNlcSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNlcSkge1xuICBmdW5jdGlvbiBJbmRleGVkU2VxKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGxcbiAgICAgID8gZW1wdHlTZXF1ZW5jZSgpXG4gICAgICA6IGlzQ29sbGVjdGlvbih2YWx1ZSlcbiAgICAgID8gaXNLZXllZCh2YWx1ZSlcbiAgICAgICAgPyB2YWx1ZS5lbnRyeVNlcSgpXG4gICAgICAgIDogdmFsdWUudG9JbmRleGVkU2VxKClcbiAgICAgIDogaXNSZWNvcmQodmFsdWUpXG4gICAgICA/IHZhbHVlLnRvU2VxKCkuZW50cnlTZXEoKVxuICAgICAgOiBpbmRleGVkU2VxRnJvbVZhbHVlKHZhbHVlKTtcbiAgfVxuXG4gIGlmICggU2VxICkgSW5kZXhlZFNlcS5fX3Byb3RvX18gPSBTZXE7XG4gIEluZGV4ZWRTZXEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2VxICYmIFNlcS5wcm90b3R5cGUgKTtcbiAgSW5kZXhlZFNlcS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbmRleGVkU2VxO1xuXG4gIEluZGV4ZWRTZXEub2YgPSBmdW5jdGlvbiBvZiAoLyouLi52YWx1ZXMqLykge1xuICAgIHJldHVybiBJbmRleGVkU2VxKGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgSW5kZXhlZFNlcS5wcm90b3R5cGUudG9JbmRleGVkU2VxID0gZnVuY3Rpb24gdG9JbmRleGVkU2VxICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBJbmRleGVkU2VxLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdTZXEgWycsICddJyk7XG4gIH07XG5cbiAgcmV0dXJuIEluZGV4ZWRTZXE7XG59KFNlcSkpO1xuXG52YXIgU2V0U2VxID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoU2VxKSB7XG4gIGZ1bmN0aW9uIFNldFNlcSh2YWx1ZSkge1xuICAgIHJldHVybiAoXG4gICAgICBpc0NvbGxlY3Rpb24odmFsdWUpICYmICFpc0Fzc29jaWF0aXZlKHZhbHVlKSA/IHZhbHVlIDogSW5kZXhlZFNlcSh2YWx1ZSlcbiAgICApLnRvU2V0U2VxKCk7XG4gIH1cblxuICBpZiAoIFNlcSApIFNldFNlcS5fX3Byb3RvX18gPSBTZXE7XG4gIFNldFNlcS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTZXEgJiYgU2VxLnByb3RvdHlwZSApO1xuICBTZXRTZXEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2V0U2VxO1xuXG4gIFNldFNlcS5vZiA9IGZ1bmN0aW9uIG9mICgvKi4uLnZhbHVlcyovKSB7XG4gICAgcmV0dXJuIFNldFNlcShhcmd1bWVudHMpO1xuICB9O1xuXG4gIFNldFNlcS5wcm90b3R5cGUudG9TZXRTZXEgPSBmdW5jdGlvbiB0b1NldFNlcSAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIFNldFNlcTtcbn0oU2VxKSk7XG5cblNlcS5pc1NlcSA9IGlzU2VxO1xuU2VxLktleWVkID0gS2V5ZWRTZXE7XG5TZXEuU2V0ID0gU2V0U2VxO1xuU2VxLkluZGV4ZWQgPSBJbmRleGVkU2VxO1xuXG5TZXEucHJvdG90eXBlW0lTX1NFUV9TWU1CT0xdID0gdHJ1ZTtcblxuLy8gI3ByYWdtYSBSb290IFNlcXVlbmNlc1xuXG52YXIgQXJyYXlTZXEgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbmRleGVkU2VxKSB7XG4gIGZ1bmN0aW9uIEFycmF5U2VxKGFycmF5KSB7XG4gICAgdGhpcy5fYXJyYXkgPSBhcnJheTtcbiAgICB0aGlzLnNpemUgPSBhcnJheS5sZW5ndGg7XG4gIH1cblxuICBpZiAoIEluZGV4ZWRTZXEgKSBBcnJheVNlcS5fX3Byb3RvX18gPSBJbmRleGVkU2VxO1xuICBBcnJheVNlcS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkU2VxICYmIEluZGV4ZWRTZXEucHJvdG90eXBlICk7XG4gIEFycmF5U2VxLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFycmF5U2VxO1xuXG4gIEFycmF5U2VxLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmhhcyhpbmRleCkgPyB0aGlzLl9hcnJheVt3cmFwSW5kZXgodGhpcywgaW5kZXgpXSA6IG5vdFNldFZhbHVlO1xuICB9O1xuXG4gIEFycmF5U2VxLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIGFycmF5ID0gdGhpcy5fYXJyYXk7XG4gICAgdmFyIHNpemUgPSBhcnJheS5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpICE9PSBzaXplKSB7XG4gICAgICB2YXIgaWkgPSByZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrKztcbiAgICAgIGlmIChmbihhcnJheVtpaV0sIGlpLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9O1xuXG4gIEFycmF5U2VxLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgIHZhciBhcnJheSA9IHRoaXMuX2FycmF5O1xuICAgIHZhciBzaXplID0gYXJyYXkubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpID09PSBzaXplKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgIH1cbiAgICAgIHZhciBpaSA9IHJldmVyc2UgPyBzaXplIC0gKytpIDogaSsrO1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaWksIGFycmF5W2lpXSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEFycmF5U2VxO1xufShJbmRleGVkU2VxKSk7XG5cbnZhciBPYmplY3RTZXEgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChLZXllZFNlcSkge1xuICBmdW5jdGlvbiBPYmplY3RTZXEob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpLmNvbmNhdChcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCkgOiBbXVxuICAgICk7XG4gICAgdGhpcy5fb2JqZWN0ID0gb2JqZWN0O1xuICAgIHRoaXMuX2tleXMgPSBrZXlzO1xuICAgIHRoaXMuc2l6ZSA9IGtleXMubGVuZ3RoO1xuICB9XG5cbiAgaWYgKCBLZXllZFNlcSApIE9iamVjdFNlcS5fX3Byb3RvX18gPSBLZXllZFNlcTtcbiAgT2JqZWN0U2VxLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEtleWVkU2VxICYmIEtleWVkU2VxLnByb3RvdHlwZSApO1xuICBPYmplY3RTZXEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT2JqZWN0U2VxO1xuXG4gIE9iamVjdFNlcS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChrZXksIG5vdFNldFZhbHVlKSB7XG4gICAgaWYgKG5vdFNldFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIXRoaXMuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBub3RTZXRWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX29iamVjdFtrZXldO1xuICB9O1xuXG4gIE9iamVjdFNlcS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9vYmplY3QsIGtleSk7XG4gIH07XG5cbiAgT2JqZWN0U2VxLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIG9iamVjdCA9IHRoaXMuX29iamVjdDtcbiAgICB2YXIga2V5cyA9IHRoaXMuX2tleXM7XG4gICAgdmFyIHNpemUgPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgIT09IHNpemUpIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW3JldmVyc2UgPyBzaXplIC0gKytpIDogaSsrXTtcbiAgICAgIGlmIChmbihvYmplY3Rba2V5XSwga2V5LCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9O1xuXG4gIE9iamVjdFNlcS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICB2YXIgb2JqZWN0ID0gdGhpcy5fb2JqZWN0O1xuICAgIHZhciBrZXlzID0gdGhpcy5fa2V5cztcbiAgICB2YXIgc2l6ZSA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpID09PSBzaXplKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSBrZXlzW3JldmVyc2UgPyBzaXplIC0gKytpIDogaSsrXTtcbiAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGtleSwgb2JqZWN0W2tleV0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBPYmplY3RTZXE7XG59KEtleWVkU2VxKSk7XG5PYmplY3RTZXEucHJvdG90eXBlW0lTX09SREVSRURfU1lNQk9MXSA9IHRydWU7XG5cbnZhciBDb2xsZWN0aW9uU2VxID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSW5kZXhlZFNlcSkge1xuICBmdW5jdGlvbiBDb2xsZWN0aW9uU2VxKGNvbGxlY3Rpb24pIHtcbiAgICB0aGlzLl9jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgICB0aGlzLnNpemUgPSBjb2xsZWN0aW9uLmxlbmd0aCB8fCBjb2xsZWN0aW9uLnNpemU7XG4gIH1cblxuICBpZiAoIEluZGV4ZWRTZXEgKSBDb2xsZWN0aW9uU2VxLl9fcHJvdG9fXyA9IEluZGV4ZWRTZXE7XG4gIENvbGxlY3Rpb25TZXEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW5kZXhlZFNlcSAmJiBJbmRleGVkU2VxLnByb3RvdHlwZSApO1xuICBDb2xsZWN0aW9uU2VxLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbGxlY3Rpb25TZXE7XG5cbiAgQ29sbGVjdGlvblNlcS5wcm90b3R5cGUuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbiBfX2l0ZXJhdGVVbmNhY2hlZCAoZm4sIHJldmVyc2UpIHtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UpO1xuICAgIH1cbiAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXMuX2NvbGxlY3Rpb247XG4gICAgdmFyIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoY29sbGVjdGlvbik7XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIGlmIChpc0l0ZXJhdG9yKGl0ZXJhdG9yKSkge1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIGlmIChmbihzdGVwLnZhbHVlLCBpdGVyYXRpb25zKyssIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpdGVyYXRpb25zO1xuICB9O1xuXG4gIENvbGxlY3Rpb25TZXEucHJvdG90eXBlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uIF9faXRlcmF0b3JVbmNhY2hlZCAodHlwZSwgcmV2ZXJzZSkge1xuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgfVxuICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcy5fY29sbGVjdGlvbjtcbiAgICB2YXIgaXRlcmF0b3IgPSBnZXRJdGVyYXRvcihjb2xsZWN0aW9uKTtcbiAgICBpZiAoIWlzSXRlcmF0b3IoaXRlcmF0b3IpKSB7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGl0ZXJhdG9yRG9uZSk7XG4gICAgfVxuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgcmV0dXJuIHN0ZXAuZG9uZSA/IHN0ZXAgOiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgc3RlcC52YWx1ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIENvbGxlY3Rpb25TZXE7XG59KEluZGV4ZWRTZXEpKTtcblxuLy8gIyBwcmFnbWEgSGVscGVyIGZ1bmN0aW9uc1xuXG52YXIgRU1QVFlfU0VRO1xuXG5mdW5jdGlvbiBlbXB0eVNlcXVlbmNlKCkge1xuICByZXR1cm4gRU1QVFlfU0VRIHx8IChFTVBUWV9TRVEgPSBuZXcgQXJyYXlTZXEoW10pKTtcbn1cblxuZnVuY3Rpb24ga2V5ZWRTZXFGcm9tVmFsdWUodmFsdWUpIHtcbiAgdmFyIHNlcSA9IG1heWJlSW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSk7XG4gIGlmIChzZXEpIHtcbiAgICByZXR1cm4gc2VxLmZyb21FbnRyeVNlcSgpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG5ldyBPYmplY3RTZXEodmFsdWUpO1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ0V4cGVjdGVkIEFycmF5IG9yIGNvbGxlY3Rpb24gb2JqZWN0IG9mIFtrLCB2XSBlbnRyaWVzLCBvciBrZXllZCBvYmplY3Q6ICcgK1xuICAgICAgdmFsdWVcbiAgKTtcbn1cblxuZnVuY3Rpb24gaW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSkge1xuICB2YXIgc2VxID0gbWF5YmVJbmRleGVkU2VxRnJvbVZhbHVlKHZhbHVlKTtcbiAgaWYgKHNlcSkge1xuICAgIHJldHVybiBzZXE7XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnRXhwZWN0ZWQgQXJyYXkgb3IgY29sbGVjdGlvbiBvYmplY3Qgb2YgdmFsdWVzOiAnICsgdmFsdWVcbiAgKTtcbn1cblxuZnVuY3Rpb24gc2VxRnJvbVZhbHVlKHZhbHVlKSB7XG4gIHZhciBzZXEgPSBtYXliZUluZGV4ZWRTZXFGcm9tVmFsdWUodmFsdWUpO1xuICBpZiAoc2VxKSB7XG4gICAgcmV0dXJuIGlzRW50cmllc0l0ZXJhYmxlKHZhbHVlKVxuICAgICAgPyBzZXEuZnJvbUVudHJ5U2VxKClcbiAgICAgIDogaXNLZXlzSXRlcmFibGUodmFsdWUpXG4gICAgICA/IHNlcS50b1NldFNlcSgpXG4gICAgICA6IHNlcTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBuZXcgT2JqZWN0U2VxKHZhbHVlKTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdFeHBlY3RlZCBBcnJheSBvciBjb2xsZWN0aW9uIG9iamVjdCBvZiB2YWx1ZXMsIG9yIGtleWVkIG9iamVjdDogJyArIHZhbHVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIG1heWJlSW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheUxpa2UodmFsdWUpXG4gICAgPyBuZXcgQXJyYXlTZXEodmFsdWUpXG4gICAgOiBoYXNJdGVyYXRvcih2YWx1ZSlcbiAgICA/IG5ldyBDb2xsZWN0aW9uU2VxKHZhbHVlKVxuICAgIDogdW5kZWZpbmVkO1xufVxuXG52YXIgSVNfTUFQX1NZTUJPTCA9ICdAQF9fSU1NVVRBQkxFX01BUF9fQEAnO1xuXG5mdW5jdGlvbiBpc01hcChtYXliZU1hcCkge1xuICByZXR1cm4gQm9vbGVhbihtYXliZU1hcCAmJiBtYXliZU1hcFtJU19NQVBfU1lNQk9MXSk7XG59XG5cbmZ1bmN0aW9uIGlzT3JkZXJlZE1hcChtYXliZU9yZGVyZWRNYXApIHtcbiAgcmV0dXJuIGlzTWFwKG1heWJlT3JkZXJlZE1hcCkgJiYgaXNPcmRlcmVkKG1heWJlT3JkZXJlZE1hcCk7XG59XG5cbmZ1bmN0aW9uIGlzVmFsdWVPYmplY3QobWF5YmVWYWx1ZSkge1xuICByZXR1cm4gQm9vbGVhbihcbiAgICBtYXliZVZhbHVlICYmXG4gICAgICB0eXBlb2YgbWF5YmVWYWx1ZS5lcXVhbHMgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHR5cGVvZiBtYXliZVZhbHVlLmhhc2hDb2RlID09PSAnZnVuY3Rpb24nXG4gICk7XG59XG5cbi8qKlxuICogQW4gZXh0ZW5zaW9uIG9mIHRoZSBcInNhbWUtdmFsdWVcIiBhbGdvcml0aG0gYXMgW2Rlc2NyaWJlZCBmb3IgdXNlIGJ5IEVTNiBNYXBcbiAqIGFuZCBTZXRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hcCNLZXlfZXF1YWxpdHkpXG4gKlxuICogTmFOIGlzIGNvbnNpZGVyZWQgdGhlIHNhbWUgYXMgTmFOLCBob3dldmVyIC0wIGFuZCAwIGFyZSBjb25zaWRlcmVkIHRoZSBzYW1lXG4gKiB2YWx1ZSwgd2hpY2ggaXMgZGlmZmVyZW50IGZyb20gdGhlIGFsZ29yaXRobSBkZXNjcmliZWQgYnlcbiAqIFtgT2JqZWN0LmlzYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzKS5cbiAqXG4gKiBUaGlzIGlzIGV4dGVuZGVkIGZ1cnRoZXIgdG8gYWxsb3cgT2JqZWN0cyB0byBkZXNjcmliZSB0aGUgdmFsdWVzIHRoZXlcbiAqIHJlcHJlc2VudCwgYnkgd2F5IG9mIGB2YWx1ZU9mYCBvciBgZXF1YWxzYCAoYW5kIGBoYXNoQ29kZWApLlxuICpcbiAqIE5vdGU6IGJlY2F1c2Ugb2YgdGhpcyBleHRlbnNpb24sIHRoZSBrZXkgZXF1YWxpdHkgb2YgSW1tdXRhYmxlLk1hcCBhbmQgdGhlXG4gKiB2YWx1ZSBlcXVhbGl0eSBvZiBJbW11dGFibGUuU2V0IHdpbGwgZGlmZmVyIGZyb20gRVM2IE1hcCBhbmQgU2V0LlxuICpcbiAqICMjIyBEZWZpbmluZyBjdXN0b20gdmFsdWVzXG4gKlxuICogVGhlIGVhc2llc3Qgd2F5IHRvIGRlc2NyaWJlIHRoZSB2YWx1ZSBhbiBvYmplY3QgcmVwcmVzZW50cyBpcyBieSBpbXBsZW1lbnRpbmdcbiAqIGB2YWx1ZU9mYC4gRm9yIGV4YW1wbGUsIGBEYXRlYCByZXByZXNlbnRzIGEgdmFsdWUgYnkgcmV0dXJuaW5nIGEgdW5peFxuICogdGltZXN0YW1wIGZvciBgdmFsdWVPZmA6XG4gKlxuICogICAgIHZhciBkYXRlMSA9IG5ldyBEYXRlKDEyMzQ1Njc4OTAwMDApOyAvLyBGcmkgRmViIDEzIDIwMDkgLi4uXG4gKiAgICAgdmFyIGRhdGUyID0gbmV3IERhdGUoMTIzNDU2Nzg5MDAwMCk7XG4gKiAgICAgZGF0ZTEudmFsdWVPZigpOyAvLyAxMjM0NTY3ODkwMDAwXG4gKiAgICAgYXNzZXJ0KCBkYXRlMSAhPT0gZGF0ZTIgKTtcbiAqICAgICBhc3NlcnQoIEltbXV0YWJsZS5pcyggZGF0ZTEsIGRhdGUyICkgKTtcbiAqXG4gKiBOb3RlOiBvdmVycmlkaW5nIGB2YWx1ZU9mYCBtYXkgaGF2ZSBvdGhlciBpbXBsaWNhdGlvbnMgaWYgeW91IHVzZSB0aGlzIG9iamVjdFxuICogd2hlcmUgSmF2YVNjcmlwdCBleHBlY3RzIGEgcHJpbWl0aXZlLCBzdWNoIGFzIGltcGxpY2l0IHN0cmluZyBjb2VyY2lvbi5cbiAqXG4gKiBGb3IgbW9yZSBjb21wbGV4IHR5cGVzLCBlc3BlY2lhbGx5IGNvbGxlY3Rpb25zLCBpbXBsZW1lbnRpbmcgYHZhbHVlT2ZgIG1heVxuICogbm90IGJlIHBlcmZvcm1hbnQuIEFuIGFsdGVybmF0aXZlIGlzIHRvIGltcGxlbWVudCBgZXF1YWxzYCBhbmQgYGhhc2hDb2RlYC5cbiAqXG4gKiBgZXF1YWxzYCB0YWtlcyBhbm90aGVyIG9iamVjdCwgcHJlc3VtYWJseSBvZiBzaW1pbGFyIHR5cGUsIGFuZCByZXR1cm5zIHRydWVcbiAqIGlmIGl0IGlzIGVxdWFsLiBFcXVhbGl0eSBpcyBzeW1tZXRyaWNhbCwgc28gdGhlIHNhbWUgcmVzdWx0IHNob3VsZCBiZVxuICogcmV0dXJuZWQgaWYgdGhpcyBhbmQgdGhlIGFyZ3VtZW50IGFyZSBmbGlwcGVkLlxuICpcbiAqICAgICBhc3NlcnQoIGEuZXF1YWxzKGIpID09PSBiLmVxdWFscyhhKSApO1xuICpcbiAqIGBoYXNoQ29kZWAgcmV0dXJucyBhIDMyYml0IGludGVnZXIgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgb2JqZWN0IHdoaWNoIHdpbGxcbiAqIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGhvdyB0byBzdG9yZSB0aGUgdmFsdWUgb2JqZWN0IGluIGEgTWFwIG9yIFNldC4gWW91IG11c3RcbiAqIHByb3ZpZGUgYm90aCBvciBuZWl0aGVyIG1ldGhvZHMsIG9uZSBtdXN0IG5vdCBleGlzdCB3aXRob3V0IHRoZSBvdGhlci5cbiAqXG4gKiBBbHNvLCBhbiBpbXBvcnRhbnQgcmVsYXRpb25zaGlwIGJldHdlZW4gdGhlc2UgbWV0aG9kcyBtdXN0IGJlIHVwaGVsZDogaWYgdHdvXG4gKiB2YWx1ZXMgYXJlIGVxdWFsLCB0aGV5ICptdXN0KiByZXR1cm4gdGhlIHNhbWUgaGFzaENvZGUuIElmIHRoZSB2YWx1ZXMgYXJlIG5vdFxuICogZXF1YWwsIHRoZXkgbWlnaHQgaGF2ZSB0aGUgc2FtZSBoYXNoQ29kZTsgdGhpcyBpcyBjYWxsZWQgYSBoYXNoIGNvbGxpc2lvbixcbiAqIGFuZCB3aGlsZSB1bmRlc2lyYWJsZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgaXQgaXMgYWNjZXB0YWJsZS5cbiAqXG4gKiAgICAgaWYgKGEuZXF1YWxzKGIpKSB7XG4gKiAgICAgICBhc3NlcnQoIGEuaGFzaENvZGUoKSA9PT0gYi5oYXNoQ29kZSgpICk7XG4gKiAgICAgfVxuICpcbiAqIEFsbCBJbW11dGFibGUgY29sbGVjdGlvbnMgYXJlIFZhbHVlIE9iamVjdHM6IHRoZXkgaW1wbGVtZW50IGBlcXVhbHMoKWBcbiAqIGFuZCBgaGFzaENvZGUoKWAuXG4gKi9cbmZ1bmN0aW9uIGlzKHZhbHVlQSwgdmFsdWVCKSB7XG4gIGlmICh2YWx1ZUEgPT09IHZhbHVlQiB8fCAodmFsdWVBICE9PSB2YWx1ZUEgJiYgdmFsdWVCICE9PSB2YWx1ZUIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCF2YWx1ZUEgfHwgIXZhbHVlQikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoXG4gICAgdHlwZW9mIHZhbHVlQS52YWx1ZU9mID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHZhbHVlQi52YWx1ZU9mID09PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHZhbHVlQSA9IHZhbHVlQS52YWx1ZU9mKCk7XG4gICAgdmFsdWVCID0gdmFsdWVCLnZhbHVlT2YoKTtcbiAgICBpZiAodmFsdWVBID09PSB2YWx1ZUIgfHwgKHZhbHVlQSAhPT0gdmFsdWVBICYmIHZhbHVlQiAhPT0gdmFsdWVCKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghdmFsdWVBIHx8ICF2YWx1ZUIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICEhKFxuICAgIGlzVmFsdWVPYmplY3QodmFsdWVBKSAmJlxuICAgIGlzVmFsdWVPYmplY3QodmFsdWVCKSAmJlxuICAgIHZhbHVlQS5lcXVhbHModmFsdWVCKVxuICApO1xufVxuXG52YXIgaW11bCA9XG4gIHR5cGVvZiBNYXRoLmltdWwgPT09ICdmdW5jdGlvbicgJiYgTWF0aC5pbXVsKDB4ZmZmZmZmZmYsIDIpID09PSAtMlxuICAgID8gTWF0aC5pbXVsXG4gICAgOiBmdW5jdGlvbiBpbXVsKGEsIGIpIHtcbiAgICAgICAgYSB8PSAwOyAvLyBpbnRcbiAgICAgICAgYiB8PSAwOyAvLyBpbnRcbiAgICAgICAgdmFyIGMgPSBhICYgMHhmZmZmO1xuICAgICAgICB2YXIgZCA9IGIgJiAweGZmZmY7XG4gICAgICAgIC8vIFNoaWZ0IGJ5IDAgZml4ZXMgdGhlIHNpZ24gb24gdGhlIGhpZ2ggcGFydC5cbiAgICAgICAgcmV0dXJuIChjICogZCArICgoKChhID4+PiAxNikgKiBkICsgYyAqIChiID4+PiAxNikpIDw8IDE2KSA+Pj4gMCkpIHwgMDsgLy8gaW50XG4gICAgICB9O1xuXG4vLyB2OCBoYXMgYW4gb3B0aW1pemF0aW9uIGZvciBzdG9yaW5nIDMxLWJpdCBzaWduZWQgbnVtYmVycy5cbi8vIFZhbHVlcyB3aGljaCBoYXZlIGVpdGhlciAwMCBvciAxMSBhcyB0aGUgaGlnaCBvcmRlciBiaXRzIHF1YWxpZnkuXG4vLyBUaGlzIGZ1bmN0aW9uIGRyb3BzIHRoZSBoaWdoZXN0IG9yZGVyIGJpdCBpbiBhIHNpZ25lZCBudW1iZXIsIG1haW50YWluaW5nXG4vLyB0aGUgc2lnbiBiaXQuXG5mdW5jdGlvbiBzbWkoaTMyKSB7XG4gIHJldHVybiAoKGkzMiA+Pj4gMSkgJiAweDQwMDAwMDAwKSB8IChpMzIgJiAweGJmZmZmZmZmKTtcbn1cblxudmFyIGRlZmF1bHRWYWx1ZU9mID0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mO1xuXG5mdW5jdGlvbiBoYXNoKG8pIHtcbiAgaWYgKG8gPT0gbnVsbCkge1xuICAgIHJldHVybiBoYXNoTnVsbGlzaChvKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygby5oYXNoQ29kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIERyb3AgYW55IGhpZ2ggYml0cyBmcm9tIGFjY2lkZW50YWxseSBsb25nIGhhc2ggY29kZXMuXG4gICAgcmV0dXJuIHNtaShvLmhhc2hDb2RlKG8pKTtcbiAgfVxuXG4gIHZhciB2ID0gdmFsdWVPZihvKTtcblxuICBpZiAodiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGhhc2hOdWxsaXNoKHYpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgLy8gVGhlIGhhc2ggdmFsdWVzIGZvciBidWlsdC1pbiBjb25zdGFudHMgYXJlIGEgMSB2YWx1ZSBmb3IgZWFjaCA1LWJ5dGVcbiAgICAgIC8vIHNoaWZ0IHJlZ2lvbiBleHBlY3QgZm9yIHRoZSBmaXJzdCwgd2hpY2ggZW5jb2RlcyB0aGUgdmFsdWUuIFRoaXNcbiAgICAgIC8vIHJlZHVjZXMgdGhlIG9kZHMgb2YgYSBoYXNoIGNvbGxpc2lvbiBmb3IgdGhlc2UgY29tbW9uIHZhbHVlcy5cbiAgICAgIHJldHVybiB2ID8gMHg0MjEwODQyMSA6IDB4NDIxMDg0MjA7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBoYXNoTnVtYmVyKHYpO1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdi5sZW5ndGggPiBTVFJJTkdfSEFTSF9DQUNIRV9NSU5fU1RSTEVOXG4gICAgICAgID8gY2FjaGVkSGFzaFN0cmluZyh2KVxuICAgICAgICA6IGhhc2hTdHJpbmcodik7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICByZXR1cm4gaGFzaEpTT2JqKHYpO1xuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICByZXR1cm4gaGFzaFN5bWJvbCh2KTtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiB2LnRvU3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBoYXNoU3RyaW5nKHYudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIHR5cGUgJyArIHR5cGVvZiB2ICsgJyBjYW5ub3QgYmUgaGFzaGVkLicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc2hOdWxsaXNoKG51bGxpc2gpIHtcbiAgcmV0dXJuIG51bGxpc2ggPT09IG51bGwgPyAweDQyMTA4NDIyIDogLyogdW5kZWZpbmVkICovIDB4NDIxMDg0MjM7XG59XG5cbi8vIENvbXByZXNzIGFyYml0cmFyaWx5IGxhcmdlIG51bWJlcnMgaW50byBzbWkgaGFzaGVzLlxuZnVuY3Rpb24gaGFzaE51bWJlcihuKSB7XG4gIGlmIChuICE9PSBuIHx8IG4gPT09IEluZmluaXR5KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIGhhc2ggPSBuIHwgMDtcbiAgaWYgKGhhc2ggIT09IG4pIHtcbiAgICBoYXNoIF49IG4gKiAweGZmZmZmZmZmO1xuICB9XG4gIHdoaWxlIChuID4gMHhmZmZmZmZmZikge1xuICAgIG4gLz0gMHhmZmZmZmZmZjtcbiAgICBoYXNoIF49IG47XG4gIH1cbiAgcmV0dXJuIHNtaShoYXNoKTtcbn1cblxuZnVuY3Rpb24gY2FjaGVkSGFzaFN0cmluZyhzdHJpbmcpIHtcbiAgdmFyIGhhc2hlZCA9IHN0cmluZ0hhc2hDYWNoZVtzdHJpbmddO1xuICBpZiAoaGFzaGVkID09PSB1bmRlZmluZWQpIHtcbiAgICBoYXNoZWQgPSBoYXNoU3RyaW5nKHN0cmluZyk7XG4gICAgaWYgKFNUUklOR19IQVNIX0NBQ0hFX1NJWkUgPT09IFNUUklOR19IQVNIX0NBQ0hFX01BWF9TSVpFKSB7XG4gICAgICBTVFJJTkdfSEFTSF9DQUNIRV9TSVpFID0gMDtcbiAgICAgIHN0cmluZ0hhc2hDYWNoZSA9IHt9O1xuICAgIH1cbiAgICBTVFJJTkdfSEFTSF9DQUNIRV9TSVpFKys7XG4gICAgc3RyaW5nSGFzaENhY2hlW3N0cmluZ10gPSBoYXNoZWQ7XG4gIH1cbiAgcmV0dXJuIGhhc2hlZDtcbn1cblxuLy8gaHR0cDovL2pzcGVyZi5jb20vaGFzaGluZy1zdHJpbmdzXG5mdW5jdGlvbiBoYXNoU3RyaW5nKHN0cmluZykge1xuICAvLyBUaGlzIGlzIHRoZSBoYXNoIGZyb20gSlZNXG4gIC8vIFRoZSBoYXNoIGNvZGUgZm9yIGEgc3RyaW5nIGlzIGNvbXB1dGVkIGFzXG4gIC8vIHNbMF0gKiAzMSBeIChuIC0gMSkgKyBzWzFdICogMzEgXiAobiAtIDIpICsgLi4uICsgc1tuIC0gMV0sXG4gIC8vIHdoZXJlIHNbaV0gaXMgdGhlIGl0aCBjaGFyYWN0ZXIgb2YgdGhlIHN0cmluZyBhbmQgbiBpcyB0aGUgbGVuZ3RoIG9mXG4gIC8vIHRoZSBzdHJpbmcuIFdlIFwibW9kXCIgdGhlIHJlc3VsdCB0byBtYWtlIGl0IGJldHdlZW4gMCAoaW5jbHVzaXZlKSBhbmQgMl4zMVxuICAvLyAoZXhjbHVzaXZlKSBieSBkcm9wcGluZyBoaWdoIGJpdHMuXG4gIHZhciBoYXNoZWQgPSAwO1xuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgc3RyaW5nLmxlbmd0aDsgaWkrKykge1xuICAgIGhhc2hlZCA9ICgzMSAqIGhhc2hlZCArIHN0cmluZy5jaGFyQ29kZUF0KGlpKSkgfCAwO1xuICB9XG4gIHJldHVybiBzbWkoaGFzaGVkKTtcbn1cblxuZnVuY3Rpb24gaGFzaFN5bWJvbChzeW0pIHtcbiAgdmFyIGhhc2hlZCA9IHN5bWJvbE1hcFtzeW1dO1xuICBpZiAoaGFzaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gaGFzaGVkO1xuICB9XG5cbiAgaGFzaGVkID0gbmV4dEhhc2goKTtcblxuICBzeW1ib2xNYXBbc3ltXSA9IGhhc2hlZDtcblxuICByZXR1cm4gaGFzaGVkO1xufVxuXG5mdW5jdGlvbiBoYXNoSlNPYmoob2JqKSB7XG4gIHZhciBoYXNoZWQ7XG4gIGlmICh1c2luZ1dlYWtNYXApIHtcbiAgICBoYXNoZWQgPSB3ZWFrTWFwLmdldChvYmopO1xuICAgIGlmIChoYXNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGhhc2hlZDtcbiAgICB9XG4gIH1cblxuICBoYXNoZWQgPSBvYmpbVUlEX0hBU0hfS0VZXTtcbiAgaWYgKGhhc2hlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGhhc2hlZDtcbiAgfVxuXG4gIGlmICghY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICBoYXNoZWQgPSBvYmoucHJvcGVydHlJc0VudW1lcmFibGUgJiYgb2JqLnByb3BlcnR5SXNFbnVtZXJhYmxlW1VJRF9IQVNIX0tFWV07XG4gICAgaWYgKGhhc2hlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gaGFzaGVkO1xuICAgIH1cblxuICAgIGhhc2hlZCA9IGdldElFTm9kZUhhc2gob2JqKTtcbiAgICBpZiAoaGFzaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBoYXNoZWQ7XG4gICAgfVxuICB9XG5cbiAgaGFzaGVkID0gbmV4dEhhc2goKTtcblxuICBpZiAodXNpbmdXZWFrTWFwKSB7XG4gICAgd2Vha01hcC5zZXQob2JqLCBoYXNoZWQpO1xuICB9IGVsc2UgaWYgKGlzRXh0ZW5zaWJsZSAhPT0gdW5kZWZpbmVkICYmIGlzRXh0ZW5zaWJsZShvYmopID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm9uLWV4dGVuc2libGUgb2JqZWN0cyBhcmUgbm90IGFsbG93ZWQgYXMga2V5cy4nKTtcbiAgfSBlbHNlIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIFVJRF9IQVNIX0tFWSwge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IGhhc2hlZCxcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChcbiAgICBvYmoucHJvcGVydHlJc0VudW1lcmFibGUgIT09IHVuZGVmaW5lZCAmJlxuICAgIG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZSA9PT0gb2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZVxuICApIHtcbiAgICAvLyBTaW5jZSB3ZSBjYW4ndCBkZWZpbmUgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBvbiB0aGUgb2JqZWN0XG4gICAgLy8gd2UnbGwgaGlqYWNrIG9uZSBvZiB0aGUgbGVzcy11c2VkIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgdG9cbiAgICAvLyBzYXZlIG91ciBoYXNoIG9uIGl0LiBTaW5jZSB0aGlzIGlzIGEgZnVuY3Rpb24gaXQgd2lsbCBub3Qgc2hvdyB1cCBpblxuICAgIC8vIGBKU09OLnN0cmluZ2lmeWAgd2hpY2ggaXMgd2hhdCB3ZSB3YW50LlxuICAgIG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5hcHBseShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgYXJndW1lbnRzXG4gICAgICApO1xuICAgIH07XG4gICAgb2JqLnByb3BlcnR5SXNFbnVtZXJhYmxlW1VJRF9IQVNIX0tFWV0gPSBoYXNoZWQ7XG4gIH0gZWxzZSBpZiAob2JqLm5vZGVUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBBdCB0aGlzIHBvaW50IHdlIGNvdWxkbid0IGdldCB0aGUgSUUgYHVuaXF1ZUlEYCB0byB1c2UgYXMgYSBoYXNoXG4gICAgLy8gYW5kIHdlIGNvdWxkbid0IHVzZSBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IHRvIGV4cGxvaXQgdGhlXG4gICAgLy8gZG9udEVudW0gYnVnIHNvIHdlIHNpbXBseSBhZGQgdGhlIGBVSURfSEFTSF9LRVlgIG9uIHRoZSBub2RlXG4gICAgLy8gaXRzZWxmLlxuICAgIG9ialtVSURfSEFTSF9LRVldID0gaGFzaGVkO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHNldCBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IG9uIG9iamVjdC4nKTtcbiAgfVxuXG4gIHJldHVybiBoYXNoZWQ7XG59XG5cbi8vIEdldCByZWZlcmVuY2VzIHRvIEVTNSBvYmplY3QgbWV0aG9kcy5cbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xuXG4vLyBUcnVlIGlmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB3b3JrcyBhcyBleHBlY3RlZC4gSUU4IGZhaWxzIHRoaXMgdGVzdC5cbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnQCcsIHt9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSkoKTtcblxuLy8gSUUgaGFzIGEgYHVuaXF1ZUlEYCBwcm9wZXJ0eSBvbiBET00gbm9kZXMuIFdlIGNhbiBjb25zdHJ1Y3QgdGhlIGhhc2ggZnJvbSBpdFxuLy8gYW5kIGF2b2lkIG1lbW9yeSBsZWFrcyBmcm9tIHRoZSBJRSBjbG9uZU5vZGUgYnVnLlxuZnVuY3Rpb24gZ2V0SUVOb2RlSGFzaChub2RlKSB7XG4gIGlmIChub2RlICYmIG5vZGUubm9kZVR5cGUgPiAwKSB7XG4gICAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG4gICAgICBjYXNlIDE6IC8vIEVsZW1lbnRcbiAgICAgICAgcmV0dXJuIG5vZGUudW5pcXVlSUQ7XG4gICAgICBjYXNlIDk6IC8vIERvY3VtZW50XG4gICAgICAgIHJldHVybiBub2RlLmRvY3VtZW50RWxlbWVudCAmJiBub2RlLmRvY3VtZW50RWxlbWVudC51bmlxdWVJRDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsdWVPZihvYmopIHtcbiAgcmV0dXJuIG9iai52YWx1ZU9mICE9PSBkZWZhdWx0VmFsdWVPZiAmJiB0eXBlb2Ygb2JqLnZhbHVlT2YgPT09ICdmdW5jdGlvbidcbiAgICA/IG9iai52YWx1ZU9mKG9iailcbiAgICA6IG9iajtcbn1cblxuZnVuY3Rpb24gbmV4dEhhc2goKSB7XG4gIHZhciBuZXh0SGFzaCA9ICsrX29iakhhc2hVSUQ7XG4gIGlmIChfb2JqSGFzaFVJRCAmIDB4NDAwMDAwMDApIHtcbiAgICBfb2JqSGFzaFVJRCA9IDA7XG4gIH1cbiAgcmV0dXJuIG5leHRIYXNoO1xufVxuXG4vLyBJZiBwb3NzaWJsZSwgdXNlIGEgV2Vha01hcC5cbnZhciB1c2luZ1dlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJztcbnZhciB3ZWFrTWFwO1xuaWYgKHVzaW5nV2Vha01hcCkge1xuICB3ZWFrTWFwID0gbmV3IFdlYWtNYXAoKTtcbn1cblxudmFyIHN5bWJvbE1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbnZhciBfb2JqSGFzaFVJRCA9IDA7XG5cbnZhciBVSURfSEFTSF9LRVkgPSAnX19pbW11dGFibGVoYXNoX18nO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgVUlEX0hBU0hfS0VZID0gU3ltYm9sKFVJRF9IQVNIX0tFWSk7XG59XG5cbnZhciBTVFJJTkdfSEFTSF9DQUNIRV9NSU5fU1RSTEVOID0gMTY7XG52YXIgU1RSSU5HX0hBU0hfQ0FDSEVfTUFYX1NJWkUgPSAyNTU7XG52YXIgU1RSSU5HX0hBU0hfQ0FDSEVfU0laRSA9IDA7XG52YXIgc3RyaW5nSGFzaENhY2hlID0ge307XG5cbnZhciBUb0tleWVkU2VxdWVuY2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChLZXllZFNlcSkge1xuICBmdW5jdGlvbiBUb0tleWVkU2VxdWVuY2UoaW5kZXhlZCwgdXNlS2V5cykge1xuICAgIHRoaXMuX2l0ZXIgPSBpbmRleGVkO1xuICAgIHRoaXMuX3VzZUtleXMgPSB1c2VLZXlzO1xuICAgIHRoaXMuc2l6ZSA9IGluZGV4ZWQuc2l6ZTtcbiAgfVxuXG4gIGlmICggS2V5ZWRTZXEgKSBUb0tleWVkU2VxdWVuY2UuX19wcm90b19fID0gS2V5ZWRTZXE7XG4gIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBLZXllZFNlcSAmJiBLZXllZFNlcS5wcm90b3R5cGUgKTtcbiAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRvS2V5ZWRTZXF1ZW5jZTtcblxuICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoa2V5LCBub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9pdGVyLmdldChrZXksIG5vdFNldFZhbHVlKTtcbiAgfTtcblxuICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZXIuaGFzKGtleSk7XG4gIH07XG5cbiAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS52YWx1ZVNlcSA9IGZ1bmN0aW9uIHZhbHVlU2VxICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlci52YWx1ZVNlcSgpO1xuICB9O1xuXG4gIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UgKCkge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmV2ZXJzZWRTZXF1ZW5jZSA9IHJldmVyc2VGYWN0b3J5KHRoaXMsIHRydWUpO1xuICAgIGlmICghdGhpcy5fdXNlS2V5cykge1xuICAgICAgcmV2ZXJzZWRTZXF1ZW5jZS52YWx1ZVNlcSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMSQxLl9pdGVyLnRvU2VxKCkucmV2ZXJzZSgpOyB9O1xuICAgIH1cbiAgICByZXR1cm4gcmV2ZXJzZWRTZXF1ZW5jZTtcbiAgfTtcblxuICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcCAobWFwcGVyLCBjb250ZXh0KSB7XG4gICAgdmFyIHRoaXMkMSQxID0gdGhpcztcblxuICAgIHZhciBtYXBwZWRTZXF1ZW5jZSA9IG1hcEZhY3RvcnkodGhpcywgbWFwcGVyLCBjb250ZXh0KTtcbiAgICBpZiAoIXRoaXMuX3VzZUtleXMpIHtcbiAgICAgIG1hcHBlZFNlcXVlbmNlLnZhbHVlU2VxID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxJDEuX2l0ZXIudG9TZXEoKS5tYXAobWFwcGVyLCBjb250ZXh0KTsgfTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcHBlZFNlcXVlbmNlO1xuICB9O1xuXG4gIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5faXRlci5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIGZuKHYsIGssIHRoaXMkMSQxKTsgfSwgcmV2ZXJzZSk7XG4gIH07XG5cbiAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgIHJldHVybiB0aGlzLl9pdGVyLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gIH07XG5cbiAgcmV0dXJuIFRvS2V5ZWRTZXF1ZW5jZTtcbn0oS2V5ZWRTZXEpKTtcblRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGVbSVNfT1JERVJFRF9TWU1CT0xdID0gdHJ1ZTtcblxudmFyIFRvSW5kZXhlZFNlcXVlbmNlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSW5kZXhlZFNlcSkge1xuICBmdW5jdGlvbiBUb0luZGV4ZWRTZXF1ZW5jZShpdGVyKSB7XG4gICAgdGhpcy5faXRlciA9IGl0ZXI7XG4gICAgdGhpcy5zaXplID0gaXRlci5zaXplO1xuICB9XG5cbiAgaWYgKCBJbmRleGVkU2VxICkgVG9JbmRleGVkU2VxdWVuY2UuX19wcm90b19fID0gSW5kZXhlZFNlcTtcbiAgVG9JbmRleGVkU2VxdWVuY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW5kZXhlZFNlcSAmJiBJbmRleGVkU2VxLnByb3RvdHlwZSApO1xuICBUb0luZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUb0luZGV4ZWRTZXF1ZW5jZTtcblxuICBUb0luZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlci5pbmNsdWRlcyh2YWx1ZSk7XG4gIH07XG5cbiAgVG9JbmRleGVkU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgdGhpcyQxJDEgPSB0aGlzO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHJldmVyc2UgJiYgZW5zdXJlU2l6ZSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5faXRlci5fX2l0ZXJhdGUoXG4gICAgICBmdW5jdGlvbiAodikgeyByZXR1cm4gZm4odiwgcmV2ZXJzZSA/IHRoaXMkMSQxLnNpemUgLSArK2kgOiBpKyssIHRoaXMkMSQxKTsgfSxcbiAgICAgIHJldmVyc2VcbiAgICApO1xuICB9O1xuXG4gIFRvSW5kZXhlZFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9pdGVyLl9faXRlcmF0b3IoSVRFUkFURV9WQUxVRVMsIHJldmVyc2UpO1xuICAgIHZhciBpID0gMDtcbiAgICByZXZlcnNlICYmIGVuc3VyZVNpemUodGhpcyk7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIHJldHVybiBzdGVwLmRvbmVcbiAgICAgICAgPyBzdGVwXG4gICAgICAgIDogaXRlcmF0b3JWYWx1ZShcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICByZXZlcnNlID8gdGhpcyQxJDEuc2l6ZSAtICsraSA6IGkrKyxcbiAgICAgICAgICAgIHN0ZXAudmFsdWUsXG4gICAgICAgICAgICBzdGVwXG4gICAgICAgICAgKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gVG9JbmRleGVkU2VxdWVuY2U7XG59KEluZGV4ZWRTZXEpKTtcblxudmFyIFRvU2V0U2VxdWVuY2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChTZXRTZXEpIHtcbiAgZnVuY3Rpb24gVG9TZXRTZXF1ZW5jZShpdGVyKSB7XG4gICAgdGhpcy5faXRlciA9IGl0ZXI7XG4gICAgdGhpcy5zaXplID0gaXRlci5zaXplO1xuICB9XG5cbiAgaWYgKCBTZXRTZXEgKSBUb1NldFNlcXVlbmNlLl9fcHJvdG9fXyA9IFNldFNlcTtcbiAgVG9TZXRTZXF1ZW5jZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTZXRTZXEgJiYgU2V0U2VxLnByb3RvdHlwZSApO1xuICBUb1NldFNlcXVlbmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRvU2V0U2VxdWVuY2U7XG5cbiAgVG9TZXRTZXF1ZW5jZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlci5pbmNsdWRlcyhrZXkpO1xuICB9O1xuXG4gIFRvU2V0U2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgdGhpcyQxJDEgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMuX2l0ZXIuX19pdGVyYXRlKGZ1bmN0aW9uICh2KSB7IHJldHVybiBmbih2LCB2LCB0aGlzJDEkMSk7IH0sIHJldmVyc2UpO1xuICB9O1xuXG4gIFRvU2V0U2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5faXRlci5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgcmV0dXJuIHN0ZXAuZG9uZVxuICAgICAgICA/IHN0ZXBcbiAgICAgICAgOiBpdGVyYXRvclZhbHVlKHR5cGUsIHN0ZXAudmFsdWUsIHN0ZXAudmFsdWUsIHN0ZXApO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBUb1NldFNlcXVlbmNlO1xufShTZXRTZXEpKTtcblxudmFyIEZyb21FbnRyaWVzU2VxdWVuY2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChLZXllZFNlcSkge1xuICBmdW5jdGlvbiBGcm9tRW50cmllc1NlcXVlbmNlKGVudHJpZXMpIHtcbiAgICB0aGlzLl9pdGVyID0gZW50cmllcztcbiAgICB0aGlzLnNpemUgPSBlbnRyaWVzLnNpemU7XG4gIH1cblxuICBpZiAoIEtleWVkU2VxICkgRnJvbUVudHJpZXNTZXF1ZW5jZS5fX3Byb3RvX18gPSBLZXllZFNlcTtcbiAgRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBLZXllZFNlcSAmJiBLZXllZFNlcS5wcm90b3R5cGUgKTtcbiAgRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGcm9tRW50cmllc1NlcXVlbmNlO1xuXG4gIEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlLmVudHJ5U2VxID0gZnVuY3Rpb24gZW50cnlTZXEgKCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVyLnRvU2VxKCk7XG4gIH07XG5cbiAgRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5faXRlci5fX2l0ZXJhdGUoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAvLyBDaGVjayBpZiBlbnRyeSBleGlzdHMgZmlyc3Qgc28gYXJyYXkgYWNjZXNzIGRvZXNuJ3QgdGhyb3cgZm9yIGhvbGVzXG4gICAgICAvLyBpbiB0aGUgcGFyZW50IGl0ZXJhdGlvbi5cbiAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICB2YWxpZGF0ZUVudHJ5KGVudHJ5KTtcbiAgICAgICAgdmFyIGluZGV4ZWRDb2xsZWN0aW9uID0gaXNDb2xsZWN0aW9uKGVudHJ5KTtcbiAgICAgICAgcmV0dXJuIGZuKFxuICAgICAgICAgIGluZGV4ZWRDb2xsZWN0aW9uID8gZW50cnkuZ2V0KDEpIDogZW50cnlbMV0sXG4gICAgICAgICAgaW5kZXhlZENvbGxlY3Rpb24gPyBlbnRyeS5nZXQoMCkgOiBlbnRyeVswXSxcbiAgICAgICAgICB0aGlzJDEkMVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sIHJldmVyc2UpO1xuICB9O1xuXG4gIEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5faXRlci5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgZW50cnkgZXhpc3RzIGZpcnN0IHNvIGFycmF5IGFjY2VzcyBkb2Vzbid0IHRocm93IGZvciBob2xlc1xuICAgICAgICAvLyBpbiB0aGUgcGFyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgdmFsaWRhdGVFbnRyeShlbnRyeSk7XG4gICAgICAgICAgdmFyIGluZGV4ZWRDb2xsZWN0aW9uID0gaXNDb2xsZWN0aW9uKGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZShcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBpbmRleGVkQ29sbGVjdGlvbiA/IGVudHJ5LmdldCgwKSA6IGVudHJ5WzBdLFxuICAgICAgICAgICAgaW5kZXhlZENvbGxlY3Rpb24gPyBlbnRyeS5nZXQoMSkgOiBlbnRyeVsxXSxcbiAgICAgICAgICAgIHN0ZXBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEZyb21FbnRyaWVzU2VxdWVuY2U7XG59KEtleWVkU2VxKSk7XG5cblRvSW5kZXhlZFNlcXVlbmNlLnByb3RvdHlwZS5jYWNoZVJlc3VsdCA9XG4gIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUuY2FjaGVSZXN1bHQgPVxuICBUb1NldFNlcXVlbmNlLnByb3RvdHlwZS5jYWNoZVJlc3VsdCA9XG4gIEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlLmNhY2hlUmVzdWx0ID1cbiAgICBjYWNoZVJlc3VsdFRocm91Z2g7XG5cbmZ1bmN0aW9uIGZsaXBGYWN0b3J5KGNvbGxlY3Rpb24pIHtcbiAgdmFyIGZsaXBTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKTtcbiAgZmxpcFNlcXVlbmNlLl9pdGVyID0gY29sbGVjdGlvbjtcbiAgZmxpcFNlcXVlbmNlLnNpemUgPSBjb2xsZWN0aW9uLnNpemU7XG4gIGZsaXBTZXF1ZW5jZS5mbGlwID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29sbGVjdGlvbjsgfTtcbiAgZmxpcFNlcXVlbmNlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJldmVyc2VkU2VxdWVuY2UgPSBjb2xsZWN0aW9uLnJldmVyc2UuYXBwbHkodGhpcyk7IC8vIHN1cGVyLnJldmVyc2UoKVxuICAgIHJldmVyc2VkU2VxdWVuY2UuZmxpcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbGxlY3Rpb24ucmV2ZXJzZSgpOyB9O1xuICAgIHJldHVybiByZXZlcnNlZFNlcXVlbmNlO1xuICB9O1xuICBmbGlwU2VxdWVuY2UuaGFzID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gY29sbGVjdGlvbi5pbmNsdWRlcyhrZXkpOyB9O1xuICBmbGlwU2VxdWVuY2UuaW5jbHVkZXMgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBjb2xsZWN0aW9uLmhhcyhrZXkpOyB9O1xuICBmbGlwU2VxdWVuY2UuY2FjaGVSZXN1bHQgPSBjYWNoZVJlc3VsdFRocm91Z2g7XG4gIGZsaXBTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICByZXR1cm4gY29sbGVjdGlvbi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIGZuKGssIHYsIHRoaXMkMSQxKSAhPT0gZmFsc2U7IH0sIHJldmVyc2UpO1xuICB9O1xuICBmbGlwU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24gKHR5cGUsIHJldmVyc2UpIHtcbiAgICBpZiAodHlwZSA9PT0gSVRFUkFURV9FTlRSSUVTKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmICghc3RlcC5kb25lKSB7XG4gICAgICAgICAgdmFyIGsgPSBzdGVwLnZhbHVlWzBdO1xuICAgICAgICAgIHN0ZXAudmFsdWVbMF0gPSBzdGVwLnZhbHVlWzFdO1xuICAgICAgICAgIHN0ZXAudmFsdWVbMV0gPSBrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uLl9faXRlcmF0b3IoXG4gICAgICB0eXBlID09PSBJVEVSQVRFX1ZBTFVFUyA/IElURVJBVEVfS0VZUyA6IElURVJBVEVfVkFMVUVTLFxuICAgICAgcmV2ZXJzZVxuICAgICk7XG4gIH07XG4gIHJldHVybiBmbGlwU2VxdWVuY2U7XG59XG5cbmZ1bmN0aW9uIG1hcEZhY3RvcnkoY29sbGVjdGlvbiwgbWFwcGVyLCBjb250ZXh0KSB7XG4gIHZhciBtYXBwZWRTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKTtcbiAgbWFwcGVkU2VxdWVuY2Uuc2l6ZSA9IGNvbGxlY3Rpb24uc2l6ZTtcbiAgbWFwcGVkU2VxdWVuY2UuaGFzID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gY29sbGVjdGlvbi5oYXMoa2V5KTsgfTtcbiAgbWFwcGVkU2VxdWVuY2UuZ2V0ID0gZnVuY3Rpb24gKGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICB2YXIgdiA9IGNvbGxlY3Rpb24uZ2V0KGtleSwgTk9UX1NFVCk7XG4gICAgcmV0dXJuIHYgPT09IE5PVF9TRVRcbiAgICAgID8gbm90U2V0VmFsdWVcbiAgICAgIDogbWFwcGVyLmNhbGwoY29udGV4dCwgdiwga2V5LCBjb2xsZWN0aW9uKTtcbiAgfTtcbiAgbWFwcGVkU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgdGhpcyQxJDEgPSB0aGlzO1xuXG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uX19pdGVyYXRlKFxuICAgICAgZnVuY3Rpb24gKHYsIGssIGMpIHsgcmV0dXJuIGZuKG1hcHBlci5jYWxsKGNvbnRleHQsIHYsIGssIGMpLCBrLCB0aGlzJDEkMSkgIT09IGZhbHNlOyB9LFxuICAgICAgcmV2ZXJzZVxuICAgICk7XG4gIH07XG4gIG1hcHBlZFNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uICh0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICB9XG4gICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgdmFyIGtleSA9IGVudHJ5WzBdO1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGtleSxcbiAgICAgICAgbWFwcGVyLmNhbGwoY29udGV4dCwgZW50cnlbMV0sIGtleSwgY29sbGVjdGlvbiksXG4gICAgICAgIHN0ZXBcbiAgICAgICk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBtYXBwZWRTZXF1ZW5jZTtcbn1cblxuZnVuY3Rpb24gcmV2ZXJzZUZhY3RvcnkoY29sbGVjdGlvbiwgdXNlS2V5cykge1xuICB2YXIgdGhpcyQxJDEgPSB0aGlzO1xuXG4gIHZhciByZXZlcnNlZFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGNvbGxlY3Rpb24pO1xuICByZXZlcnNlZFNlcXVlbmNlLl9pdGVyID0gY29sbGVjdGlvbjtcbiAgcmV2ZXJzZWRTZXF1ZW5jZS5zaXplID0gY29sbGVjdGlvbi5zaXplO1xuICByZXZlcnNlZFNlcXVlbmNlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2xsZWN0aW9uOyB9O1xuICBpZiAoY29sbGVjdGlvbi5mbGlwKSB7XG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5mbGlwID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZsaXBTZXF1ZW5jZSA9IGZsaXBGYWN0b3J5KGNvbGxlY3Rpb24pO1xuICAgICAgZmxpcFNlcXVlbmNlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2xsZWN0aW9uLmZsaXAoKTsgfTtcbiAgICAgIHJldHVybiBmbGlwU2VxdWVuY2U7XG4gICAgfTtcbiAgfVxuICByZXZlcnNlZFNlcXVlbmNlLmdldCA9IGZ1bmN0aW9uIChrZXksIG5vdFNldFZhbHVlKSB7IHJldHVybiBjb2xsZWN0aW9uLmdldCh1c2VLZXlzID8ga2V5IDogLTEgLSBrZXksIG5vdFNldFZhbHVlKTsgfTtcbiAgcmV2ZXJzZWRTZXF1ZW5jZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBjb2xsZWN0aW9uLmhhcyh1c2VLZXlzID8ga2V5IDogLTEgLSBrZXkpOyB9O1xuICByZXZlcnNlZFNlcXVlbmNlLmluY2x1ZGVzID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBjb2xsZWN0aW9uLmluY2x1ZGVzKHZhbHVlKTsgfTtcbiAgcmV2ZXJzZWRTZXF1ZW5jZS5jYWNoZVJlc3VsdCA9IGNhY2hlUmVzdWx0VGhyb3VnaDtcbiAgcmV2ZXJzZWRTZXF1ZW5jZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgdGhpcyQxJDEgPSB0aGlzO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHJldmVyc2UgJiYgZW5zdXJlU2l6ZShjb2xsZWN0aW9uKTtcbiAgICByZXR1cm4gY29sbGVjdGlvbi5fX2l0ZXJhdGUoXG4gICAgICBmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gZm4odiwgdXNlS2V5cyA/IGsgOiByZXZlcnNlID8gdGhpcyQxJDEuc2l6ZSAtICsraSA6IGkrKywgdGhpcyQxJDEpOyB9LFxuICAgICAgIXJldmVyc2VcbiAgICApO1xuICB9O1xuICByZXZlcnNlZFNlcXVlbmNlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiAodHlwZSwgcmV2ZXJzZSkge1xuICAgIHZhciBpID0gMDtcbiAgICByZXZlcnNlICYmIGVuc3VyZVNpemUoY29sbGVjdGlvbik7XG4gICAgdmFyIGl0ZXJhdG9yID0gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgIXJldmVyc2UpO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgfVxuICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKFxuICAgICAgICB0eXBlLFxuICAgICAgICB1c2VLZXlzID8gZW50cnlbMF0gOiByZXZlcnNlID8gdGhpcyQxJDEuc2l6ZSAtICsraSA6IGkrKyxcbiAgICAgICAgZW50cnlbMV0sXG4gICAgICAgIHN0ZXBcbiAgICAgICk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiByZXZlcnNlZFNlcXVlbmNlO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJGYWN0b3J5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgY29udGV4dCwgdXNlS2V5cykge1xuICB2YXIgZmlsdGVyU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG4gIGlmICh1c2VLZXlzKSB7XG4gICAgZmlsdGVyU2VxdWVuY2UuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIHYgPSBjb2xsZWN0aW9uLmdldChrZXksIE5PVF9TRVQpO1xuICAgICAgcmV0dXJuIHYgIT09IE5PVF9TRVQgJiYgISFwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrZXksIGNvbGxlY3Rpb24pO1xuICAgIH07XG4gICAgZmlsdGVyU2VxdWVuY2UuZ2V0ID0gZnVuY3Rpb24gKGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHZhciB2ID0gY29sbGVjdGlvbi5nZXQoa2V5LCBOT1RfU0VUKTtcbiAgICAgIHJldHVybiB2ICE9PSBOT1RfU0VUICYmIHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGtleSwgY29sbGVjdGlvbilcbiAgICAgICAgPyB2XG4gICAgICAgIDogbm90U2V0VmFsdWU7XG4gICAgfTtcbiAgfVxuICBmaWx0ZXJTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGssIGMpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCBjKSkge1xuICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgIHJldHVybiBmbih2LCB1c2VLZXlzID8gayA6IGl0ZXJhdGlvbnMgLSAxLCB0aGlzJDEkMSk7XG4gICAgICB9XG4gICAgfSwgcmV2ZXJzZSk7XG4gICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gIH07XG4gIGZpbHRlclNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uICh0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICB2YXIga2V5ID0gZW50cnlbMF07XG4gICAgICAgIHZhciB2YWx1ZSA9IGVudHJ5WzFdO1xuICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwoY29udGV4dCwgdmFsdWUsIGtleSwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCB1c2VLZXlzID8ga2V5IDogaXRlcmF0aW9ucysrLCB2YWx1ZSwgc3RlcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIGZpbHRlclNlcXVlbmNlO1xufVxuXG5mdW5jdGlvbiBjb3VudEJ5RmFjdG9yeShjb2xsZWN0aW9uLCBncm91cGVyLCBjb250ZXh0KSB7XG4gIHZhciBncm91cHMgPSBNYXAoKS5hc011dGFibGUoKTtcbiAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICBncm91cHMudXBkYXRlKGdyb3VwZXIuY2FsbChjb250ZXh0LCB2LCBrLCBjb2xsZWN0aW9uKSwgMCwgZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgKyAxOyB9KTtcbiAgfSk7XG4gIHJldHVybiBncm91cHMuYXNJbW11dGFibGUoKTtcbn1cblxuZnVuY3Rpb24gZ3JvdXBCeUZhY3RvcnkoY29sbGVjdGlvbiwgZ3JvdXBlciwgY29udGV4dCkge1xuICB2YXIgaXNLZXllZEl0ZXIgPSBpc0tleWVkKGNvbGxlY3Rpb24pO1xuICB2YXIgZ3JvdXBzID0gKGlzT3JkZXJlZChjb2xsZWN0aW9uKSA/IE9yZGVyZWRNYXAoKSA6IE1hcCgpKS5hc011dGFibGUoKTtcbiAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICBncm91cHMudXBkYXRlKFxuICAgICAgZ3JvdXBlci5jYWxsKGNvbnRleHQsIHYsIGssIGNvbGxlY3Rpb24pLFxuICAgICAgZnVuY3Rpb24gKGEpIHsgcmV0dXJuICgoYSA9IGEgfHwgW10pLCBhLnB1c2goaXNLZXllZEl0ZXIgPyBbaywgdl0gOiB2KSwgYSk7IH1cbiAgICApO1xuICB9KTtcbiAgdmFyIGNvZXJjZSA9IGNvbGxlY3Rpb25DbGFzcyhjb2xsZWN0aW9uKTtcbiAgcmV0dXJuIGdyb3Vwcy5tYXAoZnVuY3Rpb24gKGFycikgeyByZXR1cm4gcmVpZnkoY29sbGVjdGlvbiwgY29lcmNlKGFycikpOyB9KS5hc0ltbXV0YWJsZSgpO1xufVxuXG5mdW5jdGlvbiBzbGljZUZhY3RvcnkoY29sbGVjdGlvbiwgYmVnaW4sIGVuZCwgdXNlS2V5cykge1xuICB2YXIgb3JpZ2luYWxTaXplID0gY29sbGVjdGlvbi5zaXplO1xuXG4gIGlmICh3aG9sZVNsaWNlKGJlZ2luLCBlbmQsIG9yaWdpbmFsU2l6ZSkpIHtcbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfVxuXG4gIHZhciByZXNvbHZlZEJlZ2luID0gcmVzb2x2ZUJlZ2luKGJlZ2luLCBvcmlnaW5hbFNpemUpO1xuICB2YXIgcmVzb2x2ZWRFbmQgPSByZXNvbHZlRW5kKGVuZCwgb3JpZ2luYWxTaXplKTtcblxuICAvLyBiZWdpbiBvciBlbmQgd2lsbCBiZSBOYU4gaWYgdGhleSB3ZXJlIHByb3ZpZGVkIGFzIG5lZ2F0aXZlIG51bWJlcnMgYW5kXG4gIC8vIHRoaXMgY29sbGVjdGlvbidzIHNpemUgaXMgdW5rbm93bi4gSW4gdGhhdCBjYXNlLCBjYWNoZSBmaXJzdCBzbyB0aGVyZSBpc1xuICAvLyBhIGtub3duIHNpemUgYW5kIHRoZXNlIGRvIG5vdCByZXNvbHZlIHRvIE5hTi5cbiAgaWYgKHJlc29sdmVkQmVnaW4gIT09IHJlc29sdmVkQmVnaW4gfHwgcmVzb2x2ZWRFbmQgIT09IHJlc29sdmVkRW5kKSB7XG4gICAgcmV0dXJuIHNsaWNlRmFjdG9yeShjb2xsZWN0aW9uLnRvU2VxKCkuY2FjaGVSZXN1bHQoKSwgYmVnaW4sIGVuZCwgdXNlS2V5cyk7XG4gIH1cblxuICAvLyBOb3RlOiByZXNvbHZlZEVuZCBpcyB1bmRlZmluZWQgd2hlbiB0aGUgb3JpZ2luYWwgc2VxdWVuY2UncyBsZW5ndGggaXNcbiAgLy8gdW5rbm93biBhbmQgdGhpcyBzbGljZSBkaWQgbm90IHN1cHBseSBhbiBlbmQgYW5kIHNob3VsZCBjb250YWluIGFsbFxuICAvLyBlbGVtZW50cyBhZnRlciByZXNvbHZlZEJlZ2luLlxuICAvLyBJbiB0aGF0IGNhc2UsIHJlc29sdmVkU2l6ZSB3aWxsIGJlIE5hTiBhbmQgc2xpY2VTaXplIHdpbGwgcmVtYWluIHVuZGVmaW5lZC5cbiAgdmFyIHJlc29sdmVkU2l6ZSA9IHJlc29sdmVkRW5kIC0gcmVzb2x2ZWRCZWdpbjtcbiAgdmFyIHNsaWNlU2l6ZTtcbiAgaWYgKHJlc29sdmVkU2l6ZSA9PT0gcmVzb2x2ZWRTaXplKSB7XG4gICAgc2xpY2VTaXplID0gcmVzb2x2ZWRTaXplIDwgMCA/IDAgOiByZXNvbHZlZFNpemU7XG4gIH1cblxuICB2YXIgc2xpY2VTZXEgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG5cbiAgLy8gSWYgY29sbGVjdGlvbi5zaXplIGlzIHVuZGVmaW5lZCwgdGhlIHNpemUgb2YgdGhlIHJlYWxpemVkIHNsaWNlU2VxIGlzXG4gIC8vIHVua25vd24gYXQgdGhpcyBwb2ludCB1bmxlc3MgdGhlIG51bWJlciBvZiBpdGVtcyB0byBzbGljZSBpcyAwXG4gIHNsaWNlU2VxLnNpemUgPVxuICAgIHNsaWNlU2l6ZSA9PT0gMCA/IHNsaWNlU2l6ZSA6IChjb2xsZWN0aW9uLnNpemUgJiYgc2xpY2VTaXplKSB8fCB1bmRlZmluZWQ7XG5cbiAgaWYgKCF1c2VLZXlzICYmIGlzU2VxKGNvbGxlY3Rpb24pICYmIHNsaWNlU2l6ZSA+PSAwKSB7XG4gICAgc2xpY2VTZXEuZ2V0ID0gZnVuY3Rpb24gKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgICAgaW5kZXggPSB3cmFwSW5kZXgodGhpcywgaW5kZXgpO1xuICAgICAgcmV0dXJuIGluZGV4ID49IDAgJiYgaW5kZXggPCBzbGljZVNpemVcbiAgICAgICAgPyBjb2xsZWN0aW9uLmdldChpbmRleCArIHJlc29sdmVkQmVnaW4sIG5vdFNldFZhbHVlKVxuICAgICAgICA6IG5vdFNldFZhbHVlO1xuICAgIH07XG4gIH1cblxuICBzbGljZVNlcS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICBpZiAoc2xpY2VTaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbiAgICB9XG4gICAgdmFyIHNraXBwZWQgPSAwO1xuICAgIHZhciBpc1NraXBwaW5nID0gdHJ1ZTtcbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgIGlmICghKGlzU2tpcHBpbmcgJiYgKGlzU2tpcHBpbmcgPSBza2lwcGVkKysgPCByZXNvbHZlZEJlZ2luKSkpIHtcbiAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGZuKHYsIHVzZUtleXMgPyBrIDogaXRlcmF0aW9ucyAtIDEsIHRoaXMkMSQxKSAhPT0gZmFsc2UgJiZcbiAgICAgICAgICBpdGVyYXRpb25zICE9PSBzbGljZVNpemVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgfTtcblxuICBzbGljZVNlcS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbiAodHlwZSwgcmV2ZXJzZSkge1xuICAgIGlmIChzbGljZVNpemUgIT09IDAgJiYgcmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgaW5zdGFudGlhdGluZyBwYXJlbnQgaXRlcmF0b3IgaWYgdGFraW5nIDAuXG4gICAgaWYgKHNsaWNlU2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihpdGVyYXRvckRvbmUpO1xuICAgIH1cbiAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgdmFyIHNraXBwZWQgPSAwO1xuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgIHdoaWxlIChza2lwcGVkKysgPCByZXNvbHZlZEJlZ2luKSB7XG4gICAgICAgIGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIH1cbiAgICAgIGlmICgrK2l0ZXJhdGlvbnMgPiBzbGljZVNpemUpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgfVxuICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICBpZiAodXNlS2V5cyB8fCB0eXBlID09PSBJVEVSQVRFX1ZBTFVFUyB8fCBzdGVwLmRvbmUpIHtcbiAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gSVRFUkFURV9LRVlTKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMgLSAxLCB1bmRlZmluZWQsIHN0ZXApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucyAtIDEsIHN0ZXAudmFsdWVbMV0sIHN0ZXApO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBzbGljZVNlcTtcbn1cblxuZnVuY3Rpb24gdGFrZVdoaWxlRmFjdG9yeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgdmFyIHRha2VTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKTtcbiAgdGFrZVNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSQxID0gdGhpcztcblxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG4gICAgfVxuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICBjb2xsZWN0aW9uLl9faXRlcmF0ZShcbiAgICAgIGZ1bmN0aW9uICh2LCBrLCBjKSB7IHJldHVybiBwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCBjKSAmJiArK2l0ZXJhdGlvbnMgJiYgZm4odiwgaywgdGhpcyQxJDEpOyB9XG4gICAgKTtcbiAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgfTtcbiAgdGFrZVNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uICh0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSQxID0gdGhpcztcblxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgfVxuICAgIHZhciBpdGVyYXRvciA9IGNvbGxlY3Rpb24uX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMsIHJldmVyc2UpO1xuICAgIHZhciBpdGVyYXRpbmcgPSB0cnVlO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFpdGVyYXRpbmcpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgfVxuICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgfVxuICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgIHZhciBrID0gZW50cnlbMF07XG4gICAgICB2YXIgdiA9IGVudHJ5WzFdO1xuICAgICAgaWYgKCFwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCB0aGlzJDEkMSkpIHtcbiAgICAgICAgaXRlcmF0aW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlID09PSBJVEVSQVRFX0VOVFJJRVMgPyBzdGVwIDogaXRlcmF0b3JWYWx1ZSh0eXBlLCBrLCB2LCBzdGVwKTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIHRha2VTZXF1ZW5jZTtcbn1cblxuZnVuY3Rpb24gc2tpcFdoaWxlRmFjdG9yeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGNvbnRleHQsIHVzZUtleXMpIHtcbiAgdmFyIHNraXBTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKTtcbiAgc2tpcFNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSQxID0gdGhpcztcblxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG4gICAgfVxuICAgIHZhciBpc1NraXBwaW5nID0gdHJ1ZTtcbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGssIGMpIHtcbiAgICAgIGlmICghKGlzU2tpcHBpbmcgJiYgKGlzU2tpcHBpbmcgPSBwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCBjKSkpKSB7XG4gICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgcmV0dXJuIGZuKHYsIHVzZUtleXMgPyBrIDogaXRlcmF0aW9ucyAtIDEsIHRoaXMkMSQxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgfTtcbiAgc2tpcFNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uICh0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSQxID0gdGhpcztcblxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgfVxuICAgIHZhciBpdGVyYXRvciA9IGNvbGxlY3Rpb24uX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMsIHJldmVyc2UpO1xuICAgIHZhciBza2lwcGluZyA9IHRydWU7XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICB2YXIgaztcbiAgICAgIHZhciB2O1xuICAgICAgZG8ge1xuICAgICAgICBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgaWYgKHVzZUtleXMgfHwgdHlwZSA9PT0gSVRFUkFURV9WQUxVRVMpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZSA9PT0gSVRFUkFURV9LRVlTKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHVuZGVmaW5lZCwgc3RlcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgc3RlcC52YWx1ZVsxXSwgc3RlcCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgayA9IGVudHJ5WzBdO1xuICAgICAgICB2ID0gZW50cnlbMV07XG4gICAgICAgIHNraXBwaW5nICYmIChza2lwcGluZyA9IHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIHRoaXMkMSQxKSk7XG4gICAgICB9IHdoaWxlIChza2lwcGluZyk7XG4gICAgICByZXR1cm4gdHlwZSA9PT0gSVRFUkFURV9FTlRSSUVTID8gc3RlcCA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgaywgdiwgc3RlcCk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBza2lwU2VxdWVuY2U7XG59XG5cbmZ1bmN0aW9uIGNvbmNhdEZhY3RvcnkoY29sbGVjdGlvbiwgdmFsdWVzKSB7XG4gIHZhciBpc0tleWVkQ29sbGVjdGlvbiA9IGlzS2V5ZWQoY29sbGVjdGlvbik7XG4gIHZhciBpdGVycyA9IFtjb2xsZWN0aW9uXVxuICAgIC5jb25jYXQodmFsdWVzKVxuICAgIC5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgIGlmICghaXNDb2xsZWN0aW9uKHYpKSB7XG4gICAgICAgIHYgPSBpc0tleWVkQ29sbGVjdGlvblxuICAgICAgICAgID8ga2V5ZWRTZXFGcm9tVmFsdWUodilcbiAgICAgICAgICA6IGluZGV4ZWRTZXFGcm9tVmFsdWUoQXJyYXkuaXNBcnJheSh2KSA/IHYgOiBbdl0pO1xuICAgICAgfSBlbHNlIGlmIChpc0tleWVkQ29sbGVjdGlvbikge1xuICAgICAgICB2ID0gS2V5ZWRDb2xsZWN0aW9uKHYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHY7XG4gICAgfSlcbiAgICAuZmlsdGVyKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2LnNpemUgIT09IDA7IH0pO1xuXG4gIGlmIChpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfVxuXG4gIGlmIChpdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgc2luZ2xldG9uID0gaXRlcnNbMF07XG4gICAgaWYgKFxuICAgICAgc2luZ2xldG9uID09PSBjb2xsZWN0aW9uIHx8XG4gICAgICAoaXNLZXllZENvbGxlY3Rpb24gJiYgaXNLZXllZChzaW5nbGV0b24pKSB8fFxuICAgICAgKGlzSW5kZXhlZChjb2xsZWN0aW9uKSAmJiBpc0luZGV4ZWQoc2luZ2xldG9uKSlcbiAgICApIHtcbiAgICAgIHJldHVybiBzaW5nbGV0b247XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbmNhdFNlcSA9IG5ldyBBcnJheVNlcShpdGVycyk7XG4gIGlmIChpc0tleWVkQ29sbGVjdGlvbikge1xuICAgIGNvbmNhdFNlcSA9IGNvbmNhdFNlcS50b0tleWVkU2VxKCk7XG4gIH0gZWxzZSBpZiAoIWlzSW5kZXhlZChjb2xsZWN0aW9uKSkge1xuICAgIGNvbmNhdFNlcSA9IGNvbmNhdFNlcS50b1NldFNlcSgpO1xuICB9XG4gIGNvbmNhdFNlcSA9IGNvbmNhdFNlcS5mbGF0dGVuKHRydWUpO1xuICBjb25jYXRTZXEuc2l6ZSA9IGl0ZXJzLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBzZXEpIHtcbiAgICBpZiAoc3VtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBzaXplID0gc2VxLnNpemU7XG4gICAgICBpZiAoc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzdW0gKyBzaXplO1xuICAgICAgfVxuICAgIH1cbiAgfSwgMCk7XG4gIHJldHVybiBjb25jYXRTZXE7XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5GYWN0b3J5KGNvbGxlY3Rpb24sIGRlcHRoLCB1c2VLZXlzKSB7XG4gIHZhciBmbGF0U2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG4gIGZsYXRTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG4gICAgfVxuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICB2YXIgc3RvcHBlZCA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIGZsYXREZWVwKGl0ZXIsIGN1cnJlbnREZXB0aCkge1xuICAgICAgaXRlci5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgaWYgKCghZGVwdGggfHwgY3VycmVudERlcHRoIDwgZGVwdGgpICYmIGlzQ29sbGVjdGlvbih2KSkge1xuICAgICAgICAgIGZsYXREZWVwKHYsIGN1cnJlbnREZXB0aCArIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgICBpZiAoZm4odiwgdXNlS2V5cyA/IGsgOiBpdGVyYXRpb25zIC0gMSwgZmxhdFNlcXVlbmNlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXN0b3BwZWQ7XG4gICAgICB9LCByZXZlcnNlKTtcbiAgICB9XG4gICAgZmxhdERlZXAoY29sbGVjdGlvbiwgMCk7XG4gICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gIH07XG4gIGZsYXRTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbiAodHlwZSwgcmV2ZXJzZSkge1xuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgfVxuICAgIHZhciBpdGVyYXRvciA9IGNvbGxlY3Rpb24uX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICB3aGlsZSAoaXRlcmF0b3IpIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChzdGVwLmRvbmUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgaXRlcmF0b3IgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdiA9IHN0ZXAudmFsdWU7XG4gICAgICAgIGlmICh0eXBlID09PSBJVEVSQVRFX0VOVFJJRVMpIHtcbiAgICAgICAgICB2ID0gdlsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCFkZXB0aCB8fCBzdGFjay5sZW5ndGggPCBkZXB0aCkgJiYgaXNDb2xsZWN0aW9uKHYpKSB7XG4gICAgICAgICAgc3RhY2sucHVzaChpdGVyYXRvcik7XG4gICAgICAgICAgaXRlcmF0b3IgPSB2Ll9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHVzZUtleXMgPyBzdGVwIDogaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHYsIHN0ZXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBmbGF0U2VxdWVuY2U7XG59XG5cbmZ1bmN0aW9uIGZsYXRNYXBGYWN0b3J5KGNvbGxlY3Rpb24sIG1hcHBlciwgY29udGV4dCkge1xuICB2YXIgY29lcmNlID0gY29sbGVjdGlvbkNsYXNzKGNvbGxlY3Rpb24pO1xuICByZXR1cm4gY29sbGVjdGlvblxuICAgIC50b1NlcSgpXG4gICAgLm1hcChmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gY29lcmNlKG1hcHBlci5jYWxsKGNvbnRleHQsIHYsIGssIGNvbGxlY3Rpb24pKTsgfSlcbiAgICAuZmxhdHRlbih0cnVlKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJwb3NlRmFjdG9yeShjb2xsZWN0aW9uLCBzZXBhcmF0b3IpIHtcbiAgdmFyIGludGVycG9zZWRTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKTtcbiAgaW50ZXJwb3NlZFNlcXVlbmNlLnNpemUgPSBjb2xsZWN0aW9uLnNpemUgJiYgY29sbGVjdGlvbi5zaXplICogMiAtIDE7XG4gIGludGVycG9zZWRTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoXG4gICAgICBmdW5jdGlvbiAodikgeyByZXR1cm4gKCFpdGVyYXRpb25zIHx8IGZuKHNlcGFyYXRvciwgaXRlcmF0aW9ucysrLCB0aGlzJDEkMSkgIT09IGZhbHNlKSAmJlxuICAgICAgICBmbih2LCBpdGVyYXRpb25zKyssIHRoaXMkMSQxKSAhPT0gZmFsc2U7IH0sXG4gICAgICByZXZlcnNlXG4gICAgKTtcbiAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgfTtcbiAgaW50ZXJwb3NlZFNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uICh0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgdmFyIHN0ZXA7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXN0ZXAgfHwgaXRlcmF0aW9ucyAlIDIpIHtcbiAgICAgICAgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucyAlIDJcbiAgICAgICAgPyBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgc2VwYXJhdG9yKVxuICAgICAgICA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCBzdGVwLnZhbHVlLCBzdGVwKTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIGludGVycG9zZWRTZXF1ZW5jZTtcbn1cblxuZnVuY3Rpb24gc29ydEZhY3RvcnkoY29sbGVjdGlvbiwgY29tcGFyYXRvciwgbWFwcGVyKSB7XG4gIGlmICghY29tcGFyYXRvcikge1xuICAgIGNvbXBhcmF0b3IgPSBkZWZhdWx0Q29tcGFyYXRvcjtcbiAgfVxuICB2YXIgaXNLZXllZENvbGxlY3Rpb24gPSBpc0tleWVkKGNvbGxlY3Rpb24pO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgZW50cmllcyA9IGNvbGxlY3Rpb25cbiAgICAudG9TZXEoKVxuICAgIC5tYXAoZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIFtrLCB2LCBpbmRleCsrLCBtYXBwZXIgPyBtYXBwZXIodiwgaywgY29sbGVjdGlvbikgOiB2XTsgfSlcbiAgICAudmFsdWVTZXEoKVxuICAgIC50b0FycmF5KCk7XG4gIGVudHJpZXNcbiAgICAuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gY29tcGFyYXRvcihhWzNdLCBiWzNdKSB8fCBhWzJdIC0gYlsyXTsgfSlcbiAgICAuZm9yRWFjaChcbiAgICAgIGlzS2V5ZWRDb2xsZWN0aW9uXG4gICAgICAgID8gZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgICAgICAgIGVudHJpZXNbaV0ubGVuZ3RoID0gMjtcbiAgICAgICAgICB9XG4gICAgICAgIDogZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgICAgICAgIGVudHJpZXNbaV0gPSB2WzFdO1xuICAgICAgICAgIH1cbiAgICApO1xuICByZXR1cm4gaXNLZXllZENvbGxlY3Rpb25cbiAgICA/IEtleWVkU2VxKGVudHJpZXMpXG4gICAgOiBpc0luZGV4ZWQoY29sbGVjdGlvbilcbiAgICA/IEluZGV4ZWRTZXEoZW50cmllcylcbiAgICA6IFNldFNlcShlbnRyaWVzKTtcbn1cblxuZnVuY3Rpb24gbWF4RmFjdG9yeShjb2xsZWN0aW9uLCBjb21wYXJhdG9yLCBtYXBwZXIpIHtcbiAgaWYgKCFjb21wYXJhdG9yKSB7XG4gICAgY29tcGFyYXRvciA9IGRlZmF1bHRDb21wYXJhdG9yO1xuICB9XG4gIGlmIChtYXBwZXIpIHtcbiAgICB2YXIgZW50cnkgPSBjb2xsZWN0aW9uXG4gICAgICAudG9TZXEoKVxuICAgICAgLm1hcChmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gW3YsIG1hcHBlcih2LCBrLCBjb2xsZWN0aW9uKV07IH0pXG4gICAgICAucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiAobWF4Q29tcGFyZShjb21wYXJhdG9yLCBhWzFdLCBiWzFdKSA/IGIgOiBhKTsgfSk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5WzBdO1xuICB9XG4gIHJldHVybiBjb2xsZWN0aW9uLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gKG1heENvbXBhcmUoY29tcGFyYXRvciwgYSwgYikgPyBiIDogYSk7IH0pO1xufVxuXG5mdW5jdGlvbiBtYXhDb21wYXJlKGNvbXBhcmF0b3IsIGEsIGIpIHtcbiAgdmFyIGNvbXAgPSBjb21wYXJhdG9yKGIsIGEpO1xuICAvLyBiIGlzIGNvbnNpZGVyZWQgdGhlIG5ldyBtYXggaWYgdGhlIGNvbXBhcmF0b3IgZGVjbGFyZXMgdGhlbSBlcXVhbCwgYnV0XG4gIC8vIHRoZXkgYXJlIG5vdCBlcXVhbCBhbmQgYiBpcyBpbiBmYWN0IGEgbnVsbGlzaCB2YWx1ZS5cbiAgcmV0dXJuIChcbiAgICAoY29tcCA9PT0gMCAmJiBiICE9PSBhICYmIChiID09PSB1bmRlZmluZWQgfHwgYiA9PT0gbnVsbCB8fCBiICE9PSBiKSkgfHxcbiAgICBjb21wID4gMFxuICApO1xufVxuXG5mdW5jdGlvbiB6aXBXaXRoRmFjdG9yeShrZXlJdGVyLCB6aXBwZXIsIGl0ZXJzLCB6aXBBbGwpIHtcbiAgdmFyIHppcFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGtleUl0ZXIpO1xuICB2YXIgc2l6ZXMgPSBuZXcgQXJyYXlTZXEoaXRlcnMpLm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gaS5zaXplOyB9KTtcbiAgemlwU2VxdWVuY2Uuc2l6ZSA9IHppcEFsbCA/IHNpemVzLm1heCgpIDogc2l6ZXMubWluKCk7XG4gIC8vIE5vdGU6IHRoaXMgYSBnZW5lcmljIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgX19pdGVyYXRlIGluIHRlcm1zIG9mXG4gIC8vIF9faXRlcmF0b3Igd2hpY2ggbWF5IGJlIG1vcmUgZ2VuZXJpY2FsbHkgdXNlZnVsIGluIHRoZSBmdXR1cmUuXG4gIHppcFNlcXVlbmNlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgIC8qIGdlbmVyaWM6XG4gICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG4gICAgdmFyIHN0ZXA7XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgIGlmIChmbihzdGVwLnZhbHVlWzFdLCBzdGVwLnZhbHVlWzBdLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgICovXG4gICAgLy8gaW5kZXhlZDpcbiAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9faXRlcmF0b3IoSVRFUkFURV9WQUxVRVMsIHJldmVyc2UpO1xuICAgIHZhciBzdGVwO1xuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICBpZiAoZm4oc3RlcC52YWx1ZSwgaXRlcmF0aW9ucysrLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpdGVyYXRpb25zO1xuICB9O1xuICB6aXBTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbiAodHlwZSwgcmV2ZXJzZSkge1xuICAgIHZhciBpdGVyYXRvcnMgPSBpdGVycy5tYXAoXG4gICAgICBmdW5jdGlvbiAoaSkgeyByZXR1cm4gKChpID0gQ29sbGVjdGlvbihpKSksIGdldEl0ZXJhdG9yKHJldmVyc2UgPyBpLnJldmVyc2UoKSA6IGkpKTsgfVxuICAgICk7XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIHZhciBpc0RvbmUgPSBmYWxzZTtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdGVwcztcbiAgICAgIGlmICghaXNEb25lKSB7XG4gICAgICAgIHN0ZXBzID0gaXRlcmF0b3JzLm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gaS5uZXh0KCk7IH0pO1xuICAgICAgICBpc0RvbmUgPSB6aXBBbGwgPyBzdGVwcy5ldmVyeShmdW5jdGlvbiAocykgeyByZXR1cm4gcy5kb25lOyB9KSA6IHN0ZXBzLnNvbWUoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMuZG9uZTsgfSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNEb25lKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKFxuICAgICAgICB0eXBlLFxuICAgICAgICBpdGVyYXRpb25zKyssXG4gICAgICAgIHppcHBlci5hcHBseShcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHN0ZXBzLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gcy52YWx1ZTsgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIHppcFNlcXVlbmNlO1xufVxuXG4vLyAjcHJhZ21hIEhlbHBlciBGdW5jdGlvbnNcblxuZnVuY3Rpb24gcmVpZnkoaXRlciwgc2VxKSB7XG4gIHJldHVybiBpdGVyID09PSBzZXEgPyBpdGVyIDogaXNTZXEoaXRlcikgPyBzZXEgOiBpdGVyLmNvbnN0cnVjdG9yKHNlcSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRW50cnkoZW50cnkpIHtcbiAgaWYgKGVudHJ5ICE9PSBPYmplY3QoZW50cnkpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgW0ssIFZdIHR1cGxlOiAnICsgZW50cnkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3Rpb25DbGFzcyhjb2xsZWN0aW9uKSB7XG4gIHJldHVybiBpc0tleWVkKGNvbGxlY3Rpb24pXG4gICAgPyBLZXllZENvbGxlY3Rpb25cbiAgICA6IGlzSW5kZXhlZChjb2xsZWN0aW9uKVxuICAgID8gSW5kZXhlZENvbGxlY3Rpb25cbiAgICA6IFNldENvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKSB7XG4gIHJldHVybiBPYmplY3QuY3JlYXRlKFxuICAgIChpc0tleWVkKGNvbGxlY3Rpb24pXG4gICAgICA/IEtleWVkU2VxXG4gICAgICA6IGlzSW5kZXhlZChjb2xsZWN0aW9uKVxuICAgICAgPyBJbmRleGVkU2VxXG4gICAgICA6IFNldFNlcVxuICAgICkucHJvdG90eXBlXG4gICk7XG59XG5cbmZ1bmN0aW9uIGNhY2hlUmVzdWx0VGhyb3VnaCgpIHtcbiAgaWYgKHRoaXMuX2l0ZXIuY2FjaGVSZXN1bHQpIHtcbiAgICB0aGlzLl9pdGVyLmNhY2hlUmVzdWx0KCk7XG4gICAgdGhpcy5zaXplID0gdGhpcy5faXRlci5zaXplO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJldHVybiBTZXEucHJvdG90eXBlLmNhY2hlUmVzdWx0LmNhbGwodGhpcyk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDb21wYXJhdG9yKGEsIGIpIHtcbiAgaWYgKGEgPT09IHVuZGVmaW5lZCAmJiBiID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChhID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDA7XG59XG5cbmZ1bmN0aW9uIGFyckNvcHkoYXJyLCBvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBsZW4gPSBNYXRoLm1heCgwLCBhcnIubGVuZ3RoIC0gb2Zmc2V0KTtcbiAgdmFyIG5ld0FyciA9IG5ldyBBcnJheShsZW4pO1xuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbGVuOyBpaSsrKSB7XG4gICAgbmV3QXJyW2lpXSA9IGFycltpaSArIG9mZnNldF07XG4gIH1cbiAgcmV0dXJuIG5ld0Fycjtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZXJyb3IpIHtcbiAgaWYgKCFjb25kaXRpb24pIHsgdGhyb3cgbmV3IEVycm9yKGVycm9yKTsgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnROb3RJbmZpbml0ZShzaXplKSB7XG4gIGludmFyaWFudChcbiAgICBzaXplICE9PSBJbmZpbml0eSxcbiAgICAnQ2Fubm90IHBlcmZvcm0gdGhpcyBhY3Rpb24gd2l0aCBhbiBpbmZpbml0ZSBzaXplLidcbiAgKTtcbn1cblxuZnVuY3Rpb24gY29lcmNlS2V5UGF0aChrZXlQYXRoKSB7XG4gIGlmIChpc0FycmF5TGlrZShrZXlQYXRoKSAmJiB0eXBlb2Yga2V5UGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4ga2V5UGF0aDtcbiAgfVxuICBpZiAoaXNPcmRlcmVkKGtleVBhdGgpKSB7XG4gICAgcmV0dXJuIGtleVBhdGgudG9BcnJheSgpO1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ0ludmFsaWQga2V5UGF0aDogZXhwZWN0ZWQgT3JkZXJlZCBDb2xsZWN0aW9uIG9yIEFycmF5OiAnICsga2V5UGF0aFxuICApO1xufVxuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIC8vIFRoZSBiYXNlIHByb3RvdHlwZSdzIHRvU3RyaW5nIGRlYWxzIHdpdGggQXJndW1lbnQgb2JqZWN0cyBhbmQgbmF0aXZlIG5hbWVzcGFjZXMgbGlrZSBNYXRoXG4gIGlmIChcbiAgICAhdmFsdWUgfHxcbiAgICB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8XG4gICAgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgIT09ICdbb2JqZWN0IE9iamVjdF0nXG4gICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gSXRlcmF0aXZlbHkgZ29pbmcgdXAgdGhlIHByb3RvdHlwZSBjaGFpbiBpcyBuZWVkZWQgZm9yIGNyb3NzLXJlYWxtIGVudmlyb25tZW50cyAoZGlmZmVyaW5nIGNvbnRleHRzLCBpZnJhbWVzLCBldGMpXG4gIHZhciBwYXJlbnRQcm90byA9IHByb3RvO1xuICB2YXIgbmV4dFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgd2hpbGUgKG5leHRQcm90byAhPT0gbnVsbCkge1xuICAgIHBhcmVudFByb3RvID0gbmV4dFByb3RvO1xuICAgIG5leHRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwYXJlbnRQcm90byk7XG4gIH1cbiAgcmV0dXJuIHBhcmVudFByb3RvID09PSBwcm90bztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgcG90ZW50aWFsbHktcGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZSwgZWl0aGVyXG4gKiBwcm92aWRlZCBieSBJbW11dGFibGUuanMgb3IgYSBwbGFpbiBBcnJheSBvciBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzRGF0YVN0cnVjdHVyZSh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAoaXNJbW11dGFibGUodmFsdWUpIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKVxuICApO1xufVxuXG5mdW5jdGlvbiBxdW90ZVN0cmluZyh2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogU3RyaW5nKHZhbHVlKTtcbiAgfSBjYXRjaCAoX2lnbm9yZUVycm9yKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXMoY29sbGVjdGlvbiwga2V5KSB7XG4gIHJldHVybiBpc0ltbXV0YWJsZShjb2xsZWN0aW9uKVxuICAgID8gY29sbGVjdGlvbi5oYXMoa2V5KVxuICAgIDogaXNEYXRhU3RydWN0dXJlKGNvbGxlY3Rpb24pICYmIGhhc093blByb3BlcnR5LmNhbGwoY29sbGVjdGlvbiwga2V5KTtcbn1cblxuZnVuY3Rpb24gZ2V0KGNvbGxlY3Rpb24sIGtleSwgbm90U2V0VmFsdWUpIHtcbiAgcmV0dXJuIGlzSW1tdXRhYmxlKGNvbGxlY3Rpb24pXG4gICAgPyBjb2xsZWN0aW9uLmdldChrZXksIG5vdFNldFZhbHVlKVxuICAgIDogIWhhcyhjb2xsZWN0aW9uLCBrZXkpXG4gICAgPyBub3RTZXRWYWx1ZVxuICAgIDogdHlwZW9mIGNvbGxlY3Rpb24uZ2V0ID09PSAnZnVuY3Rpb24nXG4gICAgPyBjb2xsZWN0aW9uLmdldChrZXkpXG4gICAgOiBjb2xsZWN0aW9uW2tleV07XG59XG5cbmZ1bmN0aW9uIHNoYWxsb3dDb3B5KGZyb20pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZnJvbSkpIHtcbiAgICByZXR1cm4gYXJyQ29weShmcm9tKTtcbiAgfVxuICB2YXIgdG8gPSB7fTtcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG4gICAgICB0b1trZXldID0gZnJvbVtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG87XG59XG5cbmZ1bmN0aW9uIHJlbW92ZShjb2xsZWN0aW9uLCBrZXkpIHtcbiAgaWYgKCFpc0RhdGFTdHJ1Y3R1cmUoY29sbGVjdGlvbikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ0Nhbm5vdCB1cGRhdGUgbm9uLWRhdGEtc3RydWN0dXJlIHZhbHVlOiAnICsgY29sbGVjdGlvblxuICAgICk7XG4gIH1cbiAgaWYgKGlzSW1tdXRhYmxlKGNvbGxlY3Rpb24pKSB7XG4gICAgaWYgKCFjb2xsZWN0aW9uLnJlbW92ZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCB1cGRhdGUgaW1tdXRhYmxlIHZhbHVlIHdpdGhvdXQgLnJlbW92ZSgpIG1ldGhvZDogJyArIGNvbGxlY3Rpb25cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uLnJlbW92ZShrZXkpO1xuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChjb2xsZWN0aW9uLCBrZXkpKSB7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH1cbiAgdmFyIGNvbGxlY3Rpb25Db3B5ID0gc2hhbGxvd0NvcHkoY29sbGVjdGlvbik7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbGxlY3Rpb25Db3B5KSkge1xuICAgIGNvbGxlY3Rpb25Db3B5LnNwbGljZShrZXksIDEpO1xuICB9IGVsc2Uge1xuICAgIGRlbGV0ZSBjb2xsZWN0aW9uQ29weVtrZXldO1xuICB9XG4gIHJldHVybiBjb2xsZWN0aW9uQ29weTtcbn1cblxuZnVuY3Rpb24gc2V0KGNvbGxlY3Rpb24sIGtleSwgdmFsdWUpIHtcbiAgaWYgKCFpc0RhdGFTdHJ1Y3R1cmUoY29sbGVjdGlvbikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ0Nhbm5vdCB1cGRhdGUgbm9uLWRhdGEtc3RydWN0dXJlIHZhbHVlOiAnICsgY29sbGVjdGlvblxuICAgICk7XG4gIH1cbiAgaWYgKGlzSW1tdXRhYmxlKGNvbGxlY3Rpb24pKSB7XG4gICAgaWYgKCFjb2xsZWN0aW9uLnNldCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCB1cGRhdGUgaW1tdXRhYmxlIHZhbHVlIHdpdGhvdXQgLnNldCgpIG1ldGhvZDogJyArIGNvbGxlY3Rpb25cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uLnNldChrZXksIHZhbHVlKTtcbiAgfVxuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb2xsZWN0aW9uLCBrZXkpICYmIHZhbHVlID09PSBjb2xsZWN0aW9uW2tleV0pIHtcbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfVxuICB2YXIgY29sbGVjdGlvbkNvcHkgPSBzaGFsbG93Q29weShjb2xsZWN0aW9uKTtcbiAgY29sbGVjdGlvbkNvcHlba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gY29sbGVjdGlvbkNvcHk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUluJDEoY29sbGVjdGlvbiwga2V5UGF0aCwgbm90U2V0VmFsdWUsIHVwZGF0ZXIpIHtcbiAgaWYgKCF1cGRhdGVyKSB7XG4gICAgdXBkYXRlciA9IG5vdFNldFZhbHVlO1xuICAgIG5vdFNldFZhbHVlID0gdW5kZWZpbmVkO1xuICB9XG4gIHZhciB1cGRhdGVkVmFsdWUgPSB1cGRhdGVJbkRlZXBseShcbiAgICBpc0ltbXV0YWJsZShjb2xsZWN0aW9uKSxcbiAgICBjb2xsZWN0aW9uLFxuICAgIGNvZXJjZUtleVBhdGgoa2V5UGF0aCksXG4gICAgMCxcbiAgICBub3RTZXRWYWx1ZSxcbiAgICB1cGRhdGVyXG4gICk7XG4gIHJldHVybiB1cGRhdGVkVmFsdWUgPT09IE5PVF9TRVQgPyBub3RTZXRWYWx1ZSA6IHVwZGF0ZWRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSW5EZWVwbHkoXG4gIGluSW1tdXRhYmxlLFxuICBleGlzdGluZyxcbiAga2V5UGF0aCxcbiAgaSxcbiAgbm90U2V0VmFsdWUsXG4gIHVwZGF0ZXJcbikge1xuICB2YXIgd2FzTm90U2V0ID0gZXhpc3RpbmcgPT09IE5PVF9TRVQ7XG4gIGlmIChpID09PSBrZXlQYXRoLmxlbmd0aCkge1xuICAgIHZhciBleGlzdGluZ1ZhbHVlID0gd2FzTm90U2V0ID8gbm90U2V0VmFsdWUgOiBleGlzdGluZztcbiAgICB2YXIgbmV3VmFsdWUgPSB1cGRhdGVyKGV4aXN0aW5nVmFsdWUpO1xuICAgIHJldHVybiBuZXdWYWx1ZSA9PT0gZXhpc3RpbmdWYWx1ZSA/IGV4aXN0aW5nIDogbmV3VmFsdWU7XG4gIH1cbiAgaWYgKCF3YXNOb3RTZXQgJiYgIWlzRGF0YVN0cnVjdHVyZShleGlzdGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ0Nhbm5vdCB1cGRhdGUgd2l0aGluIG5vbi1kYXRhLXN0cnVjdHVyZSB2YWx1ZSBpbiBwYXRoIFsnICtcbiAgICAgICAga2V5UGF0aC5zbGljZSgwLCBpKS5tYXAocXVvdGVTdHJpbmcpICtcbiAgICAgICAgJ106ICcgK1xuICAgICAgICBleGlzdGluZ1xuICAgICk7XG4gIH1cbiAgdmFyIGtleSA9IGtleVBhdGhbaV07XG4gIHZhciBuZXh0RXhpc3RpbmcgPSB3YXNOb3RTZXQgPyBOT1RfU0VUIDogZ2V0KGV4aXN0aW5nLCBrZXksIE5PVF9TRVQpO1xuICB2YXIgbmV4dFVwZGF0ZWQgPSB1cGRhdGVJbkRlZXBseShcbiAgICBuZXh0RXhpc3RpbmcgPT09IE5PVF9TRVQgPyBpbkltbXV0YWJsZSA6IGlzSW1tdXRhYmxlKG5leHRFeGlzdGluZyksXG4gICAgbmV4dEV4aXN0aW5nLFxuICAgIGtleVBhdGgsXG4gICAgaSArIDEsXG4gICAgbm90U2V0VmFsdWUsXG4gICAgdXBkYXRlclxuICApO1xuICByZXR1cm4gbmV4dFVwZGF0ZWQgPT09IG5leHRFeGlzdGluZ1xuICAgID8gZXhpc3RpbmdcbiAgICA6IG5leHRVcGRhdGVkID09PSBOT1RfU0VUXG4gICAgPyByZW1vdmUoZXhpc3RpbmcsIGtleSlcbiAgICA6IHNldChcbiAgICAgICAgd2FzTm90U2V0ID8gKGluSW1tdXRhYmxlID8gZW1wdHlNYXAoKSA6IHt9KSA6IGV4aXN0aW5nLFxuICAgICAgICBrZXksXG4gICAgICAgIG5leHRVcGRhdGVkXG4gICAgICApO1xufVxuXG5mdW5jdGlvbiBzZXRJbiQxKGNvbGxlY3Rpb24sIGtleVBhdGgsIHZhbHVlKSB7XG4gIHJldHVybiB1cGRhdGVJbiQxKGNvbGxlY3Rpb24sIGtleVBhdGgsIE5PVF9TRVQsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlOyB9KTtcbn1cblxuZnVuY3Rpb24gc2V0SW4oa2V5UGF0aCwgdikge1xuICByZXR1cm4gc2V0SW4kMSh0aGlzLCBrZXlQYXRoLCB2KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlSW4oY29sbGVjdGlvbiwga2V5UGF0aCkge1xuICByZXR1cm4gdXBkYXRlSW4kMShjb2xsZWN0aW9uLCBrZXlQYXRoLCBmdW5jdGlvbiAoKSB7IHJldHVybiBOT1RfU0VUOyB9KTtcbn1cblxuZnVuY3Rpb24gZGVsZXRlSW4oa2V5UGF0aCkge1xuICByZXR1cm4gcmVtb3ZlSW4odGhpcywga2V5UGF0aCk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZSQxKGNvbGxlY3Rpb24sIGtleSwgbm90U2V0VmFsdWUsIHVwZGF0ZXIpIHtcbiAgcmV0dXJuIHVwZGF0ZUluJDEoY29sbGVjdGlvbiwgW2tleV0sIG5vdFNldFZhbHVlLCB1cGRhdGVyKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlKGtleSwgbm90U2V0VmFsdWUsIHVwZGF0ZXIpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDFcbiAgICA/IGtleSh0aGlzKVxuICAgIDogdXBkYXRlJDEodGhpcywga2V5LCBub3RTZXRWYWx1ZSwgdXBkYXRlcik7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUluKGtleVBhdGgsIG5vdFNldFZhbHVlLCB1cGRhdGVyKSB7XG4gIHJldHVybiB1cGRhdGVJbiQxKHRoaXMsIGtleVBhdGgsIG5vdFNldFZhbHVlLCB1cGRhdGVyKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2UkMSgpIHtcbiAgdmFyIGl0ZXJzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHdoaWxlICggbGVuLS0gKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gIHJldHVybiBtZXJnZUludG9LZXllZFdpdGgodGhpcywgaXRlcnMpO1xufVxuXG5mdW5jdGlvbiBtZXJnZVdpdGgkMShtZXJnZXIpIHtcbiAgdmFyIGl0ZXJzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICB3aGlsZSAoIGxlbi0tID4gMCApIGl0ZXJzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gIGlmICh0eXBlb2YgbWVyZ2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtZXJnZXIgZnVuY3Rpb246ICcgKyBtZXJnZXIpO1xuICB9XG4gIHJldHVybiBtZXJnZUludG9LZXllZFdpdGgodGhpcywgaXRlcnMsIG1lcmdlcik7XG59XG5cbmZ1bmN0aW9uIG1lcmdlSW50b0tleWVkV2l0aChjb2xsZWN0aW9uLCBjb2xsZWN0aW9ucywgbWVyZ2VyKSB7XG4gIHZhciBpdGVycyA9IFtdO1xuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgY29sbGVjdGlvbnMubGVuZ3RoOyBpaSsrKSB7XG4gICAgdmFyIGNvbGxlY3Rpb24kMSA9IEtleWVkQ29sbGVjdGlvbihjb2xsZWN0aW9uc1tpaV0pO1xuICAgIGlmIChjb2xsZWN0aW9uJDEuc2l6ZSAhPT0gMCkge1xuICAgICAgaXRlcnMucHVzaChjb2xsZWN0aW9uJDEpO1xuICAgIH1cbiAgfVxuICBpZiAoaXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH1cbiAgaWYgKFxuICAgIGNvbGxlY3Rpb24udG9TZXEoKS5zaXplID09PSAwICYmXG4gICAgIWNvbGxlY3Rpb24uX19vd25lcklEICYmXG4gICAgaXRlcnMubGVuZ3RoID09PSAxXG4gICkge1xuICAgIHJldHVybiBjb2xsZWN0aW9uLmNvbnN0cnVjdG9yKGl0ZXJzWzBdKTtcbiAgfVxuICByZXR1cm4gY29sbGVjdGlvbi53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XG4gICAgdmFyIG1lcmdlSW50b0NvbGxlY3Rpb24gPSBtZXJnZXJcbiAgICAgID8gZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICB1cGRhdGUkMShjb2xsZWN0aW9uLCBrZXksIE5PVF9TRVQsIGZ1bmN0aW9uIChvbGRWYWwpIHsgcmV0dXJuIG9sZFZhbCA9PT0gTk9UX1NFVCA/IHZhbHVlIDogbWVyZ2VyKG9sZFZhbCwgdmFsdWUsIGtleSk7IH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICA6IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgY29sbGVjdGlvbi5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGl0ZXJzLmxlbmd0aDsgaWkrKykge1xuICAgICAgaXRlcnNbaWldLmZvckVhY2gobWVyZ2VJbnRvQ29sbGVjdGlvbik7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gbWVyZ2UoY29sbGVjdGlvbikge1xuICB2YXIgc291cmNlcyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKCBsZW4tLSA+IDAgKSBzb3VyY2VzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gIHJldHVybiBtZXJnZVdpdGhTb3VyY2VzKGNvbGxlY3Rpb24sIHNvdXJjZXMpO1xufVxuXG5mdW5jdGlvbiBtZXJnZVdpdGgobWVyZ2VyLCBjb2xsZWN0aW9uKSB7XG4gIHZhciBzb3VyY2VzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICB3aGlsZSAoIGxlbi0tID4gMCApIHNvdXJjZXNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAyIF07XG5cbiAgcmV0dXJuIG1lcmdlV2l0aFNvdXJjZXMoY29sbGVjdGlvbiwgc291cmNlcywgbWVyZ2VyKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VEZWVwJDEoY29sbGVjdGlvbikge1xuICB2YXIgc291cmNlcyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKCBsZW4tLSA+IDAgKSBzb3VyY2VzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gIHJldHVybiBtZXJnZURlZXBXaXRoU291cmNlcyhjb2xsZWN0aW9uLCBzb3VyY2VzKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VEZWVwV2l0aCQxKG1lcmdlciwgY29sbGVjdGlvbikge1xuICB2YXIgc291cmNlcyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgd2hpbGUgKCBsZW4tLSA+IDAgKSBzb3VyY2VzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMiBdO1xuXG4gIHJldHVybiBtZXJnZURlZXBXaXRoU291cmNlcyhjb2xsZWN0aW9uLCBzb3VyY2VzLCBtZXJnZXIpO1xufVxuXG5mdW5jdGlvbiBtZXJnZURlZXBXaXRoU291cmNlcyhjb2xsZWN0aW9uLCBzb3VyY2VzLCBtZXJnZXIpIHtcbiAgcmV0dXJuIG1lcmdlV2l0aFNvdXJjZXMoY29sbGVjdGlvbiwgc291cmNlcywgZGVlcE1lcmdlcldpdGgobWVyZ2VyKSk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlV2l0aFNvdXJjZXMoY29sbGVjdGlvbiwgc291cmNlcywgbWVyZ2VyKSB7XG4gIGlmICghaXNEYXRhU3RydWN0dXJlKGNvbGxlY3Rpb24pKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdDYW5ub3QgbWVyZ2UgaW50byBub24tZGF0YS1zdHJ1Y3R1cmUgdmFsdWU6ICcgKyBjb2xsZWN0aW9uXG4gICAgKTtcbiAgfVxuICBpZiAoaXNJbW11dGFibGUoY29sbGVjdGlvbikpIHtcbiAgICByZXR1cm4gdHlwZW9mIG1lcmdlciA9PT0gJ2Z1bmN0aW9uJyAmJiBjb2xsZWN0aW9uLm1lcmdlV2l0aFxuICAgICAgPyBjb2xsZWN0aW9uLm1lcmdlV2l0aC5hcHBseShjb2xsZWN0aW9uLCBbIG1lcmdlciBdLmNvbmNhdCggc291cmNlcyApKVxuICAgICAgOiBjb2xsZWN0aW9uLm1lcmdlXG4gICAgICA/IGNvbGxlY3Rpb24ubWVyZ2UuYXBwbHkoY29sbGVjdGlvbiwgc291cmNlcylcbiAgICAgIDogY29sbGVjdGlvbi5jb25jYXQuYXBwbHkoY29sbGVjdGlvbiwgc291cmNlcyk7XG4gIH1cbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGNvbGxlY3Rpb24pO1xuICB2YXIgbWVyZ2VkID0gY29sbGVjdGlvbjtcbiAgdmFyIENvbGxlY3Rpb24gPSBpc0FycmF5ID8gSW5kZXhlZENvbGxlY3Rpb24gOiBLZXllZENvbGxlY3Rpb247XG4gIHZhciBtZXJnZUl0ZW0gPSBpc0FycmF5XG4gICAgPyBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gQ29weSBvbiB3cml0ZVxuICAgICAgICBpZiAobWVyZ2VkID09PSBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgbWVyZ2VkID0gc2hhbGxvd0NvcHkobWVyZ2VkKTtcbiAgICAgICAgfVxuICAgICAgICBtZXJnZWQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgOiBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICB2YXIgaGFzVmFsID0gaGFzT3duUHJvcGVydHkuY2FsbChtZXJnZWQsIGtleSk7XG4gICAgICAgIHZhciBuZXh0VmFsID1cbiAgICAgICAgICBoYXNWYWwgJiYgbWVyZ2VyID8gbWVyZ2VyKG1lcmdlZFtrZXldLCB2YWx1ZSwga2V5KSA6IHZhbHVlO1xuICAgICAgICBpZiAoIWhhc1ZhbCB8fCBuZXh0VmFsICE9PSBtZXJnZWRba2V5XSkge1xuICAgICAgICAgIC8vIENvcHkgb24gd3JpdGVcbiAgICAgICAgICBpZiAobWVyZ2VkID09PSBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICBtZXJnZWQgPSBzaGFsbG93Q29weShtZXJnZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZXJnZWRba2V5XSA9IG5leHRWYWw7XG4gICAgICAgIH1cbiAgICAgIH07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgIENvbGxlY3Rpb24oc291cmNlc1tpXSkuZm9yRWFjaChtZXJnZUl0ZW0pO1xuICB9XG4gIHJldHVybiBtZXJnZWQ7XG59XG5cbmZ1bmN0aW9uIGRlZXBNZXJnZXJXaXRoKG1lcmdlcikge1xuICBmdW5jdGlvbiBkZWVwTWVyZ2VyKG9sZFZhbHVlLCBuZXdWYWx1ZSwga2V5KSB7XG4gICAgcmV0dXJuIGlzRGF0YVN0cnVjdHVyZShvbGRWYWx1ZSkgJiZcbiAgICAgIGlzRGF0YVN0cnVjdHVyZShuZXdWYWx1ZSkgJiZcbiAgICAgIGFyZU1lcmdlYWJsZShvbGRWYWx1ZSwgbmV3VmFsdWUpXG4gICAgICA/IG1lcmdlV2l0aFNvdXJjZXMob2xkVmFsdWUsIFtuZXdWYWx1ZV0sIGRlZXBNZXJnZXIpXG4gICAgICA6IG1lcmdlclxuICAgICAgPyBtZXJnZXIob2xkVmFsdWUsIG5ld1ZhbHVlLCBrZXkpXG4gICAgICA6IG5ld1ZhbHVlO1xuICB9XG4gIHJldHVybiBkZWVwTWVyZ2VyO1xufVxuXG4vKipcbiAqIEl0J3MgdW5jbGVhciB3aGF0IHRoZSBkZXNpcmVkIGJlaGF2aW9yIGlzIGZvciBtZXJnaW5nIHR3byBjb2xsZWN0aW9ucyB0aGF0XG4gKiBmYWxsIGludG8gc2VwYXJhdGUgY2F0ZWdvcmllcyBiZXR3ZWVuIGtleWVkLCBpbmRleGVkLCBvciBzZXQtbGlrZSwgc28gd2Ugb25seVxuICogY29uc2lkZXIgdGhlbSBtZXJnZWFibGUgaWYgdGhleSBmYWxsIGludG8gdGhlIHNhbWUgY2F0ZWdvcnkuXG4gKi9cbmZ1bmN0aW9uIGFyZU1lcmdlYWJsZShvbGREYXRhU3RydWN0dXJlLCBuZXdEYXRhU3RydWN0dXJlKSB7XG4gIHZhciBvbGRTZXEgPSBTZXEob2xkRGF0YVN0cnVjdHVyZSk7XG4gIHZhciBuZXdTZXEgPSBTZXEobmV3RGF0YVN0cnVjdHVyZSk7XG4gIC8vIFRoaXMgbG9naWMgYXNzdW1lcyB0aGF0IGEgc2VxdWVuY2UgY2FuIG9ubHkgZmFsbCBpbnRvIG9uZSBvZiB0aGUgdGhyZWVcbiAgLy8gY2F0ZWdvcmllcyBtZW50aW9uZWQgYWJvdmUgKHNpbmNlIHRoZXJlJ3Mgbm8gYGlzU2V0TGlrZSgpYCBtZXRob2QpLlxuICByZXR1cm4gKFxuICAgIGlzSW5kZXhlZChvbGRTZXEpID09PSBpc0luZGV4ZWQobmV3U2VxKSAmJlxuICAgIGlzS2V5ZWQob2xkU2VxKSA9PT0gaXNLZXllZChuZXdTZXEpXG4gICk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlRGVlcCgpIHtcbiAgdmFyIGl0ZXJzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHdoaWxlICggbGVuLS0gKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gIHJldHVybiBtZXJnZURlZXBXaXRoU291cmNlcyh0aGlzLCBpdGVycyk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlRGVlcFdpdGgobWVyZ2VyKSB7XG4gIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKCBsZW4tLSA+IDAgKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICByZXR1cm4gbWVyZ2VEZWVwV2l0aFNvdXJjZXModGhpcywgaXRlcnMsIG1lcmdlcik7XG59XG5cbmZ1bmN0aW9uIG1lcmdlSW4oa2V5UGF0aCkge1xuICB2YXIgaXRlcnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gIHdoaWxlICggbGVuLS0gPiAwICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgcmV0dXJuIHVwZGF0ZUluJDEodGhpcywga2V5UGF0aCwgZW1wdHlNYXAoKSwgZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1lcmdlV2l0aFNvdXJjZXMobSwgaXRlcnMpOyB9KTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VEZWVwSW4oa2V5UGF0aCkge1xuICB2YXIgaXRlcnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gIHdoaWxlICggbGVuLS0gPiAwICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgcmV0dXJuIHVwZGF0ZUluJDEodGhpcywga2V5UGF0aCwgZW1wdHlNYXAoKSwgZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1lcmdlRGVlcFdpdGhTb3VyY2VzKG0sIGl0ZXJzKTsgfVxuICApO1xufVxuXG5mdW5jdGlvbiB3aXRoTXV0YXRpb25zKGZuKSB7XG4gIHZhciBtdXRhYmxlID0gdGhpcy5hc011dGFibGUoKTtcbiAgZm4obXV0YWJsZSk7XG4gIHJldHVybiBtdXRhYmxlLndhc0FsdGVyZWQoKSA/IG11dGFibGUuX19lbnN1cmVPd25lcih0aGlzLl9fb3duZXJJRCkgOiB0aGlzO1xufVxuXG5mdW5jdGlvbiBhc011dGFibGUoKSB7XG4gIHJldHVybiB0aGlzLl9fb3duZXJJRCA/IHRoaXMgOiB0aGlzLl9fZW5zdXJlT3duZXIobmV3IE93bmVySUQoKSk7XG59XG5cbmZ1bmN0aW9uIGFzSW1tdXRhYmxlKCkge1xuICByZXR1cm4gdGhpcy5fX2Vuc3VyZU93bmVyKCk7XG59XG5cbmZ1bmN0aW9uIHdhc0FsdGVyZWQoKSB7XG4gIHJldHVybiB0aGlzLl9fYWx0ZXJlZDtcbn1cblxudmFyIE1hcCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEtleWVkQ29sbGVjdGlvbikge1xuICBmdW5jdGlvbiBNYXAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbFxuICAgICAgPyBlbXB0eU1hcCgpXG4gICAgICA6IGlzTWFwKHZhbHVlKSAmJiAhaXNPcmRlcmVkKHZhbHVlKVxuICAgICAgPyB2YWx1ZVxuICAgICAgOiBlbXB0eU1hcCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgIHZhciBpdGVyID0gS2V5ZWRDb2xsZWN0aW9uKHZhbHVlKTtcbiAgICAgICAgICBhc3NlcnROb3RJbmZpbml0ZShpdGVyLnNpemUpO1xuICAgICAgICAgIGl0ZXIuZm9yRWFjaChmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gbWFwLnNldChrLCB2KTsgfSk7XG4gICAgICAgIH0pO1xuICB9XG5cbiAgaWYgKCBLZXllZENvbGxlY3Rpb24gKSBNYXAuX19wcm90b19fID0gS2V5ZWRDb2xsZWN0aW9uO1xuICBNYXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggS2V5ZWRDb2xsZWN0aW9uICYmIEtleWVkQ29sbGVjdGlvbi5wcm90b3R5cGUgKTtcbiAgTWFwLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1hcDtcblxuICBNYXAub2YgPSBmdW5jdGlvbiBvZiAoKSB7XG4gICAgdmFyIGtleVZhbHVlcyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBrZXlWYWx1ZXNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHJldHVybiBlbXB0eU1hcCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKG1hcCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlWYWx1ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgaWYgKGkgKyAxID49IGtleVZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdmFsdWUgZm9yIGtleTogJyArIGtleVZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgbWFwLnNldChrZXlWYWx1ZXNbaV0sIGtleVZhbHVlc1tpICsgMV0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIE1hcC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnTWFwIHsnLCAnfScpO1xuICB9O1xuXG4gIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGssIG5vdFNldFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3RcbiAgICAgID8gdGhpcy5fcm9vdC5nZXQoMCwgdW5kZWZpbmVkLCBrLCBub3RTZXRWYWx1ZSlcbiAgICAgIDogbm90U2V0VmFsdWU7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBNb2RpZmljYXRpb25cblxuICBNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoaywgdikge1xuICAgIHJldHVybiB1cGRhdGVNYXAodGhpcywgaywgdik7XG4gIH07XG5cbiAgTWFwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKGspIHtcbiAgICByZXR1cm4gdXBkYXRlTWFwKHRoaXMsIGssIE5PVF9TRVQpO1xuICB9O1xuXG4gIE1hcC5wcm90b3R5cGUuZGVsZXRlQWxsID0gZnVuY3Rpb24gZGVsZXRlQWxsIChrZXlzKSB7XG4gICAgdmFyIGNvbGxlY3Rpb24gPSBDb2xsZWN0aW9uKGtleXMpO1xuXG4gICAgaWYgKGNvbGxlY3Rpb24uc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobWFwKSB7XG4gICAgICBjb2xsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gbWFwLnJlbW92ZShrZXkpOyB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAodGhpcy5fX293bmVySUQpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICAgIHRoaXMuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBlbXB0eU1hcCgpO1xuICB9O1xuXG4gIC8vIEBwcmFnbWEgQ29tcG9zaXRpb25cblxuICBNYXAucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbiBzb3J0IChjb21wYXJhdG9yKSB7XG4gICAgLy8gTGF0ZSBiaW5kaW5nXG4gICAgcmV0dXJuIE9yZGVyZWRNYXAoc29ydEZhY3RvcnkodGhpcywgY29tcGFyYXRvcikpO1xuICB9O1xuXG4gIE1hcC5wcm90b3R5cGUuc29ydEJ5ID0gZnVuY3Rpb24gc29ydEJ5IChtYXBwZXIsIGNvbXBhcmF0b3IpIHtcbiAgICAvLyBMYXRlIGJpbmRpbmdcbiAgICByZXR1cm4gT3JkZXJlZE1hcChzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yLCBtYXBwZXIpKTtcbiAgfTtcblxuICBNYXAucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcCAobWFwcGVyLCBjb250ZXh0KSB7XG4gICAgdmFyIHRoaXMkMSQxID0gdGhpcztcblxuICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKG1hcCkge1xuICAgICAgbWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgbWFwLnNldChrZXksIG1hcHBlci5jYWxsKGNvbnRleHQsIHZhbHVlLCBrZXksIHRoaXMkMSQxKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBAcHJhZ21hIE11dGFiaWxpdHlcblxuICBNYXAucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgcmV0dXJuIG5ldyBNYXBJdGVyYXRvcih0aGlzLCB0eXBlLCByZXZlcnNlKTtcbiAgfTtcblxuICBNYXAucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgdGhpcyQxJDEgPSB0aGlzO1xuXG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIHRoaXMuX3Jvb3QgJiZcbiAgICAgIHRoaXMuX3Jvb3QuaXRlcmF0ZShmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICByZXR1cm4gZm4oZW50cnlbMV0sIGVudHJ5WzBdLCB0aGlzJDEkMSk7XG4gICAgICB9LCByZXZlcnNlKTtcbiAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgfTtcblxuICBNYXAucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbiBfX2Vuc3VyZU93bmVyIChvd25lcklEKSB7XG4gICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKCFvd25lcklEKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBlbXB0eU1hcCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fX293bmVySUQgPSBvd25lcklEO1xuICAgICAgdGhpcy5fX2FsdGVyZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gbWFrZU1hcCh0aGlzLnNpemUsIHRoaXMuX3Jvb3QsIG93bmVySUQsIHRoaXMuX19oYXNoKTtcbiAgfTtcblxuICByZXR1cm4gTWFwO1xufShLZXllZENvbGxlY3Rpb24pKTtcblxuTWFwLmlzTWFwID0gaXNNYXA7XG5cbnZhciBNYXBQcm90b3R5cGUgPSBNYXAucHJvdG90eXBlO1xuTWFwUHJvdG90eXBlW0lTX01BUF9TWU1CT0xdID0gdHJ1ZTtcbk1hcFByb3RvdHlwZVtERUxFVEVdID0gTWFwUHJvdG90eXBlLnJlbW92ZTtcbk1hcFByb3RvdHlwZS5yZW1vdmVBbGwgPSBNYXBQcm90b3R5cGUuZGVsZXRlQWxsO1xuTWFwUHJvdG90eXBlLnNldEluID0gc2V0SW47XG5NYXBQcm90b3R5cGUucmVtb3ZlSW4gPSBNYXBQcm90b3R5cGUuZGVsZXRlSW4gPSBkZWxldGVJbjtcbk1hcFByb3RvdHlwZS51cGRhdGUgPSB1cGRhdGU7XG5NYXBQcm90b3R5cGUudXBkYXRlSW4gPSB1cGRhdGVJbjtcbk1hcFByb3RvdHlwZS5tZXJnZSA9IE1hcFByb3RvdHlwZS5jb25jYXQgPSBtZXJnZSQxO1xuTWFwUHJvdG90eXBlLm1lcmdlV2l0aCA9IG1lcmdlV2l0aCQxO1xuTWFwUHJvdG90eXBlLm1lcmdlRGVlcCA9IG1lcmdlRGVlcDtcbk1hcFByb3RvdHlwZS5tZXJnZURlZXBXaXRoID0gbWVyZ2VEZWVwV2l0aDtcbk1hcFByb3RvdHlwZS5tZXJnZUluID0gbWVyZ2VJbjtcbk1hcFByb3RvdHlwZS5tZXJnZURlZXBJbiA9IG1lcmdlRGVlcEluO1xuTWFwUHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSB3aXRoTXV0YXRpb25zO1xuTWFwUHJvdG90eXBlLndhc0FsdGVyZWQgPSB3YXNBbHRlcmVkO1xuTWFwUHJvdG90eXBlLmFzSW1tdXRhYmxlID0gYXNJbW11dGFibGU7XG5NYXBQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBNYXBQcm90b3R5cGUuYXNNdXRhYmxlID0gYXNNdXRhYmxlO1xuTWFwUHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgYXJyKSB7XG4gIHJldHVybiByZXN1bHQuc2V0KGFyclswXSwgYXJyWzFdKTtcbn07XG5NYXBQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iai5hc0ltbXV0YWJsZSgpO1xufTtcblxuLy8gI3ByYWdtYSBUcmllIE5vZGVzXG5cbnZhciBBcnJheU1hcE5vZGUgPSBmdW5jdGlvbiBBcnJheU1hcE5vZGUob3duZXJJRCwgZW50cmllcykge1xuICB0aGlzLm93bmVySUQgPSBvd25lcklEO1xuICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xufTtcblxuQXJyYXlNYXBOb2RlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKHNoaWZ0LCBrZXlIYXNoLCBrZXksIG5vdFNldFZhbHVlKSB7XG4gIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuICBmb3IgKHZhciBpaSA9IDAsIGxlbiA9IGVudHJpZXMubGVuZ3RoOyBpaSA8IGxlbjsgaWkrKykge1xuICAgIGlmIChpcyhrZXksIGVudHJpZXNbaWldWzBdKSkge1xuICAgICAgcmV0dXJuIGVudHJpZXNbaWldWzFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm90U2V0VmFsdWU7XG59O1xuXG5BcnJheU1hcE5vZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAob3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKSB7XG4gIHZhciByZW1vdmVkID0gdmFsdWUgPT09IE5PVF9TRVQ7XG5cbiAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gZW50cmllcy5sZW5ndGg7XG4gIGZvciAoOyBpZHggPCBsZW47IGlkeCsrKSB7XG4gICAgaWYgKGlzKGtleSwgZW50cmllc1tpZHhdWzBdKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHZhciBleGlzdHMgPSBpZHggPCBsZW47XG5cbiAgaWYgKGV4aXN0cyA/IGVudHJpZXNbaWR4XVsxXSA9PT0gdmFsdWUgOiByZW1vdmVkKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBTZXRSZWYoZGlkQWx0ZXIpO1xuICAocmVtb3ZlZCB8fCAhZXhpc3RzKSAmJiBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG5cbiAgaWYgKHJlbW92ZWQgJiYgZW50cmllcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm47IC8vIHVuZGVmaW5lZFxuICB9XG5cbiAgaWYgKCFleGlzdHMgJiYgIXJlbW92ZWQgJiYgZW50cmllcy5sZW5ndGggPj0gTUFYX0FSUkFZX01BUF9TSVpFKSB7XG4gICAgcmV0dXJuIGNyZWF0ZU5vZGVzKG93bmVySUQsIGVudHJpZXMsIGtleSwgdmFsdWUpO1xuICB9XG5cbiAgdmFyIGlzRWRpdGFibGUgPSBvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRDtcbiAgdmFyIG5ld0VudHJpZXMgPSBpc0VkaXRhYmxlID8gZW50cmllcyA6IGFyckNvcHkoZW50cmllcyk7XG5cbiAgaWYgKGV4aXN0cykge1xuICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICBpZHggPT09IGxlbiAtIDFcbiAgICAgICAgPyBuZXdFbnRyaWVzLnBvcCgpXG4gICAgICAgIDogKG5ld0VudHJpZXNbaWR4XSA9IG5ld0VudHJpZXMucG9wKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdFbnRyaWVzW2lkeF0gPSBba2V5LCB2YWx1ZV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5ld0VudHJpZXMucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9XG5cbiAgaWYgKGlzRWRpdGFibGUpIHtcbiAgICB0aGlzLmVudHJpZXMgPSBuZXdFbnRyaWVzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBBcnJheU1hcE5vZGUob3duZXJJRCwgbmV3RW50cmllcyk7XG59O1xuXG52YXIgQml0bWFwSW5kZXhlZE5vZGUgPSBmdW5jdGlvbiBCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCBiaXRtYXAsIG5vZGVzKSB7XG4gIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gIHRoaXMuYml0bWFwID0gYml0bWFwO1xuICB0aGlzLm5vZGVzID0gbm9kZXM7XG59O1xuXG5CaXRtYXBJbmRleGVkTm9kZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuICBpZiAoa2V5SGFzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAga2V5SGFzaCA9IGhhc2goa2V5KTtcbiAgfVxuICB2YXIgYml0ID0gMSA8PCAoKHNoaWZ0ID09PSAwID8ga2V5SGFzaCA6IGtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0spO1xuICB2YXIgYml0bWFwID0gdGhpcy5iaXRtYXA7XG4gIHJldHVybiAoYml0bWFwICYgYml0KSA9PT0gMFxuICAgID8gbm90U2V0VmFsdWVcbiAgICA6IHRoaXMubm9kZXNbcG9wQ291bnQoYml0bWFwICYgKGJpdCAtIDEpKV0uZ2V0KFxuICAgICAgICBzaGlmdCArIFNISUZULFxuICAgICAgICBrZXlIYXNoLFxuICAgICAgICBrZXksXG4gICAgICAgIG5vdFNldFZhbHVlXG4gICAgICApO1xufTtcblxuQml0bWFwSW5kZXhlZE5vZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAob3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKSB7XG4gIGlmIChrZXlIYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICBrZXlIYXNoID0gaGFzaChrZXkpO1xuICB9XG4gIHZhciBrZXlIYXNoRnJhZyA9IChzaGlmdCA9PT0gMCA/IGtleUhhc2ggOiBrZXlIYXNoID4+PiBzaGlmdCkgJiBNQVNLO1xuICB2YXIgYml0ID0gMSA8PCBrZXlIYXNoRnJhZztcbiAgdmFyIGJpdG1hcCA9IHRoaXMuYml0bWFwO1xuICB2YXIgZXhpc3RzID0gKGJpdG1hcCAmIGJpdCkgIT09IDA7XG5cbiAgaWYgKCFleGlzdHMgJiYgdmFsdWUgPT09IE5PVF9TRVQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBpZHggPSBwb3BDb3VudChiaXRtYXAgJiAoYml0IC0gMSkpO1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICB2YXIgbm9kZSA9IGV4aXN0cyA/IG5vZGVzW2lkeF0gOiB1bmRlZmluZWQ7XG4gIHZhciBuZXdOb2RlID0gdXBkYXRlTm9kZShcbiAgICBub2RlLFxuICAgIG93bmVySUQsXG4gICAgc2hpZnQgKyBTSElGVCxcbiAgICBrZXlIYXNoLFxuICAgIGtleSxcbiAgICB2YWx1ZSxcbiAgICBkaWRDaGFuZ2VTaXplLFxuICAgIGRpZEFsdGVyXG4gICk7XG5cbiAgaWYgKG5ld05vZGUgPT09IG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmICghZXhpc3RzICYmIG5ld05vZGUgJiYgbm9kZXMubGVuZ3RoID49IE1BWF9CSVRNQVBfSU5ERVhFRF9TSVpFKSB7XG4gICAgcmV0dXJuIGV4cGFuZE5vZGVzKG93bmVySUQsIG5vZGVzLCBiaXRtYXAsIGtleUhhc2hGcmFnLCBuZXdOb2RlKTtcbiAgfVxuXG4gIGlmIChcbiAgICBleGlzdHMgJiZcbiAgICAhbmV3Tm9kZSAmJlxuICAgIG5vZGVzLmxlbmd0aCA9PT0gMiAmJlxuICAgIGlzTGVhZk5vZGUobm9kZXNbaWR4IF4gMV0pXG4gICkge1xuICAgIHJldHVybiBub2Rlc1tpZHggXiAxXTtcbiAgfVxuXG4gIGlmIChleGlzdHMgJiYgbmV3Tm9kZSAmJiBub2Rlcy5sZW5ndGggPT09IDEgJiYgaXNMZWFmTm9kZShuZXdOb2RlKSkge1xuICAgIHJldHVybiBuZXdOb2RlO1xuICB9XG5cbiAgdmFyIGlzRWRpdGFibGUgPSBvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRDtcbiAgdmFyIG5ld0JpdG1hcCA9IGV4aXN0cyA/IChuZXdOb2RlID8gYml0bWFwIDogYml0bWFwIF4gYml0KSA6IGJpdG1hcCB8IGJpdDtcbiAgdmFyIG5ld05vZGVzID0gZXhpc3RzXG4gICAgPyBuZXdOb2RlXG4gICAgICA/IHNldEF0KG5vZGVzLCBpZHgsIG5ld05vZGUsIGlzRWRpdGFibGUpXG4gICAgICA6IHNwbGljZU91dChub2RlcywgaWR4LCBpc0VkaXRhYmxlKVxuICAgIDogc3BsaWNlSW4obm9kZXMsIGlkeCwgbmV3Tm9kZSwgaXNFZGl0YWJsZSk7XG5cbiAgaWYgKGlzRWRpdGFibGUpIHtcbiAgICB0aGlzLmJpdG1hcCA9IG5ld0JpdG1hcDtcbiAgICB0aGlzLm5vZGVzID0gbmV3Tm9kZXM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZXR1cm4gbmV3IEJpdG1hcEluZGV4ZWROb2RlKG93bmVySUQsIG5ld0JpdG1hcCwgbmV3Tm9kZXMpO1xufTtcblxudmFyIEhhc2hBcnJheU1hcE5vZGUgPSBmdW5jdGlvbiBIYXNoQXJyYXlNYXBOb2RlKG93bmVySUQsIGNvdW50LCBub2Rlcykge1xuICB0aGlzLm93bmVySUQgPSBvd25lcklEO1xuICB0aGlzLmNvdW50ID0gY291bnQ7XG4gIHRoaXMubm9kZXMgPSBub2Rlcztcbn07XG5cbkhhc2hBcnJheU1hcE5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoc2hpZnQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpIHtcbiAgaWYgKGtleUhhc2ggPT09IHVuZGVmaW5lZCkge1xuICAgIGtleUhhc2ggPSBoYXNoKGtleSk7XG4gIH1cbiAgdmFyIGlkeCA9IChzaGlmdCA9PT0gMCA/IGtleUhhc2ggOiBrZXlIYXNoID4+PiBzaGlmdCkgJiBNQVNLO1xuICB2YXIgbm9kZSA9IHRoaXMubm9kZXNbaWR4XTtcbiAgcmV0dXJuIG5vZGVcbiAgICA/IG5vZGUuZ2V0KHNoaWZ0ICsgU0hJRlQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpXG4gICAgOiBub3RTZXRWYWx1ZTtcbn07XG5cbkhhc2hBcnJheU1hcE5vZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAob3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKSB7XG4gIGlmIChrZXlIYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICBrZXlIYXNoID0gaGFzaChrZXkpO1xuICB9XG4gIHZhciBpZHggPSAoc2hpZnQgPT09IDAgPyBrZXlIYXNoIDoga2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcbiAgdmFyIHJlbW92ZWQgPSB2YWx1ZSA9PT0gTk9UX1NFVDtcbiAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcztcbiAgdmFyIG5vZGUgPSBub2Rlc1tpZHhdO1xuXG4gIGlmIChyZW1vdmVkICYmICFub2RlKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbmV3Tm9kZSA9IHVwZGF0ZU5vZGUoXG4gICAgbm9kZSxcbiAgICBvd25lcklELFxuICAgIHNoaWZ0ICsgU0hJRlQsXG4gICAga2V5SGFzaCxcbiAgICBrZXksXG4gICAgdmFsdWUsXG4gICAgZGlkQ2hhbmdlU2l6ZSxcbiAgICBkaWRBbHRlclxuICApO1xuICBpZiAobmV3Tm9kZSA9PT0gbm9kZSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIG5ld0NvdW50ID0gdGhpcy5jb3VudDtcbiAgaWYgKCFub2RlKSB7XG4gICAgbmV3Q291bnQrKztcbiAgfSBlbHNlIGlmICghbmV3Tm9kZSkge1xuICAgIG5ld0NvdW50LS07XG4gICAgaWYgKG5ld0NvdW50IDwgTUlOX0hBU0hfQVJSQVlfTUFQX1NJWkUpIHtcbiAgICAgIHJldHVybiBwYWNrTm9kZXMob3duZXJJRCwgbm9kZXMsIG5ld0NvdW50LCBpZHgpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpc0VkaXRhYmxlID0gb3duZXJJRCAmJiBvd25lcklEID09PSB0aGlzLm93bmVySUQ7XG4gIHZhciBuZXdOb2RlcyA9IHNldEF0KG5vZGVzLCBpZHgsIG5ld05vZGUsIGlzRWRpdGFibGUpO1xuXG4gIGlmIChpc0VkaXRhYmxlKSB7XG4gICAgdGhpcy5jb3VudCA9IG5ld0NvdW50O1xuICAgIHRoaXMubm9kZXMgPSBuZXdOb2RlcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJldHVybiBuZXcgSGFzaEFycmF5TWFwTm9kZShvd25lcklELCBuZXdDb3VudCwgbmV3Tm9kZXMpO1xufTtcblxudmFyIEhhc2hDb2xsaXNpb25Ob2RlID0gZnVuY3Rpb24gSGFzaENvbGxpc2lvbk5vZGUob3duZXJJRCwga2V5SGFzaCwgZW50cmllcykge1xuICB0aGlzLm93bmVySUQgPSBvd25lcklEO1xuICB0aGlzLmtleUhhc2ggPSBrZXlIYXNoO1xuICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xufTtcblxuSGFzaENvbGxpc2lvbk5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoc2hpZnQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpIHtcbiAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XG4gIGZvciAodmFyIGlpID0gMCwgbGVuID0gZW50cmllcy5sZW5ndGg7IGlpIDwgbGVuOyBpaSsrKSB7XG4gICAgaWYgKGlzKGtleSwgZW50cmllc1tpaV1bMF0pKSB7XG4gICAgICByZXR1cm4gZW50cmllc1tpaV1bMV07XG4gICAgfVxuICB9XG4gIHJldHVybiBub3RTZXRWYWx1ZTtcbn07XG5cbkhhc2hDb2xsaXNpb25Ob2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcikge1xuICBpZiAoa2V5SGFzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAga2V5SGFzaCA9IGhhc2goa2V5KTtcbiAgfVxuXG4gIHZhciByZW1vdmVkID0gdmFsdWUgPT09IE5PVF9TRVQ7XG5cbiAgaWYgKGtleUhhc2ggIT09IHRoaXMua2V5SGFzaCkge1xuICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgU2V0UmVmKGRpZEFsdGVyKTtcbiAgICBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG4gICAgcmV0dXJuIG1lcmdlSW50b05vZGUodGhpcywgb3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIFtrZXksIHZhbHVlXSk7XG4gIH1cblxuICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBlbnRyaWVzLmxlbmd0aDtcbiAgZm9yICg7IGlkeCA8IGxlbjsgaWR4KyspIHtcbiAgICBpZiAoaXMoa2V5LCBlbnRyaWVzW2lkeF1bMF0pKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdmFyIGV4aXN0cyA9IGlkeCA8IGxlbjtcblxuICBpZiAoZXhpc3RzID8gZW50cmllc1tpZHhdWzFdID09PSB2YWx1ZSA6IHJlbW92ZWQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIFNldFJlZihkaWRBbHRlcik7XG4gIChyZW1vdmVkIHx8ICFleGlzdHMpICYmIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcblxuICBpZiAocmVtb3ZlZCAmJiBsZW4gPT09IDIpIHtcbiAgICByZXR1cm4gbmV3IFZhbHVlTm9kZShvd25lcklELCB0aGlzLmtleUhhc2gsIGVudHJpZXNbaWR4IF4gMV0pO1xuICB9XG5cbiAgdmFyIGlzRWRpdGFibGUgPSBvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRDtcbiAgdmFyIG5ld0VudHJpZXMgPSBpc0VkaXRhYmxlID8gZW50cmllcyA6IGFyckNvcHkoZW50cmllcyk7XG5cbiAgaWYgKGV4aXN0cykge1xuICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICBpZHggPT09IGxlbiAtIDFcbiAgICAgICAgPyBuZXdFbnRyaWVzLnBvcCgpXG4gICAgICAgIDogKG5ld0VudHJpZXNbaWR4XSA9IG5ld0VudHJpZXMucG9wKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdFbnRyaWVzW2lkeF0gPSBba2V5LCB2YWx1ZV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5ld0VudHJpZXMucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9XG5cbiAgaWYgKGlzRWRpdGFibGUpIHtcbiAgICB0aGlzLmVudHJpZXMgPSBuZXdFbnRyaWVzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBIYXNoQ29sbGlzaW9uTm9kZShvd25lcklELCB0aGlzLmtleUhhc2gsIG5ld0VudHJpZXMpO1xufTtcblxudmFyIFZhbHVlTm9kZSA9IGZ1bmN0aW9uIFZhbHVlTm9kZShvd25lcklELCBrZXlIYXNoLCBlbnRyeSkge1xuICB0aGlzLm93bmVySUQgPSBvd25lcklEO1xuICB0aGlzLmtleUhhc2ggPSBrZXlIYXNoO1xuICB0aGlzLmVudHJ5ID0gZW50cnk7XG59O1xuXG5WYWx1ZU5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoc2hpZnQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpIHtcbiAgcmV0dXJuIGlzKGtleSwgdGhpcy5lbnRyeVswXSkgPyB0aGlzLmVudHJ5WzFdIDogbm90U2V0VmFsdWU7XG59O1xuXG5WYWx1ZU5vZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAob3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKSB7XG4gIHZhciByZW1vdmVkID0gdmFsdWUgPT09IE5PVF9TRVQ7XG4gIHZhciBrZXlNYXRjaCA9IGlzKGtleSwgdGhpcy5lbnRyeVswXSk7XG4gIGlmIChrZXlNYXRjaCA/IHZhbHVlID09PSB0aGlzLmVudHJ5WzFdIDogcmVtb3ZlZCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgU2V0UmVmKGRpZEFsdGVyKTtcblxuICBpZiAocmVtb3ZlZCkge1xuICAgIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcbiAgICByZXR1cm47IC8vIHVuZGVmaW5lZFxuICB9XG5cbiAgaWYgKGtleU1hdGNoKSB7XG4gICAgaWYgKG93bmVySUQgJiYgb3duZXJJRCA9PT0gdGhpcy5vd25lcklEKSB7XG4gICAgICB0aGlzLmVudHJ5WzFdID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBWYWx1ZU5vZGUob3duZXJJRCwgdGhpcy5rZXlIYXNoLCBba2V5LCB2YWx1ZV0pO1xuICB9XG5cbiAgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuICByZXR1cm4gbWVyZ2VJbnRvTm9kZSh0aGlzLCBvd25lcklELCBzaGlmdCwgaGFzaChrZXkpLCBba2V5LCB2YWx1ZV0pO1xufTtcblxuLy8gI3ByYWdtYSBJdGVyYXRvcnNcblxuQXJyYXlNYXBOb2RlLnByb3RvdHlwZS5pdGVyYXRlID0gSGFzaENvbGxpc2lvbk5vZGUucHJvdG90eXBlLml0ZXJhdGUgPVxuICBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcbiAgICBmb3IgKHZhciBpaSA9IDAsIG1heEluZGV4ID0gZW50cmllcy5sZW5ndGggLSAxOyBpaSA8PSBtYXhJbmRleDsgaWkrKykge1xuICAgICAgaWYgKGZuKGVudHJpZXNbcmV2ZXJzZSA/IG1heEluZGV4IC0gaWkgOiBpaV0pID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG5CaXRtYXBJbmRleGVkTm9kZS5wcm90b3R5cGUuaXRlcmF0ZSA9IEhhc2hBcnJheU1hcE5vZGUucHJvdG90eXBlLml0ZXJhdGUgPVxuICBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICAgIGZvciAodmFyIGlpID0gMCwgbWF4SW5kZXggPSBub2Rlcy5sZW5ndGggLSAxOyBpaSA8PSBtYXhJbmRleDsgaWkrKykge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tyZXZlcnNlID8gbWF4SW5kZXggLSBpaSA6IGlpXTtcbiAgICAgIGlmIChub2RlICYmIG5vZGUuaXRlcmF0ZShmbiwgcmV2ZXJzZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuVmFsdWVOb2RlLnByb3RvdHlwZS5pdGVyYXRlID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7XG4gIHJldHVybiBmbih0aGlzLmVudHJ5KTtcbn07XG5cbnZhciBNYXBJdGVyYXRvciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEl0ZXJhdG9yKSB7XG4gIGZ1bmN0aW9uIE1hcEl0ZXJhdG9yKG1hcCwgdHlwZSwgcmV2ZXJzZSkge1xuICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgIHRoaXMuX3JldmVyc2UgPSByZXZlcnNlO1xuICAgIHRoaXMuX3N0YWNrID0gbWFwLl9yb290ICYmIG1hcEl0ZXJhdG9yRnJhbWUobWFwLl9yb290KTtcbiAgfVxuXG4gIGlmICggSXRlcmF0b3IgKSBNYXBJdGVyYXRvci5fX3Byb3RvX18gPSBJdGVyYXRvcjtcbiAgTWFwSXRlcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSXRlcmF0b3IgJiYgSXRlcmF0b3IucHJvdG90eXBlICk7XG4gIE1hcEl0ZXJhdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1hcEl0ZXJhdG9yO1xuXG4gIE1hcEl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gbmV4dCAoKSB7XG4gICAgdmFyIHR5cGUgPSB0aGlzLl90eXBlO1xuICAgIHZhciBzdGFjayA9IHRoaXMuX3N0YWNrO1xuICAgIHdoaWxlIChzdGFjaykge1xuICAgICAgdmFyIG5vZGUgPSBzdGFjay5ub2RlO1xuICAgICAgdmFyIGluZGV4ID0gc3RhY2suaW5kZXgrKztcbiAgICAgIHZhciBtYXhJbmRleCA9ICh2b2lkIDApO1xuICAgICAgaWYgKG5vZGUuZW50cnkpIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG1hcEl0ZXJhdG9yVmFsdWUodHlwZSwgbm9kZS5lbnRyeSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIG1heEluZGV4ID0gbm9kZS5lbnRyaWVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChpbmRleCA8PSBtYXhJbmRleCkge1xuICAgICAgICAgIHJldHVybiBtYXBJdGVyYXRvclZhbHVlKFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIG5vZGUuZW50cmllc1t0aGlzLl9yZXZlcnNlID8gbWF4SW5kZXggLSBpbmRleCA6IGluZGV4XVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heEluZGV4ID0gbm9kZS5ub2Rlcy5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoaW5kZXggPD0gbWF4SW5kZXgpIHtcbiAgICAgICAgICB2YXIgc3ViTm9kZSA9IG5vZGUubm9kZXNbdGhpcy5fcmV2ZXJzZSA/IG1heEluZGV4IC0gaW5kZXggOiBpbmRleF07XG4gICAgICAgICAgaWYgKHN1Yk5vZGUpIHtcbiAgICAgICAgICAgIGlmIChzdWJOb2RlLmVudHJ5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBtYXBJdGVyYXRvclZhbHVlKHR5cGUsIHN1Yk5vZGUuZW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhY2sgPSB0aGlzLl9zdGFjayA9IG1hcEl0ZXJhdG9yRnJhbWUoc3ViTm9kZSwgc3RhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhY2sgPSB0aGlzLl9zdGFjayA9IHRoaXMuX3N0YWNrLl9fcHJldjtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICB9O1xuXG4gIHJldHVybiBNYXBJdGVyYXRvcjtcbn0oSXRlcmF0b3IpKTtcblxuZnVuY3Rpb24gbWFwSXRlcmF0b3JWYWx1ZSh0eXBlLCBlbnRyeSkge1xuICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBlbnRyeVswXSwgZW50cnlbMV0pO1xufVxuXG5mdW5jdGlvbiBtYXBJdGVyYXRvckZyYW1lKG5vZGUsIHByZXYpIHtcbiAgcmV0dXJuIHtcbiAgICBub2RlOiBub2RlLFxuICAgIGluZGV4OiAwLFxuICAgIF9fcHJldjogcHJldixcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFrZU1hcChzaXplLCByb290LCBvd25lcklELCBoYXNoKSB7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKE1hcFByb3RvdHlwZSk7XG4gIG1hcC5zaXplID0gc2l6ZTtcbiAgbWFwLl9yb290ID0gcm9vdDtcbiAgbWFwLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gIG1hcC5fX2hhc2ggPSBoYXNoO1xuICBtYXAuX19hbHRlcmVkID0gZmFsc2U7XG4gIHJldHVybiBtYXA7XG59XG5cbnZhciBFTVBUWV9NQVA7XG5mdW5jdGlvbiBlbXB0eU1hcCgpIHtcbiAgcmV0dXJuIEVNUFRZX01BUCB8fCAoRU1QVFlfTUFQID0gbWFrZU1hcCgwKSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU1hcChtYXAsIGssIHYpIHtcbiAgdmFyIG5ld1Jvb3Q7XG4gIHZhciBuZXdTaXplO1xuICBpZiAoIW1hcC5fcm9vdCkge1xuICAgIGlmICh2ID09PSBOT1RfU0VUKSB7XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICBuZXdTaXplID0gMTtcbiAgICBuZXdSb290ID0gbmV3IEFycmF5TWFwTm9kZShtYXAuX19vd25lcklELCBbW2ssIHZdXSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRpZENoYW5nZVNpemUgPSBNYWtlUmVmKCk7XG4gICAgdmFyIGRpZEFsdGVyID0gTWFrZVJlZigpO1xuICAgIG5ld1Jvb3QgPSB1cGRhdGVOb2RlKFxuICAgICAgbWFwLl9yb290LFxuICAgICAgbWFwLl9fb3duZXJJRCxcbiAgICAgIDAsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICBrLFxuICAgICAgdixcbiAgICAgIGRpZENoYW5nZVNpemUsXG4gICAgICBkaWRBbHRlclxuICAgICk7XG4gICAgaWYgKCFkaWRBbHRlci52YWx1ZSkge1xuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgbmV3U2l6ZSA9IG1hcC5zaXplICsgKGRpZENoYW5nZVNpemUudmFsdWUgPyAodiA9PT0gTk9UX1NFVCA/IC0xIDogMSkgOiAwKTtcbiAgfVxuICBpZiAobWFwLl9fb3duZXJJRCkge1xuICAgIG1hcC5zaXplID0gbmV3U2l6ZTtcbiAgICBtYXAuX3Jvb3QgPSBuZXdSb290O1xuICAgIG1hcC5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgbWFwLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuICByZXR1cm4gbmV3Um9vdCA/IG1ha2VNYXAobmV3U2l6ZSwgbmV3Um9vdCkgOiBlbXB0eU1hcCgpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVOb2RlKFxuICBub2RlLFxuICBvd25lcklELFxuICBzaGlmdCxcbiAga2V5SGFzaCxcbiAga2V5LFxuICB2YWx1ZSxcbiAgZGlkQ2hhbmdlU2l6ZSxcbiAgZGlkQWx0ZXJcbikge1xuICBpZiAoIW5vZGUpIHtcbiAgICBpZiAodmFsdWUgPT09IE5PVF9TRVQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBTZXRSZWYoZGlkQWx0ZXIpO1xuICAgIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcbiAgICByZXR1cm4gbmV3IFZhbHVlTm9kZShvd25lcklELCBrZXlIYXNoLCBba2V5LCB2YWx1ZV0pO1xuICB9XG4gIHJldHVybiBub2RlLnVwZGF0ZShcbiAgICBvd25lcklELFxuICAgIHNoaWZ0LFxuICAgIGtleUhhc2gsXG4gICAga2V5LFxuICAgIHZhbHVlLFxuICAgIGRpZENoYW5nZVNpemUsXG4gICAgZGlkQWx0ZXJcbiAgKTtcbn1cblxuZnVuY3Rpb24gaXNMZWFmTm9kZShub2RlKSB7XG4gIHJldHVybiAoXG4gICAgbm9kZS5jb25zdHJ1Y3RvciA9PT0gVmFsdWVOb2RlIHx8IG5vZGUuY29uc3RydWN0b3IgPT09IEhhc2hDb2xsaXNpb25Ob2RlXG4gICk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlSW50b05vZGUobm9kZSwgb3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGVudHJ5KSB7XG4gIGlmIChub2RlLmtleUhhc2ggPT09IGtleUhhc2gpIHtcbiAgICByZXR1cm4gbmV3IEhhc2hDb2xsaXNpb25Ob2RlKG93bmVySUQsIGtleUhhc2gsIFtub2RlLmVudHJ5LCBlbnRyeV0pO1xuICB9XG5cbiAgdmFyIGlkeDEgPSAoc2hpZnQgPT09IDAgPyBub2RlLmtleUhhc2ggOiBub2RlLmtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0s7XG4gIHZhciBpZHgyID0gKHNoaWZ0ID09PSAwID8ga2V5SGFzaCA6IGtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0s7XG5cbiAgdmFyIG5ld05vZGU7XG4gIHZhciBub2RlcyA9XG4gICAgaWR4MSA9PT0gaWR4MlxuICAgICAgPyBbbWVyZ2VJbnRvTm9kZShub2RlLCBvd25lcklELCBzaGlmdCArIFNISUZULCBrZXlIYXNoLCBlbnRyeSldXG4gICAgICA6ICgobmV3Tm9kZSA9IG5ldyBWYWx1ZU5vZGUob3duZXJJRCwga2V5SGFzaCwgZW50cnkpKSxcbiAgICAgICAgaWR4MSA8IGlkeDIgPyBbbm9kZSwgbmV3Tm9kZV0gOiBbbmV3Tm9kZSwgbm9kZV0pO1xuXG4gIHJldHVybiBuZXcgQml0bWFwSW5kZXhlZE5vZGUob3duZXJJRCwgKDEgPDwgaWR4MSkgfCAoMSA8PCBpZHgyKSwgbm9kZXMpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb2Rlcyhvd25lcklELCBlbnRyaWVzLCBrZXksIHZhbHVlKSB7XG4gIGlmICghb3duZXJJRCkge1xuICAgIG93bmVySUQgPSBuZXcgT3duZXJJRCgpO1xuICB9XG4gIHZhciBub2RlID0gbmV3IFZhbHVlTm9kZShvd25lcklELCBoYXNoKGtleSksIFtrZXksIHZhbHVlXSk7XG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBlbnRyaWVzLmxlbmd0aDsgaWkrKykge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaWldO1xuICAgIG5vZGUgPSBub2RlLnVwZGF0ZShvd25lcklELCAwLCB1bmRlZmluZWQsIGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIHBhY2tOb2Rlcyhvd25lcklELCBub2RlcywgY291bnQsIGV4Y2x1ZGluZykge1xuICB2YXIgYml0bWFwID0gMDtcbiAgdmFyIHBhY2tlZElJID0gMDtcbiAgdmFyIHBhY2tlZE5vZGVzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgZm9yICh2YXIgaWkgPSAwLCBiaXQgPSAxLCBsZW4gPSBub2Rlcy5sZW5ndGg7IGlpIDwgbGVuOyBpaSsrLCBiaXQgPDw9IDEpIHtcbiAgICB2YXIgbm9kZSA9IG5vZGVzW2lpXTtcbiAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkICYmIGlpICE9PSBleGNsdWRpbmcpIHtcbiAgICAgIGJpdG1hcCB8PSBiaXQ7XG4gICAgICBwYWNrZWROb2Rlc1twYWNrZWRJSSsrXSA9IG5vZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgQml0bWFwSW5kZXhlZE5vZGUob3duZXJJRCwgYml0bWFwLCBwYWNrZWROb2Rlcyk7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZE5vZGVzKG93bmVySUQsIG5vZGVzLCBiaXRtYXAsIGluY2x1ZGluZywgbm9kZSkge1xuICB2YXIgY291bnQgPSAwO1xuICB2YXIgZXhwYW5kZWROb2RlcyA9IG5ldyBBcnJheShTSVpFKTtcbiAgZm9yICh2YXIgaWkgPSAwOyBiaXRtYXAgIT09IDA7IGlpKyssIGJpdG1hcCA+Pj49IDEpIHtcbiAgICBleHBhbmRlZE5vZGVzW2lpXSA9IGJpdG1hcCAmIDEgPyBub2Rlc1tjb3VudCsrXSA6IHVuZGVmaW5lZDtcbiAgfVxuICBleHBhbmRlZE5vZGVzW2luY2x1ZGluZ10gPSBub2RlO1xuICByZXR1cm4gbmV3IEhhc2hBcnJheU1hcE5vZGUob3duZXJJRCwgY291bnQgKyAxLCBleHBhbmRlZE5vZGVzKTtcbn1cblxuZnVuY3Rpb24gcG9wQ291bnQoeCkge1xuICB4IC09ICh4ID4+IDEpICYgMHg1NTU1NTU1NTtcbiAgeCA9ICh4ICYgMHgzMzMzMzMzMykgKyAoKHggPj4gMikgJiAweDMzMzMzMzMzKTtcbiAgeCA9ICh4ICsgKHggPj4gNCkpICYgMHgwZjBmMGYwZjtcbiAgeCArPSB4ID4+IDg7XG4gIHggKz0geCA+PiAxNjtcbiAgcmV0dXJuIHggJiAweDdmO1xufVxuXG5mdW5jdGlvbiBzZXRBdChhcnJheSwgaWR4LCB2YWwsIGNhbkVkaXQpIHtcbiAgdmFyIG5ld0FycmF5ID0gY2FuRWRpdCA/IGFycmF5IDogYXJyQ29weShhcnJheSk7XG4gIG5ld0FycmF5W2lkeF0gPSB2YWw7XG4gIHJldHVybiBuZXdBcnJheTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlSW4oYXJyYXksIGlkeCwgdmFsLCBjYW5FZGl0KSB7XG4gIHZhciBuZXdMZW4gPSBhcnJheS5sZW5ndGggKyAxO1xuICBpZiAoY2FuRWRpdCAmJiBpZHggKyAxID09PSBuZXdMZW4pIHtcbiAgICBhcnJheVtpZHhdID0gdmFsO1xuICAgIHJldHVybiBhcnJheTtcbiAgfVxuICB2YXIgbmV3QXJyYXkgPSBuZXcgQXJyYXkobmV3TGVuKTtcbiAgdmFyIGFmdGVyID0gMDtcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG5ld0xlbjsgaWkrKykge1xuICAgIGlmIChpaSA9PT0gaWR4KSB7XG4gICAgICBuZXdBcnJheVtpaV0gPSB2YWw7XG4gICAgICBhZnRlciA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdBcnJheVtpaV0gPSBhcnJheVtpaSArIGFmdGVyXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld0FycmF5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPdXQoYXJyYXksIGlkeCwgY2FuRWRpdCkge1xuICB2YXIgbmV3TGVuID0gYXJyYXkubGVuZ3RoIC0gMTtcbiAgaWYgKGNhbkVkaXQgJiYgaWR4ID09PSBuZXdMZW4pIHtcbiAgICBhcnJheS5wb3AoKTtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbiAgdmFyIG5ld0FycmF5ID0gbmV3IEFycmF5KG5ld0xlbik7XG4gIHZhciBhZnRlciA9IDA7XG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBuZXdMZW47IGlpKyspIHtcbiAgICBpZiAoaWkgPT09IGlkeCkge1xuICAgICAgYWZ0ZXIgPSAxO1xuICAgIH1cbiAgICBuZXdBcnJheVtpaV0gPSBhcnJheVtpaSArIGFmdGVyXTtcbiAgfVxuICByZXR1cm4gbmV3QXJyYXk7XG59XG5cbnZhciBNQVhfQVJSQVlfTUFQX1NJWkUgPSBTSVpFIC8gNDtcbnZhciBNQVhfQklUTUFQX0lOREVYRURfU0laRSA9IFNJWkUgLyAyO1xudmFyIE1JTl9IQVNIX0FSUkFZX01BUF9TSVpFID0gU0laRSAvIDQ7XG5cbnZhciBJU19MSVNUX1NZTUJPTCA9ICdAQF9fSU1NVVRBQkxFX0xJU1RfX0BAJztcblxuZnVuY3Rpb24gaXNMaXN0KG1heWJlTGlzdCkge1xuICByZXR1cm4gQm9vbGVhbihtYXliZUxpc3QgJiYgbWF5YmVMaXN0W0lTX0xJU1RfU1lNQk9MXSk7XG59XG5cbnZhciBMaXN0ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSW5kZXhlZENvbGxlY3Rpb24pIHtcbiAgZnVuY3Rpb24gTGlzdCh2YWx1ZSkge1xuICAgIHZhciBlbXB0eSA9IGVtcHR5TGlzdCgpO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZW1wdHk7XG4gICAgfVxuICAgIGlmIChpc0xpc3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHZhciBpdGVyID0gSW5kZXhlZENvbGxlY3Rpb24odmFsdWUpO1xuICAgIHZhciBzaXplID0gaXRlci5zaXplO1xuICAgIGlmIChzaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gZW1wdHk7XG4gICAgfVxuICAgIGFzc2VydE5vdEluZmluaXRlKHNpemUpO1xuICAgIGlmIChzaXplID4gMCAmJiBzaXplIDwgU0laRSkge1xuICAgICAgcmV0dXJuIG1ha2VMaXN0KDAsIHNpemUsIFNISUZULCBudWxsLCBuZXcgVk5vZGUoaXRlci50b0FycmF5KCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGVtcHR5LndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgIGxpc3Quc2V0U2l6ZShzaXplKTtcbiAgICAgIGl0ZXIuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkgeyByZXR1cm4gbGlzdC5zZXQoaSwgdik7IH0pO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCBJbmRleGVkQ29sbGVjdGlvbiApIExpc3QuX19wcm90b19fID0gSW5kZXhlZENvbGxlY3Rpb247XG4gIExpc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW5kZXhlZENvbGxlY3Rpb24gJiYgSW5kZXhlZENvbGxlY3Rpb24ucHJvdG90eXBlICk7XG4gIExpc3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGlzdDtcblxuICBMaXN0Lm9mID0gZnVuY3Rpb24gb2YgKC8qLi4udmFsdWVzKi8pIHtcbiAgICByZXR1cm4gdGhpcyhhcmd1bWVudHMpO1xuICB9O1xuXG4gIExpc3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ0xpc3QgWycsICddJyk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICBMaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuc2l6ZSkge1xuICAgICAgaW5kZXggKz0gdGhpcy5fb3JpZ2luO1xuICAgICAgdmFyIG5vZGUgPSBsaXN0Tm9kZUZvcih0aGlzLCBpbmRleCk7XG4gICAgICByZXR1cm4gbm9kZSAmJiBub2RlLmFycmF5W2luZGV4ICYgTUFTS107XG4gICAgfVxuICAgIHJldHVybiBub3RTZXRWYWx1ZTtcbiAgfTtcblxuICAvLyBAcHJhZ21hIE1vZGlmaWNhdGlvblxuXG4gIExpc3QucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoaW5kZXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHVwZGF0ZUxpc3QodGhpcywgaW5kZXgsIHZhbHVlKTtcbiAgfTtcblxuICBMaXN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKGluZGV4KSB7XG4gICAgcmV0dXJuICF0aGlzLmhhcyhpbmRleClcbiAgICAgID8gdGhpc1xuICAgICAgOiBpbmRleCA9PT0gMFxuICAgICAgPyB0aGlzLnNoaWZ0KClcbiAgICAgIDogaW5kZXggPT09IHRoaXMuc2l6ZSAtIDFcbiAgICAgID8gdGhpcy5wb3AoKVxuICAgICAgOiB0aGlzLnNwbGljZShpbmRleCwgMSk7XG4gIH07XG5cbiAgTGlzdC5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gaW5zZXJ0IChpbmRleCwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5zcGxpY2UoaW5kZXgsIDAsIHZhbHVlKTtcbiAgfTtcblxuICBMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICB0aGlzLnNpemUgPSB0aGlzLl9vcmlnaW4gPSB0aGlzLl9jYXBhY2l0eSA9IDA7XG4gICAgICB0aGlzLl9sZXZlbCA9IFNISUZUO1xuICAgICAgdGhpcy5fcm9vdCA9IHRoaXMuX3RhaWwgPSB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gZW1wdHlMaXN0KCk7XG4gIH07XG5cbiAgTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKC8qLi4udmFsdWVzKi8pIHtcbiAgICB2YXIgdmFsdWVzID0gYXJndW1lbnRzO1xuICAgIHZhciBvbGRTaXplID0gdGhpcy5zaXplO1xuICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgIHNldExpc3RCb3VuZHMobGlzdCwgMCwgb2xkU2l6ZSArIHZhbHVlcy5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHZhbHVlcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgbGlzdC5zZXQob2xkU2l6ZSArIGlpLCB2YWx1ZXNbaWldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBMaXN0LnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiBwb3AgKCkge1xuICAgIHJldHVybiBzZXRMaXN0Qm91bmRzKHRoaXMsIDAsIC0xKTtcbiAgfTtcblxuICBMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCAoLyouLi52YWx1ZXMqLykge1xuICAgIHZhciB2YWx1ZXMgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobGlzdCkge1xuICAgICAgc2V0TGlzdEJvdW5kcyhsaXN0LCAtdmFsdWVzLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgdmFsdWVzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICBsaXN0LnNldChpaSwgdmFsdWVzW2lpXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCAoKSB7XG4gICAgcmV0dXJuIHNldExpc3RCb3VuZHModGhpcywgMSk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBDb21wb3NpdGlvblxuXG4gIExpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAoLyouLi5jb2xsZWN0aW9ucyovKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIHNlcXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFyZ3VtZW50ID0gYXJndW1lbnRzJDFbaV07XG4gICAgICB2YXIgc2VxID0gSW5kZXhlZENvbGxlY3Rpb24oXG4gICAgICAgIHR5cGVvZiBhcmd1bWVudCAhPT0gJ3N0cmluZycgJiYgaGFzSXRlcmF0b3IoYXJndW1lbnQpXG4gICAgICAgICAgPyBhcmd1bWVudFxuICAgICAgICAgIDogW2FyZ3VtZW50XVxuICAgICAgKTtcbiAgICAgIGlmIChzZXEuc2l6ZSAhPT0gMCkge1xuICAgICAgICBzZXFzLnB1c2goc2VxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlcXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCAmJiAhdGhpcy5fX293bmVySUQgJiYgc2Vxcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKHNlcXNbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICBzZXFzLmZvckVhY2goZnVuY3Rpb24gKHNlcSkgeyByZXR1cm4gc2VxLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBsaXN0LnB1c2godmFsdWUpOyB9KTsgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgTGlzdC5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uIHNldFNpemUgKHNpemUpIHtcbiAgICByZXR1cm4gc2V0TGlzdEJvdW5kcyh0aGlzLCAwLCBzaXplKTtcbiAgfTtcblxuICBMaXN0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKG1hcHBlciwgY29udGV4dCkge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMkMSQxLnNpemU7IGkrKykge1xuICAgICAgICBsaXN0LnNldChpLCBtYXBwZXIuY2FsbChjb250ZXh0LCBsaXN0LmdldChpKSwgaSwgdGhpcyQxJDEpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvLyBAcHJhZ21hIEl0ZXJhdGlvblxuXG4gIExpc3QucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKGJlZ2luLCBlbmQpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICBpZiAod2hvbGVTbGljZShiZWdpbiwgZW5kLCBzaXplKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBzZXRMaXN0Qm91bmRzKFxuICAgICAgdGhpcyxcbiAgICAgIHJlc29sdmVCZWdpbihiZWdpbiwgc2l6ZSksXG4gICAgICByZXNvbHZlRW5kKGVuZCwgc2l6ZSlcbiAgICApO1xuICB9O1xuXG4gIExpc3QucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIGluZGV4ID0gcmV2ZXJzZSA/IHRoaXMuc2l6ZSA6IDA7XG4gICAgdmFyIHZhbHVlcyA9IGl0ZXJhdGVMaXN0KHRoaXMsIHJldmVyc2UpO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVzKCk7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IERPTkVcbiAgICAgICAgPyBpdGVyYXRvckRvbmUoKVxuICAgICAgICA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgcmV2ZXJzZSA/IC0taW5kZXggOiBpbmRleCsrLCB2YWx1ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgTGlzdC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciBpbmRleCA9IHJldmVyc2UgPyB0aGlzLnNpemUgOiAwO1xuICAgIHZhciB2YWx1ZXMgPSBpdGVyYXRlTGlzdCh0aGlzLCByZXZlcnNlKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgd2hpbGUgKCh2YWx1ZSA9IHZhbHVlcygpKSAhPT0gRE9ORSkge1xuICAgICAgaWYgKGZuKHZhbHVlLCByZXZlcnNlID8gLS1pbmRleCA6IGluZGV4KyssIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9O1xuXG4gIExpc3QucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbiBfX2Vuc3VyZU93bmVyIChvd25lcklEKSB7XG4gICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKCFvd25lcklEKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBlbXB0eUxpc3QoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgIHRoaXMuX19hbHRlcmVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VMaXN0KFxuICAgICAgdGhpcy5fb3JpZ2luLFxuICAgICAgdGhpcy5fY2FwYWNpdHksXG4gICAgICB0aGlzLl9sZXZlbCxcbiAgICAgIHRoaXMuX3Jvb3QsXG4gICAgICB0aGlzLl90YWlsLFxuICAgICAgb3duZXJJRCxcbiAgICAgIHRoaXMuX19oYXNoXG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gTGlzdDtcbn0oSW5kZXhlZENvbGxlY3Rpb24pKTtcblxuTGlzdC5pc0xpc3QgPSBpc0xpc3Q7XG5cbnZhciBMaXN0UHJvdG90eXBlID0gTGlzdC5wcm90b3R5cGU7XG5MaXN0UHJvdG90eXBlW0lTX0xJU1RfU1lNQk9MXSA9IHRydWU7XG5MaXN0UHJvdG90eXBlW0RFTEVURV0gPSBMaXN0UHJvdG90eXBlLnJlbW92ZTtcbkxpc3RQcm90b3R5cGUubWVyZ2UgPSBMaXN0UHJvdG90eXBlLmNvbmNhdDtcbkxpc3RQcm90b3R5cGUuc2V0SW4gPSBzZXRJbjtcbkxpc3RQcm90b3R5cGUuZGVsZXRlSW4gPSBMaXN0UHJvdG90eXBlLnJlbW92ZUluID0gZGVsZXRlSW47XG5MaXN0UHJvdG90eXBlLnVwZGF0ZSA9IHVwZGF0ZTtcbkxpc3RQcm90b3R5cGUudXBkYXRlSW4gPSB1cGRhdGVJbjtcbkxpc3RQcm90b3R5cGUubWVyZ2VJbiA9IG1lcmdlSW47XG5MaXN0UHJvdG90eXBlLm1lcmdlRGVlcEluID0gbWVyZ2VEZWVwSW47XG5MaXN0UHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSB3aXRoTXV0YXRpb25zO1xuTGlzdFByb3RvdHlwZS53YXNBbHRlcmVkID0gd2FzQWx0ZXJlZDtcbkxpc3RQcm90b3R5cGUuYXNJbW11dGFibGUgPSBhc0ltbXV0YWJsZTtcbkxpc3RQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBMaXN0UHJvdG90eXBlLmFzTXV0YWJsZSA9IGFzTXV0YWJsZTtcbkxpc3RQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBhcnIpIHtcbiAgcmV0dXJuIHJlc3VsdC5wdXNoKGFycik7XG59O1xuTGlzdFByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqLmFzSW1tdXRhYmxlKCk7XG59O1xuXG52YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZShhcnJheSwgb3duZXJJRCkge1xuICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG59O1xuXG4vLyBUT0RPOiBzZWVtcyBsaWtlIHRoZXNlIG1ldGhvZHMgYXJlIHZlcnkgc2ltaWxhclxuXG5WTm9kZS5wcm90b3R5cGUucmVtb3ZlQmVmb3JlID0gZnVuY3Rpb24gcmVtb3ZlQmVmb3JlIChvd25lcklELCBsZXZlbCwgaW5kZXgpIHtcbiAgaWYgKGluZGV4ID09PSBsZXZlbCA/IDEgPDwgbGV2ZWwgOiB0aGlzLmFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHZhciBvcmlnaW5JbmRleCA9IChpbmRleCA+Pj4gbGV2ZWwpICYgTUFTSztcbiAgaWYgKG9yaWdpbkluZGV4ID49IHRoaXMuYXJyYXkubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZShbXSwgb3duZXJJRCk7XG4gIH1cbiAgdmFyIHJlbW92aW5nRmlyc3QgPSBvcmlnaW5JbmRleCA9PT0gMDtcbiAgdmFyIG5ld0NoaWxkO1xuICBpZiAobGV2ZWwgPiAwKSB7XG4gICAgdmFyIG9sZENoaWxkID0gdGhpcy5hcnJheVtvcmlnaW5JbmRleF07XG4gICAgbmV3Q2hpbGQgPVxuICAgICAgb2xkQ2hpbGQgJiYgb2xkQ2hpbGQucmVtb3ZlQmVmb3JlKG93bmVySUQsIGxldmVsIC0gU0hJRlQsIGluZGV4KTtcbiAgICBpZiAobmV3Q2hpbGQgPT09IG9sZENoaWxkICYmIHJlbW92aW5nRmlyc3QpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuICBpZiAocmVtb3ZpbmdGaXJzdCAmJiAhbmV3Q2hpbGQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB2YXIgZWRpdGFibGUgPSBlZGl0YWJsZVZOb2RlKHRoaXMsIG93bmVySUQpO1xuICBpZiAoIXJlbW92aW5nRmlyc3QpIHtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgb3JpZ2luSW5kZXg7IGlpKyspIHtcbiAgICAgIGVkaXRhYmxlLmFycmF5W2lpXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgaWYgKG5ld0NoaWxkKSB7XG4gICAgZWRpdGFibGUuYXJyYXlbb3JpZ2luSW5kZXhdID0gbmV3Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIGVkaXRhYmxlO1xufTtcblxuVk5vZGUucHJvdG90eXBlLnJlbW92ZUFmdGVyID0gZnVuY3Rpb24gcmVtb3ZlQWZ0ZXIgKG93bmVySUQsIGxldmVsLCBpbmRleCkge1xuICBpZiAoaW5kZXggPT09IChsZXZlbCA/IDEgPDwgbGV2ZWwgOiAwKSB8fCB0aGlzLmFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHZhciBzaXplSW5kZXggPSAoKGluZGV4IC0gMSkgPj4+IGxldmVsKSAmIE1BU0s7XG4gIGlmIChzaXplSW5kZXggPj0gdGhpcy5hcnJheS5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBuZXdDaGlsZDtcbiAgaWYgKGxldmVsID4gMCkge1xuICAgIHZhciBvbGRDaGlsZCA9IHRoaXMuYXJyYXlbc2l6ZUluZGV4XTtcbiAgICBuZXdDaGlsZCA9XG4gICAgICBvbGRDaGlsZCAmJiBvbGRDaGlsZC5yZW1vdmVBZnRlcihvd25lcklELCBsZXZlbCAtIFNISUZULCBpbmRleCk7XG4gICAgaWYgKG5ld0NoaWxkID09PSBvbGRDaGlsZCAmJiBzaXplSW5kZXggPT09IHRoaXMuYXJyYXkubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVkaXRhYmxlID0gZWRpdGFibGVWTm9kZSh0aGlzLCBvd25lcklEKTtcbiAgZWRpdGFibGUuYXJyYXkuc3BsaWNlKHNpemVJbmRleCArIDEpO1xuICBpZiAobmV3Q2hpbGQpIHtcbiAgICBlZGl0YWJsZS5hcnJheVtzaXplSW5kZXhdID0gbmV3Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIGVkaXRhYmxlO1xufTtcblxudmFyIERPTkUgPSB7fTtcblxuZnVuY3Rpb24gaXRlcmF0ZUxpc3QobGlzdCwgcmV2ZXJzZSkge1xuICB2YXIgbGVmdCA9IGxpc3QuX29yaWdpbjtcbiAgdmFyIHJpZ2h0ID0gbGlzdC5fY2FwYWNpdHk7XG4gIHZhciB0YWlsUG9zID0gZ2V0VGFpbE9mZnNldChyaWdodCk7XG4gIHZhciB0YWlsID0gbGlzdC5fdGFpbDtcblxuICByZXR1cm4gaXRlcmF0ZU5vZGVPckxlYWYobGlzdC5fcm9vdCwgbGlzdC5fbGV2ZWwsIDApO1xuXG4gIGZ1bmN0aW9uIGl0ZXJhdGVOb2RlT3JMZWFmKG5vZGUsIGxldmVsLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gbGV2ZWwgPT09IDBcbiAgICAgID8gaXRlcmF0ZUxlYWYobm9kZSwgb2Zmc2V0KVxuICAgICAgOiBpdGVyYXRlTm9kZShub2RlLCBsZXZlbCwgb2Zmc2V0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGl0ZXJhdGVMZWFmKG5vZGUsIG9mZnNldCkge1xuICAgIHZhciBhcnJheSA9IG9mZnNldCA9PT0gdGFpbFBvcyA/IHRhaWwgJiYgdGFpbC5hcnJheSA6IG5vZGUgJiYgbm9kZS5hcnJheTtcbiAgICB2YXIgZnJvbSA9IG9mZnNldCA+IGxlZnQgPyAwIDogbGVmdCAtIG9mZnNldDtcbiAgICB2YXIgdG8gPSByaWdodCAtIG9mZnNldDtcbiAgICBpZiAodG8gPiBTSVpFKSB7XG4gICAgICB0byA9IFNJWkU7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgcmV0dXJuIERPTkU7XG4gICAgICB9XG4gICAgICB2YXIgaWR4ID0gcmV2ZXJzZSA/IC0tdG8gOiBmcm9tKys7XG4gICAgICByZXR1cm4gYXJyYXkgJiYgYXJyYXlbaWR4XTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaXRlcmF0ZU5vZGUobm9kZSwgbGV2ZWwsIG9mZnNldCkge1xuICAgIHZhciB2YWx1ZXM7XG4gICAgdmFyIGFycmF5ID0gbm9kZSAmJiBub2RlLmFycmF5O1xuICAgIHZhciBmcm9tID0gb2Zmc2V0ID4gbGVmdCA/IDAgOiAobGVmdCAtIG9mZnNldCkgPj4gbGV2ZWw7XG4gICAgdmFyIHRvID0gKChyaWdodCAtIG9mZnNldCkgPj4gbGV2ZWwpICsgMTtcbiAgICBpZiAodG8gPiBTSVpFKSB7XG4gICAgICB0byA9IFNJWkU7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzKCk7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBET05FKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAgICAgcmV0dXJuIERPTkU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlkeCA9IHJldmVyc2UgPyAtLXRvIDogZnJvbSsrO1xuICAgICAgICB2YWx1ZXMgPSBpdGVyYXRlTm9kZU9yTGVhZihcbiAgICAgICAgICBhcnJheSAmJiBhcnJheVtpZHhdLFxuICAgICAgICAgIGxldmVsIC0gU0hJRlQsXG4gICAgICAgICAgb2Zmc2V0ICsgKGlkeCA8PCBsZXZlbClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VMaXN0KG9yaWdpbiwgY2FwYWNpdHksIGxldmVsLCByb290LCB0YWlsLCBvd25lcklELCBoYXNoKSB7XG4gIHZhciBsaXN0ID0gT2JqZWN0LmNyZWF0ZShMaXN0UHJvdG90eXBlKTtcbiAgbGlzdC5zaXplID0gY2FwYWNpdHkgLSBvcmlnaW47XG4gIGxpc3QuX29yaWdpbiA9IG9yaWdpbjtcbiAgbGlzdC5fY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgbGlzdC5fbGV2ZWwgPSBsZXZlbDtcbiAgbGlzdC5fcm9vdCA9IHJvb3Q7XG4gIGxpc3QuX3RhaWwgPSB0YWlsO1xuICBsaXN0Ll9fb3duZXJJRCA9IG93bmVySUQ7XG4gIGxpc3QuX19oYXNoID0gaGFzaDtcbiAgbGlzdC5fX2FsdGVyZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGxpc3Q7XG59XG5cbnZhciBFTVBUWV9MSVNUO1xuZnVuY3Rpb24gZW1wdHlMaXN0KCkge1xuICByZXR1cm4gRU1QVFlfTElTVCB8fCAoRU1QVFlfTElTVCA9IG1ha2VMaXN0KDAsIDAsIFNISUZUKSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3QobGlzdCwgaW5kZXgsIHZhbHVlKSB7XG4gIGluZGV4ID0gd3JhcEluZGV4KGxpc3QsIGluZGV4KTtcblxuICBpZiAoaW5kZXggIT09IGluZGV4KSB7XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cblxuICBpZiAoaW5kZXggPj0gbGlzdC5zaXplIHx8IGluZGV4IDwgMCkge1xuICAgIHJldHVybiBsaXN0LndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgIGluZGV4IDwgMFxuICAgICAgICA/IHNldExpc3RCb3VuZHMobGlzdCwgaW5kZXgpLnNldCgwLCB2YWx1ZSlcbiAgICAgICAgOiBzZXRMaXN0Qm91bmRzKGxpc3QsIDAsIGluZGV4ICsgMSkuc2V0KGluZGV4LCB2YWx1ZSk7XG4gICAgfSk7XG4gIH1cblxuICBpbmRleCArPSBsaXN0Ll9vcmlnaW47XG5cbiAgdmFyIG5ld1RhaWwgPSBsaXN0Ll90YWlsO1xuICB2YXIgbmV3Um9vdCA9IGxpc3QuX3Jvb3Q7XG4gIHZhciBkaWRBbHRlciA9IE1ha2VSZWYoKTtcbiAgaWYgKGluZGV4ID49IGdldFRhaWxPZmZzZXQobGlzdC5fY2FwYWNpdHkpKSB7XG4gICAgbmV3VGFpbCA9IHVwZGF0ZVZOb2RlKG5ld1RhaWwsIGxpc3QuX19vd25lcklELCAwLCBpbmRleCwgdmFsdWUsIGRpZEFsdGVyKTtcbiAgfSBlbHNlIHtcbiAgICBuZXdSb290ID0gdXBkYXRlVk5vZGUoXG4gICAgICBuZXdSb290LFxuICAgICAgbGlzdC5fX293bmVySUQsXG4gICAgICBsaXN0Ll9sZXZlbCxcbiAgICAgIGluZGV4LFxuICAgICAgdmFsdWUsXG4gICAgICBkaWRBbHRlclxuICAgICk7XG4gIH1cblxuICBpZiAoIWRpZEFsdGVyLnZhbHVlKSB7XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cblxuICBpZiAobGlzdC5fX293bmVySUQpIHtcbiAgICBsaXN0Ll9yb290ID0gbmV3Um9vdDtcbiAgICBsaXN0Ll90YWlsID0gbmV3VGFpbDtcbiAgICBsaXN0Ll9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICBsaXN0Ll9fYWx0ZXJlZCA9IHRydWU7XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cbiAgcmV0dXJuIG1ha2VMaXN0KGxpc3QuX29yaWdpbiwgbGlzdC5fY2FwYWNpdHksIGxpc3QuX2xldmVsLCBuZXdSb290LCBuZXdUYWlsKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlVk5vZGUobm9kZSwgb3duZXJJRCwgbGV2ZWwsIGluZGV4LCB2YWx1ZSwgZGlkQWx0ZXIpIHtcbiAgdmFyIGlkeCA9IChpbmRleCA+Pj4gbGV2ZWwpICYgTUFTSztcbiAgdmFyIG5vZGVIYXMgPSBub2RlICYmIGlkeCA8IG5vZGUuYXJyYXkubGVuZ3RoO1xuICBpZiAoIW5vZGVIYXMgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgdmFyIG5ld05vZGU7XG5cbiAgaWYgKGxldmVsID4gMCkge1xuICAgIHZhciBsb3dlck5vZGUgPSBub2RlICYmIG5vZGUuYXJyYXlbaWR4XTtcbiAgICB2YXIgbmV3TG93ZXJOb2RlID0gdXBkYXRlVk5vZGUoXG4gICAgICBsb3dlck5vZGUsXG4gICAgICBvd25lcklELFxuICAgICAgbGV2ZWwgLSBTSElGVCxcbiAgICAgIGluZGV4LFxuICAgICAgdmFsdWUsXG4gICAgICBkaWRBbHRlclxuICAgICk7XG4gICAgaWYgKG5ld0xvd2VyTm9kZSA9PT0gbG93ZXJOb2RlKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgbmV3Tm9kZSA9IGVkaXRhYmxlVk5vZGUobm9kZSwgb3duZXJJRCk7XG4gICAgbmV3Tm9kZS5hcnJheVtpZHhdID0gbmV3TG93ZXJOb2RlO1xuICAgIHJldHVybiBuZXdOb2RlO1xuICB9XG5cbiAgaWYgKG5vZGVIYXMgJiYgbm9kZS5hcnJheVtpZHhdID09PSB2YWx1ZSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgaWYgKGRpZEFsdGVyKSB7XG4gICAgU2V0UmVmKGRpZEFsdGVyKTtcbiAgfVxuXG4gIG5ld05vZGUgPSBlZGl0YWJsZVZOb2RlKG5vZGUsIG93bmVySUQpO1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBpZHggPT09IG5ld05vZGUuYXJyYXkubGVuZ3RoIC0gMSkge1xuICAgIG5ld05vZGUuYXJyYXkucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgbmV3Tm9kZS5hcnJheVtpZHhdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG5ld05vZGU7XG59XG5cbmZ1bmN0aW9uIGVkaXRhYmxlVk5vZGUobm9kZSwgb3duZXJJRCkge1xuICBpZiAob3duZXJJRCAmJiBub2RlICYmIG93bmVySUQgPT09IG5vZGUub3duZXJJRCkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHJldHVybiBuZXcgVk5vZGUobm9kZSA/IG5vZGUuYXJyYXkuc2xpY2UoKSA6IFtdLCBvd25lcklEKTtcbn1cblxuZnVuY3Rpb24gbGlzdE5vZGVGb3IobGlzdCwgcmF3SW5kZXgpIHtcbiAgaWYgKHJhd0luZGV4ID49IGdldFRhaWxPZmZzZXQobGlzdC5fY2FwYWNpdHkpKSB7XG4gICAgcmV0dXJuIGxpc3QuX3RhaWw7XG4gIH1cbiAgaWYgKHJhd0luZGV4IDwgMSA8PCAobGlzdC5fbGV2ZWwgKyBTSElGVCkpIHtcbiAgICB2YXIgbm9kZSA9IGxpc3QuX3Jvb3Q7XG4gICAgdmFyIGxldmVsID0gbGlzdC5fbGV2ZWw7XG4gICAgd2hpbGUgKG5vZGUgJiYgbGV2ZWwgPiAwKSB7XG4gICAgICBub2RlID0gbm9kZS5hcnJheVsocmF3SW5kZXggPj4+IGxldmVsKSAmIE1BU0tdO1xuICAgICAgbGV2ZWwgLT0gU0hJRlQ7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldExpc3RCb3VuZHMobGlzdCwgYmVnaW4sIGVuZCkge1xuICAvLyBTYW5pdGl6ZSBiZWdpbiAmIGVuZCB1c2luZyB0aGlzIHNob3J0aGFuZCBmb3IgVG9JbnQzMihhcmd1bWVudClcbiAgLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvaW50MzJcbiAgaWYgKGJlZ2luICE9PSB1bmRlZmluZWQpIHtcbiAgICBiZWdpbiB8PSAwO1xuICB9XG4gIGlmIChlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCB8PSAwO1xuICB9XG4gIHZhciBvd25lciA9IGxpc3QuX19vd25lcklEIHx8IG5ldyBPd25lcklEKCk7XG4gIHZhciBvbGRPcmlnaW4gPSBsaXN0Ll9vcmlnaW47XG4gIHZhciBvbGRDYXBhY2l0eSA9IGxpc3QuX2NhcGFjaXR5O1xuICB2YXIgbmV3T3JpZ2luID0gb2xkT3JpZ2luICsgYmVnaW47XG4gIHZhciBuZXdDYXBhY2l0eSA9XG4gICAgZW5kID09PSB1bmRlZmluZWRcbiAgICAgID8gb2xkQ2FwYWNpdHlcbiAgICAgIDogZW5kIDwgMFxuICAgICAgPyBvbGRDYXBhY2l0eSArIGVuZFxuICAgICAgOiBvbGRPcmlnaW4gKyBlbmQ7XG4gIGlmIChuZXdPcmlnaW4gPT09IG9sZE9yaWdpbiAmJiBuZXdDYXBhY2l0eSA9PT0gb2xkQ2FwYWNpdHkpIHtcbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuXG4gIC8vIElmIGl0J3MgZ29pbmcgdG8gZW5kIGFmdGVyIGl0IHN0YXJ0cywgaXQncyBlbXB0eS5cbiAgaWYgKG5ld09yaWdpbiA+PSBuZXdDYXBhY2l0eSkge1xuICAgIHJldHVybiBsaXN0LmNsZWFyKCk7XG4gIH1cblxuICB2YXIgbmV3TGV2ZWwgPSBsaXN0Ll9sZXZlbDtcbiAgdmFyIG5ld1Jvb3QgPSBsaXN0Ll9yb290O1xuXG4gIC8vIE5ldyBvcmlnaW4gbWlnaHQgbmVlZCBjcmVhdGluZyBhIGhpZ2hlciByb290LlxuICB2YXIgb2Zmc2V0U2hpZnQgPSAwO1xuICB3aGlsZSAobmV3T3JpZ2luICsgb2Zmc2V0U2hpZnQgPCAwKSB7XG4gICAgbmV3Um9vdCA9IG5ldyBWTm9kZShcbiAgICAgIG5ld1Jvb3QgJiYgbmV3Um9vdC5hcnJheS5sZW5ndGggPyBbdW5kZWZpbmVkLCBuZXdSb290XSA6IFtdLFxuICAgICAgb3duZXJcbiAgICApO1xuICAgIG5ld0xldmVsICs9IFNISUZUO1xuICAgIG9mZnNldFNoaWZ0ICs9IDEgPDwgbmV3TGV2ZWw7XG4gIH1cbiAgaWYgKG9mZnNldFNoaWZ0KSB7XG4gICAgbmV3T3JpZ2luICs9IG9mZnNldFNoaWZ0O1xuICAgIG9sZE9yaWdpbiArPSBvZmZzZXRTaGlmdDtcbiAgICBuZXdDYXBhY2l0eSArPSBvZmZzZXRTaGlmdDtcbiAgICBvbGRDYXBhY2l0eSArPSBvZmZzZXRTaGlmdDtcbiAgfVxuXG4gIHZhciBvbGRUYWlsT2Zmc2V0ID0gZ2V0VGFpbE9mZnNldChvbGRDYXBhY2l0eSk7XG4gIHZhciBuZXdUYWlsT2Zmc2V0ID0gZ2V0VGFpbE9mZnNldChuZXdDYXBhY2l0eSk7XG5cbiAgLy8gTmV3IHNpemUgbWlnaHQgbmVlZCBjcmVhdGluZyBhIGhpZ2hlciByb290LlxuICB3aGlsZSAobmV3VGFpbE9mZnNldCA+PSAxIDw8IChuZXdMZXZlbCArIFNISUZUKSkge1xuICAgIG5ld1Jvb3QgPSBuZXcgVk5vZGUoXG4gICAgICBuZXdSb290ICYmIG5ld1Jvb3QuYXJyYXkubGVuZ3RoID8gW25ld1Jvb3RdIDogW10sXG4gICAgICBvd25lclxuICAgICk7XG4gICAgbmV3TGV2ZWwgKz0gU0hJRlQ7XG4gIH1cblxuICAvLyBMb2NhdGUgb3IgY3JlYXRlIHRoZSBuZXcgdGFpbC5cbiAgdmFyIG9sZFRhaWwgPSBsaXN0Ll90YWlsO1xuICB2YXIgbmV3VGFpbCA9XG4gICAgbmV3VGFpbE9mZnNldCA8IG9sZFRhaWxPZmZzZXRcbiAgICAgID8gbGlzdE5vZGVGb3IobGlzdCwgbmV3Q2FwYWNpdHkgLSAxKVxuICAgICAgOiBuZXdUYWlsT2Zmc2V0ID4gb2xkVGFpbE9mZnNldFxuICAgICAgPyBuZXcgVk5vZGUoW10sIG93bmVyKVxuICAgICAgOiBvbGRUYWlsO1xuXG4gIC8vIE1lcmdlIFRhaWwgaW50byB0cmVlLlxuICBpZiAoXG4gICAgb2xkVGFpbCAmJlxuICAgIG5ld1RhaWxPZmZzZXQgPiBvbGRUYWlsT2Zmc2V0ICYmXG4gICAgbmV3T3JpZ2luIDwgb2xkQ2FwYWNpdHkgJiZcbiAgICBvbGRUYWlsLmFycmF5Lmxlbmd0aFxuICApIHtcbiAgICBuZXdSb290ID0gZWRpdGFibGVWTm9kZShuZXdSb290LCBvd25lcik7XG4gICAgdmFyIG5vZGUgPSBuZXdSb290O1xuICAgIGZvciAodmFyIGxldmVsID0gbmV3TGV2ZWw7IGxldmVsID4gU0hJRlQ7IGxldmVsIC09IFNISUZUKSB7XG4gICAgICB2YXIgaWR4ID0gKG9sZFRhaWxPZmZzZXQgPj4+IGxldmVsKSAmIE1BU0s7XG4gICAgICBub2RlID0gbm9kZS5hcnJheVtpZHhdID0gZWRpdGFibGVWTm9kZShub2RlLmFycmF5W2lkeF0sIG93bmVyKTtcbiAgICB9XG4gICAgbm9kZS5hcnJheVsob2xkVGFpbE9mZnNldCA+Pj4gU0hJRlQpICYgTUFTS10gPSBvbGRUYWlsO1xuICB9XG5cbiAgLy8gSWYgdGhlIHNpemUgaGFzIGJlZW4gcmVkdWNlZCwgdGhlcmUncyBhIGNoYW5jZSB0aGUgdGFpbCBuZWVkcyB0byBiZSB0cmltbWVkLlxuICBpZiAobmV3Q2FwYWNpdHkgPCBvbGRDYXBhY2l0eSkge1xuICAgIG5ld1RhaWwgPSBuZXdUYWlsICYmIG5ld1RhaWwucmVtb3ZlQWZ0ZXIob3duZXIsIDAsIG5ld0NhcGFjaXR5KTtcbiAgfVxuXG4gIC8vIElmIHRoZSBuZXcgb3JpZ2luIGlzIHdpdGhpbiB0aGUgdGFpbCwgdGhlbiB3ZSBkbyBub3QgbmVlZCBhIHJvb3QuXG4gIGlmIChuZXdPcmlnaW4gPj0gbmV3VGFpbE9mZnNldCkge1xuICAgIG5ld09yaWdpbiAtPSBuZXdUYWlsT2Zmc2V0O1xuICAgIG5ld0NhcGFjaXR5IC09IG5ld1RhaWxPZmZzZXQ7XG4gICAgbmV3TGV2ZWwgPSBTSElGVDtcbiAgICBuZXdSb290ID0gbnVsbDtcbiAgICBuZXdUYWlsID0gbmV3VGFpbCAmJiBuZXdUYWlsLnJlbW92ZUJlZm9yZShvd25lciwgMCwgbmV3T3JpZ2luKTtcblxuICAgIC8vIE90aGVyd2lzZSwgaWYgdGhlIHJvb3QgaGFzIGJlZW4gdHJpbW1lZCwgZ2FyYmFnZSBjb2xsZWN0LlxuICB9IGVsc2UgaWYgKG5ld09yaWdpbiA+IG9sZE9yaWdpbiB8fCBuZXdUYWlsT2Zmc2V0IDwgb2xkVGFpbE9mZnNldCkge1xuICAgIG9mZnNldFNoaWZ0ID0gMDtcblxuICAgIC8vIElkZW50aWZ5IHRoZSBuZXcgdG9wIHJvb3Qgbm9kZSBvZiB0aGUgc3VidHJlZSBvZiB0aGUgb2xkIHJvb3QuXG4gICAgd2hpbGUgKG5ld1Jvb3QpIHtcbiAgICAgIHZhciBiZWdpbkluZGV4ID0gKG5ld09yaWdpbiA+Pj4gbmV3TGV2ZWwpICYgTUFTSztcbiAgICAgIGlmICgoYmVnaW5JbmRleCAhPT0gbmV3VGFpbE9mZnNldCA+Pj4gbmV3TGV2ZWwpICYgTUFTSykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChiZWdpbkluZGV4KSB7XG4gICAgICAgIG9mZnNldFNoaWZ0ICs9ICgxIDw8IG5ld0xldmVsKSAqIGJlZ2luSW5kZXg7XG4gICAgICB9XG4gICAgICBuZXdMZXZlbCAtPSBTSElGVDtcbiAgICAgIG5ld1Jvb3QgPSBuZXdSb290LmFycmF5W2JlZ2luSW5kZXhdO1xuICAgIH1cblxuICAgIC8vIFRyaW0gdGhlIG5ldyBzaWRlcyBvZiB0aGUgbmV3IHJvb3QuXG4gICAgaWYgKG5ld1Jvb3QgJiYgbmV3T3JpZ2luID4gb2xkT3JpZ2luKSB7XG4gICAgICBuZXdSb290ID0gbmV3Um9vdC5yZW1vdmVCZWZvcmUob3duZXIsIG5ld0xldmVsLCBuZXdPcmlnaW4gLSBvZmZzZXRTaGlmdCk7XG4gICAgfVxuICAgIGlmIChuZXdSb290ICYmIG5ld1RhaWxPZmZzZXQgPCBvbGRUYWlsT2Zmc2V0KSB7XG4gICAgICBuZXdSb290ID0gbmV3Um9vdC5yZW1vdmVBZnRlcihcbiAgICAgICAgb3duZXIsXG4gICAgICAgIG5ld0xldmVsLFxuICAgICAgICBuZXdUYWlsT2Zmc2V0IC0gb2Zmc2V0U2hpZnRcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChvZmZzZXRTaGlmdCkge1xuICAgICAgbmV3T3JpZ2luIC09IG9mZnNldFNoaWZ0O1xuICAgICAgbmV3Q2FwYWNpdHkgLT0gb2Zmc2V0U2hpZnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxpc3QuX19vd25lcklEKSB7XG4gICAgbGlzdC5zaXplID0gbmV3Q2FwYWNpdHkgLSBuZXdPcmlnaW47XG4gICAgbGlzdC5fb3JpZ2luID0gbmV3T3JpZ2luO1xuICAgIGxpc3QuX2NhcGFjaXR5ID0gbmV3Q2FwYWNpdHk7XG4gICAgbGlzdC5fbGV2ZWwgPSBuZXdMZXZlbDtcbiAgICBsaXN0Ll9yb290ID0gbmV3Um9vdDtcbiAgICBsaXN0Ll90YWlsID0gbmV3VGFpbDtcbiAgICBsaXN0Ll9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICBsaXN0Ll9fYWx0ZXJlZCA9IHRydWU7XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cbiAgcmV0dXJuIG1ha2VMaXN0KG5ld09yaWdpbiwgbmV3Q2FwYWNpdHksIG5ld0xldmVsLCBuZXdSb290LCBuZXdUYWlsKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGFpbE9mZnNldChzaXplKSB7XG4gIHJldHVybiBzaXplIDwgU0laRSA/IDAgOiAoKHNpemUgLSAxKSA+Pj4gU0hJRlQpIDw8IFNISUZUO1xufVxuXG52YXIgT3JkZXJlZE1hcCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKE1hcCkge1xuICBmdW5jdGlvbiBPcmRlcmVkTWFwKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGxcbiAgICAgID8gZW1wdHlPcmRlcmVkTWFwKClcbiAgICAgIDogaXNPcmRlcmVkTWFwKHZhbHVlKVxuICAgICAgPyB2YWx1ZVxuICAgICAgOiBlbXB0eU9yZGVyZWRNYXAoKS53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgICB2YXIgaXRlciA9IEtleWVkQ29sbGVjdGlvbih2YWx1ZSk7XG4gICAgICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICAgICAgICBpdGVyLmZvckVhY2goZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIG1hcC5zZXQoaywgdik7IH0pO1xuICAgICAgICB9KTtcbiAgfVxuXG4gIGlmICggTWFwICkgT3JkZXJlZE1hcC5fX3Byb3RvX18gPSBNYXA7XG4gIE9yZGVyZWRNYXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWFwICYmIE1hcC5wcm90b3R5cGUgKTtcbiAgT3JkZXJlZE1hcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPcmRlcmVkTWFwO1xuXG4gIE9yZGVyZWRNYXAub2YgPSBmdW5jdGlvbiBvZiAoLyouLi52YWx1ZXMqLykge1xuICAgIHJldHVybiB0aGlzKGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgT3JkZXJlZE1hcC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnT3JkZXJlZE1hcCB7JywgJ30nKTtcbiAgfTtcblxuICAvLyBAcHJhZ21hIEFjY2Vzc1xuXG4gIE9yZGVyZWRNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaywgbm90U2V0VmFsdWUpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9tYXAuZ2V0KGspO1xuICAgIHJldHVybiBpbmRleCAhPT0gdW5kZWZpbmVkID8gdGhpcy5fbGlzdC5nZXQoaW5kZXgpWzFdIDogbm90U2V0VmFsdWU7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBNb2RpZmljYXRpb25cblxuICBPcmRlcmVkTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgdGhpcy5fbWFwLmNsZWFyKCk7XG4gICAgICB0aGlzLl9saXN0LmNsZWFyKCk7XG4gICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIGVtcHR5T3JkZXJlZE1hcCgpO1xuICB9O1xuXG4gIE9yZGVyZWRNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoaywgdikge1xuICAgIHJldHVybiB1cGRhdGVPcmRlcmVkTWFwKHRoaXMsIGssIHYpO1xuICB9O1xuXG4gIE9yZGVyZWRNYXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoaykge1xuICAgIHJldHVybiB1cGRhdGVPcmRlcmVkTWFwKHRoaXMsIGssIE5PVF9TRVQpO1xuICB9O1xuXG4gIE9yZGVyZWRNYXAucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgdGhpcyQxJDEgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMuX2xpc3QuX19pdGVyYXRlKFxuICAgICAgZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBlbnRyeSAmJiBmbihlbnRyeVsxXSwgZW50cnlbMF0sIHRoaXMkMSQxKTsgfSxcbiAgICAgIHJldmVyc2VcbiAgICApO1xuICB9O1xuXG4gIE9yZGVyZWRNYXAucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpc3QuZnJvbUVudHJ5U2VxKCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgfTtcblxuICBPcmRlcmVkTWFwLnByb3RvdHlwZS5fX2Vuc3VyZU93bmVyID0gZnVuY3Rpb24gX19lbnN1cmVPd25lciAob3duZXJJRCkge1xuICAgIGlmIChvd25lcklEID09PSB0aGlzLl9fb3duZXJJRCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBuZXdNYXAgPSB0aGlzLl9tYXAuX19lbnN1cmVPd25lcihvd25lcklEKTtcbiAgICB2YXIgbmV3TGlzdCA9IHRoaXMuX2xpc3QuX19lbnN1cmVPd25lcihvd25lcklEKTtcbiAgICBpZiAoIW93bmVySUQpIHtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGVtcHR5T3JkZXJlZE1hcCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fX293bmVySUQgPSBvd25lcklEO1xuICAgICAgdGhpcy5fX2FsdGVyZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX21hcCA9IG5ld01hcDtcbiAgICAgIHRoaXMuX2xpc3QgPSBuZXdMaXN0O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBtYWtlT3JkZXJlZE1hcChuZXdNYXAsIG5ld0xpc3QsIG93bmVySUQsIHRoaXMuX19oYXNoKTtcbiAgfTtcblxuICByZXR1cm4gT3JkZXJlZE1hcDtcbn0oTWFwKSk7XG5cbk9yZGVyZWRNYXAuaXNPcmRlcmVkTWFwID0gaXNPcmRlcmVkTWFwO1xuXG5PcmRlcmVkTWFwLnByb3RvdHlwZVtJU19PUkRFUkVEX1NZTUJPTF0gPSB0cnVlO1xuT3JkZXJlZE1hcC5wcm90b3R5cGVbREVMRVRFXSA9IE9yZGVyZWRNYXAucHJvdG90eXBlLnJlbW92ZTtcblxuZnVuY3Rpb24gbWFrZU9yZGVyZWRNYXAobWFwLCBsaXN0LCBvd25lcklELCBoYXNoKSB7XG4gIHZhciBvbWFwID0gT2JqZWN0LmNyZWF0ZShPcmRlcmVkTWFwLnByb3RvdHlwZSk7XG4gIG9tYXAuc2l6ZSA9IG1hcCA/IG1hcC5zaXplIDogMDtcbiAgb21hcC5fbWFwID0gbWFwO1xuICBvbWFwLl9saXN0ID0gbGlzdDtcbiAgb21hcC5fX293bmVySUQgPSBvd25lcklEO1xuICBvbWFwLl9faGFzaCA9IGhhc2g7XG4gIG9tYXAuX19hbHRlcmVkID0gZmFsc2U7XG4gIHJldHVybiBvbWFwO1xufVxuXG52YXIgRU1QVFlfT1JERVJFRF9NQVA7XG5mdW5jdGlvbiBlbXB0eU9yZGVyZWRNYXAoKSB7XG4gIHJldHVybiAoXG4gICAgRU1QVFlfT1JERVJFRF9NQVAgfHxcbiAgICAoRU1QVFlfT1JERVJFRF9NQVAgPSBtYWtlT3JkZXJlZE1hcChlbXB0eU1hcCgpLCBlbXB0eUxpc3QoKSkpXG4gICk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU9yZGVyZWRNYXAob21hcCwgaywgdikge1xuICB2YXIgbWFwID0gb21hcC5fbWFwO1xuICB2YXIgbGlzdCA9IG9tYXAuX2xpc3Q7XG4gIHZhciBpID0gbWFwLmdldChrKTtcbiAgdmFyIGhhcyA9IGkgIT09IHVuZGVmaW5lZDtcbiAgdmFyIG5ld01hcDtcbiAgdmFyIG5ld0xpc3Q7XG4gIGlmICh2ID09PSBOT1RfU0VUKSB7XG4gICAgLy8gcmVtb3ZlZFxuICAgIGlmICghaGFzKSB7XG4gICAgICByZXR1cm4gb21hcDtcbiAgICB9XG4gICAgaWYgKGxpc3Quc2l6ZSA+PSBTSVpFICYmIGxpc3Quc2l6ZSA+PSBtYXAuc2l6ZSAqIDIpIHtcbiAgICAgIG5ld0xpc3QgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAoZW50cnksIGlkeCkgeyByZXR1cm4gZW50cnkgIT09IHVuZGVmaW5lZCAmJiBpICE9PSBpZHg7IH0pO1xuICAgICAgbmV3TWFwID0gbmV3TGlzdFxuICAgICAgICAudG9LZXllZFNlcSgpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBlbnRyeVswXTsgfSlcbiAgICAgICAgLmZsaXAoKVxuICAgICAgICAudG9NYXAoKTtcbiAgICAgIGlmIChvbWFwLl9fb3duZXJJRCkge1xuICAgICAgICBuZXdNYXAuX19vd25lcklEID0gbmV3TGlzdC5fX293bmVySUQgPSBvbWFwLl9fb3duZXJJRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3TWFwID0gbWFwLnJlbW92ZShrKTtcbiAgICAgIG5ld0xpc3QgPSBpID09PSBsaXN0LnNpemUgLSAxID8gbGlzdC5wb3AoKSA6IGxpc3Quc2V0KGksIHVuZGVmaW5lZCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGhhcykge1xuICAgIGlmICh2ID09PSBsaXN0LmdldChpKVsxXSkge1xuICAgICAgcmV0dXJuIG9tYXA7XG4gICAgfVxuICAgIG5ld01hcCA9IG1hcDtcbiAgICBuZXdMaXN0ID0gbGlzdC5zZXQoaSwgW2ssIHZdKTtcbiAgfSBlbHNlIHtcbiAgICBuZXdNYXAgPSBtYXAuc2V0KGssIGxpc3Quc2l6ZSk7XG4gICAgbmV3TGlzdCA9IGxpc3Quc2V0KGxpc3Quc2l6ZSwgW2ssIHZdKTtcbiAgfVxuICBpZiAob21hcC5fX293bmVySUQpIHtcbiAgICBvbWFwLnNpemUgPSBuZXdNYXAuc2l6ZTtcbiAgICBvbWFwLl9tYXAgPSBuZXdNYXA7XG4gICAgb21hcC5fbGlzdCA9IG5ld0xpc3Q7XG4gICAgb21hcC5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgb21hcC5fX2FsdGVyZWQgPSB0cnVlO1xuICAgIHJldHVybiBvbWFwO1xuICB9XG4gIHJldHVybiBtYWtlT3JkZXJlZE1hcChuZXdNYXAsIG5ld0xpc3QpO1xufVxuXG52YXIgSVNfU1RBQ0tfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfU1RBQ0tfX0BAJztcblxuZnVuY3Rpb24gaXNTdGFjayhtYXliZVN0YWNrKSB7XG4gIHJldHVybiBCb29sZWFuKG1heWJlU3RhY2sgJiYgbWF5YmVTdGFja1tJU19TVEFDS19TWU1CT0xdKTtcbn1cblxudmFyIFN0YWNrID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSW5kZXhlZENvbGxlY3Rpb24pIHtcbiAgZnVuY3Rpb24gU3RhY2sodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbFxuICAgICAgPyBlbXB0eVN0YWNrKClcbiAgICAgIDogaXNTdGFjayh2YWx1ZSlcbiAgICAgID8gdmFsdWVcbiAgICAgIDogZW1wdHlTdGFjaygpLnB1c2hBbGwodmFsdWUpO1xuICB9XG5cbiAgaWYgKCBJbmRleGVkQ29sbGVjdGlvbiApIFN0YWNrLl9fcHJvdG9fXyA9IEluZGV4ZWRDb2xsZWN0aW9uO1xuICBTdGFjay5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkQ29sbGVjdGlvbiAmJiBJbmRleGVkQ29sbGVjdGlvbi5wcm90b3R5cGUgKTtcbiAgU3RhY2sucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3RhY2s7XG5cbiAgU3RhY2sub2YgPSBmdW5jdGlvbiBvZiAoLyouLi52YWx1ZXMqLykge1xuICAgIHJldHVybiB0aGlzKGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgU3RhY2sucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ1N0YWNrIFsnLCAnXScpO1xuICB9O1xuXG4gIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgU3RhY2sucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgdmFyIGhlYWQgPSB0aGlzLl9oZWFkO1xuICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcbiAgICB3aGlsZSAoaGVhZCAmJiBpbmRleC0tKSB7XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gaGVhZCA/IGhlYWQudmFsdWUgOiBub3RTZXRWYWx1ZTtcbiAgfTtcblxuICBTdGFjay5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uIHBlZWsgKCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkICYmIHRoaXMuX2hlYWQudmFsdWU7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBNb2RpZmljYXRpb25cblxuICBTdGFjay5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKC8qLi4udmFsdWVzKi8pIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBuZXdTaXplID0gdGhpcy5zaXplICsgYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgZm9yICh2YXIgaWkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaWkgPj0gMDsgaWktLSkge1xuICAgICAgaGVhZCA9IHtcbiAgICAgICAgdmFsdWU6IGFyZ3VtZW50cyQxW2lpXSxcbiAgICAgICAgbmV4dDogaGVhZCxcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgdGhpcy5zaXplID0gbmV3U2l6ZTtcbiAgICAgIHRoaXMuX2hlYWQgPSBoZWFkO1xuICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VTdGFjayhuZXdTaXplLCBoZWFkKTtcbiAgfTtcblxuICBTdGFjay5wcm90b3R5cGUucHVzaEFsbCA9IGZ1bmN0aW9uIHB1c2hBbGwgKGl0ZXIpIHtcbiAgICBpdGVyID0gSW5kZXhlZENvbGxlY3Rpb24oaXRlcik7XG4gICAgaWYgKGl0ZXIuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLnNpemUgPT09IDAgJiYgaXNTdGFjayhpdGVyKSkge1xuICAgICAgcmV0dXJuIGl0ZXI7XG4gICAgfVxuICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG4gICAgdmFyIG5ld1NpemUgPSB0aGlzLnNpemU7XG4gICAgdmFyIGhlYWQgPSB0aGlzLl9oZWFkO1xuICAgIGl0ZXIuX19pdGVyYXRlKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgbmV3U2l6ZSsrO1xuICAgICAgaGVhZCA9IHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBuZXh0OiBoZWFkLFxuICAgICAgfTtcbiAgICB9LCAvKiByZXZlcnNlICovIHRydWUpO1xuICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgdGhpcy5zaXplID0gbmV3U2l6ZTtcbiAgICAgIHRoaXMuX2hlYWQgPSBoZWFkO1xuICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VTdGFjayhuZXdTaXplLCBoZWFkKTtcbiAgfTtcblxuICBTdGFjay5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gcG9wICgpIHtcbiAgICByZXR1cm4gdGhpcy5zbGljZSgxKTtcbiAgfTtcblxuICBTdGFjay5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gZW1wdHlTdGFjaygpO1xuICB9O1xuXG4gIFN0YWNrLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChiZWdpbiwgZW5kKSB7XG4gICAgaWYgKHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgdGhpcy5zaXplKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciByZXNvbHZlZEJlZ2luID0gcmVzb2x2ZUJlZ2luKGJlZ2luLCB0aGlzLnNpemUpO1xuICAgIHZhciByZXNvbHZlZEVuZCA9IHJlc29sdmVFbmQoZW5kLCB0aGlzLnNpemUpO1xuICAgIGlmIChyZXNvbHZlZEVuZCAhPT0gdGhpcy5zaXplKSB7XG4gICAgICAvLyBzdXBlci5zbGljZShiZWdpbiwgZW5kKTtcbiAgICAgIHJldHVybiBJbmRleGVkQ29sbGVjdGlvbi5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB9XG4gICAgdmFyIG5ld1NpemUgPSB0aGlzLnNpemUgLSByZXNvbHZlZEJlZ2luO1xuICAgIHZhciBoZWFkID0gdGhpcy5faGVhZDtcbiAgICB3aGlsZSAocmVzb2x2ZWRCZWdpbi0tKSB7XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgIH1cbiAgICBpZiAodGhpcy5fX293bmVySUQpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IG5ld1NpemU7XG4gICAgICB0aGlzLl9oZWFkID0gaGVhZDtcbiAgICAgIHRoaXMuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBtYWtlU3RhY2sobmV3U2l6ZSwgaGVhZCk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBNdXRhYmlsaXR5XG5cbiAgU3RhY2sucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbiBfX2Vuc3VyZU93bmVyIChvd25lcklEKSB7XG4gICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKCFvd25lcklEKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBlbXB0eVN0YWNrKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICB0aGlzLl9fYWx0ZXJlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBtYWtlU3RhY2sodGhpcy5zaXplLCB0aGlzLl9oZWFkLCBvd25lcklELCB0aGlzLl9faGFzaCk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBJdGVyYXRpb25cblxuICBTdGFjay5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIG5ldyBBcnJheVNlcSh0aGlzLnRvQXJyYXkoKSkuX19pdGVyYXRlKFxuICAgICAgICBmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gZm4odiwgaywgdGhpcyQxJDEpOyB9LFxuICAgICAgICByZXZlcnNlXG4gICAgICApO1xuICAgIH1cbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgdmFyIG5vZGUgPSB0aGlzLl9oZWFkO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICBpZiAoZm4obm9kZS52YWx1ZSwgaXRlcmF0aW9ucysrLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgfTtcblxuICBTdGFjay5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIG5ldyBBcnJheVNlcSh0aGlzLnRvQXJyYXkoKSkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICB9XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIHZhciBub2RlID0gdGhpcy5faGVhZDtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBTdGFjaztcbn0oSW5kZXhlZENvbGxlY3Rpb24pKTtcblxuU3RhY2suaXNTdGFjayA9IGlzU3RhY2s7XG5cbnZhciBTdGFja1Byb3RvdHlwZSA9IFN0YWNrLnByb3RvdHlwZTtcblN0YWNrUHJvdG90eXBlW0lTX1NUQUNLX1NZTUJPTF0gPSB0cnVlO1xuU3RhY2tQcm90b3R5cGUuc2hpZnQgPSBTdGFja1Byb3RvdHlwZS5wb3A7XG5TdGFja1Byb3RvdHlwZS51bnNoaWZ0ID0gU3RhY2tQcm90b3R5cGUucHVzaDtcblN0YWNrUHJvdG90eXBlLnVuc2hpZnRBbGwgPSBTdGFja1Byb3RvdHlwZS5wdXNoQWxsO1xuU3RhY2tQcm90b3R5cGUud2l0aE11dGF0aW9ucyA9IHdpdGhNdXRhdGlvbnM7XG5TdGFja1Byb3RvdHlwZS53YXNBbHRlcmVkID0gd2FzQWx0ZXJlZDtcblN0YWNrUHJvdG90eXBlLmFzSW1tdXRhYmxlID0gYXNJbW11dGFibGU7XG5TdGFja1Byb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IFN0YWNrUHJvdG90eXBlLmFzTXV0YWJsZSA9IGFzTXV0YWJsZTtcblN0YWNrUHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgYXJyKSB7XG4gIHJldHVybiByZXN1bHQudW5zaGlmdChhcnIpO1xufTtcblN0YWNrUHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmouYXNJbW11dGFibGUoKTtcbn07XG5cbmZ1bmN0aW9uIG1ha2VTdGFjayhzaXplLCBoZWFkLCBvd25lcklELCBoYXNoKSB7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKFN0YWNrUHJvdG90eXBlKTtcbiAgbWFwLnNpemUgPSBzaXplO1xuICBtYXAuX2hlYWQgPSBoZWFkO1xuICBtYXAuX19vd25lcklEID0gb3duZXJJRDtcbiAgbWFwLl9faGFzaCA9IGhhc2g7XG4gIG1hcC5fX2FsdGVyZWQgPSBmYWxzZTtcbiAgcmV0dXJuIG1hcDtcbn1cblxudmFyIEVNUFRZX1NUQUNLO1xuZnVuY3Rpb24gZW1wdHlTdGFjaygpIHtcbiAgcmV0dXJuIEVNUFRZX1NUQUNLIHx8IChFTVBUWV9TVEFDSyA9IG1ha2VTdGFjaygwKSk7XG59XG5cbnZhciBJU19TRVRfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfU0VUX19AQCc7XG5cbmZ1bmN0aW9uIGlzU2V0KG1heWJlU2V0KSB7XG4gIHJldHVybiBCb29sZWFuKG1heWJlU2V0ICYmIG1heWJlU2V0W0lTX1NFVF9TWU1CT0xdKTtcbn1cblxuZnVuY3Rpb24gaXNPcmRlcmVkU2V0KG1heWJlT3JkZXJlZFNldCkge1xuICByZXR1cm4gaXNTZXQobWF5YmVPcmRlcmVkU2V0KSAmJiBpc09yZGVyZWQobWF5YmVPcmRlcmVkU2V0KTtcbn1cblxuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChcbiAgICAhaXNDb2xsZWN0aW9uKGIpIHx8XG4gICAgKGEuc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGIuc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGEuc2l6ZSAhPT0gYi5zaXplKSB8fFxuICAgIChhLl9faGFzaCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBiLl9faGFzaCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBhLl9faGFzaCAhPT0gYi5fX2hhc2gpIHx8XG4gICAgaXNLZXllZChhKSAhPT0gaXNLZXllZChiKSB8fFxuICAgIGlzSW5kZXhlZChhKSAhPT0gaXNJbmRleGVkKGIpIHx8XG4gICAgaXNPcmRlcmVkKGEpICE9PSBpc09yZGVyZWQoYilcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGEuc2l6ZSA9PT0gMCAmJiBiLnNpemUgPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBub3RBc3NvY2lhdGl2ZSA9ICFpc0Fzc29jaWF0aXZlKGEpO1xuXG4gIGlmIChpc09yZGVyZWQoYSkpIHtcbiAgICB2YXIgZW50cmllcyA9IGEuZW50cmllcygpO1xuICAgIHJldHVybiAoXG4gICAgICBiLmV2ZXJ5KGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXMubmV4dCgpLnZhbHVlO1xuICAgICAgICByZXR1cm4gZW50cnkgJiYgaXMoZW50cnlbMV0sIHYpICYmIChub3RBc3NvY2lhdGl2ZSB8fCBpcyhlbnRyeVswXSwgaykpO1xuICAgICAgfSkgJiYgZW50cmllcy5uZXh0KCkuZG9uZVxuICAgICk7XG4gIH1cblxuICB2YXIgZmxpcHBlZCA9IGZhbHNlO1xuXG4gIGlmIChhLnNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChiLnNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBhLmNhY2hlUmVzdWx0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGEuY2FjaGVSZXN1bHQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZmxpcHBlZCA9IHRydWU7XG4gICAgICB2YXIgXyA9IGE7XG4gICAgICBhID0gYjtcbiAgICAgIGIgPSBfO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhbGxFcXVhbCA9IHRydWU7XG4gIHZhciBiU2l6ZSA9IGIuX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgaWYgKFxuICAgICAgbm90QXNzb2NpYXRpdmVcbiAgICAgICAgPyAhYS5oYXModilcbiAgICAgICAgOiBmbGlwcGVkXG4gICAgICAgID8gIWlzKHYsIGEuZ2V0KGssIE5PVF9TRVQpKVxuICAgICAgICA6ICFpcyhhLmdldChrLCBOT1RfU0VUKSwgdilcbiAgICApIHtcbiAgICAgIGFsbEVxdWFsID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gYWxsRXF1YWwgJiYgYS5zaXplID09PSBiU2l6ZTtcbn1cblxuZnVuY3Rpb24gbWl4aW4oY3RvciwgbWV0aG9kcykge1xuICB2YXIga2V5Q29waWVyID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGN0b3IucHJvdG90eXBlW2tleV0gPSBtZXRob2RzW2tleV07XG4gIH07XG4gIE9iamVjdC5rZXlzKG1ldGhvZHMpLmZvckVhY2goa2V5Q29waWVyKTtcbiAgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJlxuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobWV0aG9kcykuZm9yRWFjaChrZXlDb3BpZXIpO1xuICByZXR1cm4gY3Rvcjtcbn1cblxuZnVuY3Rpb24gdG9KUyh2YWx1ZSkge1xuICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKCFpc0NvbGxlY3Rpb24odmFsdWUpKSB7XG4gICAgaWYgKCFpc0RhdGFTdHJ1Y3R1cmUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHZhbHVlID0gU2VxKHZhbHVlKTtcbiAgfVxuICBpZiAoaXNLZXllZCh2YWx1ZSkpIHtcbiAgICB2YXIgcmVzdWx0JDEgPSB7fTtcbiAgICB2YWx1ZS5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgIHJlc3VsdCQxW2tdID0gdG9KUyh2KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0JDE7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YWx1ZS5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYpIHtcbiAgICByZXN1bHQucHVzaCh0b0pTKHYpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBTZXQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChTZXRDb2xsZWN0aW9uKSB7XG4gIGZ1bmN0aW9uIFNldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsXG4gICAgICA/IGVtcHR5U2V0KClcbiAgICAgIDogaXNTZXQodmFsdWUpICYmICFpc09yZGVyZWQodmFsdWUpXG4gICAgICA/IHZhbHVlXG4gICAgICA6IGVtcHR5U2V0KCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgICAgdmFyIGl0ZXIgPSBTZXRDb2xsZWN0aW9uKHZhbHVlKTtcbiAgICAgICAgICBhc3NlcnROb3RJbmZpbml0ZShpdGVyLnNpemUpO1xuICAgICAgICAgIGl0ZXIuZm9yRWFjaChmdW5jdGlvbiAodikgeyByZXR1cm4gc2V0LmFkZCh2KTsgfSk7XG4gICAgICAgIH0pO1xuICB9XG5cbiAgaWYgKCBTZXRDb2xsZWN0aW9uICkgU2V0Ll9fcHJvdG9fXyA9IFNldENvbGxlY3Rpb247XG4gIFNldC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTZXRDb2xsZWN0aW9uICYmIFNldENvbGxlY3Rpb24ucHJvdG90eXBlICk7XG4gIFNldC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXQ7XG5cbiAgU2V0Lm9mID0gZnVuY3Rpb24gb2YgKC8qLi4udmFsdWVzKi8pIHtcbiAgICByZXR1cm4gdGhpcyhhcmd1bWVudHMpO1xuICB9O1xuXG4gIFNldC5mcm9tS2V5cyA9IGZ1bmN0aW9uIGZyb21LZXlzICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzKEtleWVkQ29sbGVjdGlvbih2YWx1ZSkua2V5U2VxKCkpO1xuICB9O1xuXG4gIFNldC5pbnRlcnNlY3QgPSBmdW5jdGlvbiBpbnRlcnNlY3QgKHNldHMpIHtcbiAgICBzZXRzID0gQ29sbGVjdGlvbihzZXRzKS50b0FycmF5KCk7XG4gICAgcmV0dXJuIHNldHMubGVuZ3RoXG4gICAgICA/IFNldFByb3RvdHlwZS5pbnRlcnNlY3QuYXBwbHkoU2V0KHNldHMucG9wKCkpLCBzZXRzKVxuICAgICAgOiBlbXB0eVNldCgpO1xuICB9O1xuXG4gIFNldC51bmlvbiA9IGZ1bmN0aW9uIHVuaW9uIChzZXRzKSB7XG4gICAgc2V0cyA9IENvbGxlY3Rpb24oc2V0cykudG9BcnJheSgpO1xuICAgIHJldHVybiBzZXRzLmxlbmd0aFxuICAgICAgPyBTZXRQcm90b3R5cGUudW5pb24uYXBwbHkoU2V0KHNldHMucG9wKCkpLCBzZXRzKVxuICAgICAgOiBlbXB0eVNldCgpO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnU2V0IHsnLCAnfScpO1xuICB9O1xuXG4gIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5oYXModmFsdWUpO1xuICB9O1xuXG4gIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKHZhbHVlKSB7XG4gICAgcmV0dXJuIHVwZGF0ZVNldCh0aGlzLCB0aGlzLl9tYXAuc2V0KHZhbHVlLCB2YWx1ZSkpO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlICh2YWx1ZSkge1xuICAgIHJldHVybiB1cGRhdGVTZXQodGhpcywgdGhpcy5fbWFwLnJlbW92ZSh2YWx1ZSkpO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgcmV0dXJuIHVwZGF0ZVNldCh0aGlzLCB0aGlzLl9tYXAuY2xlYXIoKSk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBDb21wb3NpdGlvblxuXG4gIFNldC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgdGhpcyQxJDEgPSB0aGlzO1xuXG4gICAgLy8ga2VlcCB0cmFjayBpZiB0aGUgc2V0IGlzIGFsdGVyZWQgYnkgdGhlIG1hcCBmdW5jdGlvblxuICAgIHZhciBkaWRDaGFuZ2VzID0gZmFsc2U7XG5cbiAgICB2YXIgbmV3TWFwID0gdXBkYXRlU2V0KFxuICAgICAgdGhpcyxcbiAgICAgIHRoaXMuX21hcC5tYXBFbnRyaWVzKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgdmFyIHYgPSByZWZbMV07XG5cbiAgICAgICAgdmFyIG1hcHBlZCA9IG1hcHBlci5jYWxsKGNvbnRleHQsIHYsIHYsIHRoaXMkMSQxKTtcblxuICAgICAgICBpZiAobWFwcGVkICE9PSB2KSB7XG4gICAgICAgICAgZGlkQ2hhbmdlcyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW21hcHBlZCwgbWFwcGVkXTtcbiAgICAgIH0sIGNvbnRleHQpXG4gICAgKTtcblxuICAgIHJldHVybiBkaWRDaGFuZ2VzID8gbmV3TWFwIDogdGhpcztcbiAgfTtcblxuICBTZXQucHJvdG90eXBlLnVuaW9uID0gZnVuY3Rpb24gdW5pb24gKCkge1xuICAgIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgaXRlcnMgPSBpdGVycy5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguc2l6ZSAhPT0gMDsgfSk7XG4gICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLnNpemUgPT09IDAgJiYgIXRoaXMuX19vd25lcklEICYmIGl0ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IoaXRlcnNbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBpdGVycy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgU2V0Q29sbGVjdGlvbihpdGVyc1tpaV0pLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBzZXQuYWRkKHZhbHVlKTsgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgU2V0LnByb3RvdHlwZS5pbnRlcnNlY3QgPSBmdW5jdGlvbiBpbnRlcnNlY3QgKCkge1xuICAgIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGl0ZXJzID0gaXRlcnMubWFwKGZ1bmN0aW9uIChpdGVyKSB7IHJldHVybiBTZXRDb2xsZWN0aW9uKGl0ZXIpOyB9KTtcbiAgICB2YXIgdG9SZW1vdmUgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAoIWl0ZXJzLmV2ZXJ5KGZ1bmN0aW9uIChpdGVyKSB7IHJldHVybiBpdGVyLmluY2x1ZGVzKHZhbHVlKTsgfSkpIHtcbiAgICAgICAgdG9SZW1vdmUucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAoc2V0KSB7XG4gICAgICB0b1JlbW92ZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBzZXQucmVtb3ZlKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdCAoKSB7XG4gICAgdmFyIGl0ZXJzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGl0ZXJzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICBpZiAoaXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaXRlcnMgPSBpdGVycy5tYXAoZnVuY3Rpb24gKGl0ZXIpIHsgcmV0dXJuIFNldENvbGxlY3Rpb24oaXRlcik7IH0pO1xuICAgIHZhciB0b1JlbW92ZSA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmIChpdGVycy5zb21lKGZ1bmN0aW9uIChpdGVyKSB7IHJldHVybiBpdGVyLmluY2x1ZGVzKHZhbHVlKTsgfSkpIHtcbiAgICAgICAgdG9SZW1vdmUucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAoc2V0KSB7XG4gICAgICB0b1JlbW92ZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBzZXQucmVtb3ZlKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uIHNvcnQgKGNvbXBhcmF0b3IpIHtcbiAgICAvLyBMYXRlIGJpbmRpbmdcbiAgICByZXR1cm4gT3JkZXJlZFNldChzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yKSk7XG4gIH07XG5cbiAgU2V0LnByb3RvdHlwZS5zb3J0QnkgPSBmdW5jdGlvbiBzb3J0QnkgKG1hcHBlciwgY29tcGFyYXRvcikge1xuICAgIC8vIExhdGUgYmluZGluZ1xuICAgIHJldHVybiBPcmRlcmVkU2V0KHNvcnRGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IsIG1hcHBlcikpO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUud2FzQWx0ZXJlZCA9IGZ1bmN0aW9uIHdhc0FsdGVyZWQgKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXAud2FzQWx0ZXJlZCgpO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5fbWFwLl9faXRlcmF0ZShmdW5jdGlvbiAoaykgeyByZXR1cm4gZm4oaywgaywgdGhpcyQxJDEpOyB9LCByZXZlcnNlKTtcbiAgfTtcblxuICBTZXQucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uIF9fZW5zdXJlT3duZXIgKG93bmVySUQpIHtcbiAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgbmV3TWFwID0gdGhpcy5fbWFwLl9fZW5zdXJlT3duZXIob3duZXJJRCk7XG4gICAgaWYgKCFvd25lcklEKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZW1wdHkoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgIHRoaXMuX21hcCA9IG5ld01hcDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fX21ha2UobmV3TWFwLCBvd25lcklEKTtcbiAgfTtcblxuICByZXR1cm4gU2V0O1xufShTZXRDb2xsZWN0aW9uKSk7XG5cblNldC5pc1NldCA9IGlzU2V0O1xuXG52YXIgU2V0UHJvdG90eXBlID0gU2V0LnByb3RvdHlwZTtcblNldFByb3RvdHlwZVtJU19TRVRfU1lNQk9MXSA9IHRydWU7XG5TZXRQcm90b3R5cGVbREVMRVRFXSA9IFNldFByb3RvdHlwZS5yZW1vdmU7XG5TZXRQcm90b3R5cGUubWVyZ2UgPSBTZXRQcm90b3R5cGUuY29uY2F0ID0gU2V0UHJvdG90eXBlLnVuaW9uO1xuU2V0UHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSB3aXRoTXV0YXRpb25zO1xuU2V0UHJvdG90eXBlLmFzSW1tdXRhYmxlID0gYXNJbW11dGFibGU7XG5TZXRQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBTZXRQcm90b3R5cGUuYXNNdXRhYmxlID0gYXNNdXRhYmxlO1xuU2V0UHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgYXJyKSB7XG4gIHJldHVybiByZXN1bHQuYWRkKGFycik7XG59O1xuU2V0UHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmouYXNJbW11dGFibGUoKTtcbn07XG5cblNldFByb3RvdHlwZS5fX2VtcHR5ID0gZW1wdHlTZXQ7XG5TZXRQcm90b3R5cGUuX19tYWtlID0gbWFrZVNldDtcblxuZnVuY3Rpb24gdXBkYXRlU2V0KHNldCwgbmV3TWFwKSB7XG4gIGlmIChzZXQuX19vd25lcklEKSB7XG4gICAgc2V0LnNpemUgPSBuZXdNYXAuc2l6ZTtcbiAgICBzZXQuX21hcCA9IG5ld01hcDtcbiAgICByZXR1cm4gc2V0O1xuICB9XG4gIHJldHVybiBuZXdNYXAgPT09IHNldC5fbWFwXG4gICAgPyBzZXRcbiAgICA6IG5ld01hcC5zaXplID09PSAwXG4gICAgPyBzZXQuX19lbXB0eSgpXG4gICAgOiBzZXQuX19tYWtlKG5ld01hcCk7XG59XG5cbmZ1bmN0aW9uIG1ha2VTZXQobWFwLCBvd25lcklEKSB7XG4gIHZhciBzZXQgPSBPYmplY3QuY3JlYXRlKFNldFByb3RvdHlwZSk7XG4gIHNldC5zaXplID0gbWFwID8gbWFwLnNpemUgOiAwO1xuICBzZXQuX21hcCA9IG1hcDtcbiAgc2V0Ll9fb3duZXJJRCA9IG93bmVySUQ7XG4gIHJldHVybiBzZXQ7XG59XG5cbnZhciBFTVBUWV9TRVQ7XG5mdW5jdGlvbiBlbXB0eVNldCgpIHtcbiAgcmV0dXJuIEVNUFRZX1NFVCB8fCAoRU1QVFlfU0VUID0gbWFrZVNldChlbXB0eU1hcCgpKSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGxhenkgc2VxIG9mIG51bXMgZnJvbSBzdGFydCAoaW5jbHVzaXZlKSB0byBlbmRcbiAqIChleGNsdXNpdmUpLCBieSBzdGVwLCB3aGVyZSBzdGFydCBkZWZhdWx0cyB0byAwLCBzdGVwIHRvIDEsIGFuZCBlbmQgdG9cbiAqIGluZmluaXR5LiBXaGVuIHN0YXJ0IGlzIGVxdWFsIHRvIGVuZCwgcmV0dXJucyBlbXB0eSBsaXN0LlxuICovXG52YXIgUmFuZ2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbmRleGVkU2VxKSB7XG4gIGZ1bmN0aW9uIFJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXApO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoc3RlcCAhPT0gMCwgJ0Nhbm5vdCBzdGVwIGEgUmFuZ2UgYnkgMCcpO1xuICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuZCA9IEluZmluaXR5O1xuICAgIH1cbiAgICBzdGVwID0gc3RlcCA9PT0gdW5kZWZpbmVkID8gMSA6IE1hdGguYWJzKHN0ZXApO1xuICAgIGlmIChlbmQgPCBzdGFydCkge1xuICAgICAgc3RlcCA9IC1zdGVwO1xuICAgIH1cbiAgICB0aGlzLl9zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuX2VuZCA9IGVuZDtcbiAgICB0aGlzLl9zdGVwID0gc3RlcDtcbiAgICB0aGlzLnNpemUgPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKGVuZCAtIHN0YXJ0KSAvIHN0ZXAgLSAxKSArIDEpO1xuICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgIGlmIChFTVBUWV9SQU5HRSkge1xuICAgICAgICByZXR1cm4gRU1QVFlfUkFOR0U7XG4gICAgICB9XG4gICAgICBFTVBUWV9SQU5HRSA9IHRoaXM7XG4gICAgfVxuICB9XG5cbiAgaWYgKCBJbmRleGVkU2VxICkgUmFuZ2UuX19wcm90b19fID0gSW5kZXhlZFNlcTtcbiAgUmFuZ2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW5kZXhlZFNlcSAmJiBJbmRleGVkU2VxLnByb3RvdHlwZSApO1xuICBSYW5nZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSYW5nZTtcblxuICBSYW5nZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuICdSYW5nZSBbXSc7XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICAnUmFuZ2UgWyAnICtcbiAgICAgIHRoaXMuX3N0YXJ0ICtcbiAgICAgICcuLi4nICtcbiAgICAgIHRoaXMuX2VuZCArXG4gICAgICAodGhpcy5fc3RlcCAhPT0gMSA/ICcgYnkgJyArIHRoaXMuX3N0ZXAgOiAnJykgK1xuICAgICAgJyBdJ1xuICAgICk7XG4gIH07XG5cbiAgUmFuZ2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKGluZGV4KVxuICAgICAgPyB0aGlzLl9zdGFydCArIHdyYXBJbmRleCh0aGlzLCBpbmRleCkgKiB0aGlzLl9zdGVwXG4gICAgICA6IG5vdFNldFZhbHVlO1xuICB9O1xuXG4gIFJhbmdlLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzIChzZWFyY2hWYWx1ZSkge1xuICAgIHZhciBwb3NzaWJsZUluZGV4ID0gKHNlYXJjaFZhbHVlIC0gdGhpcy5fc3RhcnQpIC8gdGhpcy5fc3RlcDtcbiAgICByZXR1cm4gKFxuICAgICAgcG9zc2libGVJbmRleCA+PSAwICYmXG4gICAgICBwb3NzaWJsZUluZGV4IDwgdGhpcy5zaXplICYmXG4gICAgICBwb3NzaWJsZUluZGV4ID09PSBNYXRoLmZsb29yKHBvc3NpYmxlSW5kZXgpXG4gICAgKTtcbiAgfTtcblxuICBSYW5nZS5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoYmVnaW4sIGVuZCkge1xuICAgIGlmICh3aG9sZVNsaWNlKGJlZ2luLCBlbmQsIHRoaXMuc2l6ZSkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBiZWdpbiA9IHJlc29sdmVCZWdpbihiZWdpbiwgdGhpcy5zaXplKTtcbiAgICBlbmQgPSByZXNvbHZlRW5kKGVuZCwgdGhpcy5zaXplKTtcbiAgICBpZiAoZW5kIDw9IGJlZ2luKSB7XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKDAsIDApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJhbmdlKFxuICAgICAgdGhpcy5nZXQoYmVnaW4sIHRoaXMuX2VuZCksXG4gICAgICB0aGlzLmdldChlbmQsIHRoaXMuX2VuZCksXG4gICAgICB0aGlzLl9zdGVwXG4gICAgKTtcbiAgfTtcblxuICBSYW5nZS5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHNlYXJjaFZhbHVlKSB7XG4gICAgdmFyIG9mZnNldFZhbHVlID0gc2VhcmNoVmFsdWUgLSB0aGlzLl9zdGFydDtcbiAgICBpZiAob2Zmc2V0VmFsdWUgJSB0aGlzLl9zdGVwID09PSAwKSB7XG4gICAgICB2YXIgaW5kZXggPSBvZmZzZXRWYWx1ZSAvIHRoaXMuX3N0ZXA7XG4gICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuc2l6ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICBSYW5nZS5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAoc2VhcmNoVmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleE9mKHNlYXJjaFZhbHVlKTtcbiAgfTtcblxuICBSYW5nZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciBzaXplID0gdGhpcy5zaXplO1xuICAgIHZhciBzdGVwID0gdGhpcy5fc3RlcDtcbiAgICB2YXIgdmFsdWUgPSByZXZlcnNlID8gdGhpcy5fc3RhcnQgKyAoc2l6ZSAtIDEpICogc3RlcCA6IHRoaXMuX3N0YXJ0O1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSAhPT0gc2l6ZSkge1xuICAgICAgaWYgKGZuKHZhbHVlLCByZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdmFsdWUgKz0gcmV2ZXJzZSA/IC1zdGVwIDogc3RlcDtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH07XG5cbiAgUmFuZ2UucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgdmFyIHN0ZXAgPSB0aGlzLl9zdGVwO1xuICAgIHZhciB2YWx1ZSA9IHJldmVyc2UgPyB0aGlzLl9zdGFydCArIChzaXplIC0gMSkgKiBzdGVwIDogdGhpcy5fc3RhcnQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGkgPT09IHNpemUpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgfVxuICAgICAgdmFyIHYgPSB2YWx1ZTtcbiAgICAgIHZhbHVlICs9IHJldmVyc2UgPyAtc3RlcCA6IHN0ZXA7XG4gICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCByZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrKywgdik7XG4gICAgfSk7XG4gIH07XG5cbiAgUmFuZ2UucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAob3RoZXIpIHtcbiAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBSYW5nZVxuICAgICAgPyB0aGlzLl9zdGFydCA9PT0gb3RoZXIuX3N0YXJ0ICYmXG4gICAgICAgICAgdGhpcy5fZW5kID09PSBvdGhlci5fZW5kICYmXG4gICAgICAgICAgdGhpcy5fc3RlcCA9PT0gb3RoZXIuX3N0ZXBcbiAgICAgIDogZGVlcEVxdWFsKHRoaXMsIG90aGVyKTtcbiAgfTtcblxuICByZXR1cm4gUmFuZ2U7XG59KEluZGV4ZWRTZXEpKTtcblxudmFyIEVNUFRZX1JBTkdFO1xuXG5mdW5jdGlvbiBnZXRJbiQxKGNvbGxlY3Rpb24sIHNlYXJjaEtleVBhdGgsIG5vdFNldFZhbHVlKSB7XG4gIHZhciBrZXlQYXRoID0gY29lcmNlS2V5UGF0aChzZWFyY2hLZXlQYXRoKTtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoaSAhPT0ga2V5UGF0aC5sZW5ndGgpIHtcbiAgICBjb2xsZWN0aW9uID0gZ2V0KGNvbGxlY3Rpb24sIGtleVBhdGhbaSsrXSwgTk9UX1NFVCk7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT09IE5PVF9TRVQpIHtcbiAgICAgIHJldHVybiBub3RTZXRWYWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIGdldEluKHNlYXJjaEtleVBhdGgsIG5vdFNldFZhbHVlKSB7XG4gIHJldHVybiBnZXRJbiQxKHRoaXMsIHNlYXJjaEtleVBhdGgsIG5vdFNldFZhbHVlKTtcbn1cblxuZnVuY3Rpb24gaGFzSW4kMShjb2xsZWN0aW9uLCBrZXlQYXRoKSB7XG4gIHJldHVybiBnZXRJbiQxKGNvbGxlY3Rpb24sIGtleVBhdGgsIE5PVF9TRVQpICE9PSBOT1RfU0VUO1xufVxuXG5mdW5jdGlvbiBoYXNJbihzZWFyY2hLZXlQYXRoKSB7XG4gIHJldHVybiBoYXNJbiQxKHRoaXMsIHNlYXJjaEtleVBhdGgpO1xufVxuXG5mdW5jdGlvbiB0b09iamVjdCgpIHtcbiAgYXNzZXJ0Tm90SW5maW5pdGUodGhpcy5zaXplKTtcbiAgdmFyIG9iamVjdCA9IHt9O1xuICB0aGlzLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykge1xuICAgIG9iamVjdFtrXSA9IHY7XG4gIH0pO1xuICByZXR1cm4gb2JqZWN0O1xufVxuXG4vLyBOb3RlOiBhbGwgb2YgdGhlc2UgbWV0aG9kcyBhcmUgZGVwcmVjYXRlZC5cbkNvbGxlY3Rpb24uaXNJdGVyYWJsZSA9IGlzQ29sbGVjdGlvbjtcbkNvbGxlY3Rpb24uaXNLZXllZCA9IGlzS2V5ZWQ7XG5Db2xsZWN0aW9uLmlzSW5kZXhlZCA9IGlzSW5kZXhlZDtcbkNvbGxlY3Rpb24uaXNBc3NvY2lhdGl2ZSA9IGlzQXNzb2NpYXRpdmU7XG5Db2xsZWN0aW9uLmlzT3JkZXJlZCA9IGlzT3JkZXJlZDtcblxuQ29sbGVjdGlvbi5JdGVyYXRvciA9IEl0ZXJhdG9yO1xuXG5taXhpbihDb2xsZWN0aW9uLCB7XG4gIC8vICMjIyBDb252ZXJzaW9uIHRvIG90aGVyIHR5cGVzXG5cbiAgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICAgIHZhciBhcnJheSA9IG5ldyBBcnJheSh0aGlzLnNpemUgfHwgMCk7XG4gICAgdmFyIHVzZVR1cGxlcyA9IGlzS2V5ZWQodGhpcyk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHRoaXMuX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAvLyBLZXllZCBjb2xsZWN0aW9ucyBwcm9kdWNlIGFuIGFycmF5IG9mIHR1cGxlcy5cbiAgICAgIGFycmF5W2krK10gPSB1c2VUdXBsZXMgPyBbaywgdl0gOiB2O1xuICAgIH0pO1xuICAgIHJldHVybiBhcnJheTtcbiAgfSxcblxuICB0b0luZGV4ZWRTZXE6IGZ1bmN0aW9uIHRvSW5kZXhlZFNlcSgpIHtcbiAgICByZXR1cm4gbmV3IFRvSW5kZXhlZFNlcXVlbmNlKHRoaXMpO1xuICB9LFxuXG4gIHRvSlM6IGZ1bmN0aW9uIHRvSlMkMSgpIHtcbiAgICByZXR1cm4gdG9KUyh0aGlzKTtcbiAgfSxcblxuICB0b0tleWVkU2VxOiBmdW5jdGlvbiB0b0tleWVkU2VxKCkge1xuICAgIHJldHVybiBuZXcgVG9LZXllZFNlcXVlbmNlKHRoaXMsIHRydWUpO1xuICB9LFxuXG4gIHRvTWFwOiBmdW5jdGlvbiB0b01hcCgpIHtcbiAgICAvLyBVc2UgTGF0ZSBCaW5kaW5nIGhlcmUgdG8gc29sdmUgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gICAgcmV0dXJuIE1hcCh0aGlzLnRvS2V5ZWRTZXEoKSk7XG4gIH0sXG5cbiAgdG9PYmplY3Q6IHRvT2JqZWN0LFxuXG4gIHRvT3JkZXJlZE1hcDogZnVuY3Rpb24gdG9PcmRlcmVkTWFwKCkge1xuICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICByZXR1cm4gT3JkZXJlZE1hcCh0aGlzLnRvS2V5ZWRTZXEoKSk7XG4gIH0sXG5cbiAgdG9PcmRlcmVkU2V0OiBmdW5jdGlvbiB0b09yZGVyZWRTZXQoKSB7XG4gICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgIHJldHVybiBPcmRlcmVkU2V0KGlzS2V5ZWQodGhpcykgPyB0aGlzLnZhbHVlU2VxKCkgOiB0aGlzKTtcbiAgfSxcblxuICB0b1NldDogZnVuY3Rpb24gdG9TZXQoKSB7XG4gICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgIHJldHVybiBTZXQoaXNLZXllZCh0aGlzKSA/IHRoaXMudmFsdWVTZXEoKSA6IHRoaXMpO1xuICB9LFxuXG4gIHRvU2V0U2VxOiBmdW5jdGlvbiB0b1NldFNlcSgpIHtcbiAgICByZXR1cm4gbmV3IFRvU2V0U2VxdWVuY2UodGhpcyk7XG4gIH0sXG5cbiAgdG9TZXE6IGZ1bmN0aW9uIHRvU2VxKCkge1xuICAgIHJldHVybiBpc0luZGV4ZWQodGhpcylcbiAgICAgID8gdGhpcy50b0luZGV4ZWRTZXEoKVxuICAgICAgOiBpc0tleWVkKHRoaXMpXG4gICAgICA/IHRoaXMudG9LZXllZFNlcSgpXG4gICAgICA6IHRoaXMudG9TZXRTZXEoKTtcbiAgfSxcblxuICB0b1N0YWNrOiBmdW5jdGlvbiB0b1N0YWNrKCkge1xuICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICByZXR1cm4gU3RhY2soaXNLZXllZCh0aGlzKSA/IHRoaXMudmFsdWVTZXEoKSA6IHRoaXMpO1xuICB9LFxuXG4gIHRvTGlzdDogZnVuY3Rpb24gdG9MaXN0KCkge1xuICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICByZXR1cm4gTGlzdChpc0tleWVkKHRoaXMpID8gdGhpcy52YWx1ZVNlcSgpIDogdGhpcyk7XG4gIH0sXG5cbiAgLy8gIyMjIENvbW1vbiBKYXZhU2NyaXB0IG1ldGhvZHMgYW5kIHByb3BlcnRpZXNcblxuICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdbQ29sbGVjdGlvbl0nO1xuICB9LFxuXG4gIF9fdG9TdHJpbmc6IGZ1bmN0aW9uIF9fdG9TdHJpbmcoaGVhZCwgdGFpbCkge1xuICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIGhlYWQgK1xuICAgICAgJyAnICtcbiAgICAgIHRoaXMudG9TZXEoKS5tYXAodGhpcy5fX3RvU3RyaW5nTWFwcGVyKS5qb2luKCcsICcpICtcbiAgICAgICcgJyArXG4gICAgICB0YWlsXG4gICAgKTtcbiAgfSxcblxuICAvLyAjIyMgRVM2IENvbGxlY3Rpb24gbWV0aG9kcyAoRVM2IEFycmF5IGFuZCBNYXApXG5cbiAgY29uY2F0OiBmdW5jdGlvbiBjb25jYXQoKSB7XG4gICAgdmFyIHZhbHVlcyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSB2YWx1ZXNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHJldHVybiByZWlmeSh0aGlzLCBjb25jYXRGYWN0b3J5KHRoaXMsIHZhbHVlcykpO1xuICB9LFxuXG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnNvbWUoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBpcyh2YWx1ZSwgc2VhcmNoVmFsdWUpOyB9KTtcbiAgfSxcblxuICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgIHJldHVybiB0aGlzLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTKTtcbiAgfSxcblxuICBldmVyeTogZnVuY3Rpb24gZXZlcnkocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgYXNzZXJ0Tm90SW5maW5pdGUodGhpcy5zaXplKTtcbiAgICB2YXIgcmV0dXJuVmFsdWUgPSB0cnVlO1xuICAgIHRoaXMuX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrLCBjKSB7XG4gICAgICBpZiAoIXByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIGMpKSB7XG4gICAgICAgIHJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH0sXG5cbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGZpbHRlckZhY3RvcnkodGhpcywgcHJlZGljYXRlLCBjb250ZXh0LCB0cnVlKSk7XG4gIH0sXG5cbiAgZmluZDogZnVuY3Rpb24gZmluZChwcmVkaWNhdGUsIGNvbnRleHQsIG5vdFNldFZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5maW5kRW50cnkocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gZW50cnkgPyBlbnRyeVsxXSA6IG5vdFNldFZhbHVlO1xuICB9LFxuXG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goc2lkZUVmZmVjdCwgY29udGV4dCkge1xuICAgIGFzc2VydE5vdEluZmluaXRlKHRoaXMuc2l6ZSk7XG4gICAgcmV0dXJuIHRoaXMuX19pdGVyYXRlKGNvbnRleHQgPyBzaWRlRWZmZWN0LmJpbmQoY29udGV4dCkgOiBzaWRlRWZmZWN0KTtcbiAgfSxcblxuICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcikge1xuICAgIGFzc2VydE5vdEluZmluaXRlKHRoaXMuc2l6ZSk7XG4gICAgc2VwYXJhdG9yID0gc2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyAnJyArIHNlcGFyYXRvciA6ICcsJztcbiAgICB2YXIgam9pbmVkID0gJyc7XG4gICAgdmFyIGlzRmlyc3QgPSB0cnVlO1xuICAgIHRoaXMuX19pdGVyYXRlKGZ1bmN0aW9uICh2KSB7XG4gICAgICBpc0ZpcnN0ID8gKGlzRmlyc3QgPSBmYWxzZSkgOiAoam9pbmVkICs9IHNlcGFyYXRvcik7XG4gICAgICBqb2luZWQgKz0gdiAhPT0gbnVsbCAmJiB2ICE9PSB1bmRlZmluZWQgPyB2LnRvU3RyaW5nKCkgOiAnJztcbiAgICB9KTtcbiAgICByZXR1cm4gam9pbmVkO1xuICB9LFxuXG4gIGtleXM6IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX0tFWVMpO1xuICB9LFxuXG4gIG1hcDogZnVuY3Rpb24gbWFwKG1hcHBlciwgY29udGV4dCkge1xuICAgIHJldHVybiByZWlmeSh0aGlzLCBtYXBGYWN0b3J5KHRoaXMsIG1hcHBlciwgY29udGV4dCkpO1xuICB9LFxuXG4gIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlJDEocmVkdWNlciwgaW5pdGlhbFJlZHVjdGlvbiwgY29udGV4dCkge1xuICAgIHJldHVybiByZWR1Y2UoXG4gICAgICB0aGlzLFxuICAgICAgcmVkdWNlcixcbiAgICAgIGluaXRpYWxSZWR1Y3Rpb24sXG4gICAgICBjb250ZXh0LFxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA8IDIsXG4gICAgICBmYWxzZVxuICAgICk7XG4gIH0sXG5cbiAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KHJlZHVjZXIsIGluaXRpYWxSZWR1Y3Rpb24sIGNvbnRleHQpIHtcbiAgICByZXR1cm4gcmVkdWNlKFxuICAgICAgdGhpcyxcbiAgICAgIHJlZHVjZXIsXG4gICAgICBpbml0aWFsUmVkdWN0aW9uLFxuICAgICAgY29udGV4dCxcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPCAyLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gIH0sXG5cbiAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgcmV2ZXJzZUZhY3RvcnkodGhpcywgdHJ1ZSkpO1xuICB9LFxuXG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShiZWdpbiwgZW5kKSB7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHNsaWNlRmFjdG9yeSh0aGlzLCBiZWdpbiwgZW5kLCB0cnVlKSk7XG4gIH0sXG5cbiAgc29tZTogZnVuY3Rpb24gc29tZShwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gIXRoaXMuZXZlcnkobm90KHByZWRpY2F0ZSksIGNvbnRleHQpO1xuICB9LFxuXG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyYXRvcikge1xuICAgIHJldHVybiByZWlmeSh0aGlzLCBzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yKSk7XG4gIH0sXG5cbiAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUyk7XG4gIH0sXG5cbiAgLy8gIyMjIE1vcmUgc2VxdWVudGlhbCBtZXRob2RzXG5cbiAgYnV0TGFzdDogZnVuY3Rpb24gYnV0TGFzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5zbGljZSgwLCAtMSk7XG4gIH0sXG5cbiAgaXNFbXB0eTogZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplICE9PSB1bmRlZmluZWQgPyB0aGlzLnNpemUgPT09IDAgOiAhdGhpcy5zb21lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0pO1xuICB9LFxuXG4gIGNvdW50OiBmdW5jdGlvbiBjb3VudChwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZW5zdXJlU2l6ZShcbiAgICAgIHByZWRpY2F0ZSA/IHRoaXMudG9TZXEoKS5maWx0ZXIocHJlZGljYXRlLCBjb250ZXh0KSA6IHRoaXNcbiAgICApO1xuICB9LFxuXG4gIGNvdW50Qnk6IGZ1bmN0aW9uIGNvdW50QnkoZ3JvdXBlciwgY29udGV4dCkge1xuICAgIHJldHVybiBjb3VudEJ5RmFjdG9yeSh0aGlzLCBncm91cGVyLCBjb250ZXh0KTtcbiAgfSxcblxuICBlcXVhbHM6IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiBkZWVwRXF1YWwodGhpcywgb3RoZXIpO1xuICB9LFxuXG4gIGVudHJ5U2VxOiBmdW5jdGlvbiBlbnRyeVNlcSgpIHtcbiAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgaWYgKGNvbGxlY3Rpb24uX2NhY2hlKSB7XG4gICAgICAvLyBXZSBjYWNoZSBhcyBhbiBlbnRyaWVzIGFycmF5LCBzbyB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGNhY2hlIVxuICAgICAgcmV0dXJuIG5ldyBBcnJheVNlcShjb2xsZWN0aW9uLl9jYWNoZSk7XG4gICAgfVxuICAgIHZhciBlbnRyaWVzU2VxdWVuY2UgPSBjb2xsZWN0aW9uLnRvU2VxKCkubWFwKGVudHJ5TWFwcGVyKS50b0luZGV4ZWRTZXEoKTtcbiAgICBlbnRyaWVzU2VxdWVuY2UuZnJvbUVudHJ5U2VxID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29sbGVjdGlvbi50b1NlcSgpOyB9O1xuICAgIHJldHVybiBlbnRyaWVzU2VxdWVuY2U7XG4gIH0sXG5cbiAgZmlsdGVyTm90OiBmdW5jdGlvbiBmaWx0ZXJOb3QocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyKG5vdChwcmVkaWNhdGUpLCBjb250ZXh0KTtcbiAgfSxcblxuICBmaW5kRW50cnk6IGZ1bmN0aW9uIGZpbmRFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQsIG5vdFNldFZhbHVlKSB7XG4gICAgdmFyIGZvdW5kID0gbm90U2V0VmFsdWU7XG4gICAgdGhpcy5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGssIGMpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCBjKSkge1xuICAgICAgICBmb3VuZCA9IFtrLCB2XTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmb3VuZDtcbiAgfSxcblxuICBmaW5kS2V5OiBmdW5jdGlvbiBmaW5kS2V5KHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuZmluZEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5WzBdO1xuICB9LFxuXG4gIGZpbmRMYXN0OiBmdW5jdGlvbiBmaW5kTGFzdChwcmVkaWNhdGUsIGNvbnRleHQsIG5vdFNldFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9LZXllZFNlcSgpLnJldmVyc2UoKS5maW5kKHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpO1xuICB9LFxuXG4gIGZpbmRMYXN0RW50cnk6IGZ1bmN0aW9uIGZpbmRMYXN0RW50cnkocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnRvS2V5ZWRTZXEoKVxuICAgICAgLnJldmVyc2UoKVxuICAgICAgLmZpbmRFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQsIG5vdFNldFZhbHVlKTtcbiAgfSxcblxuICBmaW5kTGFzdEtleTogZnVuY3Rpb24gZmluZExhc3RLZXkocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMudG9LZXllZFNlcSgpLnJldmVyc2UoKS5maW5kS2V5KHByZWRpY2F0ZSwgY29udGV4dCk7XG4gIH0sXG5cbiAgZmlyc3Q6IGZ1bmN0aW9uIGZpcnN0KG5vdFNldFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluZChyZXR1cm5UcnVlLCBudWxsLCBub3RTZXRWYWx1ZSk7XG4gIH0sXG5cbiAgZmxhdE1hcDogZnVuY3Rpb24gZmxhdE1hcChtYXBwZXIsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgZmxhdE1hcEZhY3RvcnkodGhpcywgbWFwcGVyLCBjb250ZXh0KSk7XG4gIH0sXG5cbiAgZmxhdHRlbjogZnVuY3Rpb24gZmxhdHRlbihkZXB0aCkge1xuICAgIHJldHVybiByZWlmeSh0aGlzLCBmbGF0dGVuRmFjdG9yeSh0aGlzLCBkZXB0aCwgdHJ1ZSkpO1xuICB9LFxuXG4gIGZyb21FbnRyeVNlcTogZnVuY3Rpb24gZnJvbUVudHJ5U2VxKCkge1xuICAgIHJldHVybiBuZXcgRnJvbUVudHJpZXNTZXF1ZW5jZSh0aGlzKTtcbiAgfSxcblxuICBnZXQ6IGZ1bmN0aW9uIGdldChzZWFyY2hLZXksIG5vdFNldFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluZChmdW5jdGlvbiAoXywga2V5KSB7IHJldHVybiBpcyhrZXksIHNlYXJjaEtleSk7IH0sIHVuZGVmaW5lZCwgbm90U2V0VmFsdWUpO1xuICB9LFxuXG4gIGdldEluOiBnZXRJbixcblxuICBncm91cEJ5OiBmdW5jdGlvbiBncm91cEJ5KGdyb3VwZXIsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZ3JvdXBCeUZhY3RvcnkodGhpcywgZ3JvdXBlciwgY29udGV4dCk7XG4gIH0sXG5cbiAgaGFzOiBmdW5jdGlvbiBoYXMoc2VhcmNoS2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHNlYXJjaEtleSwgTk9UX1NFVCkgIT09IE5PVF9TRVQ7XG4gIH0sXG5cbiAgaGFzSW46IGhhc0luLFxuXG4gIGlzU3Vic2V0OiBmdW5jdGlvbiBpc1N1YnNldChpdGVyKSB7XG4gICAgaXRlciA9IHR5cGVvZiBpdGVyLmluY2x1ZGVzID09PSAnZnVuY3Rpb24nID8gaXRlciA6IENvbGxlY3Rpb24oaXRlcik7XG4gICAgcmV0dXJuIHRoaXMuZXZlcnkoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBpdGVyLmluY2x1ZGVzKHZhbHVlKTsgfSk7XG4gIH0sXG5cbiAgaXNTdXBlcnNldDogZnVuY3Rpb24gaXNTdXBlcnNldChpdGVyKSB7XG4gICAgaXRlciA9IHR5cGVvZiBpdGVyLmlzU3Vic2V0ID09PSAnZnVuY3Rpb24nID8gaXRlciA6IENvbGxlY3Rpb24oaXRlcik7XG4gICAgcmV0dXJuIGl0ZXIuaXNTdWJzZXQodGhpcyk7XG4gIH0sXG5cbiAga2V5T2Y6IGZ1bmN0aW9uIGtleU9mKHNlYXJjaFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluZEtleShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGlzKHZhbHVlLCBzZWFyY2hWYWx1ZSk7IH0pO1xuICB9LFxuXG4gIGtleVNlcTogZnVuY3Rpb24ga2V5U2VxKCkge1xuICAgIHJldHVybiB0aGlzLnRvU2VxKCkubWFwKGtleU1hcHBlcikudG9JbmRleGVkU2VxKCk7XG4gIH0sXG5cbiAgbGFzdDogZnVuY3Rpb24gbGFzdChub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnRvU2VxKCkucmV2ZXJzZSgpLmZpcnN0KG5vdFNldFZhbHVlKTtcbiAgfSxcblxuICBsYXN0S2V5T2Y6IGZ1bmN0aW9uIGxhc3RLZXlPZihzZWFyY2hWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnRvS2V5ZWRTZXEoKS5yZXZlcnNlKCkua2V5T2Yoc2VhcmNoVmFsdWUpO1xuICB9LFxuXG4gIG1heDogZnVuY3Rpb24gbWF4KGNvbXBhcmF0b3IpIHtcbiAgICByZXR1cm4gbWF4RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yKTtcbiAgfSxcblxuICBtYXhCeTogZnVuY3Rpb24gbWF4QnkobWFwcGVyLCBjb21wYXJhdG9yKSB7XG4gICAgcmV0dXJuIG1heEZhY3RvcnkodGhpcywgY29tcGFyYXRvciwgbWFwcGVyKTtcbiAgfSxcblxuICBtaW46IGZ1bmN0aW9uIG1pbihjb21wYXJhdG9yKSB7XG4gICAgcmV0dXJuIG1heEZhY3RvcnkoXG4gICAgICB0aGlzLFxuICAgICAgY29tcGFyYXRvciA/IG5lZyhjb21wYXJhdG9yKSA6IGRlZmF1bHROZWdDb21wYXJhdG9yXG4gICAgKTtcbiAgfSxcblxuICBtaW5CeTogZnVuY3Rpb24gbWluQnkobWFwcGVyLCBjb21wYXJhdG9yKSB7XG4gICAgcmV0dXJuIG1heEZhY3RvcnkoXG4gICAgICB0aGlzLFxuICAgICAgY29tcGFyYXRvciA/IG5lZyhjb21wYXJhdG9yKSA6IGRlZmF1bHROZWdDb21wYXJhdG9yLFxuICAgICAgbWFwcGVyXG4gICAgKTtcbiAgfSxcblxuICByZXN0OiBmdW5jdGlvbiByZXN0KCkge1xuICAgIHJldHVybiB0aGlzLnNsaWNlKDEpO1xuICB9LFxuXG4gIHNraXA6IGZ1bmN0aW9uIHNraXAoYW1vdW50KSB7XG4gICAgcmV0dXJuIGFtb3VudCA9PT0gMCA/IHRoaXMgOiB0aGlzLnNsaWNlKE1hdGgubWF4KDAsIGFtb3VudCkpO1xuICB9LFxuXG4gIHNraXBMYXN0OiBmdW5jdGlvbiBza2lwTGFzdChhbW91bnQpIHtcbiAgICByZXR1cm4gYW1vdW50ID09PSAwID8gdGhpcyA6IHRoaXMuc2xpY2UoMCwgLU1hdGgubWF4KDAsIGFtb3VudCkpO1xuICB9LFxuXG4gIHNraXBXaGlsZTogZnVuY3Rpb24gc2tpcFdoaWxlKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiByZWlmeSh0aGlzLCBza2lwV2hpbGVGYWN0b3J5KHRoaXMsIHByZWRpY2F0ZSwgY29udGV4dCwgdHJ1ZSkpO1xuICB9LFxuXG4gIHNraXBVbnRpbDogZnVuY3Rpb24gc2tpcFVudGlsKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLnNraXBXaGlsZShub3QocHJlZGljYXRlKSwgY29udGV4dCk7XG4gIH0sXG5cbiAgc29ydEJ5OiBmdW5jdGlvbiBzb3J0QnkobWFwcGVyLCBjb21wYXJhdG9yKSB7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHNvcnRGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IsIG1hcHBlcikpO1xuICB9LFxuXG4gIHRha2U6IGZ1bmN0aW9uIHRha2UoYW1vdW50KSB7XG4gICAgcmV0dXJuIHRoaXMuc2xpY2UoMCwgTWF0aC5tYXgoMCwgYW1vdW50KSk7XG4gIH0sXG5cbiAgdGFrZUxhc3Q6IGZ1bmN0aW9uIHRha2VMYXN0KGFtb3VudCkge1xuICAgIHJldHVybiB0aGlzLnNsaWNlKC1NYXRoLm1heCgwLCBhbW91bnQpKTtcbiAgfSxcblxuICB0YWtlV2hpbGU6IGZ1bmN0aW9uIHRha2VXaGlsZShwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgdGFrZVdoaWxlRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQpKTtcbiAgfSxcblxuICB0YWtlVW50aWw6IGZ1bmN0aW9uIHRha2VVbnRpbChwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gdGhpcy50YWtlV2hpbGUobm90KHByZWRpY2F0ZSksIGNvbnRleHQpO1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGZuKSB7XG4gICAgcmV0dXJuIGZuKHRoaXMpO1xuICB9LFxuXG4gIHZhbHVlU2VxOiBmdW5jdGlvbiB2YWx1ZVNlcSgpIHtcbiAgICByZXR1cm4gdGhpcy50b0luZGV4ZWRTZXEoKTtcbiAgfSxcblxuICAvLyAjIyMgSGFzaGFibGUgT2JqZWN0XG5cbiAgaGFzaENvZGU6IGZ1bmN0aW9uIGhhc2hDb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9faGFzaCB8fCAodGhpcy5fX2hhc2ggPSBoYXNoQ29sbGVjdGlvbih0aGlzKSk7XG4gIH0sXG5cbiAgLy8gIyMjIEludGVybmFsXG5cbiAgLy8gYWJzdHJhY3QgX19pdGVyYXRlKGZuLCByZXZlcnNlKVxuXG4gIC8vIGFic3RyYWN0IF9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSlcbn0pO1xuXG52YXIgQ29sbGVjdGlvblByb3RvdHlwZSA9IENvbGxlY3Rpb24ucHJvdG90eXBlO1xuQ29sbGVjdGlvblByb3RvdHlwZVtJU19DT0xMRUNUSU9OX1NZTUJPTF0gPSB0cnVlO1xuQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUl9TWU1CT0xdID0gQ29sbGVjdGlvblByb3RvdHlwZS52YWx1ZXM7XG5Db2xsZWN0aW9uUHJvdG90eXBlLnRvSlNPTiA9IENvbGxlY3Rpb25Qcm90b3R5cGUudG9BcnJheTtcbkNvbGxlY3Rpb25Qcm90b3R5cGUuX190b1N0cmluZ01hcHBlciA9IHF1b3RlU3RyaW5nO1xuQ29sbGVjdGlvblByb3RvdHlwZS5pbnNwZWN0ID0gQ29sbGVjdGlvblByb3RvdHlwZS50b1NvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbn07XG5Db2xsZWN0aW9uUHJvdG90eXBlLmNoYWluID0gQ29sbGVjdGlvblByb3RvdHlwZS5mbGF0TWFwO1xuQ29sbGVjdGlvblByb3RvdHlwZS5jb250YWlucyA9IENvbGxlY3Rpb25Qcm90b3R5cGUuaW5jbHVkZXM7XG5cbm1peGluKEtleWVkQ29sbGVjdGlvbiwge1xuICAvLyAjIyMgTW9yZSBzZXF1ZW50aWFsIG1ldGhvZHNcblxuICBmbGlwOiBmdW5jdGlvbiBmbGlwKCkge1xuICAgIHJldHVybiByZWlmeSh0aGlzLCBmbGlwRmFjdG9yeSh0aGlzKSk7XG4gIH0sXG5cbiAgbWFwRW50cmllczogZnVuY3Rpb24gbWFwRW50cmllcyhtYXBwZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgdGhpcyQxJDEgPSB0aGlzO1xuXG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIHJldHVybiByZWlmeShcbiAgICAgIHRoaXMsXG4gICAgICB0aGlzLnRvU2VxKClcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gbWFwcGVyLmNhbGwoY29udGV4dCwgW2ssIHZdLCBpdGVyYXRpb25zKyssIHRoaXMkMSQxKTsgfSlcbiAgICAgICAgLmZyb21FbnRyeVNlcSgpXG4gICAgKTtcbiAgfSxcblxuICBtYXBLZXlzOiBmdW5jdGlvbiBtYXBLZXlzKG1hcHBlciwgY29udGV4dCkge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICByZXR1cm4gcmVpZnkoXG4gICAgICB0aGlzLFxuICAgICAgdGhpcy50b1NlcSgpXG4gICAgICAgIC5mbGlwKClcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoaywgdikgeyByZXR1cm4gbWFwcGVyLmNhbGwoY29udGV4dCwgaywgdiwgdGhpcyQxJDEpOyB9KVxuICAgICAgICAuZmxpcCgpXG4gICAgKTtcbiAgfSxcbn0pO1xuXG52YXIgS2V5ZWRDb2xsZWN0aW9uUHJvdG90eXBlID0gS2V5ZWRDb2xsZWN0aW9uLnByb3RvdHlwZTtcbktleWVkQ29sbGVjdGlvblByb3RvdHlwZVtJU19LRVlFRF9TWU1CT0xdID0gdHJ1ZTtcbktleWVkQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUl9TWU1CT0xdID0gQ29sbGVjdGlvblByb3RvdHlwZS5lbnRyaWVzO1xuS2V5ZWRDb2xsZWN0aW9uUHJvdG90eXBlLnRvSlNPTiA9IHRvT2JqZWN0O1xuS2V5ZWRDb2xsZWN0aW9uUHJvdG90eXBlLl9fdG9TdHJpbmdNYXBwZXIgPSBmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gcXVvdGVTdHJpbmcoaykgKyAnOiAnICsgcXVvdGVTdHJpbmcodik7IH07XG5cbm1peGluKEluZGV4ZWRDb2xsZWN0aW9uLCB7XG4gIC8vICMjIyBDb252ZXJzaW9uIHRvIG90aGVyIHR5cGVzXG5cbiAgdG9LZXllZFNlcTogZnVuY3Rpb24gdG9LZXllZFNlcSgpIHtcbiAgICByZXR1cm4gbmV3IFRvS2V5ZWRTZXF1ZW5jZSh0aGlzLCBmYWxzZSk7XG4gIH0sXG5cbiAgLy8gIyMjIEVTNiBDb2xsZWN0aW9uIG1ldGhvZHMgKEVTNiBBcnJheSBhbmQgTWFwKVxuXG4gIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiByZWlmeSh0aGlzLCBmaWx0ZXJGYWN0b3J5KHRoaXMsIHByZWRpY2F0ZSwgY29udGV4dCwgZmFsc2UpKTtcbiAgfSxcblxuICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLmZpbmRFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHJldHVybiBlbnRyeSA/IGVudHJ5WzBdIDogLTE7XG4gIH0sXG5cbiAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hWYWx1ZSkge1xuICAgIHZhciBrZXkgPSB0aGlzLmtleU9mKHNlYXJjaFZhbHVlKTtcbiAgICByZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgPyAtMSA6IGtleTtcbiAgfSxcblxuICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoVmFsdWUpIHtcbiAgICB2YXIga2V5ID0gdGhpcy5sYXN0S2V5T2Yoc2VhcmNoVmFsdWUpO1xuICAgIHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/IC0xIDoga2V5O1xuICB9LFxuXG4gIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHJldmVyc2VGYWN0b3J5KHRoaXMsIGZhbHNlKSk7XG4gIH0sXG5cbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKGJlZ2luLCBlbmQpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgc2xpY2VGYWN0b3J5KHRoaXMsIGJlZ2luLCBlbmQsIGZhbHNlKSk7XG4gIH0sXG5cbiAgc3BsaWNlOiBmdW5jdGlvbiBzcGxpY2UoaW5kZXgsIHJlbW92ZU51bSAvKiwgLi4udmFsdWVzKi8pIHtcbiAgICB2YXIgbnVtQXJncyA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmVtb3ZlTnVtID0gTWF0aC5tYXgocmVtb3ZlTnVtIHx8IDAsIDApO1xuICAgIGlmIChudW1BcmdzID09PSAwIHx8IChudW1BcmdzID09PSAyICYmICFyZW1vdmVOdW0pKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gSWYgaW5kZXggaXMgbmVnYXRpdmUsIGl0IHNob3VsZCByZXNvbHZlIHJlbGF0aXZlIHRvIHRoZSBzaXplIG9mIHRoZVxuICAgIC8vIGNvbGxlY3Rpb24uIEhvd2V2ZXIgc2l6ZSBtYXkgYmUgZXhwZW5zaXZlIHRvIGNvbXB1dGUgaWYgbm90IGNhY2hlZCwgc29cbiAgICAvLyBvbmx5IGNhbGwgY291bnQoKSBpZiB0aGUgbnVtYmVyIGlzIGluIGZhY3QgbmVnYXRpdmUuXG4gICAgaW5kZXggPSByZXNvbHZlQmVnaW4oaW5kZXgsIGluZGV4IDwgMCA/IHRoaXMuY291bnQoKSA6IHRoaXMuc2l6ZSk7XG4gICAgdmFyIHNwbGljZWQgPSB0aGlzLnNsaWNlKDAsIGluZGV4KTtcbiAgICByZXR1cm4gcmVpZnkoXG4gICAgICB0aGlzLFxuICAgICAgbnVtQXJncyA9PT0gMVxuICAgICAgICA/IHNwbGljZWRcbiAgICAgICAgOiBzcGxpY2VkLmNvbmNhdChhcnJDb3B5KGFyZ3VtZW50cywgMiksIHRoaXMuc2xpY2UoaW5kZXggKyByZW1vdmVOdW0pKVxuICAgICk7XG4gIH0sXG5cbiAgLy8gIyMjIE1vcmUgY29sbGVjdGlvbiBtZXRob2RzXG5cbiAgZmluZExhc3RJbmRleDogZnVuY3Rpb24gZmluZExhc3RJbmRleChwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLmZpbmRMYXN0RW50cnkocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gZW50cnkgPyBlbnRyeVswXSA6IC0xO1xuICB9LFxuXG4gIGZpcnN0OiBmdW5jdGlvbiBmaXJzdChub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmdldCgwLCBub3RTZXRWYWx1ZSk7XG4gIH0sXG5cbiAgZmxhdHRlbjogZnVuY3Rpb24gZmxhdHRlbihkZXB0aCkge1xuICAgIHJldHVybiByZWlmeSh0aGlzLCBmbGF0dGVuRmFjdG9yeSh0aGlzLCBkZXB0aCwgZmFsc2UpKTtcbiAgfSxcblxuICBnZXQ6IGZ1bmN0aW9uIGdldChpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICBpbmRleCA9IHdyYXBJbmRleCh0aGlzLCBpbmRleCk7XG4gICAgcmV0dXJuIGluZGV4IDwgMCB8fFxuICAgICAgdGhpcy5zaXplID09PSBJbmZpbml0eSB8fFxuICAgICAgKHRoaXMuc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGluZGV4ID4gdGhpcy5zaXplKVxuICAgICAgPyBub3RTZXRWYWx1ZVxuICAgICAgOiB0aGlzLmZpbmQoZnVuY3Rpb24gKF8sIGtleSkgeyByZXR1cm4ga2V5ID09PSBpbmRleDsgfSwgdW5kZWZpbmVkLCBub3RTZXRWYWx1ZSk7XG4gIH0sXG5cbiAgaGFzOiBmdW5jdGlvbiBoYXMoaW5kZXgpIHtcbiAgICBpbmRleCA9IHdyYXBJbmRleCh0aGlzLCBpbmRleCk7XG4gICAgcmV0dXJuIChcbiAgICAgIGluZGV4ID49IDAgJiZcbiAgICAgICh0aGlzLnNpemUgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IHRoaXMuc2l6ZSA9PT0gSW5maW5pdHkgfHwgaW5kZXggPCB0aGlzLnNpemVcbiAgICAgICAgOiB0aGlzLmluZGV4T2YoaW5kZXgpICE9PSAtMSlcbiAgICApO1xuICB9LFxuXG4gIGludGVycG9zZTogZnVuY3Rpb24gaW50ZXJwb3NlKHNlcGFyYXRvcikge1xuICAgIHJldHVybiByZWlmeSh0aGlzLCBpbnRlcnBvc2VGYWN0b3J5KHRoaXMsIHNlcGFyYXRvcikpO1xuICB9LFxuXG4gIGludGVybGVhdmU6IGZ1bmN0aW9uIGludGVybGVhdmUoLyouLi5jb2xsZWN0aW9ucyovKSB7XG4gICAgdmFyIGNvbGxlY3Rpb25zID0gW3RoaXNdLmNvbmNhdChhcnJDb3B5KGFyZ3VtZW50cykpO1xuICAgIHZhciB6aXBwZWQgPSB6aXBXaXRoRmFjdG9yeSh0aGlzLnRvU2VxKCksIEluZGV4ZWRTZXEub2YsIGNvbGxlY3Rpb25zKTtcbiAgICB2YXIgaW50ZXJsZWF2ZWQgPSB6aXBwZWQuZmxhdHRlbih0cnVlKTtcbiAgICBpZiAoemlwcGVkLnNpemUpIHtcbiAgICAgIGludGVybGVhdmVkLnNpemUgPSB6aXBwZWQuc2l6ZSAqIGNvbGxlY3Rpb25zLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGludGVybGVhdmVkKTtcbiAgfSxcblxuICBrZXlTZXE6IGZ1bmN0aW9uIGtleVNlcSgpIHtcbiAgICByZXR1cm4gUmFuZ2UoMCwgdGhpcy5zaXplKTtcbiAgfSxcblxuICBsYXN0OiBmdW5jdGlvbiBsYXN0KG5vdFNldFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KC0xLCBub3RTZXRWYWx1ZSk7XG4gIH0sXG5cbiAgc2tpcFdoaWxlOiBmdW5jdGlvbiBza2lwV2hpbGUocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHNraXBXaGlsZUZhY3RvcnkodGhpcywgcHJlZGljYXRlLCBjb250ZXh0LCBmYWxzZSkpO1xuICB9LFxuXG4gIHppcDogZnVuY3Rpb24gemlwKC8qLCAuLi5jb2xsZWN0aW9ucyAqLykge1xuICAgIHZhciBjb2xsZWN0aW9ucyA9IFt0aGlzXS5jb25jYXQoYXJyQ29weShhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgemlwV2l0aEZhY3RvcnkodGhpcywgZGVmYXVsdFppcHBlciwgY29sbGVjdGlvbnMpKTtcbiAgfSxcblxuICB6aXBBbGw6IGZ1bmN0aW9uIHppcEFsbCgvKiwgLi4uY29sbGVjdGlvbnMgKi8pIHtcbiAgICB2YXIgY29sbGVjdGlvbnMgPSBbdGhpc10uY29uY2F0KGFyckNvcHkoYXJndW1lbnRzKSk7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHppcFdpdGhGYWN0b3J5KHRoaXMsIGRlZmF1bHRaaXBwZXIsIGNvbGxlY3Rpb25zLCB0cnVlKSk7XG4gIH0sXG5cbiAgemlwV2l0aDogZnVuY3Rpb24gemlwV2l0aCh6aXBwZXIgLyosIC4uLmNvbGxlY3Rpb25zICovKSB7XG4gICAgdmFyIGNvbGxlY3Rpb25zID0gYXJyQ29weShhcmd1bWVudHMpO1xuICAgIGNvbGxlY3Rpb25zWzBdID0gdGhpcztcbiAgICByZXR1cm4gcmVpZnkodGhpcywgemlwV2l0aEZhY3RvcnkodGhpcywgemlwcGVyLCBjb2xsZWN0aW9ucykpO1xuICB9LFxufSk7XG5cbnZhciBJbmRleGVkQ29sbGVjdGlvblByb3RvdHlwZSA9IEluZGV4ZWRDb2xsZWN0aW9uLnByb3RvdHlwZTtcbkluZGV4ZWRDb2xsZWN0aW9uUHJvdG90eXBlW0lTX0lOREVYRURfU1lNQk9MXSA9IHRydWU7XG5JbmRleGVkQ29sbGVjdGlvblByb3RvdHlwZVtJU19PUkRFUkVEX1NZTUJPTF0gPSB0cnVlO1xuXG5taXhpbihTZXRDb2xsZWN0aW9uLCB7XG4gIC8vICMjIyBFUzYgQ29sbGVjdGlvbiBtZXRob2RzIChFUzYgQXJyYXkgYW5kIE1hcClcblxuICBnZXQ6IGZ1bmN0aW9uIGdldCh2YWx1ZSwgbm90U2V0VmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5oYXModmFsdWUpID8gdmFsdWUgOiBub3RTZXRWYWx1ZTtcbiAgfSxcblxuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXModmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5oYXModmFsdWUpO1xuICB9LFxuXG4gIC8vICMjIyBNb3JlIHNlcXVlbnRpYWwgbWV0aG9kc1xuXG4gIGtleVNlcTogZnVuY3Rpb24ga2V5U2VxKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlU2VxKCk7XG4gIH0sXG59KTtcblxudmFyIFNldENvbGxlY3Rpb25Qcm90b3R5cGUgPSBTZXRDb2xsZWN0aW9uLnByb3RvdHlwZTtcblNldENvbGxlY3Rpb25Qcm90b3R5cGUuaGFzID0gQ29sbGVjdGlvblByb3RvdHlwZS5pbmNsdWRlcztcblNldENvbGxlY3Rpb25Qcm90b3R5cGUuY29udGFpbnMgPSBTZXRDb2xsZWN0aW9uUHJvdG90eXBlLmluY2x1ZGVzO1xuU2V0Q29sbGVjdGlvblByb3RvdHlwZS5rZXlzID0gU2V0Q29sbGVjdGlvblByb3RvdHlwZS52YWx1ZXM7XG5cbi8vIE1peGluIHN1YmNsYXNzZXNcblxubWl4aW4oS2V5ZWRTZXEsIEtleWVkQ29sbGVjdGlvblByb3RvdHlwZSk7XG5taXhpbihJbmRleGVkU2VxLCBJbmRleGVkQ29sbGVjdGlvblByb3RvdHlwZSk7XG5taXhpbihTZXRTZXEsIFNldENvbGxlY3Rpb25Qcm90b3R5cGUpO1xuXG4vLyAjcHJhZ21hIEhlbHBlciBmdW5jdGlvbnNcblxuZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIHJlZHVjZXIsIHJlZHVjdGlvbiwgY29udGV4dCwgdXNlRmlyc3QsIHJldmVyc2UpIHtcbiAgYXNzZXJ0Tm90SW5maW5pdGUoY29sbGVjdGlvbi5zaXplKTtcbiAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGssIGMpIHtcbiAgICBpZiAodXNlRmlyc3QpIHtcbiAgICAgIHVzZUZpcnN0ID0gZmFsc2U7XG4gICAgICByZWR1Y3Rpb24gPSB2O1xuICAgIH0gZWxzZSB7XG4gICAgICByZWR1Y3Rpb24gPSByZWR1Y2VyLmNhbGwoY29udGV4dCwgcmVkdWN0aW9uLCB2LCBrLCBjKTtcbiAgICB9XG4gIH0sIHJldmVyc2UpO1xuICByZXR1cm4gcmVkdWN0aW9uO1xufVxuXG5mdW5jdGlvbiBrZXlNYXBwZXIodiwgaykge1xuICByZXR1cm4gaztcbn1cblxuZnVuY3Rpb24gZW50cnlNYXBwZXIodiwgaykge1xuICByZXR1cm4gW2ssIHZdO1xufVxuXG5mdW5jdGlvbiBub3QocHJlZGljYXRlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbmVnKHByZWRpY2F0ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAtcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRaaXBwZXIoKSB7XG4gIHJldHVybiBhcnJDb3B5KGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHROZWdDb21wYXJhdG9yKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gMSA6IGEgPiBiID8gLTEgOiAwO1xufVxuXG5mdW5jdGlvbiBoYXNoQ29sbGVjdGlvbihjb2xsZWN0aW9uKSB7XG4gIGlmIChjb2xsZWN0aW9uLnNpemUgPT09IEluZmluaXR5KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIG9yZGVyZWQgPSBpc09yZGVyZWQoY29sbGVjdGlvbik7XG4gIHZhciBrZXllZCA9IGlzS2V5ZWQoY29sbGVjdGlvbik7XG4gIHZhciBoID0gb3JkZXJlZCA/IDEgOiAwO1xuICB2YXIgc2l6ZSA9IGNvbGxlY3Rpb24uX19pdGVyYXRlKFxuICAgIGtleWVkXG4gICAgICA/IG9yZGVyZWRcbiAgICAgICAgPyBmdW5jdGlvbiAodiwgaykge1xuICAgICAgICAgICAgaCA9ICgzMSAqIGggKyBoYXNoTWVyZ2UoaGFzaCh2KSwgaGFzaChrKSkpIHwgMDtcbiAgICAgICAgICB9XG4gICAgICAgIDogZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgICAgIGggPSAoaCArIGhhc2hNZXJnZShoYXNoKHYpLCBoYXNoKGspKSkgfCAwO1xuICAgICAgICAgIH1cbiAgICAgIDogb3JkZXJlZFxuICAgICAgPyBmdW5jdGlvbiAodikge1xuICAgICAgICAgIGggPSAoMzEgKiBoICsgaGFzaCh2KSkgfCAwO1xuICAgICAgICB9XG4gICAgICA6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgaCA9IChoICsgaGFzaCh2KSkgfCAwO1xuICAgICAgICB9XG4gICk7XG4gIHJldHVybiBtdXJtdXJIYXNoT2ZTaXplKHNpemUsIGgpO1xufVxuXG5mdW5jdGlvbiBtdXJtdXJIYXNoT2ZTaXplKHNpemUsIGgpIHtcbiAgaCA9IGltdWwoaCwgMHhjYzllMmQ1MSk7XG4gIGggPSBpbXVsKChoIDw8IDE1KSB8IChoID4+PiAtMTUpLCAweDFiODczNTkzKTtcbiAgaCA9IGltdWwoKGggPDwgMTMpIHwgKGggPj4+IC0xMyksIDUpO1xuICBoID0gKChoICsgMHhlNjU0NmI2NCkgfCAwKSBeIHNpemU7XG4gIGggPSBpbXVsKGggXiAoaCA+Pj4gMTYpLCAweDg1ZWJjYTZiKTtcbiAgaCA9IGltdWwoaCBeIChoID4+PiAxMyksIDB4YzJiMmFlMzUpO1xuICBoID0gc21pKGggXiAoaCA+Pj4gMTYpKTtcbiAgcmV0dXJuIGg7XG59XG5cbmZ1bmN0aW9uIGhhc2hNZXJnZShhLCBiKSB7XG4gIHJldHVybiAoYSBeIChiICsgMHg5ZTM3NzliOSArIChhIDw8IDYpICsgKGEgPj4gMikpKSB8IDA7IC8vIGludFxufVxuXG52YXIgT3JkZXJlZFNldCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNldCkge1xuICBmdW5jdGlvbiBPcmRlcmVkU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGxcbiAgICAgID8gZW1wdHlPcmRlcmVkU2V0KClcbiAgICAgIDogaXNPcmRlcmVkU2V0KHZhbHVlKVxuICAgICAgPyB2YWx1ZVxuICAgICAgOiBlbXB0eU9yZGVyZWRTZXQoKS53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgICAgICB2YXIgaXRlciA9IFNldENvbGxlY3Rpb24odmFsdWUpO1xuICAgICAgICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG4gICAgICAgICAgaXRlci5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHJldHVybiBzZXQuYWRkKHYpOyB9KTtcbiAgICAgICAgfSk7XG4gIH1cblxuICBpZiAoIFNldCApIE9yZGVyZWRTZXQuX19wcm90b19fID0gU2V0O1xuICBPcmRlcmVkU2V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNldCAmJiBTZXQucHJvdG90eXBlICk7XG4gIE9yZGVyZWRTZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT3JkZXJlZFNldDtcblxuICBPcmRlcmVkU2V0Lm9mID0gZnVuY3Rpb24gb2YgKC8qLi4udmFsdWVzKi8pIHtcbiAgICByZXR1cm4gdGhpcyhhcmd1bWVudHMpO1xuICB9O1xuXG4gIE9yZGVyZWRTZXQuZnJvbUtleXMgPSBmdW5jdGlvbiBmcm9tS2V5cyAodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcyhLZXllZENvbGxlY3Rpb24odmFsdWUpLmtleVNlcSgpKTtcbiAgfTtcblxuICBPcmRlcmVkU2V0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdPcmRlcmVkU2V0IHsnLCAnfScpO1xuICB9O1xuXG4gIHJldHVybiBPcmRlcmVkU2V0O1xufShTZXQpKTtcblxuT3JkZXJlZFNldC5pc09yZGVyZWRTZXQgPSBpc09yZGVyZWRTZXQ7XG5cbnZhciBPcmRlcmVkU2V0UHJvdG90eXBlID0gT3JkZXJlZFNldC5wcm90b3R5cGU7XG5PcmRlcmVkU2V0UHJvdG90eXBlW0lTX09SREVSRURfU1lNQk9MXSA9IHRydWU7XG5PcmRlcmVkU2V0UHJvdG90eXBlLnppcCA9IEluZGV4ZWRDb2xsZWN0aW9uUHJvdG90eXBlLnppcDtcbk9yZGVyZWRTZXRQcm90b3R5cGUuemlwV2l0aCA9IEluZGV4ZWRDb2xsZWN0aW9uUHJvdG90eXBlLnppcFdpdGg7XG5PcmRlcmVkU2V0UHJvdG90eXBlLnppcEFsbCA9IEluZGV4ZWRDb2xsZWN0aW9uUHJvdG90eXBlLnppcEFsbDtcblxuT3JkZXJlZFNldFByb3RvdHlwZS5fX2VtcHR5ID0gZW1wdHlPcmRlcmVkU2V0O1xuT3JkZXJlZFNldFByb3RvdHlwZS5fX21ha2UgPSBtYWtlT3JkZXJlZFNldDtcblxuZnVuY3Rpb24gbWFrZU9yZGVyZWRTZXQobWFwLCBvd25lcklEKSB7XG4gIHZhciBzZXQgPSBPYmplY3QuY3JlYXRlKE9yZGVyZWRTZXRQcm90b3R5cGUpO1xuICBzZXQuc2l6ZSA9IG1hcCA/IG1hcC5zaXplIDogMDtcbiAgc2V0Ll9tYXAgPSBtYXA7XG4gIHNldC5fX293bmVySUQgPSBvd25lcklEO1xuICByZXR1cm4gc2V0O1xufVxuXG52YXIgRU1QVFlfT1JERVJFRF9TRVQ7XG5mdW5jdGlvbiBlbXB0eU9yZGVyZWRTZXQoKSB7XG4gIHJldHVybiAoXG4gICAgRU1QVFlfT1JERVJFRF9TRVQgfHwgKEVNUFRZX09SREVSRURfU0VUID0gbWFrZU9yZGVyZWRTZXQoZW1wdHlPcmRlcmVkTWFwKCkpKVxuICApO1xufVxuXG5mdW5jdGlvbiB0aHJvd09uSW52YWxpZERlZmF1bHRWYWx1ZXMoZGVmYXVsdFZhbHVlcykge1xuICBpZiAoaXNSZWNvcmQoZGVmYXVsdFZhbHVlcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQ2FuIG5vdCBjYWxsIGBSZWNvcmRgIHdpdGggYW4gaW1tdXRhYmxlIFJlY29yZCBhcyBkZWZhdWx0IHZhbHVlcy4gVXNlIGEgcGxhaW4gamF2YXNjcmlwdCBvYmplY3QgaW5zdGVhZC4nXG4gICAgKTtcbiAgfVxuXG4gIGlmIChpc0ltbXV0YWJsZShkZWZhdWx0VmFsdWVzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdDYW4gbm90IGNhbGwgYFJlY29yZGAgd2l0aCBhbiBpbW11dGFibGUgQ29sbGVjdGlvbiBhcyBkZWZhdWx0IHZhbHVlcy4gVXNlIGEgcGxhaW4gamF2YXNjcmlwdCBvYmplY3QgaW5zdGVhZC4nXG4gICAgKTtcbiAgfVxuXG4gIGlmIChkZWZhdWx0VmFsdWVzID09PSBudWxsIHx8IHR5cGVvZiBkZWZhdWx0VmFsdWVzICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdDYW4gbm90IGNhbGwgYFJlY29yZGAgd2l0aCBhIG5vbi1vYmplY3QgYXMgZGVmYXVsdCB2YWx1ZXMuIFVzZSBhIHBsYWluIGphdmFzY3JpcHQgb2JqZWN0IGluc3RlYWQuJ1xuICAgICk7XG4gIH1cbn1cblxudmFyIFJlY29yZCA9IGZ1bmN0aW9uIFJlY29yZChkZWZhdWx0VmFsdWVzLCBuYW1lKSB7XG4gIHZhciBoYXNJbml0aWFsaXplZDtcblxuICB0aHJvd09uSW52YWxpZERlZmF1bHRWYWx1ZXMoZGVmYXVsdFZhbHVlcyk7XG5cbiAgdmFyIFJlY29yZFR5cGUgPSBmdW5jdGlvbiBSZWNvcmQodmFsdWVzKSB7XG4gICAgdmFyIHRoaXMkMSQxID0gdGhpcztcblxuICAgIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBSZWNvcmRUeXBlKSB7XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVjb3JkVHlwZSkpIHtcbiAgICAgIHJldHVybiBuZXcgUmVjb3JkVHlwZSh2YWx1ZXMpO1xuICAgIH1cbiAgICBpZiAoIWhhc0luaXRpYWxpemVkKSB7XG4gICAgICBoYXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRlZmF1bHRWYWx1ZXMpO1xuICAgICAgdmFyIGluZGljZXMgPSAoUmVjb3JkVHlwZVByb3RvdHlwZS5faW5kaWNlcyA9IHt9KTtcbiAgICAgIC8vIERlcHJlY2F0ZWQ6IGxlZnQgdG8gYXR0ZW1wdCBub3QgdG8gYnJlYWsgYW55IGV4dGVybmFsIGNvZGUgd2hpY2hcbiAgICAgIC8vIHJlbGllcyBvbiBhIC5fbmFtZSBwcm9wZXJ0eSBleGlzdGluZyBvbiByZWNvcmQgaW5zdGFuY2VzLlxuICAgICAgLy8gVXNlIFJlY29yZC5nZXREZXNjcmlwdGl2ZU5hbWUoKSBpbnN0ZWFkXG4gICAgICBSZWNvcmRUeXBlUHJvdG90eXBlLl9uYW1lID0gbmFtZTtcbiAgICAgIFJlY29yZFR5cGVQcm90b3R5cGUuX2tleXMgPSBrZXlzO1xuICAgICAgUmVjb3JkVHlwZVByb3RvdHlwZS5fZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRWYWx1ZXM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3BOYW1lID0ga2V5c1tpXTtcbiAgICAgICAgaW5kaWNlc1twcm9wTmFtZV0gPSBpO1xuICAgICAgICBpZiAoUmVjb3JkVHlwZVByb3RvdHlwZVtwcm9wTmFtZV0pIHtcbiAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgICAgdHlwZW9mIGNvbnNvbGUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBjb25zb2xlLndhcm4gJiZcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgJ0Nhbm5vdCBkZWZpbmUgJyArXG4gICAgICAgICAgICAgICAgcmVjb3JkTmFtZSh0aGlzKSArXG4gICAgICAgICAgICAgICAgJyB3aXRoIHByb3BlcnR5IFwiJyArXG4gICAgICAgICAgICAgICAgcHJvcE5hbWUgK1xuICAgICAgICAgICAgICAgICdcIiBzaW5jZSB0aGF0IHByb3BlcnR5IG5hbWUgaXMgcGFydCBvZiB0aGUgUmVjb3JkIEFQSS4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldFByb3AoUmVjb3JkVHlwZVByb3RvdHlwZSwgcHJvcE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX19vd25lcklEID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3ZhbHVlcyA9IExpc3QoKS53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChsKSB7XG4gICAgICBsLnNldFNpemUodGhpcyQxJDEuX2tleXMubGVuZ3RoKTtcbiAgICAgIEtleWVkQ29sbGVjdGlvbih2YWx1ZXMpLmZvckVhY2goZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgbC5zZXQodGhpcyQxJDEuX2luZGljZXNba10sIHYgPT09IHRoaXMkMSQxLl9kZWZhdWx0VmFsdWVzW2tdID8gdW5kZWZpbmVkIDogdik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgUmVjb3JkVHlwZVByb3RvdHlwZSA9IChSZWNvcmRUeXBlLnByb3RvdHlwZSA9XG4gICAgT2JqZWN0LmNyZWF0ZShSZWNvcmRQcm90b3R5cGUpKTtcbiAgUmVjb3JkVHlwZVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlY29yZFR5cGU7XG5cbiAgaWYgKG5hbWUpIHtcbiAgICBSZWNvcmRUeXBlLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgfVxuXG4gIHJldHVybiBSZWNvcmRUeXBlO1xufTtcblxuUmVjb3JkLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIHN0ciA9IHJlY29yZE5hbWUodGhpcykgKyAnIHsgJztcbiAgdmFyIGtleXMgPSB0aGlzLl9rZXlzO1xuICB2YXIgaztcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSAhPT0gbDsgaSsrKSB7XG4gICAgayA9IGtleXNbaV07XG4gICAgc3RyICs9IChpID8gJywgJyA6ICcnKSArIGsgKyAnOiAnICsgcXVvdGVTdHJpbmcodGhpcy5nZXQoaykpO1xuICB9XG4gIHJldHVybiBzdHIgKyAnIH0nO1xufTtcblxuUmVjb3JkLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKG90aGVyKSB7XG4gIHJldHVybiAoXG4gICAgdGhpcyA9PT0gb3RoZXIgfHxcbiAgICAoaXNSZWNvcmQob3RoZXIpICYmIHJlY29yZFNlcSh0aGlzKS5lcXVhbHMocmVjb3JkU2VxKG90aGVyKSkpXG4gICk7XG59O1xuXG5SZWNvcmQucHJvdG90eXBlLmhhc2hDb2RlID0gZnVuY3Rpb24gaGFzaENvZGUgKCkge1xuICByZXR1cm4gcmVjb3JkU2VxKHRoaXMpLmhhc2hDb2RlKCk7XG59O1xuXG4vLyBAcHJhZ21hIEFjY2Vzc1xuXG5SZWNvcmQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoaykge1xuICByZXR1cm4gdGhpcy5faW5kaWNlcy5oYXNPd25Qcm9wZXJ0eShrKTtcbn07XG5cblJlY29yZC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChrLCBub3RTZXRWYWx1ZSkge1xuICBpZiAoIXRoaXMuaGFzKGspKSB7XG4gICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICB9XG4gIHZhciBpbmRleCA9IHRoaXMuX2luZGljZXNba107XG4gIHZhciB2YWx1ZSA9IHRoaXMuX3ZhbHVlcy5nZXQoaW5kZXgpO1xuICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHRoaXMuX2RlZmF1bHRWYWx1ZXNba10gOiB2YWx1ZTtcbn07XG5cbi8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cblJlY29yZC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0IChrLCB2KSB7XG4gIGlmICh0aGlzLmhhcyhrKSkge1xuICAgIHZhciBuZXdWYWx1ZXMgPSB0aGlzLl92YWx1ZXMuc2V0KFxuICAgICAgdGhpcy5faW5kaWNlc1trXSxcbiAgICAgIHYgPT09IHRoaXMuX2RlZmF1bHRWYWx1ZXNba10gPyB1bmRlZmluZWQgOiB2XG4gICAgKTtcbiAgICBpZiAobmV3VmFsdWVzICE9PSB0aGlzLl92YWx1ZXMgJiYgIXRoaXMuX19vd25lcklEKSB7XG4gICAgICByZXR1cm4gbWFrZVJlY29yZCh0aGlzLCBuZXdWYWx1ZXMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblJlY29yZC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlIChrKSB7XG4gIHJldHVybiB0aGlzLnNldChrKTtcbn07XG5cblJlY29yZC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gIHZhciBuZXdWYWx1ZXMgPSB0aGlzLl92YWx1ZXMuY2xlYXIoKS5zZXRTaXplKHRoaXMuX2tleXMubGVuZ3RoKTtcblxuICByZXR1cm4gdGhpcy5fX293bmVySUQgPyB0aGlzIDogbWFrZVJlY29yZCh0aGlzLCBuZXdWYWx1ZXMpO1xufTtcblxuUmVjb3JkLnByb3RvdHlwZS53YXNBbHRlcmVkID0gZnVuY3Rpb24gd2FzQWx0ZXJlZCAoKSB7XG4gIHJldHVybiB0aGlzLl92YWx1ZXMud2FzQWx0ZXJlZCgpO1xufTtcblxuUmVjb3JkLnByb3RvdHlwZS50b1NlcSA9IGZ1bmN0aW9uIHRvU2VxICgpIHtcbiAgcmV0dXJuIHJlY29yZFNlcSh0aGlzKTtcbn07XG5cblJlY29yZC5wcm90b3R5cGUudG9KUyA9IGZ1bmN0aW9uIHRvSlMkMSAoKSB7XG4gIHJldHVybiB0b0pTKHRoaXMpO1xufTtcblxuUmVjb3JkLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24gZW50cmllcyAoKSB7XG4gIHJldHVybiB0aGlzLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTKTtcbn07XG5cblJlY29yZC5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgcmV0dXJuIHJlY29yZFNlcSh0aGlzKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xufTtcblxuUmVjb3JkLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gIHJldHVybiByZWNvcmRTZXEodGhpcykuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbn07XG5cblJlY29yZC5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uIF9fZW5zdXJlT3duZXIgKG93bmVySUQpIHtcbiAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdmFyIG5ld1ZhbHVlcyA9IHRoaXMuX3ZhbHVlcy5fX2Vuc3VyZU93bmVyKG93bmVySUQpO1xuICBpZiAoIW93bmVySUQpIHtcbiAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgdGhpcy5fdmFsdWVzID0gbmV3VmFsdWVzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJldHVybiBtYWtlUmVjb3JkKHRoaXMsIG5ld1ZhbHVlcywgb3duZXJJRCk7XG59O1xuXG5SZWNvcmQuaXNSZWNvcmQgPSBpc1JlY29yZDtcblJlY29yZC5nZXREZXNjcmlwdGl2ZU5hbWUgPSByZWNvcmROYW1lO1xudmFyIFJlY29yZFByb3RvdHlwZSA9IFJlY29yZC5wcm90b3R5cGU7XG5SZWNvcmRQcm90b3R5cGVbSVNfUkVDT1JEX1NZTUJPTF0gPSB0cnVlO1xuUmVjb3JkUHJvdG90eXBlW0RFTEVURV0gPSBSZWNvcmRQcm90b3R5cGUucmVtb3ZlO1xuUmVjb3JkUHJvdG90eXBlLmRlbGV0ZUluID0gUmVjb3JkUHJvdG90eXBlLnJlbW92ZUluID0gZGVsZXRlSW47XG5SZWNvcmRQcm90b3R5cGUuZ2V0SW4gPSBnZXRJbjtcblJlY29yZFByb3RvdHlwZS5oYXNJbiA9IENvbGxlY3Rpb25Qcm90b3R5cGUuaGFzSW47XG5SZWNvcmRQcm90b3R5cGUubWVyZ2UgPSBtZXJnZSQxO1xuUmVjb3JkUHJvdG90eXBlLm1lcmdlV2l0aCA9IG1lcmdlV2l0aCQxO1xuUmVjb3JkUHJvdG90eXBlLm1lcmdlSW4gPSBtZXJnZUluO1xuUmVjb3JkUHJvdG90eXBlLm1lcmdlRGVlcCA9IG1lcmdlRGVlcDtcblJlY29yZFByb3RvdHlwZS5tZXJnZURlZXBXaXRoID0gbWVyZ2VEZWVwV2l0aDtcblJlY29yZFByb3RvdHlwZS5tZXJnZURlZXBJbiA9IG1lcmdlRGVlcEluO1xuUmVjb3JkUHJvdG90eXBlLnNldEluID0gc2V0SW47XG5SZWNvcmRQcm90b3R5cGUudXBkYXRlID0gdXBkYXRlO1xuUmVjb3JkUHJvdG90eXBlLnVwZGF0ZUluID0gdXBkYXRlSW47XG5SZWNvcmRQcm90b3R5cGUud2l0aE11dGF0aW9ucyA9IHdpdGhNdXRhdGlvbnM7XG5SZWNvcmRQcm90b3R5cGUuYXNNdXRhYmxlID0gYXNNdXRhYmxlO1xuUmVjb3JkUHJvdG90eXBlLmFzSW1tdXRhYmxlID0gYXNJbW11dGFibGU7XG5SZWNvcmRQcm90b3R5cGVbSVRFUkFUT1JfU1lNQk9MXSA9IFJlY29yZFByb3RvdHlwZS5lbnRyaWVzO1xuUmVjb3JkUHJvdG90eXBlLnRvSlNPTiA9IFJlY29yZFByb3RvdHlwZS50b09iamVjdCA9XG4gIENvbGxlY3Rpb25Qcm90b3R5cGUudG9PYmplY3Q7XG5SZWNvcmRQcm90b3R5cGUuaW5zcGVjdCA9IFJlY29yZFByb3RvdHlwZS50b1NvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbn07XG5cbmZ1bmN0aW9uIG1ha2VSZWNvcmQobGlrZVJlY29yZCwgdmFsdWVzLCBvd25lcklEKSB7XG4gIHZhciByZWNvcmQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihsaWtlUmVjb3JkKSk7XG4gIHJlY29yZC5fdmFsdWVzID0gdmFsdWVzO1xuICByZWNvcmQuX19vd25lcklEID0gb3duZXJJRDtcbiAgcmV0dXJuIHJlY29yZDtcbn1cblxuZnVuY3Rpb24gcmVjb3JkTmFtZShyZWNvcmQpIHtcbiAgcmV0dXJuIHJlY29yZC5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCByZWNvcmQuY29uc3RydWN0b3IubmFtZSB8fCAnUmVjb3JkJztcbn1cblxuZnVuY3Rpb24gcmVjb3JkU2VxKHJlY29yZCkge1xuICByZXR1cm4ga2V5ZWRTZXFGcm9tVmFsdWUocmVjb3JkLl9rZXlzLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gW2ssIHJlY29yZC5nZXQoayldOyB9KSk7XG59XG5cbmZ1bmN0aW9uIHNldFByb3AocHJvdG90eXBlLCBuYW1lKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgbmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChuYW1lKTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpbnZhcmlhbnQodGhpcy5fX293bmVySUQsICdDYW5ub3Qgc2V0IG9uIGFuIGltbXV0YWJsZSByZWNvcmQuJyk7XG4gICAgICAgIHRoaXMuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gT2JqZWN0LmRlZmluZVByb3BlcnR5IGZhaWxlZC4gUHJvYmFibHkgSUU4LlxuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGxhenkgU2VxIG9mIGB2YWx1ZWAgcmVwZWF0ZWQgYHRpbWVzYCB0aW1lcy4gV2hlbiBgdGltZXNgIGlzXG4gKiB1bmRlZmluZWQsIHJldHVybnMgYW4gaW5maW5pdGUgc2VxdWVuY2Ugb2YgYHZhbHVlYC5cbiAqL1xudmFyIFJlcGVhdCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEluZGV4ZWRTZXEpIHtcbiAgZnVuY3Rpb24gUmVwZWF0KHZhbHVlLCB0aW1lcykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXBlYXQpKSB7XG4gICAgICByZXR1cm4gbmV3IFJlcGVhdCh2YWx1ZSwgdGltZXMpO1xuICAgIH1cbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuc2l6ZSA9IHRpbWVzID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IE1hdGgubWF4KDAsIHRpbWVzKTtcbiAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICBpZiAoRU1QVFlfUkVQRUFUKSB7XG4gICAgICAgIHJldHVybiBFTVBUWV9SRVBFQVQ7XG4gICAgICB9XG4gICAgICBFTVBUWV9SRVBFQVQgPSB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIGlmICggSW5kZXhlZFNlcSApIFJlcGVhdC5fX3Byb3RvX18gPSBJbmRleGVkU2VxO1xuICBSZXBlYXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW5kZXhlZFNlcSAmJiBJbmRleGVkU2VxLnByb3RvdHlwZSApO1xuICBSZXBlYXQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVwZWF0O1xuXG4gIFJlcGVhdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuICdSZXBlYXQgW10nO1xuICAgIH1cbiAgICByZXR1cm4gJ1JlcGVhdCBbICcgKyB0aGlzLl92YWx1ZSArICcgJyArIHRoaXMuc2l6ZSArICcgdGltZXMgXSc7XG4gIH07XG5cbiAgUmVwZWF0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmhhcyhpbmRleCkgPyB0aGlzLl92YWx1ZSA6IG5vdFNldFZhbHVlO1xuICB9O1xuXG4gIFJlcGVhdC5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAoc2VhcmNoVmFsdWUpIHtcbiAgICByZXR1cm4gaXModGhpcy5fdmFsdWUsIHNlYXJjaFZhbHVlKTtcbiAgfTtcblxuICBSZXBlYXQucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKGJlZ2luLCBlbmQpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICByZXR1cm4gd2hvbGVTbGljZShiZWdpbiwgZW5kLCBzaXplKVxuICAgICAgPyB0aGlzXG4gICAgICA6IG5ldyBSZXBlYXQoXG4gICAgICAgICAgdGhpcy5fdmFsdWUsXG4gICAgICAgICAgcmVzb2x2ZUVuZChlbmQsIHNpemUpIC0gcmVzb2x2ZUJlZ2luKGJlZ2luLCBzaXplKVxuICAgICAgICApO1xuICB9O1xuXG4gIFJlcGVhdC5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UgKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIFJlcGVhdC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHNlYXJjaFZhbHVlKSB7XG4gICAgaWYgKGlzKHRoaXMuX3ZhbHVlLCBzZWFyY2hWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgUmVwZWF0LnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mIChzZWFyY2hWYWx1ZSkge1xuICAgIGlmIChpcyh0aGlzLl92YWx1ZSwgc2VhcmNoVmFsdWUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaXplO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgUmVwZWF0LnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpICE9PSBzaXplKSB7XG4gICAgICBpZiAoZm4odGhpcy5fdmFsdWUsIHJldmVyc2UgPyBzaXplIC0gKytpIDogaSsrLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9O1xuXG4gIFJlcGVhdC5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICB2YXIgdGhpcyQxJDEgPSB0aGlzO1xuXG4gICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgdmFyIGkgPSAwO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkgeyByZXR1cm4gaSA9PT0gc2l6ZVxuICAgICAgICA/IGl0ZXJhdG9yRG9uZSgpXG4gICAgICAgIDogaXRlcmF0b3JWYWx1ZSh0eXBlLCByZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrKywgdGhpcyQxJDEuX3ZhbHVlKTsgfVxuICAgICk7XG4gIH07XG5cbiAgUmVwZWF0LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgUmVwZWF0XG4gICAgICA/IGlzKHRoaXMuX3ZhbHVlLCBvdGhlci5fdmFsdWUpXG4gICAgICA6IGRlZXBFcXVhbChvdGhlcik7XG4gIH07XG5cbiAgcmV0dXJuIFJlcGVhdDtcbn0oSW5kZXhlZFNlcSkpO1xuXG52YXIgRU1QVFlfUkVQRUFUO1xuXG5mdW5jdGlvbiBmcm9tSlModmFsdWUsIGNvbnZlcnRlcikge1xuICByZXR1cm4gZnJvbUpTV2l0aChcbiAgICBbXSxcbiAgICBjb252ZXJ0ZXIgfHwgZGVmYXVsdENvbnZlcnRlcixcbiAgICB2YWx1ZSxcbiAgICAnJyxcbiAgICBjb252ZXJ0ZXIgJiYgY29udmVydGVyLmxlbmd0aCA+IDIgPyBbXSA6IHVuZGVmaW5lZCxcbiAgICB7ICcnOiB2YWx1ZSB9XG4gICk7XG59XG5cbmZ1bmN0aW9uIGZyb21KU1dpdGgoc3RhY2ssIGNvbnZlcnRlciwgdmFsdWUsIGtleSwga2V5UGF0aCwgcGFyZW50VmFsdWUpIHtcbiAgaWYgKFxuICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICAhaXNJbW11dGFibGUodmFsdWUpICYmXG4gICAgKGlzQXJyYXlMaWtlKHZhbHVlKSB8fCBoYXNJdGVyYXRvcih2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpXG4gICkge1xuICAgIGlmICh+c3RhY2suaW5kZXhPZih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGNpcmN1bGFyIHN0cnVjdHVyZSB0byBJbW11dGFibGUnKTtcbiAgICB9XG4gICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAga2V5UGF0aCAmJiBrZXkgIT09ICcnICYmIGtleVBhdGgucHVzaChrZXkpO1xuICAgIHZhciBjb252ZXJ0ZWQgPSBjb252ZXJ0ZXIuY2FsbChcbiAgICAgIHBhcmVudFZhbHVlLFxuICAgICAga2V5LFxuICAgICAgU2VxKHZhbHVlKS5tYXAoZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIGZyb21KU1dpdGgoc3RhY2ssIGNvbnZlcnRlciwgdiwgaywga2V5UGF0aCwgdmFsdWUpOyB9XG4gICAgICApLFxuICAgICAga2V5UGF0aCAmJiBrZXlQYXRoLnNsaWNlKClcbiAgICApO1xuICAgIHN0YWNrLnBvcCgpO1xuICAgIGtleVBhdGggJiYga2V5UGF0aC5wb3AoKTtcbiAgICByZXR1cm4gY29udmVydGVkO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENvbnZlcnRlcihrLCB2KSB7XG4gIC8vIEVmZmVjdGl2ZWx5IHRoZSBvcHBvc2l0ZSBvZiBcIkNvbGxlY3Rpb24udG9TZXEoKVwiXG4gIHJldHVybiBpc0luZGV4ZWQodikgPyB2LnRvTGlzdCgpIDogaXNLZXllZCh2KSA/IHYudG9NYXAoKSA6IHYudG9TZXQoKTtcbn1cblxudmFyIHZlcnNpb24gPSBcIjQuMS4wXCI7XG5cbnZhciBJbW11dGFibGUgPSB7XG4gIHZlcnNpb246IHZlcnNpb24sXG5cbiAgQ29sbGVjdGlvbjogQ29sbGVjdGlvbixcbiAgLy8gTm90ZTogSXRlcmFibGUgaXMgZGVwcmVjYXRlZFxuICBJdGVyYWJsZTogQ29sbGVjdGlvbixcblxuICBTZXE6IFNlcSxcbiAgTWFwOiBNYXAsXG4gIE9yZGVyZWRNYXA6IE9yZGVyZWRNYXAsXG4gIExpc3Q6IExpc3QsXG4gIFN0YWNrOiBTdGFjayxcbiAgU2V0OiBTZXQsXG4gIE9yZGVyZWRTZXQ6IE9yZGVyZWRTZXQsXG5cbiAgUmVjb3JkOiBSZWNvcmQsXG4gIFJhbmdlOiBSYW5nZSxcbiAgUmVwZWF0OiBSZXBlYXQsXG5cbiAgaXM6IGlzLFxuICBmcm9tSlM6IGZyb21KUyxcbiAgaGFzaDogaGFzaCxcblxuICBpc0ltbXV0YWJsZTogaXNJbW11dGFibGUsXG4gIGlzQ29sbGVjdGlvbjogaXNDb2xsZWN0aW9uLFxuICBpc0tleWVkOiBpc0tleWVkLFxuICBpc0luZGV4ZWQ6IGlzSW5kZXhlZCxcbiAgaXNBc3NvY2lhdGl2ZTogaXNBc3NvY2lhdGl2ZSxcbiAgaXNPcmRlcmVkOiBpc09yZGVyZWQsXG4gIGlzVmFsdWVPYmplY3Q6IGlzVmFsdWVPYmplY3QsXG4gIGlzUGxhaW5PYmplY3Q6IGlzUGxhaW5PYmplY3QsXG4gIGlzU2VxOiBpc1NlcSxcbiAgaXNMaXN0OiBpc0xpc3QsXG4gIGlzTWFwOiBpc01hcCxcbiAgaXNPcmRlcmVkTWFwOiBpc09yZGVyZWRNYXAsXG4gIGlzU3RhY2s6IGlzU3RhY2ssXG4gIGlzU2V0OiBpc1NldCxcbiAgaXNPcmRlcmVkU2V0OiBpc09yZGVyZWRTZXQsXG4gIGlzUmVjb3JkOiBpc1JlY29yZCxcblxuICBnZXQ6IGdldCxcbiAgZ2V0SW46IGdldEluJDEsXG4gIGhhczogaGFzLFxuICBoYXNJbjogaGFzSW4kMSxcbiAgbWVyZ2U6IG1lcmdlLFxuICBtZXJnZURlZXA6IG1lcmdlRGVlcCQxLFxuICBtZXJnZVdpdGg6IG1lcmdlV2l0aCxcbiAgbWVyZ2VEZWVwV2l0aDogbWVyZ2VEZWVwV2l0aCQxLFxuICByZW1vdmU6IHJlbW92ZSxcbiAgcmVtb3ZlSW46IHJlbW92ZUluLFxuICBzZXQ6IHNldCxcbiAgc2V0SW46IHNldEluJDEsXG4gIHVwZGF0ZTogdXBkYXRlJDEsXG4gIHVwZGF0ZUluOiB1cGRhdGVJbiQxLFxufTtcblxuLy8gTm90ZTogSXRlcmFibGUgaXMgZGVwcmVjYXRlZFxudmFyIEl0ZXJhYmxlID0gQ29sbGVjdGlvbjtcblxuZXhwb3J0IGRlZmF1bHQgSW1tdXRhYmxlO1xuZXhwb3J0IHsgQ29sbGVjdGlvbiwgSXRlcmFibGUsIExpc3QsIE1hcCwgT3JkZXJlZE1hcCwgT3JkZXJlZFNldCwgUmFuZ2UsIFJlY29yZCwgUmVwZWF0LCBTZXEsIFNldCwgU3RhY2ssIGZyb21KUywgZ2V0LCBnZXRJbiQxIGFzIGdldEluLCBoYXMsIGhhc0luJDEgYXMgaGFzSW4sIGhhc2gsIGlzLCBpc0Fzc29jaWF0aXZlLCBpc0NvbGxlY3Rpb24sIGlzSW1tdXRhYmxlLCBpc0luZGV4ZWQsIGlzS2V5ZWQsIGlzTGlzdCwgaXNNYXAsIGlzT3JkZXJlZCwgaXNPcmRlcmVkTWFwLCBpc09yZGVyZWRTZXQsIGlzUGxhaW5PYmplY3QsIGlzUmVjb3JkLCBpc1NlcSwgaXNTZXQsIGlzU3RhY2ssIGlzVmFsdWVPYmplY3QsIG1lcmdlLCBtZXJnZURlZXAkMSBhcyBtZXJnZURlZXAsIG1lcmdlRGVlcFdpdGgkMSBhcyBtZXJnZURlZXBXaXRoLCBtZXJnZVdpdGgsIHJlbW92ZSwgcmVtb3ZlSW4sIHNldCwgc2V0SW4kMSBhcyBzZXRJbiwgdXBkYXRlJDEgYXMgdXBkYXRlLCB1cGRhdGVJbiQxIGFzIHVwZGF0ZUluLCB2ZXJzaW9uIH07XG4iLCJleHBvcnQgY29uc3QgRVBTSUxPTiA9IDAuMDE7XHJcbiIsImltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuLi9jb25zdGFudHMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IGRlZ3JlZXNUb1JhZGlhbnMgPSAoZGVncmVlcykgPT4ge1xyXG4gIHJldHVybiAoZGVncmVlcyAqIE1hdGguUEkpIC8gMTgwO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHJhZGlhbnNUb0RlZ3JlZXMgPSAocmFkaWFucykgPT4ge1xyXG4gIHJldHVybiAocmFkaWFucyAqIDE4MCkgLyBNYXRoLlBJO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHJhbmRSYW5nZUZsb2F0ID0gKG1pbiwgbWF4KSA9PiB7XHJcbiAgcmV0dXJuIChNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikpICsgbWluO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHJhbmRSYW5nZUludCA9IChtaW4sIG1heCkgPT4ge1xyXG4gIGNvbnN0IF9taW4gPSBNYXRoLmNlaWwobWluKTtcclxuICBjb25zdCBfbWF4ID0gTWF0aC5mbG9vcihtYXgpO1xyXG4gIHJldHVybiBNYXRoLmZsb29yKChNYXRoLnJhbmRvbSgpICogKF9tYXggLSBfbWluKSkgKyBfbWluKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjbGFtcEZsb2F0ID0gKG4sIG1pbiwgbWF4KSA9PiB7XHJcbiAgaWYgKG4gPCBtaW4pIHtcclxuICAgIHJldHVybiBtaW47XHJcbiAgfVxyXG4gIGlmIChuID4gbWF4KSB7XHJcbiAgICByZXR1cm4gbWF4O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG47XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgYXBwcm94aW1hdGVseSA9IChuLCB2YWx1ZSkgPT4ge1xyXG4gIGlmIChuID49ICh2YWx1ZSAtIGNvbnN0YW50cy5FUFNJTE9OKSAmJiBuIDw9ICh2YWx1ZSArIGNvbnN0YW50cy5FUFNJTE9OKSkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmFsc2U7XHJcbn07XHJcbiIsImltcG9ydCAqIGFzIG1hdGhVdGlscyBmcm9tICcuL3V0aWxzJztcclxuXHJcbmV4cG9ydCBjbGFzcyBWZWN0b3IyIHtcclxuICBjb25zdHJ1Y3Rvcih7IHgsIHkgfSkge1xyXG4gICAgdGhpcy54ID0geDtcclxuICAgIHRoaXMueSA9IHk7XHJcbiAgfVxyXG5cclxuICBnZXQgbWFnbml0dWRlKCkge1xyXG4gICAgcmV0dXJuIE1hdGguc3FydCgodGhpcy54ICoqIDIpICsgKHRoaXMueSAqKiAyKSk7XHJcbiAgfVxyXG5cclxuICBnZXQgcG9sYXJDb29yZHMoKSB7XHJcbiAgICBpZiAoIXRoaXMueCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGFuZ2xlOiAwLFxyXG4gICAgICAgIHJhZGl1czogMCxcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBhbmdsZTogTWF0aC5hdGFuKHRoaXMueSAvIHRoaXMueCksXHJcbiAgICAgIHJhZGl1czogdGhpcy5tYWduaXR1ZGUsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgYWRkVmVjdG9yID0gKHZlY3RvcikgPT4ge1xyXG4gICAgcmV0dXJuIG5ldyBWZWN0b3IyKHtcclxuICAgICAgeDogdGhpcy54ICsgdmVjdG9yLngsXHJcbiAgICAgIHk6IHRoaXMueSArIHZlY3Rvci55LFxyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgbXVsdGlwbHlTY2FsYXIgPSAoc2NhbGFyKSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFZlY3RvcjIoe1xyXG4gICAgICB4OiB0aGlzLnggKiBzY2FsYXIsXHJcbiAgICAgIHk6IHRoaXMueSAqIHNjYWxhcixcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIG11bHRpcGx5VmVjdG9yID0gKHZlY3RvcikgPT4ge1xyXG4gICAgcmV0dXJuIG5ldyBWZWN0b3IyKHtcclxuICAgICAgeDogdGhpcy54ICogdmVjdG9yLngsXHJcbiAgICAgIHk6IHRoaXMueSAqIHZlY3Rvci55LFxyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgZGl2aWRlU2NhbGFyID0gKHNjYWxhcikgPT4ge1xyXG4gICAgcmV0dXJuIG5ldyBWZWN0b3IyKHtcclxuICAgICAgeDogdGhpcy54IC8gc2NhbGFyLFxyXG4gICAgICB5OiB0aGlzLnkgLyBzY2FsYXIsXHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICBkaXN0YW5jZVRvID0gKHZlY3RvcikgPT4ge1xyXG4gICAgcmV0dXJuIE1hdGguc3FydCgoKHRoaXMueCAtIHZlY3Rvci54KSAqKiAyKSArICgodGhpcy55IC0gdmVjdG9yLnkpICoqIDIpKTtcclxuICB9O1xyXG5cclxuICBpbnZlcnRZID0gKHdvcmxkSGVpZ2h0KSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFZlY3RvcjIoeyB4OiB0aGlzLngsIHk6IHdvcmxkSGVpZ2h0IC0gdGhpcy55IH0pO1xyXG4gIH07XHJcblxyXG4gIGlzQmV0d2VlbiA9ICh2ZWN0b3IxLCB2ZWN0b3IyKSA9PiB7XHJcbiAgICBjb25zdCBkaXN0YW5jZVdpdGhNaWRwb2ludCA9IHRoaXMuZGlzdGFuY2VUbyh2ZWN0b3IxKSArIHRoaXMuZGlzdGFuY2VUbyh2ZWN0b3IyKTtcclxuICAgIGNvbnN0IGRpc3RhbmNlV2l0aG91dE1pZHBvaW50ID0gdmVjdG9yMS5kaXN0YW5jZVRvKHZlY3RvcjIpO1xyXG5cclxuICAgIGNvbnN0IGRpZmZlcmVuY2UgPSBkaXN0YW5jZVdpdGhNaWRwb2ludCAtIGRpc3RhbmNlV2l0aG91dE1pZHBvaW50O1xyXG5cclxuICAgIGlmIChtYXRoVXRpbHMuYXBwcm94aW1hdGVseShkaWZmZXJlbmNlLCAwKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfTtcclxuXHJcbiAgcm90YXRlID0gKGFuZ2xlUmFkaWFucykgPT4ge1xyXG4gICAgcmV0dXJuIG5ldyBWZWN0b3IyKHtcclxuICAgICAgeDogKHRoaXMueCAqIE1hdGguY29zKGFuZ2xlUmFkaWFucykpIC0gKHRoaXMueSAqIE1hdGguc2luKGFuZ2xlUmFkaWFucykpLFxyXG4gICAgICB5OiAodGhpcy54ICogTWF0aC5zaW4oYW5nbGVSYWRpYW5zKSkgKyAodGhpcy55ICogTWF0aC5jb3MoYW5nbGVSYWRpYW5zKSksXHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICB0ZXN0YWJsZU9iaiA9ICgpID0+IHtcclxuICAgIHJldHVybiB7IHg6IHRoaXMueCwgeTogdGhpcy55IH07XHJcbiAgfTtcclxuXHJcbiAgc3RhdGljIHBvbGFyQ29vcmRpbmF0ZXMgPSAoYW5nbGVSYWRpYW5zLCByYWRpdXMgPSAxKSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFZlY3RvcjIoe1xyXG4gICAgICB4OiByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpLFxyXG4gICAgICB5OiByYWRpdXMgKiBNYXRoLnNpbihhbmdsZVJhZGlhbnMpLFxyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgc3RhdGljIGdlbmVyYXRlUmFuZG9tID0gKFxyXG4gICAgcmFuZ2VMZW5ndGhTdGFydCA9IDEsXHJcbiAgICByYW5nZUxlbmd0aEVuZCA9IDUsXHJcbiAgICByYW5nZVJhZGlhbnNTdGFydCA9IDAsXHJcbiAgICByYW5nZVJhZGlhbnNFbmQgPSAoMiAqIE1hdGguUEkpLFxyXG4gICkgPT4ge1xyXG4gICAgY29uc3QgcmFkaWFucyA9IG1hdGhVdGlscy5yYW5kUmFuZ2VGbG9hdChyYW5nZVJhZGlhbnNTdGFydCwgcmFuZ2VSYWRpYW5zRW5kKTtcclxuICAgIGNvbnN0IGxlbmd0aCA9IG1hdGhVdGlscy5yYW5kUmFuZ2VGbG9hdChyYW5nZUxlbmd0aFN0YXJ0LCByYW5nZUxlbmd0aEVuZCk7XHJcblxyXG4gICAgcmV0dXJuIFZlY3RvcjIucG9sYXJDb29yZGluYXRlcyhyYWRpYW5zLCBsZW5ndGgpO1xyXG4gIH07XHJcblxyXG4gIHN0YXRpYyBnZW5lcmF0ZVJhbmRvbUZyb21Db29yZHMgPSAoXHJcbiAgICByYW5nZVhTdGFydCA9IDAsXHJcbiAgICByYW5nZVhFbmQgPSAxMDAwLFxyXG4gICAgcmFuZ2VZU3RhcnQgPSAwLFxyXG4gICAgcmFuZ2VZRW5kID0gMTAwMCxcclxuICApID0+IHtcclxuICAgIGNvbnN0IHggPSBtYXRoVXRpbHMucmFuZFJhbmdlRmxvYXQocmFuZ2VYU3RhcnQsIHJhbmdlWEVuZCk7XHJcbiAgICBjb25zdCB5ID0gbWF0aFV0aWxzLnJhbmRSYW5nZUZsb2F0KHJhbmdlWVN0YXJ0LCByYW5nZVlFbmQpO1xyXG5cclxuICAgIHJldHVybiBuZXcgVmVjdG9yMih7IHgsIHkgfSk7XHJcbiAgfTtcclxufVxyXG4iLCJpbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi9WZWN0b3IyJztcclxuaW1wb3J0ICogYXMgbWF0aFV0aWxzIGZyb20gJy4vdXRpbHMnO1xyXG5cclxuZXhwb3J0IGNsYXNzIExpbmUge1xyXG4gIGNvbnN0cnVjdG9yKHtcclxuICAgIHBvaW50MSxcclxuICAgIHBvaW50MixcclxuICB9KSB7XHJcbiAgICB0aGlzLnBvaW50MSA9IHBvaW50MTtcclxuICAgIHRoaXMucG9pbnQyID0gcG9pbnQyO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHNsb3BlKCkge1xyXG4gICAgaWYgKHRoaXMucG9pbnQxICYmIHRoaXMucG9pbnQyKSB7XHJcbiAgICAgIGNvbnN0IGRlbm9taW5hdG9yID0gKHRoaXMucG9pbnQxLnggLSB0aGlzLnBvaW50Mi54KTtcclxuICAgICAgaWYgKGRlbm9taW5hdG9yICE9PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnBvaW50MS55IC0gdGhpcy5wb2ludDIueSkgLyBkZW5vbWluYXRvcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHZlcnRpY2FsIGxpbmVcclxuICAgIHJldHVybiBOdW1iZXIuTmFOO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHlJbnRlcmNlcHQoKSB7XHJcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHRoaXMuc2xvcGUpKSB7XHJcbiAgICAgIHJldHVybiBOdW1iZXIuTmFOO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgWSBpbnRlcmNlcHQgYnkgYXNzaWduaW5nIHRoZSBjb29yZGluYXRlcyBvZiB0aGVcclxuICAgIC8vIGZpcnN0IHBvaW50IHRvIHRoZSB2YXJpYWJsZXMgb2YgdGhlIHNsb3BlLWludGVyY2VwdCBlcXVhdGlvblxyXG4gICAgLy8gKHkgPSBheCArIGIpXHJcbiAgICByZXR1cm4gdGhpcy5wb2ludDEueSAtICh0aGlzLnNsb3BlICogdGhpcy5wb2ludDEueCk7XHJcbiAgfVxyXG5cclxuICBzb2x2ZVkgPSAoeCkgPT4ge1xyXG4gICAgcmV0dXJuICh0aGlzLnNsb3BlICogeCkgKyB0aGlzLnlJbnRlcmNlcHQ7XHJcbiAgfTtcclxuXHJcbiAgY2FsY3VsYXRlSW50ZXJzZWN0aW9uID0gKG90aGVyTGluZSkgPT4ge1xyXG4gICAgY29uc3QgYm90aFZlcnRpY2FsID0gTnVtYmVyLmlzTmFOKHRoaXMuc2xvcGUpICYmIE51bWJlci5pc05hTihvdGhlckxpbmUuc2xvcGUpO1xyXG5cclxuICAgIGNvbnN0IHNhbWVTbG9wZXMgPSBib3RoVmVydGljYWwgfHwgbWF0aFV0aWxzLmFwcHJveGltYXRlbHkodGhpcy5zbG9wZSwgb3RoZXJMaW5lLnNsb3BlKTtcclxuXHJcbiAgICBpZiAoYm90aFZlcnRpY2FsKSB7XHJcbiAgICAgIC8vIGRvZXNuJ3QgbWF0dGVyIHdoaWNoIHBvaW50IHdlIGNoZWNrXHJcbiAgICAgIGlmICh0aGlzLnBvaW50MS54ID09PSBvdGhlckxpbmUucG9pbnQxLngpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gbGluZXMgYXJlIGVxdWFsXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGxpbmVzIGFyZSB2ZXJ0aWNhbCBhbmQgcGFyYWxsZWxcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHRoaXMgbGluZSBpcyB2ZXJ0aWNhbFxyXG4gICAgaWYgKE51bWJlci5pc05hTih0aGlzLnNsb3BlKSkge1xyXG4gICAgICBjb25zdCB7IHggfSA9IHRoaXMucG9pbnQxO1xyXG4gICAgICBjb25zdCB5ID0gb3RoZXJMaW5lLnNvbHZlWSh4KTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMih7IHgsIHkgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdGhlIG90aGVyIGxpbmUgaXMgdmVydGljYWxcclxuICAgIGlmIChOdW1iZXIuaXNOYU4ob3RoZXJMaW5lLnNsb3BlKSkge1xyXG4gICAgICBjb25zdCB7IHggfSA9IG90aGVyTGluZS5wb2ludDE7XHJcbiAgICAgIGNvbnN0IHkgPSB0aGlzLnNvbHZlWSh4KTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMih7IHgsIHkgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2FtZVlJbnRlcmNlcHRzID0gbWF0aFV0aWxzLmFwcHJveGltYXRlbHkodGhpcy55SW50ZXJjZXB0LCBvdGhlckxpbmUueUludGVyY2VwdCk7XHJcblxyXG4gICAgLy8gY2hlY2sgaWYgdGhlIGxpbmVzIGFyZSBlcXVhbDpcclxuICAgIGlmIChzYW1lU2xvcGVzICYmIHNhbWVZSW50ZXJjZXB0cykge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjaGVjayBpZiB0aGUgbGluZXMgYXJlIHBhcmFsbGVsOlxyXG4gICAgaWYgKHNhbWVTbG9wZXMgJiYgIXNhbWVZSW50ZXJjZXB0cykge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZmlyc3QsIHdlIGhhdmUgdHdvIGVxdWF0aW9uczpcclxuICAgIC8vXHJcbiAgICAvLyAgeTEgPSAoYTEgKiB4MSkgKyBiMVxyXG4gICAgLy8gIHkyID0gKGEyICogeDIpICsgYjJcclxuICAgIC8vXHJcbiAgICAvLyBhc3NpZ24gdGhlc2UgaW50byBhIHN5c3RlbSBvZiBlcXVhdGlvbnMgdG8gc29sdmUgZm9yIFhcclxuICAgIC8vIGxpa2UgdGhpcyAoWCBpcyBub3cgc2FtZSBpbiBib3RoIGVxdWF0aW9ucyk6XHJcbiAgICAvL1xyXG4gICAgLy8gIChhMSAqIHgpICsgYjEgPSAoYTIgKiB4KSArIGIyXHJcbiAgICAvLyAgKGExICogeCkgLSAoYTIgKiB4KSA9IGIyIC0gYjFcclxuICAgIC8vICB4ID0gKGIyIC0gYjEpIC8gKGExIC0gYTIpXHJcblxyXG4gICAgY29uc3QgeCA9IChvdGhlckxpbmUueUludGVyY2VwdCAtIHRoaXMueUludGVyY2VwdCkgLyAodGhpcy5zbG9wZSAtIG90aGVyTGluZS5zbG9wZSk7XHJcblxyXG4gICAgY29uc3QgeSA9IHRoaXMuc29sdmVZKHgpO1xyXG5cclxuICAgIHJldHVybiBuZXcgVmVjdG9yMih7IHgsIHkgfSk7XHJcbiAgfTtcclxuXHJcbiAgY2FsY3VsYXRlU2VnbWVudEludGVyc2VjdGlvbiA9IChvdGhlckxpbmUpID0+IHtcclxuICAgIGNvbnN0IGludGVyc2VjdGlvbiA9IHRoaXMuY2FsY3VsYXRlSW50ZXJzZWN0aW9uKG90aGVyTGluZSk7XHJcblxyXG4gICAgLy8gcGFyYWxsZWxcclxuICAgIGlmICghaW50ZXJzZWN0aW9uKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBlcXVhbExpbmVzID0gaW50ZXJzZWN0aW9uID09PSB0cnVlO1xyXG4gICAgY29uc3Qgb3ZlcmxhcHBpbmdTZWdtZW50cyA9IHRoaXMucG9pbnQxLmlzQmV0d2VlbihvdGhlckxpbmUucG9pbnQxLCBvdGhlckxpbmUucG9pbnQyKVxyXG4gICAgICB8fCB0aGlzLnBvaW50Mi5pc0JldHdlZW4ob3RoZXJMaW5lLnBvaW50MSwgb3RoZXJMaW5lLnBvaW50Mik7XHJcblxyXG4gICAgaWYgKGVxdWFsTGluZXMgJiYgb3ZlcmxhcHBpbmdTZWdtZW50cykge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZXF1YWxMaW5lcyAmJiAhb3ZlcmxhcHBpbmdTZWdtZW50cykge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2hlY2sgaWYgbGluZSBzZWdtZW50cyBpbnRlcnNlY3RcclxuICAgIGlmIChpbnRlcnNlY3Rpb24uaXNCZXR3ZWVuKHRoaXMucG9pbnQxLCB0aGlzLnBvaW50MilcclxuICAgICAgICAmJiBpbnRlcnNlY3Rpb24uaXNCZXR3ZWVuKG90aGVyTGluZS5wb2ludDEsIG90aGVyTGluZS5wb2ludDIpKSB7XHJcbiAgICAgIHJldHVybiBpbnRlcnNlY3Rpb247XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdGhlIGxpbmVzIGludGVyc2VjdCBidXQgbGluZSBzZWdtZW50cyBkbyBub3RcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9O1xyXG5cclxuICB0ZXN0YWJsZU9iaiA9ICgpID0+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHBvaW50MTogdGhpcy5wb2ludDEudGVzdGFibGVPYmooKSxcclxuICAgICAgcG9pbnQyOiB0aGlzLnBvaW50Mi50ZXN0YWJsZU9iaigpLFxyXG4gICAgfTtcclxuICB9O1xyXG59XHJcbiIsImltcG9ydCBJbW11dGFibGUgZnJvbSAnaW1tdXRhYmxlJztcclxuXHJcbmltcG9ydCAqIGFzIG1hdGhVdGlscyBmcm9tICcuL3V0aWxzJztcclxuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4vVmVjdG9yMic7XHJcbmltcG9ydCB7IExpbmUgfSBmcm9tICcuL0xpbmUnO1xyXG5cclxuZXhwb3J0IGNsYXNzIFBvbHlnb24ge1xyXG4gIGNvbnN0cnVjdG9yKHsgcG9pbnRzLCByYWRpdXMgfSkge1xyXG4gICAgdGhpcy5wb2ludHMgPSBwb2ludHM7XHJcbiAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcclxuICB9XHJcblxyXG4gIGdldEtvbnZhUG9pbnRzID0gKCkgPT4ge1xyXG4gICAgcmV0dXJuIHRoaXMucG9pbnRzXHJcbiAgICAgIC5tYXAoKHBvaW50KSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIFtwb2ludC54LCBwb2ludC55XTtcclxuICAgICAgfSlcclxuICAgICAgLmZsYXQoKTtcclxuICB9O1xyXG5cclxuICBnZXRMaW5lcyA9IChwb3NpdGlvbiA9IG51bGwpID0+IHtcclxuICAgIHJldHVybiBJbW11dGFibGUuZnJvbUpTKFxyXG4gICAgICB0aGlzLnBvaW50cy5tYXAoKHBvaW50LCBpKSA9PiB7XHJcbiAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gaSA8ICh0aGlzLnBvaW50cy5sZW5ndGggLSAxKVxyXG4gICAgICAgICAgPyAoaSArIDEpXHJcbiAgICAgICAgICA6IDA7XHJcblxyXG4gICAgICAgIGxldCBwb2ludDEgPSBwb2ludDtcclxuICAgICAgICBsZXQgcG9pbnQyID0gdGhpcy5wb2ludHNbbmV4dEluZGV4XTtcclxuXHJcbiAgICAgICAgaWYgKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgICBwb2ludDEgPSBwb2ludDEuYWRkVmVjdG9yKHBvc2l0aW9uKTtcclxuICAgICAgICAgIHBvaW50MiA9IHBvaW50Mi5hZGRWZWN0b3IocG9zaXRpb24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lKHsgcG9pbnQxLCBwb2ludDIgfSk7XHJcbiAgICAgIH0pLFxyXG4gICAgKTtcclxuICB9O1xyXG5cclxuICByb3RhdGUgPSAoYW5nbGVSYWRpYW5zKSA9PiB7XHJcbiAgICB0aGlzLnBvaW50cyA9IHRoaXMucG9pbnRzLm1hcCgocG9pbnQpID0+IHtcclxuICAgICAgcmV0dXJuIHBvaW50LnJvdGF0ZShhbmdsZVJhZGlhbnMpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgc3RhdGljIGdlbmVyYXRlUmFuZG9tID0gKG5Db3JuZXJzKSA9PiB7XHJcbiAgICBjb25zdCBzdGVwID0gKDIgKiBNYXRoLlBJKSAvIG5Db3JuZXJzO1xyXG4gICAgY29uc3QgcmFkaXVzID0gbWF0aFV0aWxzLnJhbmRSYW5nZUludCg1MCwgMTAwKTtcclxuXHJcbiAgICBsZXQgcHJldiA9IDA7XHJcbiAgICBsZXQgbmV4dCA9IHByZXYgKyBzdGVwO1xyXG5cclxuICAgIGNvbnN0IHBvaW50cyA9IFtdO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbkNvcm5lcnM7IGkgKz0gMSkge1xyXG4gICAgICBjb25zdCBhbmdsZSA9IG1hdGhVdGlscy5yYW5kUmFuZ2VGbG9hdChwcmV2LCBuZXh0KTtcclxuICAgICAgY29uc3QgY29vcmRzID0gVmVjdG9yMi5wb2xhckNvb3JkaW5hdGVzKGFuZ2xlLCByYWRpdXMpO1xyXG4gICAgICBwb2ludHMucHVzaChjb29yZHMpO1xyXG5cclxuICAgICAgcHJldiA9IG5leHQ7XHJcbiAgICAgIG5leHQgKz0gc3RlcDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFBvbHlnb24oeyBwb2ludHMsIHJhZGl1cyB9KTtcclxuICB9O1xyXG59XHJcbiIsImV4cG9ydCB7IFBvbHlnb24gfSBmcm9tICcuL1BvbHlnb24nO1xyXG5leHBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi9WZWN0b3IyJztcclxuZXhwb3J0IHsgTGluZSB9IGZyb20gJy4vTGluZSc7XHJcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcblxyXG5pbXBvcnQgeyBMaW5lIH0gZnJvbSAncmVhY3Qta29udmEnO1xyXG5cclxuaW1wb3J0ICogYXMgbWF0aFV0aWxzIGZyb20gJy4uL21hdGgvdXRpbHMnO1xyXG5pbXBvcnQgeyBQb2x5Z29uLCBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aCc7XHJcblxyXG5leHBvcnQgY2xhc3MgS29udmFQb2x5Z29uIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICByZW5kZXIoKSB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIHBvbHlnb24sXHJcbiAgICAgIHBvc2l0aW9uLFxyXG4gICAgfSA9IHRoaXMucHJvcHM7XHJcbiAgICBjb25zdCB7IHgsIHkgfSA9IHBvc2l0aW9uO1xyXG5cclxuICAgIGlmICgheCAmJiAheSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICA8TGluZVxyXG4gICAgICAgIHBvaW50cz17cG9seWdvbi5nZXRLb252YVBvaW50cygpfVxyXG4gICAgICAgIHN0cm9rZT1cImJsYWNrXCJcclxuICAgICAgICBzdHJva2VXaWR0aD17Mn1cclxuICAgICAgICB4PXt4fVxyXG4gICAgICAgIHk9e3l9XHJcbiAgICAgICAgY2xvc2VkXHJcbiAgICAgIC8+XHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxuS29udmFQb2x5Z29uLnByb3BUeXBlcyA9IHtcclxuICBwb2x5Z29uOiBQcm9wVHlwZXMuaW5zdGFuY2VPZihQb2x5Z29uKS5pc1JlcXVpcmVkLFxyXG4gIHBvc2l0aW9uOiBQcm9wVHlwZXMuaW5zdGFuY2VPZihWZWN0b3IyKS5pc1JlcXVpcmVkLFxyXG59O1xyXG4iLCJleHBvcnQgY29uc3QgU0VUX1NUQUdFX0JPVU5EUyA9ICdTRVRfU1RBR0VfQk9VTkRTJztcclxuXHJcbmV4cG9ydCBjb25zdCBzZXRTdGFnZUJvdW5kcyA9ICh3aWR0aCwgaGVpZ2h0KSA9PiB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGU6IFNFVF9TVEFHRV9CT1VORFMsXHJcbiAgICBwYXlsb2FkOiB7XHJcbiAgICAgIHdpZHRoLFxyXG4gICAgICBoZWlnaHQsXHJcbiAgICB9LFxyXG4gIH07XHJcbn07XHJcbiIsImV4cG9ydCBjb25zdCBTQVZFX1BPTFlHT05TID0gJ1NBVkVfUE9MWUdPTlMnO1xyXG5leHBvcnQgY29uc3QgVVBEQVRFX1BPTFlHT05TID0gJ1VQREFURV9QT0xZR09OUyc7XHJcblxyXG5leHBvcnQgY29uc3Qgc2F2ZVBvbHlnb25zID0gKHBvbHlnb25zKSA9PiB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGU6IFNBVkVfUE9MWUdPTlMsXHJcbiAgICBwYXlsb2FkOiB7XHJcbiAgICAgIHBvbHlnb25zLFxyXG4gICAgfSxcclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHVwZGF0ZVBvbHlnb25zID0gKGRlbHRhVGltZSkgPT4ge1xyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlOiBVUERBVEVfUE9MWUdPTlMsXHJcbiAgICBwYXlsb2FkOiB7XHJcbiAgICAgIGRlbHRhVGltZSxcclxuICAgIH0sXHJcbiAgfTtcclxufTtcclxuIiwiLy8gQ2FjaGUgaW1wbGVtZW50YXRpb24gYmFzZWQgb24gRXJpayBSYXNtdXNzZW4ncyBgbHJ1LW1lbW9pemVgOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2VyaWtyYXMvbHJ1LW1lbW9pemVcbnZhciBOT1RfRk9VTkQgPSAnTk9UX0ZPVU5EJztcblxuZnVuY3Rpb24gY3JlYXRlU2luZ2xldG9uQ2FjaGUoZXF1YWxzKSB7XG4gIHZhciBlbnRyeTtcbiAgcmV0dXJuIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgIGlmIChlbnRyeSAmJiBlcXVhbHMoZW50cnkua2V5LCBrZXkpKSB7XG4gICAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE5PVF9GT1VORDtcbiAgICB9LFxuICAgIHB1dDogZnVuY3Rpb24gcHV0KGtleSwgdmFsdWUpIHtcbiAgICAgIGVudHJ5ID0ge1xuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0RW50cmllczogZnVuY3Rpb24gZ2V0RW50cmllcygpIHtcbiAgICAgIHJldHVybiBlbnRyeSA/IFtlbnRyeV0gOiBbXTtcbiAgICB9LFxuICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIGVudHJ5ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTHJ1Q2FjaGUobWF4U2l6ZSwgZXF1YWxzKSB7XG4gIHZhciBlbnRyaWVzID0gW107XG5cbiAgZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIHZhciBjYWNoZUluZGV4ID0gZW50cmllcy5maW5kSW5kZXgoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICByZXR1cm4gZXF1YWxzKGtleSwgZW50cnkua2V5KTtcbiAgICB9KTsgLy8gV2UgZm91bmQgYSBjYWNoZWQgZW50cnlcblxuICAgIGlmIChjYWNoZUluZGV4ID4gLTEpIHtcbiAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbY2FjaGVJbmRleF07IC8vIENhY2hlZCBlbnRyeSBub3QgYXQgdG9wIG9mIGNhY2hlLCBtb3ZlIGl0IHRvIHRoZSB0b3BcblxuICAgICAgaWYgKGNhY2hlSW5kZXggPiAwKSB7XG4gICAgICAgIGVudHJpZXMuc3BsaWNlKGNhY2hlSW5kZXgsIDEpO1xuICAgICAgICBlbnRyaWVzLnVuc2hpZnQoZW50cnkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgfSAvLyBObyBlbnRyeSBmb3VuZCBpbiBjYWNoZSwgcmV0dXJuIHNlbnRpbmVsXG5cblxuICAgIHJldHVybiBOT1RfRk9VTkQ7XG4gIH1cblxuICBmdW5jdGlvbiBwdXQoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChnZXQoa2V5KSA9PT0gTk9UX0ZPVU5EKSB7XG4gICAgICAvLyBUT0RPIElzIHVuc2hpZnQgc2xvdz9cbiAgICAgIGVudHJpZXMudW5zaGlmdCh7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZW50cmllcy5sZW5ndGggPiBtYXhTaXplKSB7XG4gICAgICAgIGVudHJpZXMucG9wKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RW50cmllcygpIHtcbiAgICByZXR1cm4gZW50cmllcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGVudHJpZXMgPSBbXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2V0OiBnZXQsXG4gICAgcHV0OiBwdXQsXG4gICAgZ2V0RW50cmllczogZ2V0RW50cmllcyxcbiAgICBjbGVhcjogY2xlYXJcbiAgfTtcbn1cblxuZXhwb3J0IHZhciBkZWZhdWx0RXF1YWxpdHlDaGVjayA9IGZ1bmN0aW9uIGRlZmF1bHRFcXVhbGl0eUNoZWNrKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGI7XG59O1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNhY2hlS2V5Q29tcGFyYXRvcihlcXVhbGl0eUNoZWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiBhcmVBcmd1bWVudHNTaGFsbG93bHlFcXVhbChwcmV2LCBuZXh0KSB7XG4gICAgaWYgKHByZXYgPT09IG51bGwgfHwgbmV4dCA9PT0gbnVsbCB8fCBwcmV2Lmxlbmd0aCAhPT0gbmV4dC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIERvIHRoaXMgaW4gYSBmb3IgbG9vcCAoYW5kIG5vdCBhIGBmb3JFYWNoYCBvciBhbiBgZXZlcnlgKSBzbyB3ZSBjYW4gZGV0ZXJtaW5lIGVxdWFsaXR5IGFzIGZhc3QgYXMgcG9zc2libGUuXG5cblxuICAgIHZhciBsZW5ndGggPSBwcmV2Lmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghZXF1YWxpdHlDaGVjayhwcmV2W2ldLCBuZXh0W2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG4vLyBkZWZhdWx0TWVtb2l6ZSBub3cgc3VwcG9ydHMgYSBjb25maWd1cmFibGUgY2FjaGUgc2l6ZSB3aXRoIExSVSBiZWhhdmlvcixcbi8vIGFuZCBvcHRpb25hbCBjb21wYXJpc29uIG9mIHRoZSByZXN1bHQgdmFsdWUgd2l0aCBleGlzdGluZyB2YWx1ZXNcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0TWVtb2l6ZShmdW5jLCBlcXVhbGl0eUNoZWNrT3JPcHRpb25zKSB7XG4gIHZhciBwcm92aWRlZE9wdGlvbnMgPSB0eXBlb2YgZXF1YWxpdHlDaGVja09yT3B0aW9ucyA9PT0gJ29iamVjdCcgPyBlcXVhbGl0eUNoZWNrT3JPcHRpb25zIDoge1xuICAgIGVxdWFsaXR5Q2hlY2s6IGVxdWFsaXR5Q2hlY2tPck9wdGlvbnNcbiAgfTtcbiAgdmFyIF9wcm92aWRlZE9wdGlvbnMkZXF1YSA9IHByb3ZpZGVkT3B0aW9ucy5lcXVhbGl0eUNoZWNrLFxuICAgICAgZXF1YWxpdHlDaGVjayA9IF9wcm92aWRlZE9wdGlvbnMkZXF1YSA9PT0gdm9pZCAwID8gZGVmYXVsdEVxdWFsaXR5Q2hlY2sgOiBfcHJvdmlkZWRPcHRpb25zJGVxdWEsXG4gICAgICBfcHJvdmlkZWRPcHRpb25zJG1heFMgPSBwcm92aWRlZE9wdGlvbnMubWF4U2l6ZSxcbiAgICAgIG1heFNpemUgPSBfcHJvdmlkZWRPcHRpb25zJG1heFMgPT09IHZvaWQgMCA/IDEgOiBfcHJvdmlkZWRPcHRpb25zJG1heFMsXG4gICAgICByZXN1bHRFcXVhbGl0eUNoZWNrID0gcHJvdmlkZWRPcHRpb25zLnJlc3VsdEVxdWFsaXR5Q2hlY2s7XG4gIHZhciBjb21wYXJhdG9yID0gY3JlYXRlQ2FjaGVLZXlDb21wYXJhdG9yKGVxdWFsaXR5Q2hlY2spO1xuICB2YXIgY2FjaGUgPSBtYXhTaXplID09PSAxID8gY3JlYXRlU2luZ2xldG9uQ2FjaGUoY29tcGFyYXRvcikgOiBjcmVhdGVMcnVDYWNoZShtYXhTaXplLCBjb21wYXJhdG9yKTsgLy8gd2UgcmVmZXJlbmNlIGFyZ3VtZW50cyBpbnN0ZWFkIG9mIHNwcmVhZGluZyB0aGVtIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG5cbiAgZnVuY3Rpb24gbWVtb2l6ZWQoKSB7XG4gICAgdmFyIHZhbHVlID0gY2FjaGUuZ2V0KGFyZ3VtZW50cyk7XG5cbiAgICBpZiAodmFsdWUgPT09IE5PVF9GT1VORCkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdmFsdWUgPSBmdW5jLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cbiAgICAgIGlmIChyZXN1bHRFcXVhbGl0eUNoZWNrKSB7XG4gICAgICAgIHZhciBlbnRyaWVzID0gY2FjaGUuZ2V0RW50cmllcygpO1xuICAgICAgICB2YXIgbWF0Y2hpbmdFbnRyeSA9IGVudHJpZXMuZmluZChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0RXF1YWxpdHlDaGVjayhlbnRyeS52YWx1ZSwgdmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWF0Y2hpbmdFbnRyeSkge1xuICAgICAgICAgIHZhbHVlID0gbWF0Y2hpbmdFbnRyeS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYWNoZS5wdXQoYXJndW1lbnRzLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgbWVtb2l6ZWQuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FjaGUuY2xlYXIoKTtcbiAgfTtcblxuICByZXR1cm4gbWVtb2l6ZWQ7XG59IiwiaW1wb3J0IHsgZGVmYXVsdE1lbW9pemUsIGRlZmF1bHRFcXVhbGl0eUNoZWNrIH0gZnJvbSAnLi9kZWZhdWx0TWVtb2l6ZSc7XG5leHBvcnQgeyBkZWZhdWx0TWVtb2l6ZSwgZGVmYXVsdEVxdWFsaXR5Q2hlY2sgfTtcblxuZnVuY3Rpb24gZ2V0RGVwZW5kZW5jaWVzKGZ1bmNzKSB7XG4gIHZhciBkZXBlbmRlbmNpZXMgPSBBcnJheS5pc0FycmF5KGZ1bmNzWzBdKSA/IGZ1bmNzWzBdIDogZnVuY3M7XG5cbiAgaWYgKCFkZXBlbmRlbmNpZXMuZXZlcnkoZnVuY3Rpb24gKGRlcCkge1xuICAgIHJldHVybiB0eXBlb2YgZGVwID09PSAnZnVuY3Rpb24nO1xuICB9KSkge1xuICAgIHZhciBkZXBlbmRlbmN5VHlwZXMgPSBkZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZGVwID09PSAnZnVuY3Rpb24nID8gXCJmdW5jdGlvbiBcIiArIChkZXAubmFtZSB8fCAndW5uYW1lZCcpICsgXCIoKVwiIDogdHlwZW9mIGRlcDtcbiAgICB9KS5qb2luKCcsICcpO1xuICAgIHRocm93IG5ldyBFcnJvcihcImNyZWF0ZVNlbGVjdG9yIGV4cGVjdHMgYWxsIGlucHV0LXNlbGVjdG9ycyB0byBiZSBmdW5jdGlvbnMsIGJ1dCByZWNlaXZlZCB0aGUgZm9sbG93aW5nIHR5cGVzOiBbXCIgKyBkZXBlbmRlbmN5VHlwZXMgKyBcIl1cIik7XG4gIH1cblxuICByZXR1cm4gZGVwZW5kZW5jaWVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3JDcmVhdG9yKG1lbW9pemUpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1lbW9pemVPcHRpb25zRnJvbUFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIG1lbW9pemVPcHRpb25zRnJvbUFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIGNyZWF0ZVNlbGVjdG9yID0gZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3IoKSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jcyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgZnVuY3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICB2YXIgX3JlY29tcHV0YXRpb25zID0gMDtcblxuICAgIHZhciBfbGFzdFJlc3VsdDsgLy8gRHVlIHRvIHRoZSBpbnRyaWNhY2llcyBvZiByZXN0IHBhcmFtcywgd2UgY2FuJ3QgZG8gYW4gb3B0aW9uYWwgYXJnIGFmdGVyIGAuLi5mdW5jc2AuXG4gICAgLy8gU28sIHN0YXJ0IGJ5IGRlY2xhcmluZyB0aGUgZGVmYXVsdCB2YWx1ZSBoZXJlLlxuICAgIC8vIChBbmQgeWVzLCB0aGUgd29yZHMgJ21lbW9pemUnIGFuZCAnb3B0aW9ucycgYXBwZWFyIHRvbyBtYW55IHRpbWVzIGluIHRoaXMgbmV4dCBzZXF1ZW5jZS4pXG5cblxuICAgIHZhciBkaXJlY3RseVBhc3NlZE9wdGlvbnMgPSB7XG4gICAgICBtZW1vaXplT3B0aW9uczogdW5kZWZpbmVkXG4gICAgfTsgLy8gTm9ybWFsbHksIHRoZSByZXN1bHQgZnVuYyBvciBcIm91dHB1dCBzZWxlY3RvclwiIGlzIHRoZSBsYXN0IGFyZ1xuXG4gICAgdmFyIHJlc3VsdEZ1bmMgPSBmdW5jcy5wb3AoKTsgLy8gSWYgdGhlIHJlc3VsdCBmdW5jIGlzIGFjdHVhbGx5IGFuIF9vYmplY3RfLCBhc3N1bWUgaXQncyBvdXIgb3B0aW9ucyBvYmplY3RcblxuICAgIGlmICh0eXBlb2YgcmVzdWx0RnVuYyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGRpcmVjdGx5UGFzc2VkT3B0aW9ucyA9IHJlc3VsdEZ1bmM7IC8vIGFuZCBwb3AgdGhlIHJlYWwgcmVzdWx0IGZ1bmMgb2ZmXG5cbiAgICAgIHJlc3VsdEZ1bmMgPSBmdW5jcy5wb3AoKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJlc3VsdEZ1bmMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNyZWF0ZVNlbGVjdG9yIGV4cGVjdHMgYW4gb3V0cHV0IGZ1bmN0aW9uIGFmdGVyIHRoZSBpbnB1dHMsIGJ1dCByZWNlaXZlZDogW1wiICsgdHlwZW9mIHJlc3VsdEZ1bmMgKyBcIl1cIik7XG4gICAgfSAvLyBEZXRlcm1pbmUgd2hpY2ggc2V0IG9mIG9wdGlvbnMgd2UncmUgdXNpbmcuIFByZWZlciBvcHRpb25zIHBhc3NlZCBkaXJlY3RseSxcbiAgICAvLyBidXQgZmFsbCBiYWNrIHRvIG9wdGlvbnMgZ2l2ZW4gdG8gY3JlYXRlU2VsZWN0b3JDcmVhdG9yLlxuXG5cbiAgICB2YXIgX2RpcmVjdGx5UGFzc2VkT3B0aW9uID0gZGlyZWN0bHlQYXNzZWRPcHRpb25zLFxuICAgICAgICBfZGlyZWN0bHlQYXNzZWRPcHRpb24yID0gX2RpcmVjdGx5UGFzc2VkT3B0aW9uLm1lbW9pemVPcHRpb25zLFxuICAgICAgICBtZW1vaXplT3B0aW9ucyA9IF9kaXJlY3RseVBhc3NlZE9wdGlvbjIgPT09IHZvaWQgMCA/IG1lbW9pemVPcHRpb25zRnJvbUFyZ3MgOiBfZGlyZWN0bHlQYXNzZWRPcHRpb24yOyAvLyBTaW1wbGlmeWluZyBhc3N1bXB0aW9uOiBpdCdzIHVubGlrZWx5IHRoYXQgdGhlIGZpcnN0IG9wdGlvbnMgYXJnIG9mIHRoZSBwcm92aWRlZCBtZW1vaXplclxuICAgIC8vIGlzIGFuIGFycmF5LiBJbiBtb3N0IGxpYnMgSSd2ZSBsb29rZWQgYXQsIGl0J3MgYW4gZXF1YWxpdHkgZnVuY3Rpb24gb3Igb3B0aW9ucyBvYmplY3QuXG4gICAgLy8gQmFzZWQgb24gdGhhdCwgaWYgYG1lbW9pemVPcHRpb25zYCBfaXNfIGFuIGFycmF5LCB3ZSBhc3N1bWUgaXQncyBhIGZ1bGxcbiAgICAvLyB1c2VyLXByb3ZpZGVkIGFycmF5IG9mIG9wdGlvbnMuIE90aGVyd2lzZSwgaXQgbXVzdCBiZSBqdXN0IHRoZSBfZmlyc3RfIGFyZywgYW5kIHNvXG4gICAgLy8gd2Ugd3JhcCBpdCBpbiBhbiBhcnJheSBzbyB3ZSBjYW4gYXBwbHkgaXQuXG5cbiAgICB2YXIgZmluYWxNZW1vaXplT3B0aW9ucyA9IEFycmF5LmlzQXJyYXkobWVtb2l6ZU9wdGlvbnMpID8gbWVtb2l6ZU9wdGlvbnMgOiBbbWVtb2l6ZU9wdGlvbnNdO1xuICAgIHZhciBkZXBlbmRlbmNpZXMgPSBnZXREZXBlbmRlbmNpZXMoZnVuY3MpO1xuICAgIHZhciBtZW1vaXplZFJlc3VsdEZ1bmMgPSBtZW1vaXplLmFwcGx5KHZvaWQgMCwgW2Z1bmN0aW9uIHJlY29tcHV0YXRpb25XcmFwcGVyKCkge1xuICAgICAgX3JlY29tcHV0YXRpb25zKys7IC8vIGFwcGx5IGFyZ3VtZW50cyBpbnN0ZWFkIG9mIHNwcmVhZGluZyBmb3IgcGVyZm9ybWFuY2UuXG5cbiAgICAgIHJldHVybiByZXN1bHRGdW5jLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfV0uY29uY2F0KGZpbmFsTWVtb2l6ZU9wdGlvbnMpKTsgLy8gSWYgYSBzZWxlY3RvciBpcyBjYWxsZWQgd2l0aCB0aGUgZXhhY3Qgc2FtZSBhcmd1bWVudHMgd2UgZG9uJ3QgbmVlZCB0byB0cmF2ZXJzZSBvdXIgZGVwZW5kZW5jaWVzIGFnYWluLlxuXG4gICAgdmFyIHNlbGVjdG9yID0gbWVtb2l6ZShmdW5jdGlvbiBkZXBlbmRlbmNpZXNDaGVja2VyKCkge1xuICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgdmFyIGxlbmd0aCA9IGRlcGVuZGVuY2llcy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gYXBwbHkgYXJndW1lbnRzIGluc3RlYWQgb2Ygc3ByZWFkaW5nIGFuZCBtdXRhdGUgYSBsb2NhbCBsaXN0IG9mIHBhcmFtcyBmb3IgcGVyZm9ybWFuY2UuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcGFyYW1zLnB1c2goZGVwZW5kZW5jaWVzW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgfSAvLyBhcHBseSBhcmd1bWVudHMgaW5zdGVhZCBvZiBzcHJlYWRpbmcgZm9yIHBlcmZvcm1hbmNlLlxuXG5cbiAgICAgIF9sYXN0UmVzdWx0ID0gbWVtb2l6ZWRSZXN1bHRGdW5jLmFwcGx5KG51bGwsIHBhcmFtcyk7XG4gICAgICByZXR1cm4gX2xhc3RSZXN1bHQ7XG4gICAgfSk7XG4gICAgT2JqZWN0LmFzc2lnbihzZWxlY3Rvciwge1xuICAgICAgcmVzdWx0RnVuYzogcmVzdWx0RnVuYyxcbiAgICAgIG1lbW9pemVkUmVzdWx0RnVuYzogbWVtb2l6ZWRSZXN1bHRGdW5jLFxuICAgICAgZGVwZW5kZW5jaWVzOiBkZXBlbmRlbmNpZXMsXG4gICAgICBsYXN0UmVzdWx0OiBmdW5jdGlvbiBsYXN0UmVzdWx0KCkge1xuICAgICAgICByZXR1cm4gX2xhc3RSZXN1bHQ7XG4gICAgICB9LFxuICAgICAgcmVjb21wdXRhdGlvbnM6IGZ1bmN0aW9uIHJlY29tcHV0YXRpb25zKCkge1xuICAgICAgICByZXR1cm4gX3JlY29tcHV0YXRpb25zO1xuICAgICAgfSxcbiAgICAgIHJlc2V0UmVjb21wdXRhdGlvbnM6IGZ1bmN0aW9uIHJlc2V0UmVjb21wdXRhdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBfcmVjb21wdXRhdGlvbnMgPSAwO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzZWxlY3RvcjtcbiAgfTsgLy8gQHRzLWlnbm9yZVxuXG5cbiAgcmV0dXJuIGNyZWF0ZVNlbGVjdG9yO1xufVxuZXhwb3J0IHZhciBjcmVhdGVTZWxlY3RvciA9IC8qICNfX1BVUkVfXyAqL2NyZWF0ZVNlbGVjdG9yQ3JlYXRvcihkZWZhdWx0TWVtb2l6ZSk7XG4vLyBNYW51YWwgZGVmaW5pdGlvbiBvZiBzdGF0ZSBhbmQgb3V0cHV0IGFyZ3VtZW50c1xuZXhwb3J0IHZhciBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3Ioc2VsZWN0b3JzLCBzZWxlY3RvckNyZWF0b3IpIHtcbiAgaWYgKHNlbGVjdG9yQ3JlYXRvciA9PT0gdm9pZCAwKSB7XG4gICAgc2VsZWN0b3JDcmVhdG9yID0gY3JlYXRlU2VsZWN0b3I7XG4gIH1cblxuICBpZiAodHlwZW9mIHNlbGVjdG9ycyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvciBleHBlY3RzIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCAnICsgKFwid2hlcmUgZWFjaCBwcm9wZXJ0eSBpcyBhIHNlbGVjdG9yLCBpbnN0ZWFkIHJlY2VpdmVkIGEgXCIgKyB0eXBlb2Ygc2VsZWN0b3JzKSk7XG4gIH1cblxuICB2YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzKHNlbGVjdG9ycyk7XG4gIHZhciByZXN1bHRTZWxlY3RvciA9IHNlbGVjdG9yQ3JlYXRvciggLy8gQHRzLWlnbm9yZVxuICBvYmplY3RLZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yc1trZXldO1xuICB9KSwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgdmFsdWVzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICB2YWx1ZXNbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzLnJlZHVjZShmdW5jdGlvbiAoY29tcG9zaXRpb24sIHZhbHVlLCBpbmRleCkge1xuICAgICAgY29tcG9zaXRpb25bb2JqZWN0S2V5c1tpbmRleF1dID0gdmFsdWU7XG4gICAgICByZXR1cm4gY29tcG9zaXRpb247XG4gICAgfSwge30pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdFNlbGVjdG9yO1xufTsiLCJpbXBvcnQgeyBjcmVhdGVTZWxlY3RvciB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xyXG5pbXBvcnQgSW1tdXRhYmxlIGZyb20gJ2ltbXV0YWJsZSc7XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0UG9seWdvbnMgPSAoc3RhdGUpID0+IHtcclxuICByZXR1cm4gc3RhdGUucG9seWdvbnM7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0UG9seWdvbkxpc3QgPSBjcmVhdGVTZWxlY3RvcihcclxuICBnZXRQb2x5Z29ucyxcclxuICAocG9seWdvbnMpID0+IHtcclxuICAgIHJldHVybiBwb2x5Z29ucy5nZXQoJ3BvbHlnb25zJyk7XHJcbiAgfSxcclxuKTtcclxuIiwiaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3IgfSBmcm9tICdAcmVkdXhqcy90b29sa2l0JztcclxuaW1wb3J0IEltbXV0YWJsZSBmcm9tICdpbW11dGFibGUnO1xyXG5cclxuaW1wb3J0IHsgVmVjdG9yMiwgTGluZSB9IGZyb20gJy4uL21hdGgnO1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldFNpbXVsYXRpb25TdGF0ZSA9IChzdGF0ZSkgPT4ge1xyXG4gIHJldHVybiBzdGF0ZS5zaW11bGF0aW9uO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldFN0YWdlQm91bmRzID0gY3JlYXRlU2VsZWN0b3IoXHJcbiAgZ2V0U2ltdWxhdGlvblN0YXRlLFxyXG4gIChzaW11bGF0aW9uU3RhdGUpID0+IHtcclxuICAgIHJldHVybiBJbW11dGFibGUuZnJvbUpTKHtcclxuICAgICAgd2lkdGg6IHNpbXVsYXRpb25TdGF0ZS5nZXQoJ3dpZHRoJyksXHJcbiAgICAgIGhlaWdodDogc2ltdWxhdGlvblN0YXRlLmdldCgnaGVpZ2h0JyksXHJcbiAgICB9KTtcclxuICB9LFxyXG4pO1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldFN0YWdlQm9yZGVyaW5nTGluZXMgPSBjcmVhdGVTZWxlY3RvcihcclxuICBnZXRTdGFnZUJvdW5kcyxcclxuICAoYm91bmRzKSA9PiB7XHJcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGJvdW5kcy50b0pTKCk7XHJcblxyXG4gICAgY29uc3QgdG9wTGluZSA9IG5ldyBMaW5lKHtcclxuICAgICAgcG9pbnQxOiBuZXcgVmVjdG9yMih7IHg6IDAsIHk6IDAgfSksXHJcbiAgICAgIHBvaW50MjogbmV3IFZlY3RvcjIoeyB4OiB3aWR0aCwgeTogMCB9KSxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgcmlnaHRMaW5lID0gbmV3IExpbmUoe1xyXG4gICAgICBwb2ludDE6IG5ldyBWZWN0b3IyKHsgeDogd2lkdGgsIHk6IDAgfSksXHJcbiAgICAgIHBvaW50MjogbmV3IFZlY3RvcjIoeyB4OiB3aWR0aCwgeTogaGVpZ2h0IH0pLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBib3R0b21MaW5lID0gbmV3IExpbmUoe1xyXG4gICAgICBwb2ludDE6IG5ldyBWZWN0b3IyKHsgeDogMCwgeTogaGVpZ2h0IH0pLFxyXG4gICAgICBwb2ludDI6IG5ldyBWZWN0b3IyKHsgeDogd2lkdGgsIHk6IGhlaWdodCB9KSxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgbGVmdExpbmUgPSBuZXcgTGluZSh7XHJcbiAgICAgIHBvaW50MTogbmV3IFZlY3RvcjIoeyB4OiAwLCB5OiAwIH0pLFxyXG4gICAgICBwb2ludDI6IG5ldyBWZWN0b3IyKHsgeDogMCwgeTogaGVpZ2h0IH0pLFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIEltbXV0YWJsZS5mcm9tSlMoe1xyXG4gICAgICB0b3BMaW5lLFxyXG4gICAgICByaWdodExpbmUsXHJcbiAgICAgIGJvdHRvbUxpbmUsXHJcbiAgICAgIGxlZnRMaW5lLFxyXG4gICAgfSk7XHJcbiAgfSxcclxuKTtcclxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IE1lYXN1cmUgZnJvbSAncmVhY3QtbWVhc3VyZSc7XHJcbmltcG9ydCBzdHlsZWQgZnJvbSAnc3R5bGVkLWNvbXBvbmVudHMnO1xyXG5pbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5cclxuaW1wb3J0IHsgTGF5ZXIsIFN0YWdlIH0gZnJvbSAncmVhY3Qta29udmEnO1xyXG5pbXBvcnQgSW1tdXRhYmxlIGZyb20gJ2ltbXV0YWJsZSc7XHJcblxyXG5pbXBvcnQgeyBLb252YVBvbHlnb24gfSBmcm9tICcuL0tvbnZhUG9seWdvbic7XHJcblxyXG5pbXBvcnQgeyBzZXRTdGFnZUJvdW5kcyB9IGZyb20gJy4uL2FjdGlvbnMvc2ltdWxhdGlvbic7XHJcbmltcG9ydCB7IHVwZGF0ZVBvbHlnb25zIH0gZnJvbSAnLi4vYWN0aW9ucy9wb2x5Z29ucyc7XHJcblxyXG5pbXBvcnQgeyBnZXRQb2x5Z29uTGlzdCB9IGZyb20gJy4uL3NlbGVjdG9ycy9wb2x5Z29ucyc7XHJcbmltcG9ydCB7IGdldFN0YWdlQm91bmRzIH0gZnJvbSAnLi4vc2VsZWN0b3JzL3NpbXVsYXRpb24nO1xyXG5cclxuY29uc3QgUGFkZGVkQ29udGFpbmVyID0gc3R5bGVkLmRpdmBcclxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZGRkO1xyXG4gIG1hcmdpbjogMzBweDtcclxuYDtcclxuXHJcbmNvbnN0IEZSQU1FX0xFTkdUSCA9IDEwMDAgLyA2MDtcclxuXHJcbmNsYXNzIFNpbXVsYXRpb25WaWV3Q2xzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgc3VwZXIocHJvcHMpO1xyXG4gICAgdGhpcy5sYXN0VGltZSA9IDA7XHJcbiAgfVxyXG5cclxuICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGVGcmFtZSk7XHJcbiAgfVxyXG5cclxuICBhbmltYXRlRnJhbWUgPSAobm93KSA9PiB7XHJcbiAgICBjb25zdCB7IHVwZGF0ZVBvbHlnb25zIH0gPSB0aGlzLnByb3BzO1xyXG5cclxuICAgIGNvbnN0IGRlbHRhID0gbm93IC0gdGhpcy5sYXN0VGltZTtcclxuICAgIGlmIChkZWx0YSA+PSBGUkFNRV9MRU5HVEgpIHtcclxuICAgICAgdXBkYXRlUG9seWdvbnMoZGVsdGEpO1xyXG4gICAgICB0aGlzLmxhc3RUaW1lID0gbm93O1xyXG4gICAgfVxyXG5cclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGVGcmFtZSk7XHJcbiAgfTtcclxuXHJcbiAgcmVuZGVyKCkge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBib3VuZHMsXHJcbiAgICAgIHBvbHlnb25zLFxyXG4gICAgICBzZXRTdGFnZUJvdW5kcyxcclxuICAgIH0gPSB0aGlzLnByb3BzO1xyXG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBib3VuZHMudG9KUygpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgIDxQYWRkZWRDb250YWluZXI+XHJcbiAgICAgICAgPE1lYXN1cmVcclxuICAgICAgICAgIGJvdW5kc1xyXG4gICAgICAgICAgb25SZXNpemU9eyhyZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IF93aWR0aCA9IHJlY3QuYm91bmRzLndpZHRoO1xyXG4gICAgICAgICAgICBpZiAoX3dpZHRoICE9PSB3aWR0aCkge1xyXG4gICAgICAgICAgICAgIHNldFN0YWdlQm91bmRzKF93aWR0aCwgX3dpZHRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfX1cclxuICAgICAgICA+XHJcbiAgICAgICAgICB7KHsgbWVhc3VyZVJlZiB9KSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgPGRpdiByZWY9e21lYXN1cmVSZWZ9PlxyXG4gICAgICAgICAgICAgICAgPFN0YWdlIHdpZHRoPXt3aWR0aH0gaGVpZ2h0PXtoZWlnaHR9PlxyXG4gICAgICAgICAgICAgICAgICA8TGF5ZXI+XHJcbiAgICAgICAgICAgICAgICAgICAge3BvbHlnb25zLm1hcCgocG9seWdvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgPEtvbnZhUG9seWdvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGtleT17cG9seWdvbi5nZXQoJ2lkJyl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbj17cG9seWdvbi5nZXQoJ3BvbHlnb24nKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbj17cG9seWdvbi5nZXQoJ3Bvc2l0aW9uJyl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhZ2VXaWR0aD17d2lkdGh9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhZ2VIZWlnaHQ9e2hlaWdodH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSl9XHJcbiAgICAgICAgICAgICAgICAgIDwvTGF5ZXI+XHJcbiAgICAgICAgICAgICAgICA8L1N0YWdlPlxyXG4gICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfX1cclxuICAgICAgICA8L01lYXN1cmU+XHJcbiAgICAgIDwvUGFkZGVkQ29udGFpbmVyPlxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcblNpbXVsYXRpb25WaWV3Q2xzLnByb3BUeXBlcyA9IHtcclxuICBib3VuZHM6IFByb3BUeXBlcy5pbnN0YW5jZU9mKEltbXV0YWJsZS5NYXApLFxyXG4gIHBvbHlnb25zOiBQcm9wVHlwZXMuaW5zdGFuY2VPZihJbW11dGFibGUuTGlzdCksXHJcbiAgc2V0U3RhZ2VCb3VuZHM6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXHJcbiAgdXBkYXRlUG9seWdvbnM6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXHJcbn07XHJcblxyXG5TaW11bGF0aW9uVmlld0Nscy5kZWZhdWx0UHJvcHMgPSB7XHJcbiAgYm91bmRzOiB7XHJcbiAgICB3aWR0aDogMCxcclxuICAgIGhlaWdodDogMCxcclxuICB9LFxyXG4gIHBvbHlnb25zOiBJbW11dGFibGUuTGlzdCgpLFxyXG59O1xyXG5cclxuY29uc3QgbWFwU3RhdGVUb1Byb3BzID0gKHN0YXRlKSA9PiB7XHJcbiAgcmV0dXJuIHtcclxuICAgIGJvdW5kczogZ2V0U3RhZ2VCb3VuZHMoc3RhdGUpLFxyXG4gICAgcG9seWdvbnM6IGdldFBvbHlnb25MaXN0KHN0YXRlKSxcclxuICB9O1xyXG59O1xyXG5cclxuY29uc3QgbWFwRGlzcGF0Y2hUb1Byb3BzID0gKGRpc3BhdGNoKSA9PiB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHNldFN0YWdlQm91bmRzOiAod2lkdGgsIGhlaWdodCkgPT4ge1xyXG4gICAgICByZXR1cm4gZGlzcGF0Y2goc2V0U3RhZ2VCb3VuZHMod2lkdGgsIGhlaWdodCkpO1xyXG4gICAgfSxcclxuICAgIHVwZGF0ZVBvbHlnb25zOiAoZGVsdGEpID0+IHtcclxuICAgICAgcmV0dXJuIGRpc3BhdGNoKHVwZGF0ZVBvbHlnb25zKGRlbHRhKSk7XHJcbiAgICB9LFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgU2ltdWxhdGlvblZpZXcgPSBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzKShTaW11bGF0aW9uVmlld0Nscyk7XHJcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBzdHlsZWQgZnJvbSAnc3R5bGVkLWNvbXBvbmVudHMnO1xyXG5cclxuaW1wb3J0ICogYXMgdWlDb25zdGFudHMgZnJvbSAnLi4vY29uc3RhbnRzL3VpQ29uc3RhbnRzJztcclxuXHJcbmNvbnN0IGRpYWxCYXNlRGltZW5zaW9ucyA9IGAke3VpQ29uc3RhbnRzLmRpYWxCYXNlRGltZW5zaW9uc1B4fXB4YDtcclxuXHJcbmV4cG9ydCBjb25zdCBEaWFsQmFzZSA9IHN0eWxlZC5zcGFuYFxyXG4gIGJvcmRlcjogMnB4IHNvbGlkICNmZmY7XHJcbiAgYm9yZGVyLXJhZGl1czogMTAwJTtcclxuXHJcbiAgZGlzcGxheTogZmxleDtcclxuICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xyXG5cclxuICBjb2xvcjogI2ZmZjtcclxuICBmb250LXNpemU6ICR7KHByb3BzKSA9PiB7IHJldHVybiBwcm9wcy5mb250U2l6ZTsgfX07XHJcblxyXG4gIHdpZHRoOiAke2RpYWxCYXNlRGltZW5zaW9uc307XHJcbiAgaGVpZ2h0OiAke2RpYWxCYXNlRGltZW5zaW9uc307XHJcbmA7XHJcblxyXG5EaWFsQmFzZS5kZWZhdWx0UHJvcHMgPSB7XHJcbiAgZm9udFNpemU6ICc2MHB4JyxcclxufTtcclxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHN0eWxlZCBmcm9tICdzdHlsZWQtY29tcG9uZW50cyc7XHJcbmltcG9ydCBwcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcblxyXG5pbXBvcnQgeyBEaWFsQmFzZSB9IGZyb20gJy4vRGlhbEJhc2UnO1xyXG5cclxuZXhwb3J0IGNvbnN0IFNjYWxhckRpYWwgPSAoeyB2YWx1ZSwgLi4ucHJvcHMgfSkgPT4ge1xyXG4gIHJldHVybiAoXHJcbiAgICA8RGlhbEJhc2U+e3ZhbHVlfTwvRGlhbEJhc2U+XHJcbiAgKTtcclxufTtcclxuXHJcblNjYWxhckRpYWwucHJvcFR5cGVzID0ge1xyXG4gIHZhbHVlOiBwcm9wVHlwZXMubnVtYmVyLFxyXG59O1xyXG5cclxuU2NhbGFyRGlhbC5kZWZhdWx0UHJvcHMgPSB7XHJcbiAgdmFsdWU6IDAsXHJcbn07XHJcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBwcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcblxyXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aCc7XHJcblxyXG5pbXBvcnQgeyBEaWFsQmFzZSB9IGZyb20gJy4vRGlhbEJhc2UnO1xyXG5cclxuZXhwb3J0IGNvbnN0IENvb3Jkc0RpYWwgPSAoeyBjb29yZHMsIC4uLnByb3BzIH0pID0+IHtcclxuICBpZiAoIWNvb3Jkcykge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgPERpYWxCYXNlIC8+XHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxEaWFsQmFzZSBmb250U2l6ZT1cIjIwcHhcIj5cclxuICAgICAge2AoJHtNYXRoLnJvdW5kKGNvb3Jkcy54KX0sJHtNYXRoLnJvdW5kKGNvb3Jkcy55KX0pYH1cclxuICAgIDwvRGlhbEJhc2U+XHJcbiAgKTtcclxufTtcclxuXHJcbkNvb3Jkc0RpYWwucHJvcFR5cGVzID0ge1xyXG4gIGNvb3JkczogcHJvcFR5cGVzLmluc3RhbmNlT2YoVmVjdG9yMiksXHJcbn07XHJcblxyXG5Db29yZHNEaWFsLmRlZmF1bHRQcm9wcyA9IHtcclxuICBjb29yZHM6IG5ldyBWZWN0b3IyKHsgeDogMCwgeTogMCB9KSxcclxufTtcclxuIiwiaW1wb3J0IFJlYWN0LCB7IHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IHN0eWxlZCBmcm9tICdzdHlsZWQtY29tcG9uZW50cyc7XHJcblxyXG5pbXBvcnQge1xyXG4gIFN0YWdlLFxyXG4gIExheWVyLFxyXG4gIENpcmNsZSxcclxuICBBcmMsXHJcbiAgVGV4dCxcclxufSBmcm9tICdyZWFjdC1rb252YSc7XHJcblxyXG5pbXBvcnQgKiBhcyB1aUNvbnN0YW50cyBmcm9tICcuLi9jb25zdGFudHMvdWlDb25zdGFudHMnO1xyXG5cclxuaW1wb3J0IHsgRGlhbEJhc2UgfSBmcm9tICcuL0RpYWxCYXNlJztcclxuXHJcbmV4cG9ydCBjb25zdCBBbmdsZURpYWwgPSAoeyBhbmdsZSwgLi4ucHJvcHMgfSkgPT4ge1xyXG4gIGNvbnN0IHRleHQgPSB1c2VSZWYobnVsbCk7XHJcblxyXG4gIGNvbnN0IGRpbUhhbHZlZCA9IHVpQ29uc3RhbnRzLmRpYWxCYXNlRGltZW5zaW9uc1B4IC8gMjtcclxuXHJcbiAgY29uc3QgX2FuZ2xlID0gKGFuZ2xlIDwgMCkgPyAoMzYwICsgYW5nbGUpIDogYW5nbGU7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8RGlhbEJhc2U+XHJcbiAgICAgIDxTdGFnZVxyXG4gICAgICAgIHdpZHRoPXt1aUNvbnN0YW50cy5kaWFsQmFzZURpbWVuc2lvbnNQeH1cclxuICAgICAgICBoZWlnaHQ9e3VpQ29uc3RhbnRzLmRpYWxCYXNlRGltZW5zaW9uc1B4fVxyXG4gICAgICA+XHJcbiAgICAgICAgPExheWVyPlxyXG4gICAgICAgICAgPENpcmNsZVxyXG4gICAgICAgICAgICB4PXtkaW1IYWx2ZWR9XHJcbiAgICAgICAgICAgIHk9e2RpbUhhbHZlZH1cclxuICAgICAgICAgICAgcmFkaXVzPXtkaW1IYWx2ZWR9XHJcbiAgICAgICAgICAgIGZpbGw9XCIjZmZmXCJcclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgICA8QXJjXHJcbiAgICAgICAgICAgIHg9e2RpbUhhbHZlZH1cclxuICAgICAgICAgICAgeT17ZGltSGFsdmVkfVxyXG4gICAgICAgICAgICBpbm5lclJhZGl1cz17ZGltSGFsdmVkIC8gMn1cclxuICAgICAgICAgICAgb3V0ZXJSYWRpdXM9e2RpbUhhbHZlZH1cclxuICAgICAgICAgICAgYW5nbGU9e19hbmdsZX1cclxuICAgICAgICAgICAgcm90YXRpb25EZWc9ey05MH1cclxuICAgICAgICAgICAgZmlsbD17dWlDb25zdGFudHMubGlnaHRCbHVlfVxyXG4gICAgICAgICAgLz5cclxuICAgICAgICAgIDxUZXh0XHJcbiAgICAgICAgICAgIHJlZj17dGV4dH1cclxuICAgICAgICAgICAgeD17ZGltSGFsdmVkfVxyXG4gICAgICAgICAgICB5PXtkaW1IYWx2ZWR9XHJcbiAgICAgICAgICAgIG9mZnNldFg9eyh0ZXh0ICYmIHRleHQuY3VycmVudCkgPyAodGV4dC5jdXJyZW50LndpZHRoKCkgLyAyKSA6IDB9XHJcbiAgICAgICAgICAgIG9mZnNldFk9ezEwfVxyXG4gICAgICAgICAgICB0ZXh0PXtNYXRoLnJvdW5kKF9hbmdsZSkudG9TdHJpbmcoKX1cclxuICAgICAgICAgICAgZm9udFNpemU9ezIwfVxyXG4gICAgICAgICAgICBmb250RmFtaWx5PVwibW9ub3NwYWNlXCJcclxuICAgICAgICAgICAgZmlsbD17dWlDb25zdGFudHMuZGFya31cclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgPC9MYXllcj5cclxuICAgICAgPC9TdGFnZT5cclxuICAgIDwvRGlhbEJhc2U+XHJcbiAgKVxyXG59O1xyXG5cclxuQW5nbGVEaWFsLnByb3BUeXBlcyA9IHtcclxuICBhbmdsZTogcHJvcFR5cGVzLm51bWJlcixcclxufTtcclxuXHJcbkFuZ2xlRGlhbC5kZWZhdWx0UHJvcHMgPSB7XHJcbiAgYW5nbGU6IDAsXHJcbn07XHJcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBwcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcblxyXG5pbXBvcnQge1xyXG4gIFN0YWdlLFxyXG4gIExheWVyLFxyXG4gIENpcmNsZSxcclxuICBUZXh0LFxyXG4gIExpbmUsXHJcbn0gZnJvbSAncmVhY3Qta29udmEnO1xyXG5cclxuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgnO1xyXG5cclxuaW1wb3J0ICogYXMgdWlDb25zdGFudHMgZnJvbSAnLi4vY29uc3RhbnRzL3VpQ29uc3RhbnRzJztcclxuXHJcbmltcG9ydCB7IERpYWxCYXNlIH0gZnJvbSAnLi9EaWFsQmFzZSc7XHJcblxyXG5jb25zdCBtYXhWZWN0b3JMZW5ndGggPSB1aUNvbnN0YW50cy5kaWFsQmFzZURpbWVuc2lvbnNQeCAvIDI7XHJcblxyXG5leHBvcnQgY2xhc3MgVmVjdG9yRGlhbCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XHJcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgIHN1cGVyKHByb3BzKTtcclxuXHJcbiAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICByYW5nZTogNSxcclxuICAgICAgbGVuZ3RoRGl2aWRlcjogNSAvIG1heFZlY3Rvckxlbmd0aCxcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy50ZXh0ID0gUmVhY3QuY3JlYXRlUmVmKCk7XHJcbiAgfVxyXG5cclxuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XHJcbiAgICBjb25zdCB7IHZlY3RvcjogeyBtYWduaXR1ZGUgfSB9ID0gdGhpcy5wcm9wcztcclxuICAgIGNvbnN0IHsgcmFuZ2UgfSA9IHRoaXMuc3RhdGU7XHJcblxyXG4gICAgaWYgKG1hZ25pdHVkZSA+IHJhbmdlKSB7XHJcbiAgICAgIGNvbnN0IGxlbmd0aERpdmlkZXIgPSBtYWduaXR1ZGUgLyBtYXhWZWN0b3JMZW5ndGg7XHJcblxyXG4gICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICByYW5nZTogbWFnbml0dWRlLFxyXG4gICAgICAgIGxlbmd0aERpdmlkZXIsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmVuZGVyKCkge1xyXG4gICAgY29uc3QgeyB2ZWN0b3IgfSA9IHRoaXMucHJvcHM7XHJcbiAgICBjb25zdCB7IHJhbmdlLCBsZW5ndGhEaXZpZGVyIH0gPSB0aGlzLnN0YXRlO1xyXG5cclxuICAgIGNvbnN0IGRpbUhhbHZlZCA9IHVpQ29uc3RhbnRzLmRpYWxCYXNlRGltZW5zaW9uc1B4IC8gMjtcclxuICAgIGNvbnN0IHNjYWxlZFZlY3RvciA9IHZlY3Rvci5kaXZpZGVTY2FsYXIobGVuZ3RoRGl2aWRlcik7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgPERpYWxCYXNlPlxyXG4gICAgICAgIDxTdGFnZVxyXG4gICAgICAgICAgd2lkdGg9e3VpQ29uc3RhbnRzLmRpYWxCYXNlRGltZW5zaW9uc1B4fVxyXG4gICAgICAgICAgaGVpZ2h0PXt1aUNvbnN0YW50cy5kaWFsQmFzZURpbWVuc2lvbnNQeH1cclxuICAgICAgICA+XHJcbiAgICAgICAgICA8TGF5ZXI+XHJcbiAgICAgICAgICAgIDxDaXJjbGVcclxuICAgICAgICAgICAgICB4PXtkaW1IYWx2ZWR9XHJcbiAgICAgICAgICAgICAgeT17ZGltSGFsdmVkfVxyXG4gICAgICAgICAgICAgIHJhZGl1cz17ZGltSGFsdmVkfVxyXG4gICAgICAgICAgICAgIGZpbGw9XCIjZmZmXCJcclxuICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPENpcmNsZVxyXG4gICAgICAgICAgICAgIHg9e2RpbUhhbHZlZH1cclxuICAgICAgICAgICAgICB5PXtkaW1IYWx2ZWR9XHJcbiAgICAgICAgICAgICAgcmFkaXVzPXtkaW1IYWx2ZWQgLyAyfVxyXG4gICAgICAgICAgICAgIHN0cm9rZT17dWlDb25zdGFudHMuZGFya31cclxuICAgICAgICAgICAgICBzdHJva2VXaWR0aD17MX1cclxuICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPFRleHRcclxuICAgICAgICAgICAgICByZWY9e3RoaXMudGV4dH1cclxuICAgICAgICAgICAgICB4PXtkaW1IYWx2ZWR9XHJcbiAgICAgICAgICAgICAgeT17NX1cclxuICAgICAgICAgICAgICBvZmZzZXRYPXsodGhpcy50ZXh0ICYmIHRoaXMudGV4dC5jdXJyZW50KSA/ICh0aGlzLnRleHQuY3VycmVudC53aWR0aCgpIC8gMikgOiAwfVxyXG4gICAgICAgICAgICAgIHRleHQ9e01hdGgucm91bmQocmFuZ2UpLnRvU3RyaW5nKCl9XHJcbiAgICAgICAgICAgICAgZm9udFNpemU9ezEwfVxyXG4gICAgICAgICAgICAgIGZvbnRGYW1pbHk9XCJtb25vc3BhY2VcIlxyXG4gICAgICAgICAgICAgIGZpbGw9e3VpQ29uc3RhbnRzLmRhcmt9XHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDxMaW5lXHJcbiAgICAgICAgICAgICAgcG9pbnRzPXtbXHJcbiAgICAgICAgICAgICAgICBkaW1IYWx2ZWQsXHJcbiAgICAgICAgICAgICAgICBkaW1IYWx2ZWQsXHJcbiAgICAgICAgICAgICAgICBzY2FsZWRWZWN0b3IueCArIGRpbUhhbHZlZCxcclxuICAgICAgICAgICAgICAgIHNjYWxlZFZlY3Rvci55ICsgZGltSGFsdmVkLFxyXG4gICAgICAgICAgICAgIF19XHJcbiAgICAgICAgICAgICAgc3Ryb2tlPXt1aUNvbnN0YW50cy5saWdodEJsdWV9XHJcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezJ9XHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICA8L0xheWVyPlxyXG4gICAgICAgIDwvU3RhZ2U+XHJcbiAgICAgIDwvRGlhbEJhc2U+XHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxuVmVjdG9yRGlhbC5wcm9wVHlwZXMgPSB7XHJcbiAgdmVjdG9yOiBwcm9wVHlwZXMuaW5zdGFuY2VPZihWZWN0b3IyKSxcclxufTtcclxuXHJcblZlY3RvckRpYWwuZGVmYXVsdFByb3BzID0ge1xyXG4gIHZlY3RvcjogbmV3IFZlY3RvcjIoeyB4OiAwLCB5OiAwIH0pLFxyXG59O1xyXG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgc3R5bGVkIGZyb20gJ3N0eWxlZC1jb21wb25lbnRzJztcclxuaW1wb3J0IHByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuXHJcbmltcG9ydCB7IFNjYWxhckRpYWwgfSBmcm9tICcuL1NjYWxhckRpYWwnO1xyXG5pbXBvcnQgeyBDb29yZHNEaWFsIH0gZnJvbSAnLi9Db29yZHNEaWFsJztcclxuaW1wb3J0IHsgQW5nbGVEaWFsIH0gZnJvbSAnLi9BbmdsZURpYWwnO1xyXG5pbXBvcnQgeyBWZWN0b3JEaWFsIH0gZnJvbSAnLi9WZWN0b3JEaWFsJztcclxuXHJcbmltcG9ydCAqIGFzIHVpQ29uc3RhbnRzIGZyb20gJy4uL2NvbnN0YW50cy91aUNvbnN0YW50cyc7XHJcblxyXG5jb25zdCB7IERJQUxfVFlQRVMgfSA9IHVpQ29uc3RhbnRzO1xyXG5cclxuY29uc3QgRGlhbExheW91dCA9IHN0eWxlZC5kaXZgXHJcbiAgZGlzcGxheTogaW5saW5lLWZsZXg7XHJcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcclxuXHJcbiAgbWFyZ2luOiA1cHg7XHJcbmA7XHJcblxyXG5jb25zdCBEaWFsUGFuZWwgPSBzdHlsZWQuZGl2YFxyXG4gIGJvcmRlcjogMXB4IHNvbGlkICR7dWlDb25zdGFudHMuZGFya307XHJcblxyXG4gIGRpc3BsYXk6IGZsZXg7XHJcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XHJcblxyXG4gIGJhY2tncm91bmQtY29sb3I6ICR7dWlDb25zdGFudHMuZGFya0JsdWV9O1xyXG4gIGNvbG9yOiAjZmZmO1xyXG5cclxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xyXG4gIHBhZGRpbmc6IDAuNXJlbTtcclxuICB3aWR0aDogJHt1aUNvbnN0YW50cy5kaWFsRGltZW5zaW9uc307XHJcbmA7XHJcblxyXG5jb25zdCBEaWFsSGVhZGVyID0gc3R5bGVkKERpYWxQYW5lbClgXHJcbiAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogJHt1aUNvbnN0YW50cy5ib3JkZXJSYWRpdXN9O1xyXG4gIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAke3VpQ29uc3RhbnRzLmJvcmRlclJhZGl1c307XHJcbmA7XHJcblxyXG5jb25zdCBEaWFsQ29udGFpbmVyID0gc3R5bGVkLmRpdmBcclxuICBiYWNrZ3JvdW5kLWNvbG9yOiAke3VpQ29uc3RhbnRzLmRhcmtCbHVlfTtcclxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xyXG5cclxuICBib3JkZXItbGVmdDogMXB4IHNvbGlkICR7dWlDb25zdGFudHMuZGFya307XHJcbiAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgJHt1aUNvbnN0YW50cy5kYXJrfTtcclxuXHJcbiAgZGlzcGxheTogZmxleDtcclxuICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xyXG5cclxuICB3aWR0aDogJHt1aUNvbnN0YW50cy5kaWFsRGltZW5zaW9uc307XHJcbiAgaGVpZ2h0OiAke3VpQ29uc3RhbnRzLmRpYWxEaW1lbnNpb25zfTtcclxuYDtcclxuXHJcbmNvbnN0IERpYWxVbml0ID0gc3R5bGVkKERpYWxQYW5lbClgXHJcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogJHt1aUNvbnN0YW50cy5ib3JkZXJSYWRpdXN9O1xyXG4gIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAke3VpQ29uc3RhbnRzLmJvcmRlclJhZGl1c307XHJcbmA7XHJcblxyXG5leHBvcnQgY29uc3QgRGlhbCA9ICh7XHJcbiAgbGFiZWwsXHJcbiAgdmFsdWUsXHJcbiAgdHlwZSxcclxuICB1bml0LFxyXG4gIC4uLnByb3BzXHJcbn0pID0+IHtcclxuICByZXR1cm4gKFxyXG4gICAgPERpYWxMYXlvdXQ+XHJcbiAgICAgIDxEaWFsSGVhZGVyPntsYWJlbH08L0RpYWxIZWFkZXI+XHJcbiAgICAgIDxEaWFsQ29udGFpbmVyPlxyXG4gICAgICAgIHt0eXBlID09PSBESUFMX1RZUEVTLlNDQUxBUiAmJiAoXHJcbiAgICAgICAgICA8U2NhbGFyRGlhbCB2YWx1ZT17dmFsdWV9IC8+XHJcbiAgICAgICAgKX1cclxuICAgICAgICB7dHlwZSA9PT0gRElBTF9UWVBFUy5DT09SRFMgJiYgKFxyXG4gICAgICAgICAgPENvb3Jkc0RpYWwgY29vcmRzPXt2YWx1ZX0gLz5cclxuICAgICAgICApfVxyXG4gICAgICAgIHt0eXBlID09PSBESUFMX1RZUEVTLkFOR0xFICYmIChcclxuICAgICAgICAgIDxBbmdsZURpYWwgYW5nbGU9e3ZhbHVlfSAvPlxyXG4gICAgICAgICl9XHJcbiAgICAgICAge3R5cGUgPT09IERJQUxfVFlQRVMuVkVDVE9SICYmIChcclxuICAgICAgICAgIDxWZWN0b3JEaWFsIHZlY3Rvcj17dmFsdWV9IC8+XHJcbiAgICAgICAgKX1cclxuICAgICAgPC9EaWFsQ29udGFpbmVyPlxyXG4gICAgICA8RGlhbFVuaXQ+e3VuaXR9PC9EaWFsVW5pdD5cclxuICAgIDwvRGlhbExheW91dD5cclxuICApO1xyXG59O1xyXG5cclxuRGlhbC5wcm9wVHlwZXMgPSB7XHJcbiAgbGFiZWw6IHByb3BUeXBlcy5zdHJpbmcsXHJcbiAgdmFsdWU6IHByb3BUeXBlcy5vbmVPZlR5cGUoW1xyXG4gICAgcHJvcFR5cGVzLm51bWJlcixcclxuICBdKSxcclxuICB0eXBlOiBwcm9wVHlwZXMub25lT2YoW1xyXG4gICAgRElBTF9UWVBFUy5TQ0FMQVIsXHJcbiAgXSkuaXNSZXF1aXJlZCxcclxuICB1bml0OiBwcm9wVHlwZXMuc3RyaW5nLFxyXG59O1xyXG5cclxuRGlhbC5kZWZhdWx0UHJvcHMgPSB7XHJcbiAgbGFiZWw6ICctJyxcclxuICB2YWx1ZTogMCxcclxuICB1bml0OiAnPycsXHJcbn07XHJcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBzdHlsZWQgZnJvbSAnc3R5bGVkLWNvbXBvbmVudHMnO1xyXG5pbXBvcnQgeyB1c2VTZWxlY3RvciB9IGZyb20gJ3JlYWN0LXJlZHV4JztcclxuXHJcbmltcG9ydCAqIGFzIG1hdGhVdGlscyBmcm9tICcuLi9tYXRoL3V0aWxzJztcclxuXHJcbmltcG9ydCB7IGdldFBvbHlnb25MaXN0IH0gZnJvbSAnLi4vc2VsZWN0b3JzL3BvbHlnb25zJztcclxuXHJcbmltcG9ydCB7IERJQUxfVFlQRVMgfSBmcm9tICcuLi9jb25zdGFudHMvdWlDb25zdGFudHMnO1xyXG5cclxuaW1wb3J0IHsgRGlhbCB9IGZyb20gJy4vRGlhbCc7XHJcblxyXG5jb25zdCBXcmFwcGVyID0gc3R5bGVkLmRpdmBcclxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZGRkO1xyXG4gIG1heC13aWR0aDogODAwcHg7XHJcblxyXG4gIGRpc3BsYXk6IGZsZXg7XHJcbiAgZmxleC13cmFwOiB3cmFwO1xyXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xyXG5cclxuICAgQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA4MDBweCkge1xyXG4gICAgd2lkdGg6IDEwMHZ3O1xyXG4gICB9XHJcbmA7XHJcblxyXG5leHBvcnQgY29uc3QgQ29udGVudFZpZXcgPSAoKSA9PiB7XHJcbiAgY29uc3QgcG9seWdvbnMgPSB1c2VTZWxlY3RvcihnZXRQb2x5Z29uTGlzdCk7XHJcblxyXG4gIGNvbnN0IGZpcnN0UG9seWdvbiA9IHBvbHlnb25zLmdldCgwKTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxXcmFwcGVyPlxyXG4gICAgICB7Zmlyc3RQb2x5Z29uICYmIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgPERpYWxcclxuICAgICAgICAgICAgbGFiZWw9XCJNYXNzXCJcclxuICAgICAgICAgICAgdmFsdWU9e2ZpcnN0UG9seWdvbi5nZXQoJ21hc3MnKX1cclxuICAgICAgICAgICAgdHlwZT17RElBTF9UWVBFUy5TQ0FMQVJ9XHJcbiAgICAgICAgICAgIHVuaXQ9XCJrZ1wiXHJcbiAgICAgICAgICAvPlxyXG4gICAgICAgICAgPERpYWxcclxuICAgICAgICAgICAgbGFiZWw9XCJQb3NpdGlvblwiXHJcbiAgICAgICAgICAgIHZhbHVlPXtmaXJzdFBvbHlnb24uZ2V0KCdwb3NpdGlvbicpfVxyXG4gICAgICAgICAgICB0eXBlPXtESUFMX1RZUEVTLkNPT1JEU31cclxuICAgICAgICAgICAgdW5pdD1cInB4XCJcclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgICA8RGlhbFxyXG4gICAgICAgICAgICBsYWJlbD1cIlJvdGF0aW9uXCJcclxuICAgICAgICAgICAgdmFsdWU9e21hdGhVdGlscy5yYWRpYW5zVG9EZWdyZWVzKGZpcnN0UG9seWdvbi5nZXQoJ3JvdGF0aW9uJykpICUgMzYwfVxyXG4gICAgICAgICAgICB0eXBlPXtESUFMX1RZUEVTLkFOR0xFfVxyXG4gICAgICAgICAgICB1bml0PVwiZGVnXCJcclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgICA8RGlhbFxyXG4gICAgICAgICAgICBsYWJlbD1cIlZlbG9jaXR5XCJcclxuICAgICAgICAgICAgdmFsdWU9e2ZpcnN0UG9seWdvbi5nZXQoJ3ZlbG9jaXR5Jyl9XHJcbiAgICAgICAgICAgIHR5cGU9e0RJQUxfVFlQRVMuVkVDVE9SfVxyXG4gICAgICAgICAgICB1bml0PVwicHgvc1wiXHJcbiAgICAgICAgICAvPlxyXG4gICAgICAgIDwvPlxyXG4gICAgICApfVxyXG4gICAgPC9XcmFwcGVyPlxyXG4gICk7XHJcbn07XHJcbiIsImZ1bmN0aW9uIG4obil7Zm9yKHZhciByPWFyZ3VtZW50cy5sZW5ndGgsdD1BcnJheShyPjE/ci0xOjApLGU9MTtlPHI7ZSsrKXRbZS0xXT1hcmd1bWVudHNbZV07aWYoXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOVil7dmFyIGk9WVtuXSxvPWk/XCJmdW5jdGlvblwiPT10eXBlb2YgaT9pLmFwcGx5KG51bGwsdCk6aTpcInVua25vd24gZXJyb3IgbnI6IFwiK247dGhyb3cgRXJyb3IoXCJbSW1tZXJdIFwiK28pfXRocm93IEVycm9yKFwiW0ltbWVyXSBtaW5pZmllZCBlcnJvciBucjogXCIrbisodC5sZW5ndGg/XCIgXCIrdC5tYXAoKGZ1bmN0aW9uKG4pe3JldHVyblwiJ1wiK24rXCInXCJ9KSkuam9pbihcIixcIik6XCJcIikrXCIuIEZpbmQgdGhlIGZ1bGwgZXJyb3IgYXQ6IGh0dHBzOi8vYml0Lmx5LzNjWEVLV2ZcIil9ZnVuY3Rpb24gcihuKXtyZXR1cm4hIW4mJiEhbltRXX1mdW5jdGlvbiB0KG4pe3JldHVybiEhbiYmKGZ1bmN0aW9uKG4pe2lmKCFufHxcIm9iamVjdFwiIT10eXBlb2YgbilyZXR1cm4hMTt2YXIgcj1PYmplY3QuZ2V0UHJvdG90eXBlT2Yobik7aWYobnVsbD09PXIpcmV0dXJuITA7dmFyIHQ9T2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocixcImNvbnN0cnVjdG9yXCIpJiZyLmNvbnN0cnVjdG9yO3JldHVybiB0PT09T2JqZWN0fHxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0JiZGdW5jdGlvbi50b1N0cmluZy5jYWxsKHQpPT09Wn0obil8fEFycmF5LmlzQXJyYXkobil8fCEhbltMXXx8ISFuLmNvbnN0cnVjdG9yW0xdfHxzKG4pfHx2KG4pKX1mdW5jdGlvbiBlKHQpe3JldHVybiByKHQpfHxuKDIzLHQpLHRbUV0udH1mdW5jdGlvbiBpKG4scix0KXt2b2lkIDA9PT10JiYodD0hMSksMD09PW8obik/KHQ/T2JqZWN0LmtleXM6bm4pKG4pLmZvckVhY2goKGZ1bmN0aW9uKGUpe3QmJlwic3ltYm9sXCI9PXR5cGVvZiBlfHxyKGUsbltlXSxuKX0pKTpuLmZvckVhY2goKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHIoZSx0LG4pfSkpfWZ1bmN0aW9uIG8obil7dmFyIHI9bltRXTtyZXR1cm4gcj9yLmk+Mz9yLmktNDpyLmk6QXJyYXkuaXNBcnJheShuKT8xOnMobik/Mjp2KG4pPzM6MH1mdW5jdGlvbiB1KG4scil7cmV0dXJuIDI9PT1vKG4pP24uaGFzKHIpOk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLHIpfWZ1bmN0aW9uIGEobixyKXtyZXR1cm4gMj09PW8obik/bi5nZXQocik6bltyXX1mdW5jdGlvbiBmKG4scix0KXt2YXIgZT1vKG4pOzI9PT1lP24uc2V0KHIsdCk6Mz09PWU/KG4uZGVsZXRlKHIpLG4uYWRkKHQpKTpuW3JdPXR9ZnVuY3Rpb24gYyhuLHIpe3JldHVybiBuPT09cj8wIT09bnx8MS9uPT0xL3I6biE9biYmciE9cn1mdW5jdGlvbiBzKG4pe3JldHVybiBYJiZuIGluc3RhbmNlb2YgTWFwfWZ1bmN0aW9uIHYobil7cmV0dXJuIHEmJm4gaW5zdGFuY2VvZiBTZXR9ZnVuY3Rpb24gcChuKXtyZXR1cm4gbi5vfHxuLnR9ZnVuY3Rpb24gbChuKXtpZihBcnJheS5pc0FycmF5KG4pKXJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChuKTt2YXIgcj1ybihuKTtkZWxldGUgcltRXTtmb3IodmFyIHQ9bm4ociksZT0wO2U8dC5sZW5ndGg7ZSsrKXt2YXIgaT10W2VdLG89cltpXTshMT09PW8ud3JpdGFibGUmJihvLndyaXRhYmxlPSEwLG8uY29uZmlndXJhYmxlPSEwKSwoby5nZXR8fG8uc2V0KSYmKHJbaV09e2NvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCxlbnVtZXJhYmxlOm8uZW51bWVyYWJsZSx2YWx1ZTpuW2ldfSl9cmV0dXJuIE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG4pLHIpfWZ1bmN0aW9uIGQobixlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ITEpLHkobil8fHIobil8fCF0KG4pP246KG8obik+MSYmKG4uc2V0PW4uYWRkPW4uY2xlYXI9bi5kZWxldGU9aCksT2JqZWN0LmZyZWV6ZShuKSxlJiZpKG4sKGZ1bmN0aW9uKG4scil7cmV0dXJuIGQociwhMCl9KSwhMCksbil9ZnVuY3Rpb24gaCgpe24oMil9ZnVuY3Rpb24geShuKXtyZXR1cm4gbnVsbD09bnx8XCJvYmplY3RcIiE9dHlwZW9mIG58fE9iamVjdC5pc0Zyb3plbihuKX1mdW5jdGlvbiBiKHIpe3ZhciB0PXRuW3JdO3JldHVybiB0fHxuKDE4LHIpLHR9ZnVuY3Rpb24gbShuLHIpe3RuW25dfHwodG5bbl09cil9ZnVuY3Rpb24gXygpe3JldHVyblwicHJvZHVjdGlvblwiPT09cHJvY2Vzcy5lbnYuTk9ERV9FTlZ8fFV8fG4oMCksVX1mdW5jdGlvbiBqKG4scil7ciYmKGIoXCJQYXRjaGVzXCIpLG4udT1bXSxuLnM9W10sbi52PXIpfWZ1bmN0aW9uIE8obil7ZyhuKSxuLnAuZm9yRWFjaChTKSxuLnA9bnVsbH1mdW5jdGlvbiBnKG4pe249PT1VJiYoVT1uLmwpfWZ1bmN0aW9uIHcobil7cmV0dXJuIFU9e3A6W10sbDpVLGg6bixtOiEwLF86MH19ZnVuY3Rpb24gUyhuKXt2YXIgcj1uW1FdOzA9PT1yLml8fDE9PT1yLmk/ci5qKCk6ci5PPSEwfWZ1bmN0aW9uIFAocixlKXtlLl89ZS5wLmxlbmd0aDt2YXIgaT1lLnBbMF0sbz12b2lkIDAhPT1yJiZyIT09aTtyZXR1cm4gZS5oLmd8fGIoXCJFUzVcIikuUyhlLHIsbyksbz8oaVtRXS5QJiYoTyhlKSxuKDQpKSx0KHIpJiYocj1NKGUsciksZS5sfHx4KGUscikpLGUudSYmYihcIlBhdGNoZXNcIikuTShpW1FdLnQscixlLnUsZS5zKSk6cj1NKGUsaSxbXSksTyhlKSxlLnUmJmUudihlLnUsZS5zKSxyIT09SD9yOnZvaWQgMH1mdW5jdGlvbiBNKG4scix0KXtpZih5KHIpKXJldHVybiByO3ZhciBlPXJbUV07aWYoIWUpcmV0dXJuIGkociwoZnVuY3Rpb24oaSxvKXtyZXR1cm4gQShuLGUscixpLG8sdCl9KSwhMCkscjtpZihlLkEhPT1uKXJldHVybiByO2lmKCFlLlApcmV0dXJuIHgobixlLnQsITApLGUudDtpZighZS5JKXtlLkk9ITAsZS5BLl8tLTt2YXIgbz00PT09ZS5pfHw1PT09ZS5pP2Uubz1sKGUuayk6ZS5vO2koMz09PWUuaT9uZXcgU2V0KG8pOm8sKGZ1bmN0aW9uKHIsaSl7cmV0dXJuIEEobixlLG8scixpLHQpfSkpLHgobixvLCExKSx0JiZuLnUmJmIoXCJQYXRjaGVzXCIpLlIoZSx0LG4udSxuLnMpfXJldHVybiBlLm99ZnVuY3Rpb24gQShlLGksbyxhLGMscyl7aWYoXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmYz09PW8mJm4oNSkscihjKSl7dmFyIHY9TShlLGMscyYmaSYmMyE9PWkuaSYmIXUoaS5ELGEpP3MuY29uY2F0KGEpOnZvaWQgMCk7aWYoZihvLGEsdiksIXIodikpcmV0dXJuO2UubT0hMX1pZih0KGMpJiYheShjKSl7aWYoIWUuaC5GJiZlLl88MSlyZXR1cm47TShlLGMpLGkmJmkuQS5sfHx4KGUsYyl9fWZ1bmN0aW9uIHgobixyLHQpe3ZvaWQgMD09PXQmJih0PSExKSxuLmguRiYmbi5tJiZkKHIsdCl9ZnVuY3Rpb24geihuLHIpe3ZhciB0PW5bUV07cmV0dXJuKHQ/cCh0KTpuKVtyXX1mdW5jdGlvbiBJKG4scil7aWYociBpbiBuKWZvcih2YXIgdD1PYmplY3QuZ2V0UHJvdG90eXBlT2Yobik7dDspe3ZhciBlPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxyKTtpZihlKXJldHVybiBlO3Q9T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpfX1mdW5jdGlvbiBrKG4pe24uUHx8KG4uUD0hMCxuLmwmJmsobi5sKSl9ZnVuY3Rpb24gRShuKXtuLm98fChuLm89bChuLnQpKX1mdW5jdGlvbiBSKG4scix0KXt2YXIgZT1zKHIpP2IoXCJNYXBTZXRcIikuTihyLHQpOnYocik/YihcIk1hcFNldFwiKS5UKHIsdCk6bi5nP2Z1bmN0aW9uKG4scil7dmFyIHQ9QXJyYXkuaXNBcnJheShuKSxlPXtpOnQ/MTowLEE6cj9yLkE6XygpLFA6ITEsSTohMSxEOnt9LGw6cix0Om4sazpudWxsLG86bnVsbCxqOm51bGwsQzohMX0saT1lLG89ZW47dCYmKGk9W2VdLG89b24pO3ZhciB1PVByb3h5LnJldm9jYWJsZShpLG8pLGE9dS5yZXZva2UsZj11LnByb3h5O3JldHVybiBlLms9ZixlLmo9YSxmfShyLHQpOmIoXCJFUzVcIikuSihyLHQpO3JldHVybih0P3QuQTpfKCkpLnAucHVzaChlKSxlfWZ1bmN0aW9uIEQoZSl7cmV0dXJuIHIoZSl8fG4oMjIsZSksZnVuY3Rpb24gbihyKXtpZighdChyKSlyZXR1cm4gcjt2YXIgZSx1PXJbUV0sYz1vKHIpO2lmKHUpe2lmKCF1LlAmJih1Lmk8NHx8IWIoXCJFUzVcIikuSyh1KSkpcmV0dXJuIHUudDt1Lkk9ITAsZT1GKHIsYyksdS5JPSExfWVsc2UgZT1GKHIsYyk7cmV0dXJuIGkoZSwoZnVuY3Rpb24ocix0KXt1JiZhKHUudCxyKT09PXR8fGYoZSxyLG4odCkpfSkpLDM9PT1jP25ldyBTZXQoZSk6ZX0oZSl9ZnVuY3Rpb24gRihuLHIpe3N3aXRjaChyKXtjYXNlIDI6cmV0dXJuIG5ldyBNYXAobik7Y2FzZSAzOnJldHVybiBBcnJheS5mcm9tKG4pfXJldHVybiBsKG4pfWZ1bmN0aW9uIE4oKXtmdW5jdGlvbiB0KG4scil7dmFyIHQ9c1tuXTtyZXR1cm4gdD90LmVudW1lcmFibGU9cjpzW25dPXQ9e2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOnIsZ2V0OmZ1bmN0aW9uKCl7dmFyIHI9dGhpc1tRXTtyZXR1cm5cInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZmKHIpLGVuLmdldChyLG4pfSxzZXQ6ZnVuY3Rpb24ocil7dmFyIHQ9dGhpc1tRXTtcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZmKHQpLGVuLnNldCh0LG4scil9fSx0fWZ1bmN0aW9uIGUobil7Zm9yKHZhciByPW4ubGVuZ3RoLTE7cj49MDtyLS0pe3ZhciB0PW5bcl1bUV07aWYoIXQuUClzd2l0Y2godC5pKXtjYXNlIDU6YSh0KSYmayh0KTticmVhaztjYXNlIDQ6byh0KSYmayh0KX19fWZ1bmN0aW9uIG8obil7Zm9yKHZhciByPW4udCx0PW4uayxlPW5uKHQpLGk9ZS5sZW5ndGgtMTtpPj0wO2ktLSl7dmFyIG89ZVtpXTtpZihvIT09USl7dmFyIGE9cltvXTtpZih2b2lkIDA9PT1hJiYhdShyLG8pKXJldHVybiEwO3ZhciBmPXRbb10scz1mJiZmW1FdO2lmKHM/cy50IT09YTohYyhmLGEpKXJldHVybiEwfX12YXIgdj0hIXJbUV07cmV0dXJuIGUubGVuZ3RoIT09bm4ocikubGVuZ3RoKyh2PzA6MSl9ZnVuY3Rpb24gYShuKXt2YXIgcj1uLms7aWYoci5sZW5ndGghPT1uLnQubGVuZ3RoKXJldHVybiEwO3ZhciB0PU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocixyLmxlbmd0aC0xKTtpZih0JiYhdC5nZXQpcmV0dXJuITA7Zm9yKHZhciBlPTA7ZTxyLmxlbmd0aDtlKyspaWYoIXIuaGFzT3duUHJvcGVydHkoZSkpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gZihyKXtyLk8mJm4oMyxKU09OLnN0cmluZ2lmeShwKHIpKSl9dmFyIHM9e307bShcIkVTNVwiLHtKOmZ1bmN0aW9uKG4scil7dmFyIGU9QXJyYXkuaXNBcnJheShuKSxpPWZ1bmN0aW9uKG4scil7aWYobil7Zm9yKHZhciBlPUFycmF5KHIubGVuZ3RoKSxpPTA7aTxyLmxlbmd0aDtpKyspT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJcIitpLHQoaSwhMCkpO3JldHVybiBlfXZhciBvPXJuKHIpO2RlbGV0ZSBvW1FdO2Zvcih2YXIgdT1ubihvKSxhPTA7YTx1Lmxlbmd0aDthKyspe3ZhciBmPXVbYV07b1tmXT10KGYsbnx8ISFvW2ZdLmVudW1lcmFibGUpfXJldHVybiBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihyKSxvKX0oZSxuKSxvPXtpOmU/NTo0LEE6cj9yLkE6XygpLFA6ITEsSTohMSxEOnt9LGw6cix0Om4sazppLG86bnVsbCxPOiExLEM6ITF9O3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSxRLHt2YWx1ZTpvLHdyaXRhYmxlOiEwfSksaX0sUzpmdW5jdGlvbihuLHQsbyl7bz9yKHQpJiZ0W1FdLkE9PT1uJiZlKG4ucCk6KG4udSYmZnVuY3Rpb24gbihyKXtpZihyJiZcIm9iamVjdFwiPT10eXBlb2Ygcil7dmFyIHQ9cltRXTtpZih0KXt2YXIgZT10LnQsbz10LmssZj10LkQsYz10Lmk7aWYoND09PWMpaShvLChmdW5jdGlvbihyKXtyIT09USYmKHZvaWQgMCE9PWVbcl18fHUoZSxyKT9mW3JdfHxuKG9bcl0pOihmW3JdPSEwLGsodCkpKX0pKSxpKGUsKGZ1bmN0aW9uKG4pe3ZvaWQgMCE9PW9bbl18fHUobyxuKXx8KGZbbl09ITEsayh0KSl9KSk7ZWxzZSBpZig1PT09Yyl7aWYoYSh0KSYmKGsodCksZi5sZW5ndGg9ITApLG8ubGVuZ3RoPGUubGVuZ3RoKWZvcih2YXIgcz1vLmxlbmd0aDtzPGUubGVuZ3RoO3MrKylmW3NdPSExO2Vsc2UgZm9yKHZhciB2PWUubGVuZ3RoO3Y8by5sZW5ndGg7disrKWZbdl09ITA7Zm9yKHZhciBwPU1hdGgubWluKG8ubGVuZ3RoLGUubGVuZ3RoKSxsPTA7bDxwO2wrKylvLmhhc093blByb3BlcnR5KGwpfHwoZltsXT0hMCksdm9pZCAwPT09ZltsXSYmbihvW2xdKX19fX0obi5wWzBdKSxlKG4ucCkpfSxLOmZ1bmN0aW9uKG4pe3JldHVybiA0PT09bi5pP28obik6YShuKX19KX1mdW5jdGlvbiBUKCl7ZnVuY3Rpb24gZShuKXtpZighdChuKSlyZXR1cm4gbjtpZihBcnJheS5pc0FycmF5KG4pKXJldHVybiBuLm1hcChlKTtpZihzKG4pKXJldHVybiBuZXcgTWFwKEFycmF5LmZyb20obi5lbnRyaWVzKCkpLm1hcCgoZnVuY3Rpb24obil7cmV0dXJuW25bMF0sZShuWzFdKV19KSkpO2lmKHYobikpcmV0dXJuIG5ldyBTZXQoQXJyYXkuZnJvbShuKS5tYXAoZSkpO3ZhciByPU9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG4pKTtmb3IodmFyIGkgaW4gbilyW2ldPWUobltpXSk7cmV0dXJuIHUobixMKSYmKHJbTF09bltMXSkscn1mdW5jdGlvbiBmKG4pe3JldHVybiByKG4pP2Uobik6bn12YXIgYz1cImFkZFwiO20oXCJQYXRjaGVzXCIseyQ6ZnVuY3Rpb24ocix0KXtyZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbih0KXtmb3IodmFyIGk9dC5wYXRoLHU9dC5vcCxmPXIscz0wO3M8aS5sZW5ndGgtMTtzKyspe3ZhciB2PW8oZikscD1cIlwiK2lbc107MCE9PXYmJjEhPT12fHxcIl9fcHJvdG9fX1wiIT09cCYmXCJjb25zdHJ1Y3RvclwiIT09cHx8bigyNCksXCJmdW5jdGlvblwiPT10eXBlb2YgZiYmXCJwcm90b3R5cGVcIj09PXAmJm4oMjQpLFwib2JqZWN0XCIhPXR5cGVvZihmPWEoZixwKSkmJm4oMTUsaS5qb2luKFwiL1wiKSl9dmFyIGw9byhmKSxkPWUodC52YWx1ZSksaD1pW2kubGVuZ3RoLTFdO3N3aXRjaCh1KXtjYXNlXCJyZXBsYWNlXCI6c3dpdGNoKGwpe2Nhc2UgMjpyZXR1cm4gZi5zZXQoaCxkKTtjYXNlIDM6bigxNik7ZGVmYXVsdDpyZXR1cm4gZltoXT1kfWNhc2UgYzpzd2l0Y2gobCl7Y2FzZSAxOnJldHVyblwiLVwiPT09aD9mLnB1c2goZCk6Zi5zcGxpY2UoaCwwLGQpO2Nhc2UgMjpyZXR1cm4gZi5zZXQoaCxkKTtjYXNlIDM6cmV0dXJuIGYuYWRkKGQpO2RlZmF1bHQ6cmV0dXJuIGZbaF09ZH1jYXNlXCJyZW1vdmVcIjpzd2l0Y2gobCl7Y2FzZSAxOnJldHVybiBmLnNwbGljZShoLDEpO2Nhc2UgMjpyZXR1cm4gZi5kZWxldGUoaCk7Y2FzZSAzOnJldHVybiBmLmRlbGV0ZSh0LnZhbHVlKTtkZWZhdWx0OnJldHVybiBkZWxldGUgZltoXX1kZWZhdWx0Om4oMTcsdSl9fSkpLHJ9LFI6ZnVuY3Rpb24obixyLHQsZSl7c3dpdGNoKG4uaSl7Y2FzZSAwOmNhc2UgNDpjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKG4scix0LGUpe3ZhciBvPW4udCxzPW4ubztpKG4uRCwoZnVuY3Rpb24obixpKXt2YXIgdj1hKG8sbikscD1hKHMsbiksbD1pP3UobyxuKT9cInJlcGxhY2VcIjpjOlwicmVtb3ZlXCI7aWYodiE9PXB8fFwicmVwbGFjZVwiIT09bCl7dmFyIGQ9ci5jb25jYXQobik7dC5wdXNoKFwicmVtb3ZlXCI9PT1sP3tvcDpsLHBhdGg6ZH06e29wOmwscGF0aDpkLHZhbHVlOnB9KSxlLnB1c2gobD09PWM/e29wOlwicmVtb3ZlXCIscGF0aDpkfTpcInJlbW92ZVwiPT09bD97b3A6YyxwYXRoOmQsdmFsdWU6Zih2KX06e29wOlwicmVwbGFjZVwiLHBhdGg6ZCx2YWx1ZTpmKHYpfSl9fSkpfShuLHIsdCxlKTtjYXNlIDU6Y2FzZSAxOnJldHVybiBmdW5jdGlvbihuLHIsdCxlKXt2YXIgaT1uLnQsbz1uLkQsdT1uLm87aWYodS5sZW5ndGg8aS5sZW5ndGgpe3ZhciBhPVt1LGldO2k9YVswXSx1PWFbMV07dmFyIHM9W2UsdF07dD1zWzBdLGU9c1sxXX1mb3IodmFyIHY9MDt2PGkubGVuZ3RoO3YrKylpZihvW3ZdJiZ1W3ZdIT09aVt2XSl7dmFyIHA9ci5jb25jYXQoW3ZdKTt0LnB1c2goe29wOlwicmVwbGFjZVwiLHBhdGg6cCx2YWx1ZTpmKHVbdl0pfSksZS5wdXNoKHtvcDpcInJlcGxhY2VcIixwYXRoOnAsdmFsdWU6ZihpW3ZdKX0pfWZvcih2YXIgbD1pLmxlbmd0aDtsPHUubGVuZ3RoO2wrKyl7dmFyIGQ9ci5jb25jYXQoW2xdKTt0LnB1c2goe29wOmMscGF0aDpkLHZhbHVlOmYodVtsXSl9KX1pLmxlbmd0aDx1Lmxlbmd0aCYmZS5wdXNoKHtvcDpcInJlcGxhY2VcIixwYXRoOnIuY29uY2F0KFtcImxlbmd0aFwiXSksdmFsdWU6aS5sZW5ndGh9KX0obixyLHQsZSk7Y2FzZSAzOnJldHVybiBmdW5jdGlvbihuLHIsdCxlKXt2YXIgaT1uLnQsbz1uLm8sdT0wO2kuZm9yRWFjaCgoZnVuY3Rpb24obil7aWYoIW8uaGFzKG4pKXt2YXIgaT1yLmNvbmNhdChbdV0pO3QucHVzaCh7b3A6XCJyZW1vdmVcIixwYXRoOmksdmFsdWU6bn0pLGUudW5zaGlmdCh7b3A6YyxwYXRoOmksdmFsdWU6bn0pfXUrK30pKSx1PTAsby5mb3JFYWNoKChmdW5jdGlvbihuKXtpZighaS5oYXMobikpe3ZhciBvPXIuY29uY2F0KFt1XSk7dC5wdXNoKHtvcDpjLHBhdGg6byx2YWx1ZTpufSksZS51bnNoaWZ0KHtvcDpcInJlbW92ZVwiLHBhdGg6byx2YWx1ZTpufSl9dSsrfSkpfShuLHIsdCxlKX19LE06ZnVuY3Rpb24obixyLHQsZSl7dC5wdXNoKHtvcDpcInJlcGxhY2VcIixwYXRoOltdLHZhbHVlOnI9PT1IP3ZvaWQgMDpyfSksZS5wdXNoKHtvcDpcInJlcGxhY2VcIixwYXRoOltdLHZhbHVlOm59KX19KX1mdW5jdGlvbiBDKCl7ZnVuY3Rpb24gcihuLHIpe2Z1bmN0aW9uIHQoKXt0aGlzLmNvbnN0cnVjdG9yPW59YShuLHIpLG4ucHJvdG90eXBlPSh0LnByb3RvdHlwZT1yLnByb3RvdHlwZSxuZXcgdCl9ZnVuY3Rpb24gZShuKXtuLm98fChuLkQ9bmV3IE1hcCxuLm89bmV3IE1hcChuLnQpKX1mdW5jdGlvbiBvKG4pe24ub3x8KG4ubz1uZXcgU2V0LG4udC5mb3JFYWNoKChmdW5jdGlvbihyKXtpZih0KHIpKXt2YXIgZT1SKG4uQS5oLHIsbik7bi5wLnNldChyLGUpLG4uby5hZGQoZSl9ZWxzZSBuLm8uYWRkKHIpfSkpKX1mdW5jdGlvbiB1KHIpe3IuTyYmbigzLEpTT04uc3RyaW5naWZ5KHAocikpKX12YXIgYT1mdW5jdGlvbihuLHIpe3JldHVybihhPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihuLHIpe24uX19wcm90b19fPXJ9fHxmdW5jdGlvbihuLHIpe2Zvcih2YXIgdCBpbiByKXIuaGFzT3duUHJvcGVydHkodCkmJihuW3RdPXJbdF0pfSkobixyKX0sZj1mdW5jdGlvbigpe2Z1bmN0aW9uIG4obixyKXtyZXR1cm4gdGhpc1tRXT17aToyLGw6cixBOnI/ci5BOl8oKSxQOiExLEk6ITEsbzp2b2lkIDAsRDp2b2lkIDAsdDpuLGs6dGhpcyxDOiExLE86ITF9LHRoaXN9cihuLE1hcCk7dmFyIG89bi5wcm90b3R5cGU7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLFwic2l6ZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcCh0aGlzW1FdKS5zaXplfX0pLG8uaGFzPWZ1bmN0aW9uKG4pe3JldHVybiBwKHRoaXNbUV0pLmhhcyhuKX0sby5zZXQ9ZnVuY3Rpb24obixyKXt2YXIgdD10aGlzW1FdO3JldHVybiB1KHQpLHAodCkuaGFzKG4pJiZwKHQpLmdldChuKT09PXJ8fChlKHQpLGsodCksdC5ELnNldChuLCEwKSx0Lm8uc2V0KG4sciksdC5ELnNldChuLCEwKSksdGhpc30sby5kZWxldGU9ZnVuY3Rpb24obil7aWYoIXRoaXMuaGFzKG4pKXJldHVybiExO3ZhciByPXRoaXNbUV07cmV0dXJuIHUociksZShyKSxrKHIpLHIudC5oYXMobik/ci5ELnNldChuLCExKTpyLkQuZGVsZXRlKG4pLHIuby5kZWxldGUobiksITB9LG8uY2xlYXI9ZnVuY3Rpb24oKXt2YXIgbj10aGlzW1FdO3UobikscChuKS5zaXplJiYoZShuKSxrKG4pLG4uRD1uZXcgTWFwLGkobi50LChmdW5jdGlvbihyKXtuLkQuc2V0KHIsITEpfSkpLG4uby5jbGVhcigpKX0sby5mb3JFYWNoPWZ1bmN0aW9uKG4scil7dmFyIHQ9dGhpcztwKHRoaXNbUV0pLmZvckVhY2goKGZ1bmN0aW9uKGUsaSl7bi5jYWxsKHIsdC5nZXQoaSksaSx0KX0pKX0sby5nZXQ9ZnVuY3Rpb24obil7dmFyIHI9dGhpc1tRXTt1KHIpO3ZhciBpPXAocikuZ2V0KG4pO2lmKHIuSXx8IXQoaSkpcmV0dXJuIGk7aWYoaSE9PXIudC5nZXQobikpcmV0dXJuIGk7dmFyIG89UihyLkEuaCxpLHIpO3JldHVybiBlKHIpLHIuby5zZXQobixvKSxvfSxvLmtleXM9ZnVuY3Rpb24oKXtyZXR1cm4gcCh0aGlzW1FdKS5rZXlzKCl9LG8udmFsdWVzPWZ1bmN0aW9uKCl7dmFyIG4scj10aGlzLHQ9dGhpcy5rZXlzKCk7cmV0dXJuKG49e30pW1ZdPWZ1bmN0aW9uKCl7cmV0dXJuIHIudmFsdWVzKCl9LG4ubmV4dD1mdW5jdGlvbigpe3ZhciBuPXQubmV4dCgpO3JldHVybiBuLmRvbmU/bjp7ZG9uZTohMSx2YWx1ZTpyLmdldChuLnZhbHVlKX19LG59LG8uZW50cmllcz1mdW5jdGlvbigpe3ZhciBuLHI9dGhpcyx0PXRoaXMua2V5cygpO3JldHVybihuPXt9KVtWXT1mdW5jdGlvbigpe3JldHVybiByLmVudHJpZXMoKX0sbi5uZXh0PWZ1bmN0aW9uKCl7dmFyIG49dC5uZXh0KCk7aWYobi5kb25lKXJldHVybiBuO3ZhciBlPXIuZ2V0KG4udmFsdWUpO3JldHVybntkb25lOiExLHZhbHVlOltuLnZhbHVlLGVdfX0sbn0sb1tWXT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVudHJpZXMoKX0sbn0oKSxjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihuLHIpe3JldHVybiB0aGlzW1FdPXtpOjMsbDpyLEE6cj9yLkE6XygpLFA6ITEsSTohMSxvOnZvaWQgMCx0Om4sazp0aGlzLHA6bmV3IE1hcCxPOiExLEM6ITF9LHRoaXN9cihuLFNldCk7dmFyIHQ9bi5wcm90b3R5cGU7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwic2l6ZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcCh0aGlzW1FdKS5zaXplfX0pLHQuaGFzPWZ1bmN0aW9uKG4pe3ZhciByPXRoaXNbUV07cmV0dXJuIHUociksci5vPyEhci5vLmhhcyhuKXx8ISghci5wLmhhcyhuKXx8IXIuby5oYXMoci5wLmdldChuKSkpOnIudC5oYXMobil9LHQuYWRkPWZ1bmN0aW9uKG4pe3ZhciByPXRoaXNbUV07cmV0dXJuIHUociksdGhpcy5oYXMobil8fChvKHIpLGsociksci5vLmFkZChuKSksdGhpc30sdC5kZWxldGU9ZnVuY3Rpb24obil7aWYoIXRoaXMuaGFzKG4pKXJldHVybiExO3ZhciByPXRoaXNbUV07cmV0dXJuIHUociksbyhyKSxrKHIpLHIuby5kZWxldGUobil8fCEhci5wLmhhcyhuKSYmci5vLmRlbGV0ZShyLnAuZ2V0KG4pKX0sdC5jbGVhcj1mdW5jdGlvbigpe3ZhciBuPXRoaXNbUV07dShuKSxwKG4pLnNpemUmJihvKG4pLGsobiksbi5vLmNsZWFyKCkpfSx0LnZhbHVlcz1mdW5jdGlvbigpe3ZhciBuPXRoaXNbUV07cmV0dXJuIHUobiksbyhuKSxuLm8udmFsdWVzKCl9LHQuZW50cmllcz1mdW5jdGlvbigpe3ZhciBuPXRoaXNbUV07cmV0dXJuIHUobiksbyhuKSxuLm8uZW50cmllcygpfSx0LmtleXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZXMoKX0sdFtWXT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlcygpfSx0LmZvckVhY2g9ZnVuY3Rpb24obixyKXtmb3IodmFyIHQ9dGhpcy52YWx1ZXMoKSxlPXQubmV4dCgpOyFlLmRvbmU7KW4uY2FsbChyLGUudmFsdWUsZS52YWx1ZSx0aGlzKSxlPXQubmV4dCgpfSxufSgpO20oXCJNYXBTZXRcIix7TjpmdW5jdGlvbihuLHIpe3JldHVybiBuZXcgZihuLHIpfSxUOmZ1bmN0aW9uKG4scil7cmV0dXJuIG5ldyBjKG4scil9fSl9ZnVuY3Rpb24gSigpe04oKSxDKCksVCgpfWZ1bmN0aW9uIEsobil7cmV0dXJuIG59ZnVuY3Rpb24gJChuKXtyZXR1cm4gbn12YXIgRyxVLFc9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbChcInhcIiksWD1cInVuZGVmaW5lZFwiIT10eXBlb2YgTWFwLHE9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFNldCxCPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBQcm94eSYmdm9pZCAwIT09UHJveHkucmV2b2NhYmxlJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgUmVmbGVjdCxIPVc/U3ltYm9sLmZvcihcImltbWVyLW5vdGhpbmdcIik6KChHPXt9KVtcImltbWVyLW5vdGhpbmdcIl09ITAsRyksTD1XP1N5bWJvbC5mb3IoXCJpbW1lci1kcmFmdGFibGVcIik6XCJfXyRpbW1lcl9kcmFmdGFibGVcIixRPVc/U3ltYm9sLmZvcihcImltbWVyLXN0YXRlXCIpOlwiX18kaW1tZXJfc3RhdGVcIixWPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5pdGVyYXRvcnx8XCJAQGl0ZXJhdG9yXCIsWT17MDpcIklsbGVnYWwgc3RhdGVcIiwxOlwiSW1tZXIgZHJhZnRzIGNhbm5vdCBoYXZlIGNvbXB1dGVkIHByb3BlcnRpZXNcIiwyOlwiVGhpcyBvYmplY3QgaGFzIGJlZW4gZnJvemVuIGFuZCBzaG91bGQgbm90IGJlIG11dGF0ZWRcIiwzOmZ1bmN0aW9uKG4pe3JldHVyblwiQ2Fubm90IHVzZSBhIHByb3h5IHRoYXQgaGFzIGJlZW4gcmV2b2tlZC4gRGlkIHlvdSBwYXNzIGFuIG9iamVjdCBmcm9tIGluc2lkZSBhbiBpbW1lciBmdW5jdGlvbiB0byBhbiBhc3luYyBwcm9jZXNzPyBcIitufSw0OlwiQW4gaW1tZXIgcHJvZHVjZXIgcmV0dXJuZWQgYSBuZXcgdmFsdWUgKmFuZCogbW9kaWZpZWQgaXRzIGRyYWZ0LiBFaXRoZXIgcmV0dXJuIGEgbmV3IHZhbHVlICpvciogbW9kaWZ5IHRoZSBkcmFmdC5cIiw1OlwiSW1tZXIgZm9yYmlkcyBjaXJjdWxhciByZWZlcmVuY2VzXCIsNjpcIlRoZSBmaXJzdCBvciBzZWNvbmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvblwiLDc6XCJUaGUgdGhpcmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvbiBvciB1bmRlZmluZWRcIiw4OlwiRmlyc3QgYXJndW1lbnQgdG8gYGNyZWF0ZURyYWZ0YCBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0LCBhbiBhcnJheSwgb3IgYW4gaW1tZXJhYmxlIG9iamVjdFwiLDk6XCJGaXJzdCBhcmd1bWVudCB0byBgZmluaXNoRHJhZnRgIG11c3QgYmUgYSBkcmFmdCByZXR1cm5lZCBieSBgY3JlYXRlRHJhZnRgXCIsMTA6XCJUaGUgZ2l2ZW4gZHJhZnQgaXMgYWxyZWFkeSBmaW5hbGl6ZWRcIiwxMTpcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eSgpIGNhbm5vdCBiZSB1c2VkIG9uIGFuIEltbWVyIGRyYWZ0XCIsMTI6XCJPYmplY3Quc2V0UHJvdG90eXBlT2YoKSBjYW5ub3QgYmUgdXNlZCBvbiBhbiBJbW1lciBkcmFmdFwiLDEzOlwiSW1tZXIgb25seSBzdXBwb3J0cyBkZWxldGluZyBhcnJheSBpbmRpY2VzXCIsMTQ6XCJJbW1lciBvbmx5IHN1cHBvcnRzIHNldHRpbmcgYXJyYXkgaW5kaWNlcyBhbmQgdGhlICdsZW5ndGgnIHByb3BlcnR5XCIsMTU6ZnVuY3Rpb24obil7cmV0dXJuXCJDYW5ub3QgYXBwbHkgcGF0Y2gsIHBhdGggZG9lc24ndCByZXNvbHZlOiBcIitufSwxNjonU2V0cyBjYW5ub3QgaGF2ZSBcInJlcGxhY2VcIiBwYXRjaGVzLicsMTc6ZnVuY3Rpb24obil7cmV0dXJuXCJVbnN1cHBvcnRlZCBwYXRjaCBvcGVyYXRpb246IFwiK259LDE4OmZ1bmN0aW9uKG4pe3JldHVyblwiVGhlIHBsdWdpbiBmb3IgJ1wiK24rXCInIGhhcyBub3QgYmVlbiBsb2FkZWQgaW50byBJbW1lci4gVG8gZW5hYmxlIHRoZSBwbHVnaW4sIGltcG9ydCBhbmQgY2FsbCBgZW5hYmxlXCIrbitcIigpYCB3aGVuIGluaXRpYWxpemluZyB5b3VyIGFwcGxpY2F0aW9uLlwifSwyMDpcIkNhbm5vdCB1c2UgcHJveGllcyBpZiBQcm94eSwgUHJveHkucmV2b2NhYmxlIG9yIFJlZmxlY3QgYXJlIG5vdCBhdmFpbGFibGVcIiwyMTpmdW5jdGlvbihuKXtyZXR1cm5cInByb2R1Y2UgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHRoaW5ncyB0aGF0IGFyZSBkcmFmdGFibGU6IHBsYWluIG9iamVjdHMsIGFycmF5cywgTWFwLCBTZXQgb3IgY2xhc3NlcyB0aGF0IGFyZSBtYXJrZWQgd2l0aCAnW2ltbWVyYWJsZV06IHRydWUnLiBHb3QgJ1wiK24rXCInXCJ9LDIyOmZ1bmN0aW9uKG4pe3JldHVyblwiJ2N1cnJlbnQnIGV4cGVjdHMgYSBkcmFmdCwgZ290OiBcIitufSwyMzpmdW5jdGlvbihuKXtyZXR1cm5cIidvcmlnaW5hbCcgZXhwZWN0cyBhIGRyYWZ0LCBnb3Q6IFwiK259LDI0OlwiUGF0Y2hpbmcgcmVzZXJ2ZWQgYXR0cmlidXRlcyBsaWtlIF9fcHJvdG9fXywgcHJvdG90eXBlIGFuZCBjb25zdHJ1Y3RvciBpcyBub3QgYWxsb3dlZFwifSxaPVwiXCIrT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcixubj1cInVuZGVmaW5lZFwiIT10eXBlb2YgUmVmbGVjdCYmUmVmbGVjdC5vd25LZXlzP1JlZmxlY3Qub3duS2V5czp2b2lkIDAhPT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzP2Z1bmN0aW9uKG4pe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhuKS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhuKSl9Ok9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLHJuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzfHxmdW5jdGlvbihuKXt2YXIgcj17fTtyZXR1cm4gbm4obikuZm9yRWFjaCgoZnVuY3Rpb24odCl7clt0XT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCl9KSkscn0sdG49e30sZW49e2dldDpmdW5jdGlvbihuLHIpe2lmKHI9PT1RKXJldHVybiBuO3ZhciBlPXAobik7aWYoIXUoZSxyKSlyZXR1cm4gZnVuY3Rpb24obixyLHQpe3ZhciBlLGk9SShyLHQpO3JldHVybiBpP1widmFsdWVcImluIGk/aS52YWx1ZTpudWxsPT09KGU9aS5nZXQpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLmNhbGwobi5rKTp2b2lkIDB9KG4sZSxyKTt2YXIgaT1lW3JdO3JldHVybiBuLkl8fCF0KGkpP2k6aT09PXoobi50LHIpPyhFKG4pLG4ub1tyXT1SKG4uQS5oLGksbikpOml9LGhhczpmdW5jdGlvbihuLHIpe3JldHVybiByIGluIHAobil9LG93bktleXM6ZnVuY3Rpb24obil7cmV0dXJuIFJlZmxlY3Qub3duS2V5cyhwKG4pKX0sc2V0OmZ1bmN0aW9uKG4scix0KXt2YXIgZT1JKHAobikscik7aWYobnVsbD09ZT92b2lkIDA6ZS5zZXQpcmV0dXJuIGUuc2V0LmNhbGwobi5rLHQpLCEwO2lmKCFuLlApe3ZhciBpPXoocChuKSxyKSxvPW51bGw9PWk/dm9pZCAwOmlbUV07aWYobyYmby50PT09dClyZXR1cm4gbi5vW3JdPXQsbi5EW3JdPSExLCEwO2lmKGModCxpKSYmKHZvaWQgMCE9PXR8fHUobi50LHIpKSlyZXR1cm4hMDtFKG4pLGsobil9cmV0dXJuIG4ub1tyXT09PXQmJlwibnVtYmVyXCIhPXR5cGVvZiB0JiYodm9pZCAwIT09dHx8ciBpbiBuLm8pfHwobi5vW3JdPXQsbi5EW3JdPSEwLCEwKX0sZGVsZXRlUHJvcGVydHk6ZnVuY3Rpb24obixyKXtyZXR1cm4gdm9pZCAwIT09eihuLnQscil8fHIgaW4gbi50PyhuLkRbcl09ITEsRShuKSxrKG4pKTpkZWxldGUgbi5EW3JdLG4ubyYmZGVsZXRlIG4ub1tyXSwhMH0sZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOmZ1bmN0aW9uKG4scil7dmFyIHQ9cChuKSxlPVJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQscik7cmV0dXJuIGU/e3dyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZToxIT09bi5pfHxcImxlbmd0aFwiIT09cixlbnVtZXJhYmxlOmUuZW51bWVyYWJsZSx2YWx1ZTp0W3JdfTplfSxkZWZpbmVQcm9wZXJ0eTpmdW5jdGlvbigpe24oMTEpfSxnZXRQcm90b3R5cGVPZjpmdW5jdGlvbihuKXtyZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG4udCl9LHNldFByb3RvdHlwZU9mOmZ1bmN0aW9uKCl7bigxMil9fSxvbj17fTtpKGVuLChmdW5jdGlvbihuLHIpe29uW25dPWZ1bmN0aW9uKCl7cmV0dXJuIGFyZ3VtZW50c1swXT1hcmd1bWVudHNbMF1bMF0sci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fSkpLG9uLmRlbGV0ZVByb3BlcnR5PWZ1bmN0aW9uKHIsdCl7cmV0dXJuXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmaXNOYU4ocGFyc2VJbnQodCkpJiZuKDEzKSxvbi5zZXQuY2FsbCh0aGlzLHIsdCx2b2lkIDApfSxvbi5zZXQ9ZnVuY3Rpb24ocix0LGUpe3JldHVyblwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJlwibGVuZ3RoXCIhPT10JiZpc05hTihwYXJzZUludCh0KSkmJm4oMTQpLGVuLnNldC5jYWxsKHRoaXMsclswXSx0LGUsclswXSl9O3ZhciB1bj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUocil7dmFyIGU9dGhpczt0aGlzLmc9Qix0aGlzLkY9ITAsdGhpcy5wcm9kdWNlPWZ1bmN0aW9uKHIsaSxvKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiByJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBpKXt2YXIgdT1pO2k9cjt2YXIgYT1lO3JldHVybiBmdW5jdGlvbihuKXt2YXIgcj10aGlzO3ZvaWQgMD09PW4mJihuPXUpO2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLGU9QXJyYXkodD4xP3QtMTowKSxvPTE7bzx0O28rKyllW28tMV09YXJndW1lbnRzW29dO3JldHVybiBhLnByb2R1Y2UobiwoZnVuY3Rpb24obil7dmFyIHQ7cmV0dXJuKHQ9aSkuY2FsbC5hcHBseSh0LFtyLG5dLmNvbmNhdChlKSl9KSl9fXZhciBmO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGkmJm4oNiksdm9pZCAwIT09byYmXCJmdW5jdGlvblwiIT10eXBlb2YgbyYmbig3KSx0KHIpKXt2YXIgYz13KGUpLHM9UihlLHIsdm9pZCAwKSx2PSEwO3RyeXtmPWkocyksdj0hMX1maW5hbGx5e3Y/TyhjKTpnKGMpfXJldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBQcm9taXNlJiZmIGluc3RhbmNlb2YgUHJvbWlzZT9mLnRoZW4oKGZ1bmN0aW9uKG4pe3JldHVybiBqKGMsbyksUChuLGMpfSksKGZ1bmN0aW9uKG4pe3Rocm93IE8oYyksbn0pKTooaihjLG8pLFAoZixjKSl9aWYoIXJ8fFwib2JqZWN0XCIhPXR5cGVvZiByKXtpZih2b2lkIDA9PT0oZj1pKHIpKSYmKGY9ciksZj09PUgmJihmPXZvaWQgMCksZS5GJiZkKGYsITApLG8pe3ZhciBwPVtdLGw9W107YihcIlBhdGNoZXNcIikuTShyLGYscCxsKSxvKHAsbCl9cmV0dXJuIGZ9bigyMSxyKX0sdGhpcy5wcm9kdWNlV2l0aFBhdGNoZXM9ZnVuY3Rpb24obixyKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBuKXJldHVybiBmdW5jdGlvbihyKXtmb3IodmFyIHQ9YXJndW1lbnRzLmxlbmd0aCxpPUFycmF5KHQ+MT90LTE6MCksbz0xO288dDtvKyspaVtvLTFdPWFyZ3VtZW50c1tvXTtyZXR1cm4gZS5wcm9kdWNlV2l0aFBhdGNoZXMociwoZnVuY3Rpb24ocil7cmV0dXJuIG4uYXBwbHkodm9pZCAwLFtyXS5jb25jYXQoaSkpfSkpfTt2YXIgdCxpLG89ZS5wcm9kdWNlKG4sciwoZnVuY3Rpb24obixyKXt0PW4saT1yfSkpO3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBQcm9taXNlJiZvIGluc3RhbmNlb2YgUHJvbWlzZT9vLnRoZW4oKGZ1bmN0aW9uKG4pe3JldHVybltuLHQsaV19KSk6W28sdCxpXX0sXCJib29sZWFuXCI9PXR5cGVvZihudWxsPT1yP3ZvaWQgMDpyLnVzZVByb3hpZXMpJiZ0aGlzLnNldFVzZVByb3hpZXMoci51c2VQcm94aWVzKSxcImJvb2xlYW5cIj09dHlwZW9mKG51bGw9PXI/dm9pZCAwOnIuYXV0b0ZyZWV6ZSkmJnRoaXMuc2V0QXV0b0ZyZWV6ZShyLmF1dG9GcmVlemUpfXZhciBpPWUucHJvdG90eXBlO3JldHVybiBpLmNyZWF0ZURyYWZ0PWZ1bmN0aW9uKGUpe3QoZSl8fG4oOCkscihlKSYmKGU9RChlKSk7dmFyIGk9dyh0aGlzKSxvPVIodGhpcyxlLHZvaWQgMCk7cmV0dXJuIG9bUV0uQz0hMCxnKGkpLG99LGkuZmluaXNoRHJhZnQ9ZnVuY3Rpb24ocix0KXt2YXIgZT1yJiZyW1FdO1wicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJihlJiZlLkN8fG4oOSksZS5JJiZuKDEwKSk7dmFyIGk9ZS5BO3JldHVybiBqKGksdCksUCh2b2lkIDAsaSl9LGkuc2V0QXV0b0ZyZWV6ZT1mdW5jdGlvbihuKXt0aGlzLkY9bn0saS5zZXRVc2VQcm94aWVzPWZ1bmN0aW9uKHIpe3ImJiFCJiZuKDIwKSx0aGlzLmc9cn0saS5hcHBseVBhdGNoZXM9ZnVuY3Rpb24obix0KXt2YXIgZTtmb3IoZT10Lmxlbmd0aC0xO2U+PTA7ZS0tKXt2YXIgaT10W2VdO2lmKDA9PT1pLnBhdGgubGVuZ3RoJiZcInJlcGxhY2VcIj09PWkub3Ape249aS52YWx1ZTticmVha319ZT4tMSYmKHQ9dC5zbGljZShlKzEpKTt2YXIgbz1iKFwiUGF0Y2hlc1wiKS4kO3JldHVybiByKG4pP28obix0KTp0aGlzLnByb2R1Y2UobiwoZnVuY3Rpb24obil7cmV0dXJuIG8obix0KX0pKX0sZX0oKSxhbj1uZXcgdW4sZm49YW4ucHJvZHVjZSxjbj1hbi5wcm9kdWNlV2l0aFBhdGNoZXMuYmluZChhbiksc249YW4uc2V0QXV0b0ZyZWV6ZS5iaW5kKGFuKSx2bj1hbi5zZXRVc2VQcm94aWVzLmJpbmQoYW4pLHBuPWFuLmFwcGx5UGF0Y2hlcy5iaW5kKGFuKSxsbj1hbi5jcmVhdGVEcmFmdC5iaW5kKGFuKSxkbj1hbi5maW5pc2hEcmFmdC5iaW5kKGFuKTtleHBvcnQgZGVmYXVsdCBmbjtleHBvcnR7dW4gYXMgSW1tZXIscG4gYXMgYXBwbHlQYXRjaGVzLEsgYXMgY2FzdERyYWZ0LCQgYXMgY2FzdEltbXV0YWJsZSxsbiBhcyBjcmVhdGVEcmFmdCxEIGFzIGN1cnJlbnQsSiBhcyBlbmFibGVBbGxQbHVnaW5zLE4gYXMgZW5hYmxlRVM1LEMgYXMgZW5hYmxlTWFwU2V0LFQgYXMgZW5hYmxlUGF0Y2hlcyxkbiBhcyBmaW5pc2hEcmFmdCxkIGFzIGZyZWV6ZSxMIGFzIGltbWVyYWJsZSxyIGFzIGlzRHJhZnQsdCBhcyBpc0RyYWZ0YWJsZSxIIGFzIG5vdGhpbmcsZSBhcyBvcmlnaW5hbCxmbiBhcyBwcm9kdWNlLGNuIGFzIHByb2R1Y2VXaXRoUGF0Y2hlcyxzbiBhcyBzZXRBdXRvRnJlZXplLHZuIGFzIHNldFVzZVByb3hpZXN9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1tZXIuZXNtLmpzLm1hcFxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59IiwiaW1wb3J0IGRlZmluZVByb3BlcnR5IGZyb20gXCIuL2RlZmluZVByb3BlcnR5LmpzXCI7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufSIsImltcG9ydCBfb2JqZWN0U3ByZWFkIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFNwcmVhZDInO1xuXG4vKipcbiAqIEFkYXB0ZWQgZnJvbSBSZWFjdDogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3NoYXJlZC9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlLmpzXG4gKlxuICogRG8gbm90IHJlcXVpcmUgdGhpcyBtb2R1bGUgZGlyZWN0bHkhIFVzZSBub3JtYWwgdGhyb3cgZXJyb3IgY2FsbHMuIFRoZXNlIG1lc3NhZ2VzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBlcnJvciBjb2Rlc1xuICogZHVyaW5nIGJ1aWxkLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqL1xuZnVuY3Rpb24gZm9ybWF0UHJvZEVycm9yTWVzc2FnZShjb2RlKSB7XG4gIHJldHVybiBcIk1pbmlmaWVkIFJlZHV4IGVycm9yICNcIiArIGNvZGUgKyBcIjsgdmlzaXQgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvRXJyb3JzP2NvZGU9XCIgKyBjb2RlICsgXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgXCIgKyAndXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycy4gJztcbn1cblxuLy8gSW5saW5lZCB2ZXJzaW9uIG9mIHRoZSBgc3ltYm9sLW9ic2VydmFibGVgIHBvbHlmaWxsXG52YXIgJCRvYnNlcnZhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLm9ic2VydmFibGUgfHwgJ0BAb2JzZXJ2YWJsZSc7XG59KSgpO1xuXG4vKipcbiAqIFRoZXNlIGFyZSBwcml2YXRlIGFjdGlvbiB0eXBlcyByZXNlcnZlZCBieSBSZWR1eC5cbiAqIEZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB5b3UgbXVzdCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBJZiB0aGUgY3VycmVudCBzdGF0ZSBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAqIERvIG5vdCByZWZlcmVuY2UgdGhlc2UgYWN0aW9uIHR5cGVzIGRpcmVjdGx5IGluIHlvdXIgY29kZS5cbiAqL1xudmFyIHJhbmRvbVN0cmluZyA9IGZ1bmN0aW9uIHJhbmRvbVN0cmluZygpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KS5zcGxpdCgnJykuam9pbignLicpO1xufTtcblxudmFyIEFjdGlvblR5cGVzID0ge1xuICBJTklUOiBcIkBAcmVkdXgvSU5JVFwiICsgcmFuZG9tU3RyaW5nKCksXG4gIFJFUExBQ0U6IFwiQEByZWR1eC9SRVBMQUNFXCIgKyByYW5kb21TdHJpbmcoKSxcbiAgUFJPQkVfVU5LTk9XTl9BQ1RJT046IGZ1bmN0aW9uIFBST0JFX1VOS05PV05fQUNUSU9OKCkge1xuICAgIHJldHVybiBcIkBAcmVkdXgvUFJPQkVfVU5LTk9XTl9BQ1RJT05cIiArIHJhbmRvbVN0cmluZygpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBvYmogVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGFyZ3VtZW50IGFwcGVhcnMgdG8gYmUgYSBwbGFpbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgdmFyIHByb3RvID0gb2JqO1xuXG4gIHdoaWxlIChPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pICE9PSBudWxsKSB7XG4gICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09PSBwcm90bztcbn1cblxuLy8gSW5saW5lZCAvIHNob3J0ZW5lZCB2ZXJzaW9uIG9mIGBraW5kT2ZgIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQva2luZC1vZlxuZnVuY3Rpb24gbWluaUtpbmRPZih2YWwpIHtcbiAgaWYgKHZhbCA9PT0gdm9pZCAwKSByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIGlmICh2YWwgPT09IG51bGwpIHJldHVybiAnbnVsbCc7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkgcmV0dXJuICdhcnJheSc7XG4gIGlmIChpc0RhdGUodmFsKSkgcmV0dXJuICdkYXRlJztcbiAgaWYgKGlzRXJyb3IodmFsKSkgcmV0dXJuICdlcnJvcic7XG4gIHZhciBjb25zdHJ1Y3Rvck5hbWUgPSBjdG9yTmFtZSh2YWwpO1xuXG4gIHN3aXRjaCAoY29uc3RydWN0b3JOYW1lKSB7XG4gICAgY2FzZSAnU3ltYm9sJzpcbiAgICBjYXNlICdQcm9taXNlJzpcbiAgICBjYXNlICdXZWFrTWFwJzpcbiAgICBjYXNlICdXZWFrU2V0JzpcbiAgICBjYXNlICdNYXAnOlxuICAgIGNhc2UgJ1NldCc6XG4gICAgICByZXR1cm4gY29uc3RydWN0b3JOYW1lO1xuICB9IC8vIG90aGVyXG5cblxuICByZXR1cm4gdHlwZS5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMvZywgJycpO1xufVxuXG5mdW5jdGlvbiBjdG9yTmFtZSh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwuY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicgPyB2YWwuY29uc3RydWN0b3IubmFtZSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3IodmFsKSB7XG4gIHJldHVybiB2YWwgaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgdmFsLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmIHZhbC5jb25zdHJ1Y3RvciAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLnN0YWNrVHJhY2VMaW1pdCA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpIHJldHVybiB0cnVlO1xuICByZXR1cm4gdHlwZW9mIHZhbC50b0RhdGVTdHJpbmcgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbC5nZXREYXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWwuc2V0RGF0ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24ga2luZE9mKHZhbCkge1xuICB2YXIgdHlwZU9mVmFsID0gdHlwZW9mIHZhbDtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHR5cGVPZlZhbCA9IG1pbmlLaW5kT2YodmFsKTtcbiAgfVxuXG4gIHJldHVybiB0eXBlT2ZWYWw7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqXG4gKiAqKldlIHJlY29tbWVuZCB1c2luZyB0aGUgYGNvbmZpZ3VyZVN0b3JlYCBtZXRob2RcbiAqIG9mIHRoZSBgQHJlZHV4anMvdG9vbGtpdGAgcGFja2FnZSoqLCB3aGljaCByZXBsYWNlcyBgY3JlYXRlU3RvcmVgLlxuICpcbiAqIFJlZHV4IFRvb2xraXQgaXMgb3VyIHJlY29tbWVuZGVkIGFwcHJvYWNoIGZvciB3cml0aW5nIFJlZHV4IGxvZ2ljIHRvZGF5LFxuICogaW5jbHVkaW5nIHN0b3JlIHNldHVwLCByZWR1Y2VycywgZGF0YSBmZXRjaGluZywgYW5kIG1vcmUuXG4gKlxuICogKipGb3IgbW9yZSBkZXRhaWxzLCBwbGVhc2UgcmVhZCB0aGlzIFJlZHV4IGRvY3MgcGFnZToqKlxuICogKipodHRwczovL3JlZHV4LmpzLm9yZy9pbnRyb2R1Y3Rpb24vd2h5LXJ0ay1pcy1yZWR1eC10b2RheSoqXG4gKlxuICogYGNvbmZpZ3VyZVN0b3JlYCBmcm9tIFJlZHV4IFRvb2xraXQgaXMgYW4gaW1wcm92ZWQgdmVyc2lvbiBvZiBgY3JlYXRlU3RvcmVgIHRoYXRcbiAqIHNpbXBsaWZpZXMgc2V0dXAgYW5kIGhlbHBzIGF2b2lkIGNvbW1vbiBidWdzLlxuICpcbiAqIFlvdSBzaG91bGQgbm90IGJlIHVzaW5nIHRoZSBgcmVkdXhgIGNvcmUgcGFja2FnZSBieSBpdHNlbGYgdG9kYXksIGV4Y2VwdCBmb3IgbGVhcm5pbmcgcHVycG9zZXMuXG4gKiBUaGUgYGNyZWF0ZVN0b3JlYCBtZXRob2QgZnJvbSB0aGUgY29yZSBgcmVkdXhgIHBhY2thZ2Ugd2lsbCBub3QgYmUgcmVtb3ZlZCwgYnV0IHdlIGVuY291cmFnZVxuICogYWxsIHVzZXJzIHRvIG1pZ3JhdGUgdG8gdXNpbmcgUmVkdXggVG9vbGtpdCBmb3IgYWxsIFJlZHV4IGNvZGUuXG4gKlxuICogSWYgeW91IHdhbnQgdG8gdXNlIGBjcmVhdGVTdG9yZWAgd2l0aG91dCB0aGlzIHZpc3VhbCBkZXByZWNhdGlvbiB3YXJuaW5nLCB1c2VcbiAqIHRoZSBgbGVnYWN5X2NyZWF0ZVN0b3JlYCBpbXBvcnQgaW5zdGVhZDpcbiAqXG4gKiBgaW1wb3J0IHsgbGVnYWN5X2NyZWF0ZVN0b3JlIGFzIGNyZWF0ZVN0b3JlfSBmcm9tICdyZWR1eCdgXG4gKlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBlbmhhbmNlcikge1xuICB2YXIgX3JlZjI7XG5cbiAgaWYgKHR5cGVvZiBwcmVsb2FkZWRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZW5oYW5jZXIgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVuaGFuY2VyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgwKSA6ICdJdCBsb29rcyBsaWtlIHlvdSBhcmUgcGFzc2luZyBzZXZlcmFsIHN0b3JlIGVuaGFuY2VycyB0byAnICsgJ2NyZWF0ZVN0b3JlKCkuIFRoaXMgaXMgbm90IHN1cHBvcnRlZC4gSW5zdGVhZCwgY29tcG9zZSB0aGVtICcgKyAndG9nZXRoZXIgdG8gYSBzaW5nbGUgZnVuY3Rpb24uIFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3BhcnQtNC1zdG9yZSNjcmVhdGluZy1hLXN0b3JlLXdpdGgtZW5oYW5jZXJzIGZvciBhbiBleGFtcGxlLicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwcmVsb2FkZWRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZW5oYW5jZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZW5oYW5jZXIgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgICBwcmVsb2FkZWRTdGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMSkgOiBcIkV4cGVjdGVkIHRoZSBlbmhhbmNlciB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkLCByZWNlaXZlZDogJ1wiICsga2luZE9mKGVuaGFuY2VyKSArIFwiJ1wiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5oYW5jZXIoY3JlYXRlU3RvcmUpKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIpIDogXCJFeHBlY3RlZCB0aGUgcm9vdCByZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQsIHJlY2VpdmVkOiAnXCIgKyBraW5kT2YocmVkdWNlcikgKyBcIidcIik7XG4gIH1cblxuICB2YXIgY3VycmVudFJlZHVjZXIgPSByZWR1Y2VyO1xuICB2YXIgY3VycmVudFN0YXRlID0gcHJlbG9hZGVkU3RhdGU7XG4gIHZhciBjdXJyZW50TGlzdGVuZXJzID0gW107XG4gIHZhciBuZXh0TGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycztcbiAgdmFyIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgLyoqXG4gICAqIFRoaXMgbWFrZXMgYSBzaGFsbG93IGNvcHkgb2YgY3VycmVudExpc3RlbmVycyBzbyB3ZSBjYW4gdXNlXG4gICAqIG5leHRMaXN0ZW5lcnMgYXMgYSB0ZW1wb3JhcnkgbGlzdCB3aGlsZSBkaXNwYXRjaGluZy5cbiAgICpcbiAgICogVGhpcyBwcmV2ZW50cyBhbnkgYnVncyBhcm91bmQgY29uc3VtZXJzIGNhbGxpbmdcbiAgICogc3Vic2NyaWJlL3Vuc3Vic2NyaWJlIGluIHRoZSBtaWRkbGUgb2YgYSBkaXNwYXRjaC5cbiAgICovXG5cbiAgZnVuY3Rpb24gZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpIHtcbiAgICBpZiAobmV4dExpc3RlbmVycyA9PT0gY3VycmVudExpc3RlbmVycykge1xuICAgICAgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMuc2xpY2UoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBzdGF0ZSB0cmVlIG1hbmFnZWQgYnkgdGhlIHN0b3JlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7YW55fSBUaGUgY3VycmVudCBzdGF0ZSB0cmVlIG9mIHlvdXIgYXBwbGljYXRpb24uXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMpIDogJ1lvdSBtYXkgbm90IGNhbGwgc3RvcmUuZ2V0U3RhdGUoKSB3aGlsZSB0aGUgcmVkdWNlciBpcyBleGVjdXRpbmcuICcgKyAnVGhlIHJlZHVjZXIgaGFzIGFscmVhZHkgcmVjZWl2ZWQgdGhlIHN0YXRlIGFzIGFuIGFyZ3VtZW50LiAnICsgJ1Bhc3MgaXQgZG93biBmcm9tIHRoZSB0b3AgcmVkdWNlciBpbnN0ZWFkIG9mIHJlYWRpbmcgaXQgZnJvbSB0aGUgc3RvcmUuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnRTdGF0ZTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIGNoYW5nZSBsaXN0ZW5lci4gSXQgd2lsbCBiZSBjYWxsZWQgYW55IHRpbWUgYW4gYWN0aW9uIGlzIGRpc3BhdGNoZWQsXG4gICAqIGFuZCBzb21lIHBhcnQgb2YgdGhlIHN0YXRlIHRyZWUgbWF5IHBvdGVudGlhbGx5IGhhdmUgY2hhbmdlZC4gWW91IG1heSB0aGVuXG4gICAqIGNhbGwgYGdldFN0YXRlKClgIHRvIHJlYWQgdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBpbnNpZGUgdGhlIGNhbGxiYWNrLlxuICAgKlxuICAgKiBZb3UgbWF5IGNhbGwgYGRpc3BhdGNoKClgIGZyb20gYSBjaGFuZ2UgbGlzdGVuZXIsIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgKiBjYXZlYXRzOlxuICAgKlxuICAgKiAxLiBUaGUgc3Vic2NyaXB0aW9ucyBhcmUgc25hcHNob3R0ZWQganVzdCBiZWZvcmUgZXZlcnkgYGRpc3BhdGNoKClgIGNhbGwuXG4gICAqIElmIHlvdSBzdWJzY3JpYmUgb3IgdW5zdWJzY3JpYmUgd2hpbGUgdGhlIGxpc3RlbmVycyBhcmUgYmVpbmcgaW52b2tlZCwgdGhpc1xuICAgKiB3aWxsIG5vdCBoYXZlIGFueSBlZmZlY3Qgb24gdGhlIGBkaXNwYXRjaCgpYCB0aGF0IGlzIGN1cnJlbnRseSBpbiBwcm9ncmVzcy5cbiAgICogSG93ZXZlciwgdGhlIG5leHQgYGRpc3BhdGNoKClgIGNhbGwsIHdoZXRoZXIgbmVzdGVkIG9yIG5vdCwgd2lsbCB1c2UgYSBtb3JlXG4gICAqIHJlY2VudCBzbmFwc2hvdCBvZiB0aGUgc3Vic2NyaXB0aW9uIGxpc3QuXG4gICAqXG4gICAqIDIuIFRoZSBsaXN0ZW5lciBzaG91bGQgbm90IGV4cGVjdCB0byBzZWUgYWxsIHN0YXRlIGNoYW5nZXMsIGFzIHRoZSBzdGF0ZVxuICAgKiBtaWdodCBoYXZlIGJlZW4gdXBkYXRlZCBtdWx0aXBsZSB0aW1lcyBkdXJpbmcgYSBuZXN0ZWQgYGRpc3BhdGNoKClgIGJlZm9yZVxuICAgKiB0aGUgbGlzdGVuZXIgaXMgY2FsbGVkLiBJdCBpcywgaG93ZXZlciwgZ3VhcmFudGVlZCB0aGF0IGFsbCBzdWJzY3JpYmVyc1xuICAgKiByZWdpc3RlcmVkIGJlZm9yZSB0aGUgYGRpc3BhdGNoKClgIHN0YXJ0ZWQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgbGF0ZXN0XG4gICAqIHN0YXRlIGJ5IHRoZSB0aW1lIGl0IGV4aXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBBIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgb24gZXZlcnkgZGlzcGF0Y2guXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0byByZW1vdmUgdGhpcyBjaGFuZ2UgbGlzdGVuZXIuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNCkgOiBcIkV4cGVjdGVkIHRoZSBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkLCByZWNlaXZlZDogJ1wiICsga2luZE9mKGxpc3RlbmVyKSArIFwiJ1wiKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNSkgOiAnWW91IG1heSBub3QgY2FsbCBzdG9yZS5zdWJzY3JpYmUoKSB3aGlsZSB0aGUgcmVkdWNlciBpcyBleGVjdXRpbmcuICcgKyAnSWYgeW91IHdvdWxkIGxpa2UgdG8gYmUgbm90aWZpZWQgYWZ0ZXIgdGhlIHN0b3JlIGhhcyBiZWVuIHVwZGF0ZWQsIHN1YnNjcmliZSBmcm9tIGEgJyArICdjb21wb25lbnQgYW5kIGludm9rZSBzdG9yZS5nZXRTdGF0ZSgpIGluIHRoZSBjYWxsYmFjayB0byBhY2Nlc3MgdGhlIGxhdGVzdCBzdGF0ZS4gJyArICdTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvYXBpL3N0b3JlI3N1YnNjcmliZWxpc3RlbmVyIGZvciBtb3JlIGRldGFpbHMuJyk7XG4gICAgfVxuXG4gICAgdmFyIGlzU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgIG5leHRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgaWYgKCFpc1N1YnNjcmliZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg2KSA6ICdZb3UgbWF5IG5vdCB1bnN1YnNjcmliZSBmcm9tIGEgc3RvcmUgbGlzdGVuZXIgd2hpbGUgdGhlIHJlZHVjZXIgaXMgZXhlY3V0aW5nLiAnICsgJ1NlZSBodHRwczovL3JlZHV4LmpzLm9yZy9hcGkvc3RvcmUjc3Vic2NyaWJlbGlzdGVuZXIgZm9yIG1vcmUgZGV0YWlscy4nKTtcbiAgICAgIH1cblxuICAgICAgaXNTdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgICB2YXIgaW5kZXggPSBuZXh0TGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgbmV4dExpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgY3VycmVudExpc3RlbmVycyA9IG51bGw7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbiBhY3Rpb24uIEl0IGlzIHRoZSBvbmx5IHdheSB0byB0cmlnZ2VyIGEgc3RhdGUgY2hhbmdlLlxuICAgKlxuICAgKiBUaGUgYHJlZHVjZXJgIGZ1bmN0aW9uLCB1c2VkIHRvIGNyZWF0ZSB0aGUgc3RvcmUsIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlXG4gICAqIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGdpdmVuIGBhY3Rpb25gLiBJdHMgcmV0dXJuIHZhbHVlIHdpbGxcbiAgICogYmUgY29uc2lkZXJlZCB0aGUgKipuZXh0Kiogc3RhdGUgb2YgdGhlIHRyZWUsIGFuZCB0aGUgY2hhbmdlIGxpc3RlbmVyc1xuICAgKiB3aWxsIGJlIG5vdGlmaWVkLlxuICAgKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvbmx5IHN1cHBvcnRzIHBsYWluIG9iamVjdCBhY3Rpb25zLiBJZiB5b3Ugd2FudCB0b1xuICAgKiBkaXNwYXRjaCBhIFByb21pc2UsIGFuIE9ic2VydmFibGUsIGEgdGh1bmssIG9yIHNvbWV0aGluZyBlbHNlLCB5b3UgbmVlZCB0b1xuICAgKiB3cmFwIHlvdXIgc3RvcmUgY3JlYXRpbmcgZnVuY3Rpb24gaW50byB0aGUgY29ycmVzcG9uZGluZyBtaWRkbGV3YXJlLiBGb3JcbiAgICogZXhhbXBsZSwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgYHJlZHV4LXRodW5rYCBwYWNrYWdlLiBFdmVuIHRoZVxuICAgKiBtaWRkbGV3YXJlIHdpbGwgZXZlbnR1YWxseSBkaXNwYXRjaCBwbGFpbiBvYmplY3QgYWN0aW9ucyB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBBIHBsYWluIG9iamVjdCByZXByZXNlbnRpbmcg4oCcd2hhdCBjaGFuZ2Vk4oCdLiBJdCBpc1xuICAgKiBhIGdvb2QgaWRlYSB0byBrZWVwIGFjdGlvbnMgc2VyaWFsaXphYmxlIHNvIHlvdSBjYW4gcmVjb3JkIGFuZCByZXBsYXkgdXNlclxuICAgKiBzZXNzaW9ucywgb3IgdXNlIHRoZSB0aW1lIHRyYXZlbGxpbmcgYHJlZHV4LWRldnRvb2xzYC4gQW4gYWN0aW9uIG11c3QgaGF2ZVxuICAgKiBhIGB0eXBlYCBwcm9wZXJ0eSB3aGljaCBtYXkgbm90IGJlIGB1bmRlZmluZWRgLiBJdCBpcyBhIGdvb2QgaWRlYSB0byB1c2VcbiAgICogc3RyaW5nIGNvbnN0YW50cyBmb3IgYWN0aW9uIHR5cGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBGb3IgY29udmVuaWVuY2UsIHRoZSBzYW1lIGFjdGlvbiBvYmplY3QgeW91IGRpc3BhdGNoZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCwgaWYgeW91IHVzZSBhIGN1c3RvbSBtaWRkbGV3YXJlLCBpdCBtYXkgd3JhcCBgZGlzcGF0Y2goKWAgdG9cbiAgICogcmV0dXJuIHNvbWV0aGluZyBlbHNlIChmb3IgZXhhbXBsZSwgYSBQcm9taXNlIHlvdSBjYW4gYXdhaXQpLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbikge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg3KSA6IFwiQWN0aW9ucyBtdXN0IGJlIHBsYWluIG9iamVjdHMuIEluc3RlYWQsIHRoZSBhY3R1YWwgdHlwZSB3YXM6ICdcIiArIGtpbmRPZihhY3Rpb24pICsgXCInLiBZb3UgbWF5IG5lZWQgdG8gYWRkIG1pZGRsZXdhcmUgdG8geW91ciBzdG9yZSBzZXR1cCB0byBoYW5kbGUgZGlzcGF0Y2hpbmcgb3RoZXIgdmFsdWVzLCBzdWNoIGFzICdyZWR1eC10aHVuaycgdG8gaGFuZGxlIGRpc3BhdGNoaW5nIGZ1bmN0aW9ucy4gU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvcGFydC00LXN0b3JlI21pZGRsZXdhcmUgYW5kIGh0dHBzOi8vcmVkdXguanMub3JnL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvcGFydC02LWFzeW5jLWxvZ2ljI3VzaW5nLXRoZS1yZWR1eC10aHVuay1taWRkbGV3YXJlIGZvciBleGFtcGxlcy5cIik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhY3Rpb24udHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDgpIDogJ0FjdGlvbnMgbWF5IG5vdCBoYXZlIGFuIHVuZGVmaW5lZCBcInR5cGVcIiBwcm9wZXJ0eS4gWW91IG1heSBoYXZlIG1pc3NwZWxsZWQgYW4gYWN0aW9uIHR5cGUgc3RyaW5nIGNvbnN0YW50LicpO1xuICAgIH1cblxuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg5KSA6ICdSZWR1Y2VycyBtYXkgbm90IGRpc3BhdGNoIGFjdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSB0cnVlO1xuICAgICAgY3VycmVudFN0YXRlID0gY3VycmVudFJlZHVjZXIoY3VycmVudFN0YXRlLCBhY3Rpb24pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGxpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMgPSBuZXh0TGlzdGVuZXJzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGlvbjtcbiAgfVxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIHJlZHVjZXIgY3VycmVudGx5IHVzZWQgYnkgdGhlIHN0b3JlIHRvIGNhbGN1bGF0ZSB0aGUgc3RhdGUuXG4gICAqXG4gICAqIFlvdSBtaWdodCBuZWVkIHRoaXMgaWYgeW91ciBhcHAgaW1wbGVtZW50cyBjb2RlIHNwbGl0dGluZyBhbmQgeW91IHdhbnQgdG9cbiAgICogbG9hZCBzb21lIG9mIHRoZSByZWR1Y2VycyBkeW5hbWljYWxseS4gWW91IG1pZ2h0IGFsc28gbmVlZCB0aGlzIGlmIHlvdVxuICAgKiBpbXBsZW1lbnQgYSBob3QgcmVsb2FkaW5nIG1lY2hhbmlzbSBmb3IgUmVkdXguXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRSZWR1Y2VyIFRoZSByZWR1Y2VyIGZvciB0aGUgc3RvcmUgdG8gdXNlIGluc3RlYWQuXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHJlcGxhY2VSZWR1Y2VyKG5leHRSZWR1Y2VyKSB7XG4gICAgaWYgKHR5cGVvZiBuZXh0UmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTApIDogXCJFeHBlY3RlZCB0aGUgbmV4dFJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICdcIiArIGtpbmRPZihuZXh0UmVkdWNlcikpO1xuICAgIH1cblxuICAgIGN1cnJlbnRSZWR1Y2VyID0gbmV4dFJlZHVjZXI7IC8vIFRoaXMgYWN0aW9uIGhhcyBhIHNpbWlsaWFyIGVmZmVjdCB0byBBY3Rpb25UeXBlcy5JTklULlxuICAgIC8vIEFueSByZWR1Y2VycyB0aGF0IGV4aXN0ZWQgaW4gYm90aCB0aGUgbmV3IGFuZCBvbGQgcm9vdFJlZHVjZXJcbiAgICAvLyB3aWxsIHJlY2VpdmUgdGhlIHByZXZpb3VzIHN0YXRlLiBUaGlzIGVmZmVjdGl2ZWx5IHBvcHVsYXRlc1xuICAgIC8vIHRoZSBuZXcgc3RhdGUgdHJlZSB3aXRoIGFueSByZWxldmFudCBkYXRhIGZyb20gdGhlIG9sZCBvbmUuXG5cbiAgICBkaXNwYXRjaCh7XG4gICAgICB0eXBlOiBBY3Rpb25UeXBlcy5SRVBMQUNFXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEludGVyb3BlcmFiaWxpdHkgcG9pbnQgZm9yIG9ic2VydmFibGUvcmVhY3RpdmUgbGlicmFyaWVzLlxuICAgKiBAcmV0dXJucyB7b2JzZXJ2YWJsZX0gQSBtaW5pbWFsIG9ic2VydmFibGUgb2Ygc3RhdGUgY2hhbmdlcy5cbiAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgb2JzZXJ2YWJsZSBwcm9wb3NhbDpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JzZXJ2YWJsZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG9ic2VydmFibGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgb3V0ZXJTdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgcmV0dXJuIF9yZWYgPSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBtaW5pbWFsIG9ic2VydmFibGUgc3Vic2NyaXB0aW9uIG1ldGhvZC5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYnNlcnZlciBBbnkgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gb2JzZXJ2ZXIuXG4gICAgICAgKiBUaGUgb2JzZXJ2ZXIgb2JqZWN0IHNob3VsZCBoYXZlIGEgYG5leHRgIG1ldGhvZC5cbiAgICAgICAqIEByZXR1cm5zIHtzdWJzY3JpcHRpb259IEFuIG9iamVjdCB3aXRoIGFuIGB1bnN1YnNjcmliZWAgbWV0aG9kIHRoYXQgY2FuXG4gICAgICAgKiBiZSB1c2VkIHRvIHVuc3Vic2NyaWJlIHRoZSBvYnNlcnZhYmxlIGZyb20gdGhlIHN0b3JlLCBhbmQgcHJldmVudCBmdXJ0aGVyXG4gICAgICAgKiBlbWlzc2lvbiBvZiB2YWx1ZXMgZnJvbSB0aGUgb2JzZXJ2YWJsZS5cbiAgICAgICAqL1xuICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYnNlcnZlciAhPT0gJ29iamVjdCcgfHwgb2JzZXJ2ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMSkgOiBcIkV4cGVjdGVkIHRoZSBvYnNlcnZlciB0byBiZSBhbiBvYmplY3QuIEluc3RlYWQsIHJlY2VpdmVkOiAnXCIgKyBraW5kT2Yob2JzZXJ2ZXIpICsgXCInXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb2JzZXJ2ZVN0YXRlKCkge1xuICAgICAgICAgIGlmIChvYnNlcnZlci5uZXh0KSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGdldFN0YXRlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9ic2VydmVTdGF0ZSgpO1xuICAgICAgICB2YXIgdW5zdWJzY3JpYmUgPSBvdXRlclN1YnNjcmliZShvYnNlcnZlU3RhdGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVuc3Vic2NyaWJlOiB1bnN1YnNjcmliZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIF9yZWZbJCRvYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIF9yZWY7XG4gIH0gLy8gV2hlbiBhIHN0b3JlIGlzIGNyZWF0ZWQsIGFuIFwiSU5JVFwiIGFjdGlvbiBpcyBkaXNwYXRjaGVkIHNvIHRoYXQgZXZlcnlcbiAgLy8gcmVkdWNlciByZXR1cm5zIHRoZWlyIGluaXRpYWwgc3RhdGUuIFRoaXMgZWZmZWN0aXZlbHkgcG9wdWxhdGVzXG4gIC8vIHRoZSBpbml0aWFsIHN0YXRlIHRyZWUuXG5cblxuICBkaXNwYXRjaCh7XG4gICAgdHlwZTogQWN0aW9uVHlwZXMuSU5JVFxuICB9KTtcbiAgcmV0dXJuIF9yZWYyID0ge1xuICAgIGRpc3BhdGNoOiBkaXNwYXRjaCxcbiAgICBzdWJzY3JpYmU6IHN1YnNjcmliZSxcbiAgICBnZXRTdGF0ZTogZ2V0U3RhdGUsXG4gICAgcmVwbGFjZVJlZHVjZXI6IHJlcGxhY2VSZWR1Y2VyXG4gIH0sIF9yZWYyWyQkb2JzZXJ2YWJsZV0gPSBvYnNlcnZhYmxlLCBfcmVmMjtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIFJlZHV4IHN0b3JlIHRoYXQgaG9sZHMgdGhlIHN0YXRlIHRyZWUuXG4gKlxuICogKipXZSByZWNvbW1lbmQgdXNpbmcgYGNvbmZpZ3VyZVN0b3JlYCBmcm9tIHRoZVxuICogYEByZWR1eGpzL3Rvb2xraXRgIHBhY2thZ2UqKiwgd2hpY2ggcmVwbGFjZXMgYGNyZWF0ZVN0b3JlYDpcbiAqICoqaHR0cHM6Ly9yZWR1eC5qcy5vcmcvaW50cm9kdWN0aW9uL3doeS1ydGstaXMtcmVkdXgtdG9kYXkqKlxuICpcbiAqIFRoZSBvbmx5IHdheSB0byBjaGFuZ2UgdGhlIGRhdGEgaW4gdGhlIHN0b3JlIGlzIHRvIGNhbGwgYGRpc3BhdGNoKClgIG9uIGl0LlxuICpcbiAqIFRoZXJlIHNob3VsZCBvbmx5IGJlIGEgc2luZ2xlIHN0b3JlIGluIHlvdXIgYXBwLiBUbyBzcGVjaWZ5IGhvdyBkaWZmZXJlbnRcbiAqIHBhcnRzIG9mIHRoZSBzdGF0ZSB0cmVlIHJlc3BvbmQgdG8gYWN0aW9ucywgeW91IG1heSBjb21iaW5lIHNldmVyYWwgcmVkdWNlcnNcbiAqIGludG8gYSBzaW5nbGUgcmVkdWNlciBmdW5jdGlvbiBieSB1c2luZyBgY29tYmluZVJlZHVjZXJzYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWR1Y2VyIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBuZXh0IHN0YXRlIHRyZWUsIGdpdmVuXG4gKiB0aGUgY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgYWN0aW9uIHRvIGhhbmRsZS5cbiAqXG4gKiBAcGFyYW0ge2FueX0gW3ByZWxvYWRlZFN0YXRlXSBUaGUgaW5pdGlhbCBzdGF0ZS4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAqIHRvIGh5ZHJhdGUgdGhlIHN0YXRlIGZyb20gdGhlIHNlcnZlciBpbiB1bml2ZXJzYWwgYXBwcywgb3IgdG8gcmVzdG9yZSBhXG4gKiBwcmV2aW91c2x5IHNlcmlhbGl6ZWQgdXNlciBzZXNzaW9uLlxuICogSWYgeW91IHVzZSBgY29tYmluZVJlZHVjZXJzYCB0byBwcm9kdWNlIHRoZSByb290IHJlZHVjZXIgZnVuY3Rpb24sIHRoaXMgbXVzdCBiZVxuICogYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUgYXMgYGNvbWJpbmVSZWR1Y2Vyc2Aga2V5cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZW5oYW5jZXJdIFRoZSBzdG9yZSBlbmhhbmNlci4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAqIHRvIGVuaGFuY2UgdGhlIHN0b3JlIHdpdGggdGhpcmQtcGFydHkgY2FwYWJpbGl0aWVzIHN1Y2ggYXMgbWlkZGxld2FyZSxcbiAqIHRpbWUgdHJhdmVsLCBwZXJzaXN0ZW5jZSwgZXRjLiBUaGUgb25seSBzdG9yZSBlbmhhbmNlciB0aGF0IHNoaXBzIHdpdGggUmVkdXhcbiAqIGlzIGBhcHBseU1pZGRsZXdhcmUoKWAuXG4gKlxuICogQHJldHVybnMge1N0b3JlfSBBIFJlZHV4IHN0b3JlIHRoYXQgbGV0cyB5b3UgcmVhZCB0aGUgc3RhdGUsIGRpc3BhdGNoIGFjdGlvbnNcbiAqIGFuZCBzdWJzY3JpYmUgdG8gY2hhbmdlcy5cbiAqL1xuXG52YXIgbGVnYWN5X2NyZWF0ZVN0b3JlID0gY3JlYXRlU3RvcmU7XG5cbi8qKlxuICogUHJpbnRzIGEgd2FybmluZyBpbiB0aGUgY29uc29sZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cblxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCBpZiB5b3UgZW5hYmxlXG4gICAgLy8gXCJicmVhayBvbiBhbGwgZXhjZXB0aW9uc1wiIGluIHlvdXIgY29uc29sZSxcbiAgICAvLyBpdCB3b3VsZCBwYXVzZSB0aGUgZXhlY3V0aW9uIGF0IHRoaXMgbGluZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH0gY2F0Y2ggKGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcblxufVxuXG5mdW5jdGlvbiBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKGlucHV0U3RhdGUsIHJlZHVjZXJzLCBhY3Rpb24sIHVuZXhwZWN0ZWRLZXlDYWNoZSkge1xuICB2YXIgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIHZhciBhcmd1bWVudE5hbWUgPSBhY3Rpb24gJiYgYWN0aW9uLnR5cGUgPT09IEFjdGlvblR5cGVzLklOSVQgPyAncHJlbG9hZGVkU3RhdGUgYXJndW1lbnQgcGFzc2VkIHRvIGNyZWF0ZVN0b3JlJyA6ICdwcmV2aW91cyBzdGF0ZSByZWNlaXZlZCBieSB0aGUgcmVkdWNlcic7XG5cbiAgaWYgKHJlZHVjZXJLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnU3RvcmUgZG9lcyBub3QgaGF2ZSBhIHZhbGlkIHJlZHVjZXIuIE1ha2Ugc3VyZSB0aGUgYXJndW1lbnQgcGFzc2VkICcgKyAndG8gY29tYmluZVJlZHVjZXJzIGlzIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIHJlZHVjZXJzLic7XG4gIH1cblxuICBpZiAoIWlzUGxhaW5PYmplY3QoaW5wdXRTdGF0ZSkpIHtcbiAgICByZXR1cm4gXCJUaGUgXCIgKyBhcmd1bWVudE5hbWUgKyBcIiBoYXMgdW5leHBlY3RlZCB0eXBlIG9mIFxcXCJcIiArIGtpbmRPZihpbnB1dFN0YXRlKSArIFwiXFxcIi4gRXhwZWN0ZWQgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBcIiArIChcImtleXM6IFxcXCJcIiArIHJlZHVjZXJLZXlzLmpvaW4oJ1wiLCBcIicpICsgXCJcXFwiXCIpO1xuICB9XG5cbiAgdmFyIHVuZXhwZWN0ZWRLZXlzID0gT2JqZWN0LmtleXMoaW5wdXRTdGF0ZSkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gIXJlZHVjZXJzLmhhc093blByb3BlcnR5KGtleSkgJiYgIXVuZXhwZWN0ZWRLZXlDYWNoZVtrZXldO1xuICB9KTtcbiAgdW5leHBlY3RlZEtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdW5leHBlY3RlZEtleUNhY2hlW2tleV0gPSB0cnVlO1xuICB9KTtcbiAgaWYgKGFjdGlvbiAmJiBhY3Rpb24udHlwZSA9PT0gQWN0aW9uVHlwZXMuUkVQTEFDRSkgcmV0dXJuO1xuXG4gIGlmICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIFwiVW5leHBlY3RlZCBcIiArICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAxID8gJ2tleXMnIDogJ2tleScpICsgXCIgXCIgKyAoXCJcXFwiXCIgKyB1bmV4cGVjdGVkS2V5cy5qb2luKCdcIiwgXCInKSArIFwiXFxcIiBmb3VuZCBpbiBcIiArIGFyZ3VtZW50TmFtZSArIFwiLiBcIikgKyBcIkV4cGVjdGVkIHRvIGZpbmQgb25lIG9mIHRoZSBrbm93biByZWR1Y2VyIGtleXMgaW5zdGVhZDogXCIgKyAoXCJcXFwiXCIgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArIFwiXFxcIi4gVW5leHBlY3RlZCBrZXlzIHdpbGwgYmUgaWdub3JlZC5cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0UmVkdWNlclNoYXBlKHJlZHVjZXJzKSB7XG4gIE9iamVjdC5rZXlzKHJlZHVjZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcmVkdWNlciA9IHJlZHVjZXJzW2tleV07XG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IHJlZHVjZXIodW5kZWZpbmVkLCB7XG4gICAgICB0eXBlOiBBY3Rpb25UeXBlcy5JTklUXG4gICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEyKSA6IFwiVGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgcmV0dXJuZWQgdW5kZWZpbmVkIGR1cmluZyBpbml0aWFsaXphdGlvbi4gXCIgKyBcIklmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlIHJlZHVjZXIgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCBcIiArIFwiZXhwbGljaXRseSByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSBcIiArIFwibm90IGJlIHVuZGVmaW5lZC4gSWYgeW91IGRvbid0IHdhbnQgdG8gc2V0IGEgdmFsdWUgZm9yIHRoaXMgcmVkdWNlciwgXCIgKyBcInlvdSBjYW4gdXNlIG51bGwgaW5zdGVhZCBvZiB1bmRlZmluZWQuXCIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcmVkdWNlcih1bmRlZmluZWQsIHtcbiAgICAgIHR5cGU6IEFjdGlvblR5cGVzLlBST0JFX1VOS05PV05fQUNUSU9OKClcbiAgICB9KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEzKSA6IFwiVGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgcmV0dXJuZWQgdW5kZWZpbmVkIHdoZW4gcHJvYmVkIHdpdGggYSByYW5kb20gdHlwZS4gXCIgKyAoXCJEb24ndCB0cnkgdG8gaGFuZGxlICdcIiArIEFjdGlvblR5cGVzLklOSVQgKyBcIicgb3Igb3RoZXIgYWN0aW9ucyBpbiBcXFwicmVkdXgvKlxcXCIgXCIpICsgXCJuYW1lc3BhY2UuIFRoZXkgYXJlIGNvbnNpZGVyZWQgcHJpdmF0ZS4gSW5zdGVhZCwgeW91IG11c3QgcmV0dXJuIHRoZSBcIiArIFwiY3VycmVudCBzdGF0ZSBmb3IgYW55IHVua25vd24gYWN0aW9ucywgdW5sZXNzIGl0IGlzIHVuZGVmaW5lZCwgXCIgKyBcImluIHdoaWNoIGNhc2UgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLCByZWdhcmRsZXNzIG9mIHRoZSBcIiArIFwiYWN0aW9uIHR5cGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSBub3QgYmUgdW5kZWZpbmVkLCBidXQgY2FuIGJlIG51bGwuXCIpO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIFR1cm5zIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGRpZmZlcmVudCByZWR1Y2VyIGZ1bmN0aW9ucywgaW50byBhIHNpbmdsZVxuICogcmVkdWNlciBmdW5jdGlvbi4gSXQgd2lsbCBjYWxsIGV2ZXJ5IGNoaWxkIHJlZHVjZXIsIGFuZCBnYXRoZXIgdGhlaXIgcmVzdWx0c1xuICogaW50byBhIHNpbmdsZSBzdGF0ZSBvYmplY3QsIHdob3NlIGtleXMgY29ycmVzcG9uZCB0byB0aGUga2V5cyBvZiB0aGUgcGFzc2VkXG4gKiByZWR1Y2VyIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVkdWNlcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBjb3JyZXNwb25kIHRvIGRpZmZlcmVudFxuICogcmVkdWNlciBmdW5jdGlvbnMgdGhhdCBuZWVkIHRvIGJlIGNvbWJpbmVkIGludG8gb25lLiBPbmUgaGFuZHkgd2F5IHRvIG9idGFpblxuICogaXQgaXMgdG8gdXNlIEVTNiBgaW1wb3J0ICogYXMgcmVkdWNlcnNgIHN5bnRheC4gVGhlIHJlZHVjZXJzIG1heSBuZXZlciByZXR1cm5cbiAqIHVuZGVmaW5lZCBmb3IgYW55IGFjdGlvbi4gSW5zdGVhZCwgdGhleSBzaG91bGQgcmV0dXJuIHRoZWlyIGluaXRpYWwgc3RhdGVcbiAqIGlmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlbSB3YXMgdW5kZWZpbmVkLCBhbmQgdGhlIGN1cnJlbnQgc3RhdGUgZm9yIGFueVxuICogdW5yZWNvZ25pemVkIGFjdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgcmVkdWNlciBmdW5jdGlvbiB0aGF0IGludm9rZXMgZXZlcnkgcmVkdWNlciBpbnNpZGUgdGhlXG4gKiBwYXNzZWQgb2JqZWN0LCBhbmQgYnVpbGRzIGEgc3RhdGUgb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUuXG4gKi9cblxuXG5mdW5jdGlvbiBjb21iaW5lUmVkdWNlcnMocmVkdWNlcnMpIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgZmluYWxSZWR1Y2VycyA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gcmVkdWNlcktleXNbaV07XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiByZWR1Y2Vyc1trZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3YXJuaW5nKFwiTm8gcmVkdWNlciBwcm92aWRlZCBmb3Iga2V5IFxcXCJcIiArIGtleSArIFwiXFxcIlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJlZHVjZXJzW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZpbmFsUmVkdWNlcnNba2V5XSA9IHJlZHVjZXJzW2tleV07XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpbmFsUmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhmaW5hbFJlZHVjZXJzKTsgLy8gVGhpcyBpcyB1c2VkIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCB3YXJuIGFib3V0IHRoZSBzYW1lXG4gIC8vIGtleXMgbXVsdGlwbGUgdGltZXMuXG5cbiAgdmFyIHVuZXhwZWN0ZWRLZXlDYWNoZTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHVuZXhwZWN0ZWRLZXlDYWNoZSA9IHt9O1xuICB9XG5cbiAgdmFyIHNoYXBlQXNzZXJ0aW9uRXJyb3I7XG5cbiAgdHJ5IHtcbiAgICBhc3NlcnRSZWR1Y2VyU2hhcGUoZmluYWxSZWR1Y2Vycyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzaGFwZUFzc2VydGlvbkVycm9yID0gZTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBjb21iaW5hdGlvbihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgaWYgKHN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgIHN0YXRlID0ge307XG4gICAgfVxuXG4gICAgaWYgKHNoYXBlQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICAgIHRocm93IHNoYXBlQXNzZXJ0aW9uRXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciB3YXJuaW5nTWVzc2FnZSA9IGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2Uoc3RhdGUsIGZpbmFsUmVkdWNlcnMsIGFjdGlvbiwgdW5leHBlY3RlZEtleUNhY2hlKTtcblxuICAgICAgaWYgKHdhcm5pbmdNZXNzYWdlKSB7XG4gICAgICAgIHdhcm5pbmcod2FybmluZ01lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBoYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgdmFyIG5leHRTdGF0ZSA9IHt9O1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGZpbmFsUmVkdWNlcktleXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2tleSA9IGZpbmFsUmVkdWNlcktleXNbX2ldO1xuICAgICAgdmFyIHJlZHVjZXIgPSBmaW5hbFJlZHVjZXJzW19rZXldO1xuICAgICAgdmFyIHByZXZpb3VzU3RhdGVGb3JLZXkgPSBzdGF0ZVtfa2V5XTtcbiAgICAgIHZhciBuZXh0U3RhdGVGb3JLZXkgPSByZWR1Y2VyKHByZXZpb3VzU3RhdGVGb3JLZXksIGFjdGlvbik7XG5cbiAgICAgIGlmICh0eXBlb2YgbmV4dFN0YXRlRm9yS2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgYWN0aW9uVHlwZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTQpIDogXCJXaGVuIGNhbGxlZCB3aXRoIGFuIGFjdGlvbiBvZiB0eXBlIFwiICsgKGFjdGlvblR5cGUgPyBcIlxcXCJcIiArIFN0cmluZyhhY3Rpb25UeXBlKSArIFwiXFxcIlwiIDogJyh1bmtub3duIHR5cGUpJykgKyBcIiwgdGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcXFwiXCIgKyBfa2V5ICsgXCJcXFwiIHJldHVybmVkIHVuZGVmaW5lZC4gXCIgKyBcIlRvIGlnbm9yZSBhbiBhY3Rpb24sIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBwcmV2aW91cyBzdGF0ZS4gXCIgKyBcIklmIHlvdSB3YW50IHRoaXMgcmVkdWNlciB0byBob2xkIG5vIHZhbHVlLCB5b3UgY2FuIHJldHVybiBudWxsIGluc3RlYWQgb2YgdW5kZWZpbmVkLlwiKTtcbiAgICAgIH1cblxuICAgICAgbmV4dFN0YXRlW19rZXldID0gbmV4dFN0YXRlRm9yS2V5O1xuICAgICAgaGFzQ2hhbmdlZCA9IGhhc0NoYW5nZWQgfHwgbmV4dFN0YXRlRm9yS2V5ICE9PSBwcmV2aW91c1N0YXRlRm9yS2V5O1xuICAgIH1cblxuICAgIGhhc0NoYW5nZWQgPSBoYXNDaGFuZ2VkIHx8IGZpbmFsUmVkdWNlcktleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhzdGF0ZSkubGVuZ3RoO1xuICAgIHJldHVybiBoYXNDaGFuZ2VkID8gbmV4dFN0YXRlIDogc3RhdGU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoKGFjdGlvbkNyZWF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH07XG59XG4vKipcbiAqIFR1cm5zIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGFjdGlvbiBjcmVhdG9ycywgaW50byBhbiBvYmplY3Qgd2l0aCB0aGVcbiAqIHNhbWUga2V5cywgYnV0IHdpdGggZXZlcnkgZnVuY3Rpb24gd3JhcHBlZCBpbnRvIGEgYGRpc3BhdGNoYCBjYWxsIHNvIHRoZXlcbiAqIG1heSBiZSBpbnZva2VkIGRpcmVjdGx5LiBUaGlzIGlzIGp1c3QgYSBjb252ZW5pZW5jZSBtZXRob2QsIGFzIHlvdSBjYW4gY2FsbFxuICogYHN0b3JlLmRpc3BhdGNoKE15QWN0aW9uQ3JlYXRvcnMuZG9Tb21ldGhpbmcoKSlgIHlvdXJzZWxmIGp1c3QgZmluZS5cbiAqXG4gKiBGb3IgY29udmVuaWVuY2UsIHlvdSBjYW4gYWxzbyBwYXNzIGFuIGFjdGlvbiBjcmVhdG9yIGFzIHRoZSBmaXJzdCBhcmd1bWVudCxcbiAqIGFuZCBnZXQgYSBkaXNwYXRjaCB3cmFwcGVkIGZ1bmN0aW9uIGluIHJldHVybi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gYWN0aW9uQ3JlYXRvcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgYWN0aW9uXG4gKiBjcmVhdG9yIGZ1bmN0aW9ucy4gT25lIGhhbmR5IHdheSB0byBvYnRhaW4gaXQgaXMgdG8gdXNlIEVTNiBgaW1wb3J0ICogYXNgXG4gKiBzeW50YXguIFlvdSBtYXkgYWxzbyBwYXNzIGEgc2luZ2xlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRpc3BhdGNoIFRoZSBgZGlzcGF0Y2hgIGZ1bmN0aW9uIGF2YWlsYWJsZSBvbiB5b3VyIFJlZHV4XG4gKiBzdG9yZS5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBUaGUgb2JqZWN0IG1pbWlja2luZyB0aGUgb3JpZ2luYWwgb2JqZWN0LCBidXQgd2l0aFxuICogZXZlcnkgYWN0aW9uIGNyZWF0b3Igd3JhcHBlZCBpbnRvIHRoZSBgZGlzcGF0Y2hgIGNhbGwuIElmIHlvdSBwYXNzZWQgYVxuICogZnVuY3Rpb24gYXMgYGFjdGlvbkNyZWF0b3JzYCwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGFsc28gYmUgYSBzaW5nbGVcbiAqIGZ1bmN0aW9uLlxuICovXG5cblxuZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3JzKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCkge1xuICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3JzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3JzICE9PSAnb2JqZWN0JyB8fCBhY3Rpb25DcmVhdG9ycyA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE2KSA6IFwiYmluZEFjdGlvbkNyZWF0b3JzIGV4cGVjdGVkIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uLCBidXQgaW5zdGVhZCByZWNlaXZlZDogJ1wiICsga2luZE9mKGFjdGlvbkNyZWF0b3JzKSArIFwiJy4gXCIgKyBcIkRpZCB5b3Ugd3JpdGUgXFxcImltcG9ydCBBY3Rpb25DcmVhdG9ycyBmcm9tXFxcIiBpbnN0ZWFkIG9mIFxcXCJpbXBvcnQgKiBhcyBBY3Rpb25DcmVhdG9ycyBmcm9tXFxcIj9cIik7XG4gIH1cblxuICB2YXIgYm91bmRBY3Rpb25DcmVhdG9ycyA9IHt9O1xuXG4gIGZvciAodmFyIGtleSBpbiBhY3Rpb25DcmVhdG9ycykge1xuICAgIHZhciBhY3Rpb25DcmVhdG9yID0gYWN0aW9uQ3JlYXRvcnNba2V5XTtcblxuICAgIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYm91bmRBY3Rpb25DcmVhdG9yc1trZXldID0gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvciwgZGlzcGF0Y2gpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBib3VuZEFjdGlvbkNyZWF0b3JzO1xufVxuXG4vKipcbiAqIENvbXBvc2VzIHNpbmdsZS1hcmd1bWVudCBmdW5jdGlvbnMgZnJvbSByaWdodCB0byBsZWZ0LiBUaGUgcmlnaHRtb3N0XG4gKiBmdW5jdGlvbiBjYW4gdGFrZSBtdWx0aXBsZSBhcmd1bWVudHMgYXMgaXQgcHJvdmlkZXMgdGhlIHNpZ25hdHVyZSBmb3JcbiAqIHRoZSByZXN1bHRpbmcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGZ1bmNzIFRoZSBmdW5jdGlvbnMgdG8gY29tcG9zZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiBvYnRhaW5lZCBieSBjb21wb3NpbmcgdGhlIGFyZ3VtZW50IGZ1bmN0aW9uc1xuICogZnJvbSByaWdodCB0byBsZWZ0LiBGb3IgZXhhbXBsZSwgY29tcG9zZShmLCBnLCBoKSBpcyBpZGVudGljYWwgdG8gZG9pbmdcbiAqICguLi5hcmdzKSA9PiBmKGcoaCguLi5hcmdzKSkpLlxuICovXG5mdW5jdGlvbiBjb21wb3NlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZnVuY3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZnVuY3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIHJldHVybiBhcmc7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChmdW5jcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZnVuY3NbMF07XG4gIH1cblxuICByZXR1cm4gZnVuY3MucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhKGIuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RvcmUgZW5oYW5jZXIgdGhhdCBhcHBsaWVzIG1pZGRsZXdhcmUgdG8gdGhlIGRpc3BhdGNoIG1ldGhvZFxuICogb2YgdGhlIFJlZHV4IHN0b3JlLiBUaGlzIGlzIGhhbmR5IGZvciBhIHZhcmlldHkgb2YgdGFza3MsIHN1Y2ggYXMgZXhwcmVzc2luZ1xuICogYXN5bmNocm9ub3VzIGFjdGlvbnMgaW4gYSBjb25jaXNlIG1hbm5lciwgb3IgbG9nZ2luZyBldmVyeSBhY3Rpb24gcGF5bG9hZC5cbiAqXG4gKiBTZWUgYHJlZHV4LXRodW5rYCBwYWNrYWdlIGFzIGFuIGV4YW1wbGUgb2YgdGhlIFJlZHV4IG1pZGRsZXdhcmUuXG4gKlxuICogQmVjYXVzZSBtaWRkbGV3YXJlIGlzIHBvdGVudGlhbGx5IGFzeW5jaHJvbm91cywgdGhpcyBzaG91bGQgYmUgdGhlIGZpcnN0XG4gKiBzdG9yZSBlbmhhbmNlciBpbiB0aGUgY29tcG9zaXRpb24gY2hhaW4uXG4gKlxuICogTm90ZSB0aGF0IGVhY2ggbWlkZGxld2FyZSB3aWxsIGJlIGdpdmVuIHRoZSBgZGlzcGF0Y2hgIGFuZCBgZ2V0U3RhdGVgIGZ1bmN0aW9uc1xuICogYXMgbmFtZWQgYXJndW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IG1pZGRsZXdhcmVzIFRoZSBtaWRkbGV3YXJlIGNoYWluIHRvIGJlIGFwcGxpZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgc3RvcmUgZW5oYW5jZXIgYXBwbHlpbmcgdGhlIG1pZGRsZXdhcmUuXG4gKi9cblxuZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWlkZGxld2FyZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgbWlkZGxld2FyZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGNyZWF0ZVN0b3JlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdG9yZSA9IGNyZWF0ZVN0b3JlLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcblxuICAgICAgdmFyIF9kaXNwYXRjaCA9IGZ1bmN0aW9uIGRpc3BhdGNoKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNSkgOiAnRGlzcGF0Y2hpbmcgd2hpbGUgY29uc3RydWN0aW5nIHlvdXIgbWlkZGxld2FyZSBpcyBub3QgYWxsb3dlZC4gJyArICdPdGhlciBtaWRkbGV3YXJlIHdvdWxkIG5vdCBiZSBhcHBsaWVkIHRvIHRoaXMgZGlzcGF0Y2guJyk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgbWlkZGxld2FyZUFQSSA9IHtcbiAgICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxuICAgICAgICBkaXNwYXRjaDogZnVuY3Rpb24gZGlzcGF0Y2goKSB7XG4gICAgICAgICAgcmV0dXJuIF9kaXNwYXRjaC5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgY2hhaW4gPSBtaWRkbGV3YXJlcy5tYXAoZnVuY3Rpb24gKG1pZGRsZXdhcmUpIHtcbiAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmUobWlkZGxld2FyZUFQSSk7XG4gICAgICB9KTtcbiAgICAgIF9kaXNwYXRjaCA9IGNvbXBvc2UuYXBwbHkodm9pZCAwLCBjaGFpbikoc3RvcmUuZGlzcGF0Y2gpO1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3RvcmUpLCB7fSwge1xuICAgICAgICBkaXNwYXRjaDogX2Rpc3BhdGNoXG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xufVxuXG4vKlxuICogVGhpcyBpcyBhIGR1bW15IGZ1bmN0aW9uIHRvIGNoZWNrIGlmIHRoZSBmdW5jdGlvbiBuYW1lIGhhcyBiZWVuIGFsdGVyZWQgYnkgbWluaWZpY2F0aW9uLlxuICogSWYgdGhlIGZ1bmN0aW9uIGhhcyBiZWVuIG1pbmlmaWVkIGFuZCBOT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLCB3YXJuIHRoZSB1c2VyLlxuICovXG5cbmZ1bmN0aW9uIGlzQ3J1c2hlZCgpIHt9XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBpc0NydXNoZWQubmFtZSA9PT0gJ3N0cmluZycgJiYgaXNDcnVzaGVkLm5hbWUgIT09ICdpc0NydXNoZWQnKSB7XG4gIHdhcm5pbmcoJ1lvdSBhcmUgY3VycmVudGx5IHVzaW5nIG1pbmlmaWVkIGNvZGUgb3V0c2lkZSBvZiBOT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIuICcgKyAnVGhpcyBtZWFucyB0aGF0IHlvdSBhcmUgcnVubmluZyBhIHNsb3dlciBkZXZlbG9wbWVudCBidWlsZCBvZiBSZWR1eC4gJyArICdZb3UgY2FuIHVzZSBsb29zZS1lbnZpZnkgKGh0dHBzOi8vZ2l0aHViLmNvbS96ZXJ0b3NoL2xvb3NlLWVudmlmeSkgZm9yIGJyb3dzZXJpZnkgJyArICdvciBzZXR0aW5nIG1vZGUgdG8gcHJvZHVjdGlvbiBpbiB3ZWJwYWNrIChodHRwczovL3dlYnBhY2suanMub3JnL2NvbmNlcHRzL21vZGUvKSAnICsgJ3RvIGVuc3VyZSB5b3UgaGF2ZSB0aGUgY29ycmVjdCBjb2RlIGZvciB5b3VyIHByb2R1Y3Rpb24gYnVpbGQuJyk7XG59XG5cbmV4cG9ydCB7IEFjdGlvblR5cGVzIGFzIF9fRE9fTk9UX1VTRV9fQWN0aW9uVHlwZXMsIGFwcGx5TWlkZGxld2FyZSwgYmluZEFjdGlvbkNyZWF0b3JzLCBjb21iaW5lUmVkdWNlcnMsIGNvbXBvc2UsIGNyZWF0ZVN0b3JlLCBsZWdhY3lfY3JlYXRlU3RvcmUgfTtcbiIsIi8qKiBBIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhIHBvdGVudGlhbCBcImV4dHJhIGFyZ3VtZW50XCIgdmFsdWUgdG8gYmUgaW5qZWN0ZWQgbGF0ZXIsXHJcbiAqIGFuZCByZXR1cm5zIGFuIGluc3RhbmNlIG9mIHRoZSB0aHVuayBtaWRkbGV3YXJlIHRoYXQgdXNlcyB0aGF0IHZhbHVlXHJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVGh1bmtNaWRkbGV3YXJlKGV4dHJhQXJndW1lbnQpIHtcbiAgLy8gU3RhbmRhcmQgUmVkdXggbWlkZGxld2FyZSBkZWZpbml0aW9uIHBhdHRlcm46XG4gIC8vIFNlZTogaHR0cHM6Ly9yZWR1eC5qcy5vcmcvdHV0b3JpYWxzL2Z1bmRhbWVudGFscy9wYXJ0LTQtc3RvcmUjd3JpdGluZy1jdXN0b20tbWlkZGxld2FyZVxuICB2YXIgbWlkZGxld2FyZSA9IGZ1bmN0aW9uIG1pZGRsZXdhcmUoX3JlZikge1xuICAgIHZhciBkaXNwYXRjaCA9IF9yZWYuZGlzcGF0Y2gsXG4gICAgICAgIGdldFN0YXRlID0gX3JlZi5nZXRTdGF0ZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIC8vIFRoZSB0aHVuayBtaWRkbGV3YXJlIGxvb2tzIGZvciBhbnkgZnVuY3Rpb25zIHRoYXQgd2VyZSBwYXNzZWQgdG8gYHN0b3JlLmRpc3BhdGNoYC5cbiAgICAgICAgLy8gSWYgdGhpcyBcImFjdGlvblwiIGlzIHJlYWxseSBhIGZ1bmN0aW9uLCBjYWxsIGl0IGFuZCByZXR1cm4gdGhlIHJlc3VsdC5cbiAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBJbmplY3QgdGhlIHN0b3JlJ3MgYGRpc3BhdGNoYCBhbmQgYGdldFN0YXRlYCBtZXRob2RzLCBhcyB3ZWxsIGFzIGFueSBcImV4dHJhIGFyZ1wiXG4gICAgICAgICAgcmV0dXJuIGFjdGlvbihkaXNwYXRjaCwgZ2V0U3RhdGUsIGV4dHJhQXJndW1lbnQpO1xuICAgICAgICB9IC8vIE90aGVyd2lzZSwgcGFzcyB0aGUgYWN0aW9uIGRvd24gdGhlIG1pZGRsZXdhcmUgY2hhaW4gYXMgdXN1YWxcblxuXG4gICAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gICAgICB9O1xuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIG1pZGRsZXdhcmU7XG59XG5cbnZhciB0aHVuayA9IGNyZWF0ZVRodW5rTWlkZGxld2FyZSgpOyAvLyBBdHRhY2ggdGhlIGZhY3RvcnkgZnVuY3Rpb24gc28gdXNlcnMgY2FuIGNyZWF0ZSBhIGN1c3RvbWl6ZWQgdmVyc2lvblxuLy8gd2l0aCB3aGF0ZXZlciBcImV4dHJhIGFyZ1wiIHRoZXkgd2FudCB0byBpbmplY3QgaW50byB0aGVpciB0aHVua3NcblxudGh1bmsud2l0aEV4dHJhQXJndW1lbnQgPSBjcmVhdGVUaHVua01pZGRsZXdhcmU7XG5leHBvcnQgZGVmYXVsdCB0aHVuazsiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBmcm9tLmxlbmd0aCwgaiA9IHRvLmxlbmd0aDsgaSA8IGlsOyBpKyssIGorKylcclxuICAgICAgICB0b1tqXSA9IGZyb21baV07XHJcbiAgICByZXR1cm4gdG87XHJcbn07XHJcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XHJcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XHJcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xyXG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XHJcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcclxudmFyIF9fZGVmTm9ybWFsUHJvcCA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHsgcmV0dXJuIGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTsgfTtcclxudmFyIF9fc3ByZWFkVmFsdWVzID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcclxuICAgICAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXHJcbiAgICAgICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcclxuICAgIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2MgPSBfX2dldE93blByb3BTeW1ib2xzKGIpOyBfaSA8IF9jLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgcHJvcCA9IF9jW19pXTtcclxuICAgICAgICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxyXG4gICAgICAgICAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiBhO1xyXG59O1xyXG52YXIgX19zcHJlYWRQcm9wcyA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTsgfTtcclxudmFyIF9fYXN5bmMgPSBmdW5jdGlvbiAoX190aGlzLCBfX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIHZhciBmdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yLnRocm93KHZhbHVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHN0ZXAgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9O1xyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG4vLyBzcmMvaW5kZXgudHNcclxuaW1wb3J0IHsgZW5hYmxlRVM1IH0gZnJvbSBcImltbWVyXCI7XHJcbmV4cG9ydCAqIGZyb20gXCJyZWR1eFwiO1xyXG5pbXBvcnQgeyBkZWZhdWx0IGFzIGRlZmF1bHQyLCBjdXJyZW50IGFzIGN1cnJlbnQyLCBmcmVlemUsIG9yaWdpbmFsLCBpc0RyYWZ0IGFzIGlzRHJhZnQ0IH0gZnJvbSBcImltbWVyXCI7XHJcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yIGFzIGNyZWF0ZVNlbGVjdG9yMiB9IGZyb20gXCJyZXNlbGVjdFwiO1xyXG4vLyBzcmMvY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IudHNcclxuaW1wb3J0IHsgY3VycmVudCwgaXNEcmFmdCB9IGZyb20gXCJpbW1lclwiO1xyXG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvciB9IGZyb20gXCJyZXNlbGVjdFwiO1xyXG52YXIgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICB2YXIgc2VsZWN0b3IgPSBjcmVhdGVTZWxlY3Rvci5hcHBseSh2b2lkIDAsIGFyZ3MpO1xyXG4gICAgdmFyIHdyYXBwZWRTZWxlY3RvciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHZhciByZXN0ID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgcmVzdFtfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbaXNEcmFmdCh2YWx1ZSkgPyBjdXJyZW50KHZhbHVlKSA6IHZhbHVlXSwgcmVzdCkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiB3cmFwcGVkU2VsZWN0b3I7XHJcbn07XHJcbi8vIHNyYy9jb25maWd1cmVTdG9yZS50c1xyXG5pbXBvcnQgeyBjcmVhdGVTdG9yZSwgY29tcG9zZSBhcyBjb21wb3NlMiwgYXBwbHlNaWRkbGV3YXJlLCBjb21iaW5lUmVkdWNlcnMgfSBmcm9tIFwicmVkdXhcIjtcclxuLy8gc3JjL2RldnRvb2xzRXh0ZW5zaW9uLnRzXHJcbmltcG9ydCB7IGNvbXBvc2UgfSBmcm9tIFwicmVkdXhcIjtcclxudmFyIGNvbXBvc2VXaXRoRGV2VG9vbHMgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18gPyB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fIDogZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcclxuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSBcIm9iamVjdFwiKVxyXG4gICAgICAgIHJldHVybiBjb21wb3NlO1xyXG4gICAgcmV0dXJuIGNvbXBvc2UuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxufTtcclxudmFyIGRldlRvb2xzRW5oYW5jZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fID8gd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18gOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vb3AyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5vb3AyO1xyXG4gICAgfTtcclxufTtcclxuLy8gc3JjL2lzUGxhaW5PYmplY3QudHNcclxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xyXG4gICAgaWYgKHByb3RvID09PSBudWxsKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgdmFyIGJhc2VQcm90byA9IHByb3RvO1xyXG4gICAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihiYXNlUHJvdG8pICE9PSBudWxsKSB7XHJcbiAgICAgICAgYmFzZVByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2VQcm90byk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJvdG8gPT09IGJhc2VQcm90bztcclxufVxyXG4vLyBzcmMvZ2V0RGVmYXVsdE1pZGRsZXdhcmUudHNcclxuaW1wb3J0IHRodW5rTWlkZGxld2FyZSBmcm9tIFwicmVkdXgtdGh1bmtcIjtcclxuLy8gc3JjL3V0aWxzLnRzXHJcbmZ1bmN0aW9uIGdldFRpbWVNZWFzdXJlVXRpbHMobWF4RGVsYXksIGZuTmFtZSkge1xyXG4gICAgdmFyIGVsYXBzZWQgPSAwO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBtZWFzdXJlVGltZTogZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFydGVkID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpbmlzaGVkID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIGVsYXBzZWQgKz0gZmluaXNoZWQgLSBzdGFydGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB3YXJuSWZFeGNlZWRlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoZWxhcHNlZCA+IG1heERlbGF5KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZm5OYW1lICsgXCIgdG9vayBcIiArIGVsYXBzZWQgKyBcIm1zLCB3aGljaCBpcyBtb3JlIHRoYW4gdGhlIHdhcm5pbmcgdGhyZXNob2xkIG9mIFwiICsgbWF4RGVsYXkgKyBcIm1zLiBcXG5JZiB5b3VyIHN0YXRlIG9yIGFjdGlvbnMgYXJlIHZlcnkgbGFyZ2UsIHlvdSBtYXkgd2FudCB0byBkaXNhYmxlIHRoZSBtaWRkbGV3YXJlIGFzIGl0IG1pZ2h0IGNhdXNlIHRvbyBtdWNoIG9mIGEgc2xvd2Rvd24gaW4gZGV2ZWxvcG1lbnQgbW9kZS4gU2VlIGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvYXBpL2dldERlZmF1bHRNaWRkbGV3YXJlIGZvciBpbnN0cnVjdGlvbnMuXFxuSXQgaXMgZGlzYWJsZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMsIHNvIHlvdSBkb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoYXQuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG52YXIgTWlkZGxld2FyZUFycmF5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1pZGRsZXdhcmVBcnJheSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1pZGRsZXdhcmVBcnJheSgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3MpIHx8IHRoaXM7XHJcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBNaWRkbGV3YXJlQXJyYXkucHJvdG90eXBlKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWlkZGxld2FyZUFycmF5LCBTeW1ib2wuc3BlY2llcywge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWlkZGxld2FyZUFycmF5O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE1pZGRsZXdhcmVBcnJheS5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhcnIgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcnJbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY29uY2F0LmFwcGx5KHRoaXMsIGFycik7XHJcbiAgICB9O1xyXG4gICAgTWlkZGxld2FyZUFycmF5LnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhcnIgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcnJbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFyci5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcnJbMF0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgKE1pZGRsZXdhcmVBcnJheS5iaW5kLmFwcGx5KE1pZGRsZXdhcmVBcnJheSwgX19zcHJlYWRBcnJheShbdm9pZCAwXSwgYXJyWzBdLmNvbmNhdCh0aGlzKSkpKSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IChNaWRkbGV3YXJlQXJyYXkuYmluZC5hcHBseShNaWRkbGV3YXJlQXJyYXksIF9fc3ByZWFkQXJyYXkoW3ZvaWQgMF0sIGFyci5jb25jYXQodGhpcykpKSkoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTWlkZGxld2FyZUFycmF5O1xyXG59KEFycmF5KSk7XHJcbi8vIHNyYy9pbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHNcclxudmFyIGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIjtcclxudmFyIHByZWZpeCA9IFwiSW52YXJpYW50IGZhaWxlZFwiO1xyXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XHJcbiAgICBpZiAoY29uZGl0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzUHJvZHVjdGlvbikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcmVmaXgpO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKHByZWZpeCArIFwiOiBcIiArIChtZXNzYWdlIHx8IFwiXCIpKTtcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnkob2JqLCBzZXJpYWxpemVyLCBpbmRlbnQsIGRlY3ljbGVyKSB7XHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBnZXRTZXJpYWxpemUoc2VyaWFsaXplciwgZGVjeWNsZXIpLCBpbmRlbnQpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFNlcmlhbGl6ZShzZXJpYWxpemVyLCBkZWN5Y2xlcikge1xyXG4gICAgdmFyIHN0YWNrID0gW10sIGtleXMgPSBbXTtcclxuICAgIGlmICghZGVjeWNsZXIpXHJcbiAgICAgICAgZGVjeWNsZXIgPSBmdW5jdGlvbiAoXywgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHN0YWNrWzBdID09PSB2YWx1ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIltDaXJjdWxhciB+XVwiO1xyXG4gICAgICAgICAgICByZXR1cm4gXCJbQ2lyY3VsYXIgfi5cIiArIGtleXMuc2xpY2UoMCwgc3RhY2suaW5kZXhPZih2YWx1ZSkpLmpvaW4oXCIuXCIpICsgXCJdXCI7XHJcbiAgICAgICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGlzUG9zID0gc3RhY2suaW5kZXhPZih0aGlzKTtcclxuICAgICAgICAgICAgfnRoaXNQb3MgPyBzdGFjay5zcGxpY2UodGhpc1BvcyArIDEpIDogc3RhY2sucHVzaCh0aGlzKTtcclxuICAgICAgICAgICAgfnRoaXNQb3MgPyBrZXlzLnNwbGljZSh0aGlzUG9zLCBJbmZpbml0eSwga2V5KSA6IGtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICBpZiAofnN0YWNrLmluZGV4T2YodmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkZWN5Y2xlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBzZXJpYWxpemVyID09IG51bGwgPyB2YWx1ZSA6IHNlcmlhbGl6ZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaXNJbW11dGFibGVEZWZhdWx0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBPYmplY3QuaXNGcm96ZW4odmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIHRyYWNrRm9yTXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgb2JqKSB7XHJcbiAgICB2YXIgdHJhY2tlZFByb3BlcnRpZXMgPSB0cmFja1Byb3BlcnRpZXMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCBvYmopO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBkZXRlY3RNdXRhdGlvbnM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRldGVjdE11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIHRyYWNrZWRQcm9wZXJ0aWVzLCBvYmopO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gdHJhY2tQcm9wZXJ0aWVzKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgb2JqLCBwYXRoKSB7XHJcbiAgICBpZiAoaWdub3JlUGF0aHMgPT09IHZvaWQgMCkgeyBpZ25vcmVQYXRocyA9IFtdOyB9XHJcbiAgICBpZiAocGF0aCA9PT0gdm9pZCAwKSB7IHBhdGggPSBcIlwiOyB9XHJcbiAgICB2YXIgdHJhY2tlZCA9IHsgdmFsdWU6IG9iaiB9O1xyXG4gICAgaWYgKCFpc0ltbXV0YWJsZShvYmopKSB7XHJcbiAgICAgICAgdHJhY2tlZC5jaGlsZHJlbiA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XHJcbiAgICAgICAgICAgIGlmIChpZ25vcmVQYXRocy5sZW5ndGggJiYgaWdub3JlUGF0aHMuaW5kZXhPZihjaGlsZFBhdGgpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJhY2tlZC5jaGlsZHJlbltrZXldID0gdHJhY2tQcm9wZXJ0aWVzKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgb2JqW2tleV0sIGNoaWxkUGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRyYWNrZWQ7XHJcbn1cclxuZnVuY3Rpb24gZGV0ZWN0TXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgdHJhY2tlZFByb3BlcnR5LCBvYmosIHNhbWVQYXJlbnRSZWYsIHBhdGgpIHtcclxuICAgIGlmIChpZ25vcmVQYXRocyA9PT0gdm9pZCAwKSB7IGlnbm9yZVBhdGhzID0gW107IH1cclxuICAgIGlmIChzYW1lUGFyZW50UmVmID09PSB2b2lkIDApIHsgc2FtZVBhcmVudFJlZiA9IGZhbHNlOyB9XHJcbiAgICBpZiAocGF0aCA9PT0gdm9pZCAwKSB7IHBhdGggPSBcIlwiOyB9XHJcbiAgICB2YXIgcHJldk9iaiA9IHRyYWNrZWRQcm9wZXJ0eSA/IHRyYWNrZWRQcm9wZXJ0eS52YWx1ZSA6IHZvaWQgMDtcclxuICAgIHZhciBzYW1lUmVmID0gcHJldk9iaiA9PT0gb2JqO1xyXG4gICAgaWYgKHNhbWVQYXJlbnRSZWYgJiYgIXNhbWVSZWYgJiYgIU51bWJlci5pc05hTihvYmopKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgd2FzTXV0YXRlZDogdHJ1ZSwgcGF0aDogcGF0aCB9O1xyXG4gICAgfVxyXG4gICAgaWYgKGlzSW1tdXRhYmxlKHByZXZPYmopIHx8IGlzSW1tdXRhYmxlKG9iaikpIHtcclxuICAgICAgICByZXR1cm4geyB3YXNNdXRhdGVkOiBmYWxzZSB9O1xyXG4gICAgfVxyXG4gICAgdmFyIGtleXNUb0RldGVjdCA9IHt9O1xyXG4gICAgZm9yICh2YXIga2V5IGluIHRyYWNrZWRQcm9wZXJ0eS5jaGlsZHJlbikge1xyXG4gICAgICAgIGtleXNUb0RldGVjdFtrZXldID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcclxuICAgICAgICBrZXlzVG9EZXRlY3Rba2V5XSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBrZXkgaW4ga2V5c1RvRGV0ZWN0KSB7XHJcbiAgICAgICAgdmFyIGNoaWxkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XHJcbiAgICAgICAgaWYgKGlnbm9yZVBhdGhzLmxlbmd0aCAmJiBpZ25vcmVQYXRocy5pbmRleE9mKGNoaWxkUGF0aCkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gZGV0ZWN0TXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgdHJhY2tlZFByb3BlcnR5LmNoaWxkcmVuW2tleV0sIG9ialtrZXldLCBzYW1lUmVmLCBjaGlsZFBhdGgpO1xyXG4gICAgICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7IHdhc011dGF0ZWQ6IGZhbHNlIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7IHJldHVybiBuZXh0KGFjdGlvbik7IH07IH07IH07XHJcbiAgICB9XHJcbiAgICB2YXIgX2MgPSBvcHRpb25zLmlzSW1tdXRhYmxlLCBpc0ltbXV0YWJsZSA9IF9jID09PSB2b2lkIDAgPyBpc0ltbXV0YWJsZURlZmF1bHQgOiBfYywgaWdub3JlZFBhdGhzID0gb3B0aW9ucy5pZ25vcmVkUGF0aHMsIF9kID0gb3B0aW9ucy53YXJuQWZ0ZXIsIHdhcm5BZnRlciA9IF9kID09PSB2b2lkIDAgPyAzMiA6IF9kLCBpZ25vcmUgPSBvcHRpb25zLmlnbm9yZTtcclxuICAgIGlnbm9yZWRQYXRocyA9IGlnbm9yZWRQYXRocyB8fCBpZ25vcmU7XHJcbiAgICB2YXIgdHJhY2sgPSB0cmFja0Zvck11dGF0aW9ucy5iaW5kKG51bGwsIGlzSW1tdXRhYmxlLCBpZ25vcmVkUGF0aHMpO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfYykge1xyXG4gICAgICAgIHZhciBnZXRTdGF0ZSA9IF9jLmdldFN0YXRlO1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IGdldFN0YXRlKCk7XHJcbiAgICAgICAgdmFyIHRyYWNrZXIgPSB0cmFjayhzdGF0ZSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIG1lYXN1cmVVdGlscyA9IGdldFRpbWVNZWFzdXJlVXRpbHMod2FybkFmdGVyLCBcIkltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZVwiKTtcclxuICAgICAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlID0gZ2V0U3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRyYWNrZXIuZGV0ZWN0TXV0YXRpb25zKCk7XHJcbiAgICAgICAgICAgICAgICB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgaW52YXJpYW50KCFyZXN1bHQud2FzTXV0YXRlZCwgXCJBIHN0YXRlIG11dGF0aW9uIHdhcyBkZXRlY3RlZCBiZXR3ZWVuIGRpc3BhdGNoZXMsIGluIHRoZSBwYXRoICdcIiArIChyZXN1bHQucGF0aCB8fCBcIlwiKSArIFwiJy4gIFRoaXMgbWF5IGNhdXNlIGluY29ycmVjdCBiZWhhdmlvci4gKGh0dHBzOi8vcmVkdXguanMub3JnL3N0eWxlLWd1aWRlL3N0eWxlLWd1aWRlI2RvLW5vdC1tdXRhdGUtc3RhdGUpXCIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIGRpc3BhdGNoZWRBY3Rpb24gPSBuZXh0KGFjdGlvbik7XHJcbiAgICAgICAgICAgIG1lYXN1cmVVdGlscy5tZWFzdXJlVGltZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IGdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cmFja2VyLmRldGVjdE11dGF0aW9ucygpO1xyXG4gICAgICAgICAgICAgICAgdHJhY2tlciA9IHRyYWNrKHN0YXRlKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC53YXNNdXRhdGVkICYmIGludmFyaWFudCghcmVzdWx0Lndhc011dGF0ZWQsIFwiQSBzdGF0ZSBtdXRhdGlvbiB3YXMgZGV0ZWN0ZWQgaW5zaWRlIGEgZGlzcGF0Y2gsIGluIHRoZSBwYXRoOiBcIiArIChyZXN1bHQucGF0aCB8fCBcIlwiKSArIFwiLiBUYWtlIGEgbG9vayBhdCB0aGUgcmVkdWNlcihzKSBoYW5kbGluZyB0aGUgYWN0aW9uIFwiICsgc3RyaW5naWZ5KGFjdGlvbikgKyBcIi4gKGh0dHBzOi8vcmVkdXguanMub3JnL3N0eWxlLWd1aWRlL3N0eWxlLWd1aWRlI2RvLW5vdC1tdXRhdGUtc3RhdGUpXCIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbWVhc3VyZVV0aWxzLndhcm5JZkV4Y2VlZGVkKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXNwYXRjaGVkQWN0aW9uO1xyXG4gICAgICAgIH07IH07XHJcbiAgICB9O1xyXG59XHJcbi8vIHNyYy9zZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHNcclxuZnVuY3Rpb24gaXNQbGFpbih2YWwpIHtcclxuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcclxuICAgIHJldHVybiB0eXBlID09PSBcInVuZGVmaW5lZFwiIHx8IHZhbCA9PT0gbnVsbCB8fCB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgQXJyYXkuaXNBcnJheSh2YWwpIHx8IGlzUGxhaW5PYmplY3QodmFsKTtcclxufVxyXG5mdW5jdGlvbiBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUodmFsdWUsIHBhdGgsIGlzU2VyaWFsaXphYmxlLCBnZXRFbnRyaWVzLCBpZ25vcmVkUGF0aHMpIHtcclxuICAgIGlmIChwYXRoID09PSB2b2lkIDApIHsgcGF0aCA9IFwiXCI7IH1cclxuICAgIGlmIChpc1NlcmlhbGl6YWJsZSA9PT0gdm9pZCAwKSB7IGlzU2VyaWFsaXphYmxlID0gaXNQbGFpbjsgfVxyXG4gICAgaWYgKGlnbm9yZWRQYXRocyA9PT0gdm9pZCAwKSB7IGlnbm9yZWRQYXRocyA9IFtdOyB9XHJcbiAgICB2YXIgZm91bmROZXN0ZWRTZXJpYWxpemFibGU7XHJcbiAgICBpZiAoIWlzU2VyaWFsaXphYmxlKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGtleVBhdGg6IHBhdGggfHwgXCI8cm9vdD5cIixcclxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB2YXIgZW50cmllcyA9IGdldEVudHJpZXMgIT0gbnVsbCA/IGdldEVudHJpZXModmFsdWUpIDogT2JqZWN0LmVudHJpZXModmFsdWUpO1xyXG4gICAgdmFyIGhhc0lnbm9yZWRQYXRocyA9IGlnbm9yZWRQYXRocy5sZW5ndGggPiAwO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBlbnRyaWVzXzEgPSBlbnRyaWVzOyBfaSA8IGVudHJpZXNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgX2MgPSBlbnRyaWVzXzFbX2ldLCBrZXkgPSBfY1swXSwgbmVzdGVkVmFsdWUgPSBfY1sxXTtcclxuICAgICAgICB2YXIgbmVzdGVkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XHJcbiAgICAgICAgaWYgKGhhc0lnbm9yZWRQYXRocyAmJiBpZ25vcmVkUGF0aHMuaW5kZXhPZihuZXN0ZWRQYXRoKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzU2VyaWFsaXphYmxlKG5lc3RlZFZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAga2V5UGF0aDogbmVzdGVkUGF0aCxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXN0ZWRWYWx1ZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKG5lc3RlZFZhbHVlLCBuZXN0ZWRQYXRoLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzKTtcclxuICAgICAgICAgICAgaWYgKGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmROZXN0ZWRTZXJpYWxpemFibGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7IHJldHVybiBuZXh0KGFjdGlvbik7IH07IH07IH07XHJcbiAgICB9XHJcbiAgICB2YXIgX2MgPSBvcHRpb25zLmlzU2VyaWFsaXphYmxlLCBpc1NlcmlhbGl6YWJsZSA9IF9jID09PSB2b2lkIDAgPyBpc1BsYWluIDogX2MsIGdldEVudHJpZXMgPSBvcHRpb25zLmdldEVudHJpZXMsIF9kID0gb3B0aW9ucy5pZ25vcmVkQWN0aW9ucywgaWdub3JlZEFjdGlvbnMgPSBfZCA9PT0gdm9pZCAwID8gW10gOiBfZCwgX2UgPSBvcHRpb25zLmlnbm9yZWRBY3Rpb25QYXRocywgaWdub3JlZEFjdGlvblBhdGhzID0gX2UgPT09IHZvaWQgMCA/IFtcIm1ldGEuYXJnXCIsIFwibWV0YS5iYXNlUXVlcnlNZXRhXCJdIDogX2UsIF9mID0gb3B0aW9ucy5pZ25vcmVkUGF0aHMsIGlnbm9yZWRQYXRocyA9IF9mID09PSB2b2lkIDAgPyBbXSA6IF9mLCBfZyA9IG9wdGlvbnMud2FybkFmdGVyLCB3YXJuQWZ0ZXIgPSBfZyA9PT0gdm9pZCAwID8gMzIgOiBfZywgX2ggPSBvcHRpb25zLmlnbm9yZVN0YXRlLCBpZ25vcmVTdGF0ZSA9IF9oID09PSB2b2lkIDAgPyBmYWxzZSA6IF9oLCBfaiA9IG9wdGlvbnMuaWdub3JlQWN0aW9ucywgaWdub3JlQWN0aW9ucyA9IF9qID09PSB2b2lkIDAgPyBmYWxzZSA6IF9qO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdG9yZUFQSSkgeyByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV4dChhY3Rpb24pO1xyXG4gICAgICAgIHZhciBtZWFzdXJlVXRpbHMgPSBnZXRUaW1lTWVhc3VyZVV0aWxzKHdhcm5BZnRlciwgXCJTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVcIik7XHJcbiAgICAgICAgaWYgKCFpZ25vcmVBY3Rpb25zICYmICEoaWdub3JlZEFjdGlvbnMubGVuZ3RoICYmIGlnbm9yZWRBY3Rpb25zLmluZGV4T2YoYWN0aW9uLnR5cGUpICE9PSAtMSkpIHtcclxuICAgICAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKGFjdGlvbiwgXCJcIiwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRBY3Rpb25QYXRocyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm91bmRBY3Rpb25Ob25TZXJpYWxpemFibGVWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlQYXRoID0gZm91bmRBY3Rpb25Ob25TZXJpYWxpemFibGVWYWx1ZS5rZXlQYXRoLCB2YWx1ZSA9IGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSB3YXMgZGV0ZWN0ZWQgaW4gYW4gYWN0aW9uLCBpbiB0aGUgcGF0aDogYFwiICsga2V5UGF0aCArIFwiYC4gVmFsdWU6XCIsIHZhbHVlLCBcIlxcblRha2UgYSBsb29rIGF0IHRoZSBsb2dpYyB0aGF0IGRpc3BhdGNoZWQgdGhpcyBhY3Rpb246IFwiLCBhY3Rpb24sIFwiXFxuKFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy9mYXEvYWN0aW9ucyN3aHktc2hvdWxkLXR5cGUtYmUtYS1zdHJpbmctb3ItYXQtbGVhc3Qtc2VyaWFsaXphYmxlLXdoeS1zaG91bGQtbXktYWN0aW9uLXR5cGVzLWJlLWNvbnN0YW50cylcIiwgXCJcXG4oVG8gYWxsb3cgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZXMgc2VlOiBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL3VzYWdlL3VzYWdlLWd1aWRlI3dvcmtpbmctd2l0aC1ub24tc2VyaWFsaXphYmxlLWRhdGEpXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpZ25vcmVTdGF0ZSkge1xyXG4gICAgICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gc3RvcmVBUEkuZ2V0U3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHZhciBmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUoc3RhdGUsIFwiXCIsIGlzU2VyaWFsaXphYmxlLCBnZXRFbnRyaWVzLCBpZ25vcmVkUGF0aHMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlQYXRoID0gZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlLmtleVBhdGgsIHZhbHVlID0gZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJBIG5vbi1zZXJpYWxpemFibGUgdmFsdWUgd2FzIGRldGVjdGVkIGluIHRoZSBzdGF0ZSwgaW4gdGhlIHBhdGg6IGBcIiArIGtleVBhdGggKyBcImAuIFZhbHVlOlwiLCB2YWx1ZSwgXCJcXG5UYWtlIGEgbG9vayBhdCB0aGUgcmVkdWNlcihzKSBoYW5kbGluZyB0aGlzIGFjdGlvbiB0eXBlOiBcIiArIGFjdGlvbi50eXBlICsgXCIuXFxuKFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy9mYXEvb3JnYW5pemluZy1zdGF0ZSNjYW4taS1wdXQtZnVuY3Rpb25zLXByb21pc2VzLW9yLW90aGVyLW5vbi1zZXJpYWxpemFibGUtaXRlbXMtaW4tbXktc3RvcmUtc3RhdGUpXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbWVhc3VyZVV0aWxzLndhcm5JZkV4Y2VlZGVkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9OyB9OyB9O1xyXG59XHJcbi8vIHNyYy9nZXREZWZhdWx0TWlkZGxld2FyZS50c1xyXG5mdW5jdGlvbiBpc0Jvb2xlYW4oeCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSBcImJvb2xlYW5cIjtcclxufVxyXG5mdW5jdGlvbiBjdXJyeUdldERlZmF1bHRNaWRkbGV3YXJlKCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGN1cnJpZWRHZXREZWZhdWx0TWlkZGxld2FyZShvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldERlZmF1bHRNaWRkbGV3YXJlKG9wdGlvbnMpO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXREZWZhdWx0TWlkZGxld2FyZShvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgdmFyIF9jID0gb3B0aW9ucy50aHVuaywgdGh1bmsgPSBfYyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9jLCBfZCA9IG9wdGlvbnMuaW1tdXRhYmxlQ2hlY2ssIGltbXV0YWJsZUNoZWNrID0gX2QgPT09IHZvaWQgMCA/IHRydWUgOiBfZCwgX2UgPSBvcHRpb25zLnNlcmlhbGl6YWJsZUNoZWNrLCBzZXJpYWxpemFibGVDaGVjayA9IF9lID09PSB2b2lkIDAgPyB0cnVlIDogX2U7XHJcbiAgICB2YXIgbWlkZGxld2FyZUFycmF5ID0gbmV3IE1pZGRsZXdhcmVBcnJheSgpO1xyXG4gICAgaWYgKHRodW5rKSB7XHJcbiAgICAgICAgaWYgKGlzQm9vbGVhbih0aHVuaykpIHtcclxuICAgICAgICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2godGh1bmtNaWRkbGV3YXJlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1pZGRsZXdhcmVBcnJheS5wdXNoKHRodW5rTWlkZGxld2FyZS53aXRoRXh0cmFBcmd1bWVudCh0aHVuay5leHRyYUFyZ3VtZW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgIGlmIChpbW11dGFibGVDaGVjaykge1xyXG4gICAgICAgICAgICB2YXIgaW1tdXRhYmxlT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICBpZiAoIWlzQm9vbGVhbihpbW11dGFibGVDaGVjaykpIHtcclxuICAgICAgICAgICAgICAgIGltbXV0YWJsZU9wdGlvbnMgPSBpbW11dGFibGVDaGVjaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtaWRkbGV3YXJlQXJyYXkudW5zaGlmdChjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUoaW1tdXRhYmxlT3B0aW9ucykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2VyaWFsaXphYmxlQ2hlY2spIHtcclxuICAgICAgICAgICAgdmFyIHNlcmlhbGl6YWJsZU9wdGlvbnMgPSB7fTtcclxuICAgICAgICAgICAgaWYgKCFpc0Jvb2xlYW4oc2VyaWFsaXphYmxlQ2hlY2spKSB7XHJcbiAgICAgICAgICAgICAgICBzZXJpYWxpemFibGVPcHRpb25zID0gc2VyaWFsaXphYmxlQ2hlY2s7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2goY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKHNlcmlhbGl6YWJsZU9wdGlvbnMpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWlkZGxld2FyZUFycmF5O1xyXG59XHJcbi8vIHNyYy9jb25maWd1cmVTdG9yZS50c1xyXG52YXIgSVNfUFJPRFVDVElPTiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIjtcclxuZnVuY3Rpb24gY29uZmlndXJlU3RvcmUob3B0aW9ucykge1xyXG4gICAgdmFyIGN1cnJpZWRHZXREZWZhdWx0TWlkZGxld2FyZSA9IGN1cnJ5R2V0RGVmYXVsdE1pZGRsZXdhcmUoKTtcclxuICAgIHZhciBfYyA9IG9wdGlvbnMgfHwge30sIF9kID0gX2MucmVkdWNlciwgcmVkdWNlciA9IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZCwgX2UgPSBfYy5taWRkbGV3YXJlLCBtaWRkbGV3YXJlID0gX2UgPT09IHZvaWQgMCA/IGN1cnJpZWRHZXREZWZhdWx0TWlkZGxld2FyZSgpIDogX2UsIF9mID0gX2MuZGV2VG9vbHMsIGRldlRvb2xzID0gX2YgPT09IHZvaWQgMCA/IHRydWUgOiBfZiwgX2cgPSBfYy5wcmVsb2FkZWRTdGF0ZSwgcHJlbG9hZGVkU3RhdGUgPSBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2csIF9oID0gX2MuZW5oYW5jZXJzLCBlbmhhbmNlcnMgPSBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2g7XHJcbiAgICB2YXIgcm9vdFJlZHVjZXI7XHJcbiAgICBpZiAodHlwZW9mIHJlZHVjZXIgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIHJvb3RSZWR1Y2VyID0gcmVkdWNlcjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocmVkdWNlcikpIHtcclxuICAgICAgICByb290UmVkdWNlciA9IGNvbWJpbmVSZWR1Y2VycyhyZWR1Y2VyKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCJyZWR1Y2VyXCIgaXMgYSByZXF1aXJlZCBhcmd1bWVudCwgYW5kIG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3Qgb2YgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHBhc3NlZCB0byBjb21iaW5lUmVkdWNlcnMnKTtcclxuICAgIH1cclxuICAgIHZhciBmaW5hbE1pZGRsZXdhcmUgPSBtaWRkbGV3YXJlO1xyXG4gICAgaWYgKHR5cGVvZiBmaW5hbE1pZGRsZXdhcmUgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIGZpbmFsTWlkZGxld2FyZSA9IGZpbmFsTWlkZGxld2FyZShjdXJyaWVkR2V0RGVmYXVsdE1pZGRsZXdhcmUpO1xyXG4gICAgICAgIGlmICghSVNfUFJPRFVDVElPTiAmJiAhQXJyYXkuaXNBcnJheShmaW5hbE1pZGRsZXdhcmUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIndoZW4gdXNpbmcgYSBtaWRkbGV3YXJlIGJ1aWxkZXIgZnVuY3Rpb24sIGFuIGFycmF5IG9mIG1pZGRsZXdhcmUgbXVzdCBiZSByZXR1cm5lZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgZmluYWxNaWRkbGV3YXJlLnNvbWUoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIHR5cGVvZiBpdGVtICE9PSBcImZ1bmN0aW9uXCI7IH0pKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZWFjaCBtaWRkbGV3YXJlIHByb3ZpZGVkIHRvIGNvbmZpZ3VyZVN0b3JlIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcclxuICAgIH1cclxuICAgIHZhciBtaWRkbGV3YXJlRW5oYW5jZXIgPSBhcHBseU1pZGRsZXdhcmUuYXBwbHkodm9pZCAwLCBmaW5hbE1pZGRsZXdhcmUpO1xyXG4gICAgdmFyIGZpbmFsQ29tcG9zZSA9IGNvbXBvc2UyO1xyXG4gICAgaWYgKGRldlRvb2xzKSB7XHJcbiAgICAgICAgZmluYWxDb21wb3NlID0gY29tcG9zZVdpdGhEZXZUb29scyhfX3NwcmVhZFZhbHVlcyh7XHJcbiAgICAgICAgICAgIHRyYWNlOiAhSVNfUFJPRFVDVElPTlxyXG4gICAgICAgIH0sIHR5cGVvZiBkZXZUb29scyA9PT0gXCJvYmplY3RcIiAmJiBkZXZUb29scykpO1xyXG4gICAgfVxyXG4gICAgdmFyIHN0b3JlRW5oYW5jZXJzID0gW21pZGRsZXdhcmVFbmhhbmNlcl07XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlbmhhbmNlcnMpKSB7XHJcbiAgICAgICAgc3RvcmVFbmhhbmNlcnMgPSBfX3NwcmVhZEFycmF5KFttaWRkbGV3YXJlRW5oYW5jZXJdLCBlbmhhbmNlcnMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGVuaGFuY2VycyA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgc3RvcmVFbmhhbmNlcnMgPSBlbmhhbmNlcnMoc3RvcmVFbmhhbmNlcnMpO1xyXG4gICAgfVxyXG4gICAgdmFyIGNvbXBvc2VkRW5oYW5jZXIgPSBmaW5hbENvbXBvc2UuYXBwbHkodm9pZCAwLCBzdG9yZUVuaGFuY2Vycyk7XHJcbiAgICByZXR1cm4gY3JlYXRlU3RvcmUocm9vdFJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBjb21wb3NlZEVuaGFuY2VyKTtcclxufVxyXG4vLyBzcmMvY3JlYXRlQWN0aW9uLnRzXHJcbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbih0eXBlLCBwcmVwYXJlQWN0aW9uKSB7XHJcbiAgICBmdW5jdGlvbiBhY3Rpb25DcmVhdG9yKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJlcGFyZUFjdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgcHJlcGFyZWQgPSBwcmVwYXJlQWN0aW9uLmFwcGx5KHZvaWQgMCwgYXJncyk7XHJcbiAgICAgICAgICAgIGlmICghcHJlcGFyZWQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInByZXBhcmVBY3Rpb24gZGlkIG5vdCByZXR1cm4gYW4gb2JqZWN0XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogcHJlcGFyZWQucGF5bG9hZFxyXG4gICAgICAgICAgICB9LCBcIm1ldGFcIiBpbiBwcmVwYXJlZCAmJiB7IG1ldGE6IHByZXBhcmVkLm1ldGEgfSksIFwiZXJyb3JcIiBpbiBwcmVwYXJlZCAmJiB7IGVycm9yOiBwcmVwYXJlZC5lcnJvciB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgcGF5bG9hZDogYXJnc1swXSB9O1xyXG4gICAgfVxyXG4gICAgYWN0aW9uQ3JlYXRvci50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiXCIgKyB0eXBlOyB9O1xyXG4gICAgYWN0aW9uQ3JlYXRvci50eXBlID0gdHlwZTtcclxuICAgIGFjdGlvbkNyZWF0b3IubWF0Y2ggPSBmdW5jdGlvbiAoYWN0aW9uKSB7IHJldHVybiBhY3Rpb24udHlwZSA9PT0gdHlwZTsgfTtcclxuICAgIHJldHVybiBhY3Rpb25DcmVhdG9yO1xyXG59XHJcbmZ1bmN0aW9uIGlzRlNBKGFjdGlvbikge1xyXG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QoYWN0aW9uKSAmJiB0eXBlb2YgYWN0aW9uLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgT2JqZWN0LmtleXMoYWN0aW9uKS5ldmVyeShpc1ZhbGlkS2V5KTtcclxufVxyXG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleSkge1xyXG4gICAgcmV0dXJuIFtcInR5cGVcIiwgXCJwYXlsb2FkXCIsIFwiZXJyb3JcIiwgXCJtZXRhXCJdLmluZGV4T2Yoa2V5KSA+IC0xO1xyXG59XHJcbmZ1bmN0aW9uIGdldFR5cGUoYWN0aW9uQ3JlYXRvcikge1xyXG4gICAgcmV0dXJuIFwiXCIgKyBhY3Rpb25DcmVhdG9yO1xyXG59XHJcbi8vIHNyYy9jcmVhdGVSZWR1Y2VyLnRzXHJcbmltcG9ydCBjcmVhdGVOZXh0U3RhdGUsIHsgaXNEcmFmdCBhcyBpc0RyYWZ0MiwgaXNEcmFmdGFibGUgfSBmcm9tIFwiaW1tZXJcIjtcclxuLy8gc3JjL21hcEJ1aWxkZXJzLnRzXHJcbmZ1bmN0aW9uIGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKGJ1aWxkZXJDYWxsYmFjaykge1xyXG4gICAgdmFyIGFjdGlvbnNNYXAgPSB7fTtcclxuICAgIHZhciBhY3Rpb25NYXRjaGVycyA9IFtdO1xyXG4gICAgdmFyIGRlZmF1bHRDYXNlUmVkdWNlcjtcclxuICAgIHZhciBidWlsZGVyID0ge1xyXG4gICAgICAgIGFkZENhc2U6IGZ1bmN0aW9uICh0eXBlT3JBY3Rpb25DcmVhdG9yLCByZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhY3Rpb25NYXRjaGVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGJ1aWxkZXIuYWRkQ2FzZWAgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZE1hdGNoZXJgXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImBidWlsZGVyLmFkZENhc2VgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWBcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdHlwZU9yQWN0aW9uQ3JlYXRvciA9PT0gXCJzdHJpbmdcIiA/IHR5cGVPckFjdGlvbkNyZWF0b3IgOiB0eXBlT3JBY3Rpb25DcmVhdG9yLnR5cGU7XHJcbiAgICAgICAgICAgIGlmICh0eXBlIGluIGFjdGlvbnNNYXApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZENhc2UgY2Fubm90IGJlIGNhbGxlZCB3aXRoIHR3byByZWR1Y2VycyBmb3IgdGhlIHNhbWUgYWN0aW9uIHR5cGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWN0aW9uc01hcFt0eXBlXSA9IHJlZHVjZXI7XHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZGVyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkTWF0Y2hlcjogZnVuY3Rpb24gKG1hdGNoZXIsIHJlZHVjZXIpIHtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImBidWlsZGVyLmFkZE1hdGNoZXJgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWBcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWN0aW9uTWF0Y2hlcnMucHVzaCh7IG1hdGNoZXI6IG1hdGNoZXIsIHJlZHVjZXI6IHJlZHVjZXIgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZGVyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkRGVmYXVsdENhc2U6IGZ1bmN0aW9uIChyZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWAgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2VcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVmYXVsdENhc2VSZWR1Y2VyID0gcmVkdWNlcjtcclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGJ1aWxkZXJDYWxsYmFjayhidWlsZGVyKTtcclxuICAgIHJldHVybiBbYWN0aW9uc01hcCwgYWN0aW9uTWF0Y2hlcnMsIGRlZmF1bHRDYXNlUmVkdWNlcl07XHJcbn1cclxuLy8gc3JjL2NyZWF0ZVJlZHVjZXIudHNcclxuZnVuY3Rpb24gaXNTdGF0ZUZ1bmN0aW9uKHgpIHtcclxuICAgIHJldHVybiB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlZHVjZXIoaW5pdGlhbFN0YXRlLCBtYXBPckJ1aWxkZXJDYWxsYmFjaywgYWN0aW9uTWF0Y2hlcnMsIGRlZmF1bHRDYXNlUmVkdWNlcikge1xyXG4gICAgaWYgKGFjdGlvbk1hdGNoZXJzID09PSB2b2lkIDApIHsgYWN0aW9uTWF0Y2hlcnMgPSBbXTsgfVxyXG4gICAgdmFyIF9jID0gdHlwZW9mIG1hcE9yQnVpbGRlckNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIgPyBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhtYXBPckJ1aWxkZXJDYWxsYmFjaykgOiBbbWFwT3JCdWlsZGVyQ2FsbGJhY2ssIGFjdGlvbk1hdGNoZXJzLCBkZWZhdWx0Q2FzZVJlZHVjZXJdLCBhY3Rpb25zTWFwID0gX2NbMF0sIGZpbmFsQWN0aW9uTWF0Y2hlcnMgPSBfY1sxXSwgZmluYWxEZWZhdWx0Q2FzZVJlZHVjZXIgPSBfY1syXTtcclxuICAgIHZhciBnZXRJbml0aWFsU3RhdGU7XHJcbiAgICBpZiAoaXNTdGF0ZUZ1bmN0aW9uKGluaXRpYWxTdGF0ZSkpIHtcclxuICAgICAgICBnZXRJbml0aWFsU3RhdGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVOZXh0U3RhdGUoaW5pdGlhbFN0YXRlKCksIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB9KTsgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBmcm96ZW5Jbml0aWFsU3RhdGVfMSA9IGNyZWF0ZU5leHRTdGF0ZShpbml0aWFsU3RhdGUsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB9KTtcclxuICAgICAgICBnZXRJbml0aWFsU3RhdGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmcm96ZW5Jbml0aWFsU3RhdGVfMTsgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xyXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7IHN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlKCk7IH1cclxuICAgICAgICB2YXIgY2FzZVJlZHVjZXJzID0gX19zcHJlYWRBcnJheShbXHJcbiAgICAgICAgICAgIGFjdGlvbnNNYXBbYWN0aW9uLnR5cGVdXHJcbiAgICAgICAgXSwgZmluYWxBY3Rpb25NYXRjaGVycy5maWx0ZXIoZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXRjaGVyID0gX2MubWF0Y2hlcjtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXIoYWN0aW9uKTtcclxuICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgICAgIHZhciByZWR1Y2VyMiA9IF9jLnJlZHVjZXI7XHJcbiAgICAgICAgICAgIHJldHVybiByZWR1Y2VyMjtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgaWYgKGNhc2VSZWR1Y2Vycy5maWx0ZXIoZnVuY3Rpb24gKGNyKSB7IHJldHVybiAhIWNyOyB9KS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgY2FzZVJlZHVjZXJzID0gW2ZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNhc2VSZWR1Y2Vycy5yZWR1Y2UoZnVuY3Rpb24gKHByZXZpb3VzU3RhdGUsIGNhc2VSZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgIGlmIChjYXNlUmVkdWNlcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRHJhZnQyKHByZXZpb3VzU3RhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyYWZ0ID0gcHJldmlvdXNTdGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gY2FzZVJlZHVjZXIoZHJhZnQsIGFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNEcmFmdGFibGUocHJldmlvdXNTdGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gY2FzZVJlZHVjZXIocHJldmlvdXNTdGF0ZSwgYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNTdGF0ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJBIGNhc2UgcmVkdWNlciBvbiBhIG5vbi1kcmFmdGFibGUgdmFsdWUgbXVzdCBub3QgcmV0dXJuIHVuZGVmaW5lZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVOZXh0U3RhdGUocHJldmlvdXNTdGF0ZSwgZnVuY3Rpb24gKGRyYWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYXNlUmVkdWNlcihkcmFmdCwgYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXNTdGF0ZTtcclxuICAgICAgICB9LCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICByZWR1Y2VyLmdldEluaXRpYWxTdGF0ZSA9IGdldEluaXRpYWxTdGF0ZTtcclxuICAgIHJldHVybiByZWR1Y2VyO1xyXG59XHJcbi8vIHNyYy9jcmVhdGVTbGljZS50c1xyXG5mdW5jdGlvbiBnZXRUeXBlMihzbGljZSwgYWN0aW9uS2V5KSB7XHJcbiAgICByZXR1cm4gc2xpY2UgKyBcIi9cIiArIGFjdGlvbktleTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVTbGljZShvcHRpb25zKSB7XHJcbiAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZTtcclxuICAgIGlmICghbmFtZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImBuYW1lYCBpcyBhIHJlcXVpcmVkIG9wdGlvbiBmb3IgY3JlYXRlU2xpY2VcIik7XHJcbiAgICB9XHJcbiAgICB2YXIgaW5pdGlhbFN0YXRlID0gdHlwZW9mIG9wdGlvbnMuaW5pdGlhbFN0YXRlID09IFwiZnVuY3Rpb25cIiA/IG9wdGlvbnMuaW5pdGlhbFN0YXRlIDogZGVmYXVsdDIob3B0aW9ucy5pbml0aWFsU3RhdGUsIGZ1bmN0aW9uICgpIHtcclxuICAgIH0pO1xyXG4gICAgdmFyIHJlZHVjZXJzID0gb3B0aW9ucy5yZWR1Y2VycyB8fCB7fTtcclxuICAgIHZhciByZWR1Y2VyTmFtZXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XHJcbiAgICB2YXIgc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWUgPSB7fTtcclxuICAgIHZhciBzbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZSA9IHt9O1xyXG4gICAgdmFyIGFjdGlvbkNyZWF0b3JzID0ge307XHJcbiAgICByZWR1Y2VyTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocmVkdWNlck5hbWUpIHtcclxuICAgICAgICB2YXIgbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUgPSByZWR1Y2Vyc1tyZWR1Y2VyTmFtZV07XHJcbiAgICAgICAgdmFyIHR5cGUgPSBnZXRUeXBlMihuYW1lLCByZWR1Y2VyTmFtZSk7XHJcbiAgICAgICAgdmFyIGNhc2VSZWR1Y2VyO1xyXG4gICAgICAgIHZhciBwcmVwYXJlQ2FsbGJhY2s7XHJcbiAgICAgICAgaWYgKFwicmVkdWNlclwiIGluIG1heWJlUmVkdWNlcldpdGhQcmVwYXJlKSB7XHJcbiAgICAgICAgICAgIGNhc2VSZWR1Y2VyID0gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUucmVkdWNlcjtcclxuICAgICAgICAgICAgcHJlcGFyZUNhbGxiYWNrID0gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUucHJlcGFyZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNhc2VSZWR1Y2VyID0gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lW3JlZHVjZXJOYW1lXSA9IGNhc2VSZWR1Y2VyO1xyXG4gICAgICAgIHNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlW3R5cGVdID0gY2FzZVJlZHVjZXI7XHJcbiAgICAgICAgYWN0aW9uQ3JlYXRvcnNbcmVkdWNlck5hbWVdID0gcHJlcGFyZUNhbGxiYWNrID8gY3JlYXRlQWN0aW9uKHR5cGUsIHByZXBhcmVDYWxsYmFjaykgOiBjcmVhdGVBY3Rpb24odHlwZSk7XHJcbiAgICB9KTtcclxuICAgIGZ1bmN0aW9uIGJ1aWxkUmVkdWNlcigpIHtcclxuICAgICAgICB2YXIgX2MgPSB0eXBlb2Ygb3B0aW9ucy5leHRyYVJlZHVjZXJzID09PSBcImZ1bmN0aW9uXCIgPyBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhvcHRpb25zLmV4dHJhUmVkdWNlcnMpIDogW29wdGlvbnMuZXh0cmFSZWR1Y2Vyc10sIF9kID0gX2NbMF0sIGV4dHJhUmVkdWNlcnMgPSBfZCA9PT0gdm9pZCAwID8ge30gOiBfZCwgX2UgPSBfY1sxXSwgYWN0aW9uTWF0Y2hlcnMgPSBfZSA9PT0gdm9pZCAwID8gW10gOiBfZSwgX2YgPSBfY1syXSwgZGVmYXVsdENhc2VSZWR1Y2VyID0gX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mO1xyXG4gICAgICAgIHZhciBmaW5hbENhc2VSZWR1Y2VycyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBleHRyYVJlZHVjZXJzKSwgc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGUpO1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVSZWR1Y2VyKGluaXRpYWxTdGF0ZSwgZmluYWxDYXNlUmVkdWNlcnMsIGFjdGlvbk1hdGNoZXJzLCBkZWZhdWx0Q2FzZVJlZHVjZXIpO1xyXG4gICAgfVxyXG4gICAgdmFyIF9yZWR1Y2VyO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICAgIHJlZHVjZXI6IGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmICghX3JlZHVjZXIpXHJcbiAgICAgICAgICAgICAgICBfcmVkdWNlciA9IGJ1aWxkUmVkdWNlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gX3JlZHVjZXIoc3RhdGUsIGFjdGlvbik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhY3Rpb25zOiBhY3Rpb25DcmVhdG9ycyxcclxuICAgICAgICBjYXNlUmVkdWNlcnM6IHNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lLFxyXG4gICAgICAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIV9yZWR1Y2VyKVxyXG4gICAgICAgICAgICAgICAgX3JlZHVjZXIgPSBidWlsZFJlZHVjZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIF9yZWR1Y2VyLmdldEluaXRpYWxTdGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuLy8gc3JjL2VudGl0aWVzL2VudGl0eV9zdGF0ZS50c1xyXG5mdW5jdGlvbiBnZXRJbml0aWFsRW50aXR5U3RhdGUoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGlkczogW10sXHJcbiAgICAgICAgZW50aXRpZXM6IHt9XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxTdGF0ZUZhY3RvcnkoKSB7XHJcbiAgICBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoYWRkaXRpb25hbFN0YXRlKSB7XHJcbiAgICAgICAgaWYgKGFkZGl0aW9uYWxTdGF0ZSA9PT0gdm9pZCAwKSB7IGFkZGl0aW9uYWxTdGF0ZSA9IHt9OyB9XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZ2V0SW5pdGlhbEVudGl0eVN0YXRlKCksIGFkZGl0aW9uYWxTdGF0ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBnZXRJbml0aWFsU3RhdGU6IGdldEluaXRpYWxTdGF0ZSB9O1xyXG59XHJcbi8vIHNyYy9lbnRpdGllcy9zdGF0ZV9zZWxlY3RvcnMudHNcclxuZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSgpIHtcclxuICAgIGZ1bmN0aW9uIGdldFNlbGVjdG9ycyhzZWxlY3RTdGF0ZSkge1xyXG4gICAgICAgIHZhciBzZWxlY3RJZHMgPSBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIHN0YXRlLmlkczsgfTtcclxuICAgICAgICB2YXIgc2VsZWN0RW50aXRpZXMgPSBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIHN0YXRlLmVudGl0aWVzOyB9O1xyXG4gICAgICAgIHZhciBzZWxlY3RBbGwgPSBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcihzZWxlY3RJZHMsIHNlbGVjdEVudGl0aWVzLCBmdW5jdGlvbiAoaWRzLCBlbnRpdGllcykgeyByZXR1cm4gaWRzLm1hcChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIGVudGl0aWVzW2lkXTsgfSk7IH0pO1xyXG4gICAgICAgIHZhciBzZWxlY3RJZCA9IGZ1bmN0aW9uIChfLCBpZCkgeyByZXR1cm4gaWQ7IH07XHJcbiAgICAgICAgdmFyIHNlbGVjdEJ5SWQgPSBmdW5jdGlvbiAoZW50aXRpZXMsIGlkKSB7IHJldHVybiBlbnRpdGllc1tpZF07IH07XHJcbiAgICAgICAgdmFyIHNlbGVjdFRvdGFsID0gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3Ioc2VsZWN0SWRzLCBmdW5jdGlvbiAoaWRzKSB7IHJldHVybiBpZHMubGVuZ3RoOyB9KTtcclxuICAgICAgICBpZiAoIXNlbGVjdFN0YXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RJZHM6IHNlbGVjdElkcyxcclxuICAgICAgICAgICAgICAgIHNlbGVjdEVudGl0aWVzOiBzZWxlY3RFbnRpdGllcyxcclxuICAgICAgICAgICAgICAgIHNlbGVjdEFsbDogc2VsZWN0QWxsLFxyXG4gICAgICAgICAgICAgICAgc2VsZWN0VG90YWw6IHNlbGVjdFRvdGFsLFxyXG4gICAgICAgICAgICAgICAgc2VsZWN0QnlJZDogY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3Ioc2VsZWN0RW50aXRpZXMsIHNlbGVjdElkLCBzZWxlY3RCeUlkKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2VsZWN0R2xvYmFsaXplZEVudGl0aWVzID0gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3Ioc2VsZWN0U3RhdGUsIHNlbGVjdEVudGl0aWVzKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzZWxlY3RJZHM6IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdFN0YXRlLCBzZWxlY3RJZHMpLFxyXG4gICAgICAgICAgICBzZWxlY3RFbnRpdGllczogc2VsZWN0R2xvYmFsaXplZEVudGl0aWVzLFxyXG4gICAgICAgICAgICBzZWxlY3RBbGw6IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdFN0YXRlLCBzZWxlY3RBbGwpLFxyXG4gICAgICAgICAgICBzZWxlY3RUb3RhbDogY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3Ioc2VsZWN0U3RhdGUsIHNlbGVjdFRvdGFsKSxcclxuICAgICAgICAgICAgc2VsZWN0QnlJZDogY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3Ioc2VsZWN0R2xvYmFsaXplZEVudGl0aWVzLCBzZWxlY3RJZCwgc2VsZWN0QnlJZClcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgZ2V0U2VsZWN0b3JzOiBnZXRTZWxlY3RvcnMgfTtcclxufVxyXG4vLyBzcmMvZW50aXRpZXMvc3RhdGVfYWRhcHRlci50c1xyXG5pbXBvcnQgY3JlYXRlTmV4dFN0YXRlMiwgeyBpc0RyYWZ0IGFzIGlzRHJhZnQzIH0gZnJvbSBcImltbWVyXCI7XHJcbmZ1bmN0aW9uIGNyZWF0ZVNpbmdsZUFyZ3VtZW50U3RhdGVPcGVyYXRvcihtdXRhdG9yKSB7XHJcbiAgICB2YXIgb3BlcmF0b3IgPSBjcmVhdGVTdGF0ZU9wZXJhdG9yKGZ1bmN0aW9uIChfLCBzdGF0ZSkgeyByZXR1cm4gbXV0YXRvcihzdGF0ZSk7IH0pO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9wZXJhdGlvbihzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBvcGVyYXRvcihzdGF0ZSwgdm9pZCAwKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlU3RhdGVPcGVyYXRvcihtdXRhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gb3BlcmF0aW9uKHN0YXRlLCBhcmcpIHtcclxuICAgICAgICBmdW5jdGlvbiBpc1BheWxvYWRBY3Rpb25Bcmd1bWVudChhcmcyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0ZTQShhcmcyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJ1bk11dGF0b3IgPSBmdW5jdGlvbiAoZHJhZnQpIHtcclxuICAgICAgICAgICAgaWYgKGlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50KGFyZykpIHtcclxuICAgICAgICAgICAgICAgIG11dGF0b3IoYXJnLnBheWxvYWQsIGRyYWZ0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG11dGF0b3IoYXJnLCBkcmFmdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChpc0RyYWZ0MyhzdGF0ZSkpIHtcclxuICAgICAgICAgICAgcnVuTXV0YXRvcihzdGF0ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVOZXh0U3RhdGUyKHN0YXRlLCBydW5NdXRhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbi8vIHNyYy9lbnRpdGllcy91dGlscy50c1xyXG5mdW5jdGlvbiBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpIHtcclxuICAgIHZhciBrZXkgPSBzZWxlY3RJZChlbnRpdHkpO1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBrZXkgPT09IHZvaWQgMCkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIlRoZSBlbnRpdHkgcGFzc2VkIHRvIHRoZSBgc2VsZWN0SWRgIGltcGxlbWVudGF0aW9uIHJldHVybmVkIHVuZGVmaW5lZC5cIiwgXCJZb3Ugc2hvdWxkIHByb2JhYmx5IHByb3ZpZGUgeW91ciBvd24gYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbi5cIiwgXCJUaGUgZW50aXR5IHRoYXQgd2FzIHBhc3NlZDpcIiwgZW50aXR5LCBcIlRoZSBgc2VsZWN0SWRgIGltcGxlbWVudGF0aW9uOlwiLCBzZWxlY3RJZC50b1N0cmluZygpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBrZXk7XHJcbn1cclxuZnVuY3Rpb24gZW5zdXJlRW50aXRpZXNBcnJheShlbnRpdGllcykge1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGVudGl0aWVzKSkge1xyXG4gICAgICAgIGVudGl0aWVzID0gT2JqZWN0LnZhbHVlcyhlbnRpdGllcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZW50aXRpZXM7XHJcbn1cclxuZnVuY3Rpb24gc3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllcyhuZXdFbnRpdGllcywgc2VsZWN0SWQsIHN0YXRlKSB7XHJcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xyXG4gICAgdmFyIGFkZGVkID0gW107XHJcbiAgICB2YXIgdXBkYXRlZCA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBuZXdFbnRpdGllc18xID0gbmV3RW50aXRpZXM7IF9pIDwgbmV3RW50aXRpZXNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgZW50aXR5ID0gbmV3RW50aXRpZXNfMVtfaV07XHJcbiAgICAgICAgdmFyIGlkID0gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKTtcclxuICAgICAgICBpZiAoaWQgaW4gc3RhdGUuZW50aXRpZXMpIHtcclxuICAgICAgICAgICAgdXBkYXRlZC5wdXNoKHsgaWQ6IGlkLCBjaGFuZ2VzOiBlbnRpdHkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhZGRlZC5wdXNoKGVudGl0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFthZGRlZCwgdXBkYXRlZF07XHJcbn1cclxuLy8gc3JjL2VudGl0aWVzL3Vuc29ydGVkX3N0YXRlX2FkYXB0ZXIudHNcclxuZnVuY3Rpb24gY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpIHtcclxuICAgIGZ1bmN0aW9uIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xyXG4gICAgICAgIHZhciBrZXkgPSBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpO1xyXG4gICAgICAgIGlmIChrZXkgaW4gc3RhdGUuZW50aXRpZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0ZS5pZHMucHVzaChrZXkpO1xyXG4gICAgICAgIHN0YXRlLmVudGl0aWVzW2tleV0gPSBlbnRpdHk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcclxuICAgICAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgbmV3RW50aXRpZXNfMiA9IG5ld0VudGl0aWVzOyBfaSA8IG5ld0VudGl0aWVzXzIubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBlbnRpdHkgPSBuZXdFbnRpdGllc18yW19pXTtcclxuICAgICAgICAgICAgYWRkT25lTXV0YWJseShlbnRpdHksIHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzZXRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcclxuICAgICAgICB2YXIga2V5ID0gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKTtcclxuICAgICAgICBpZiAoIShrZXkgaW4gc3RhdGUuZW50aXRpZXMpKSB7XHJcbiAgICAgICAgICAgIHN0YXRlLmlkcy5wdXNoKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRlLmVudGl0aWVzW2tleV0gPSBlbnRpdHk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzZXRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcclxuICAgICAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgbmV3RW50aXRpZXNfMyA9IG5ld0VudGl0aWVzOyBfaSA8IG5ld0VudGl0aWVzXzMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBlbnRpdHkgPSBuZXdFbnRpdGllc18zW19pXTtcclxuICAgICAgICAgICAgc2V0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzZXRBbGxNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xyXG4gICAgICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XHJcbiAgICAgICAgc3RhdGUuaWRzID0gW107XHJcbiAgICAgICAgc3RhdGUuZW50aXRpZXMgPSB7fTtcclxuICAgICAgICBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVtb3ZlT25lTXV0YWJseShrZXksIHN0YXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlbW92ZU1hbnlNdXRhYmx5KFtrZXldLCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW1vdmVNYW55TXV0YWJseShrZXlzLCBzdGF0ZSkge1xyXG4gICAgICAgIHZhciBkaWRNdXRhdGUgPSBmYWxzZTtcclxuICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICBpZiAoa2V5IGluIHN0YXRlLmVudGl0aWVzKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNba2V5XTtcclxuICAgICAgICAgICAgICAgIGRpZE11dGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoZGlkTXV0YXRlKSB7XHJcbiAgICAgICAgICAgIHN0YXRlLmlkcyA9IHN0YXRlLmlkcy5maWx0ZXIoZnVuY3Rpb24gKGlkKSB7IHJldHVybiBpZCBpbiBzdGF0ZS5lbnRpdGllczsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTXV0YWJseShzdGF0ZSkge1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24oc3RhdGUsIHtcclxuICAgICAgICAgICAgaWRzOiBbXSxcclxuICAgICAgICAgICAgZW50aXRpZXM6IHt9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB0YWtlTmV3S2V5KGtleXMsIHVwZGF0ZSwgc3RhdGUpIHtcclxuICAgICAgICB2YXIgb3JpZ2luYWwyID0gc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcclxuICAgICAgICB2YXIgdXBkYXRlZCA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWdpbmFsMiwgdXBkYXRlLmNoYW5nZXMpO1xyXG4gICAgICAgIHZhciBuZXdLZXkgPSBzZWxlY3RJZFZhbHVlKHVwZGF0ZWQsIHNlbGVjdElkKTtcclxuICAgICAgICB2YXIgaGFzTmV3S2V5ID0gbmV3S2V5ICE9PSB1cGRhdGUuaWQ7XHJcbiAgICAgICAgaWYgKGhhc05ld0tleSkge1xyXG4gICAgICAgICAgICBrZXlzW3VwZGF0ZS5pZF0gPSBuZXdLZXk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0ZS5lbnRpdGllc1tuZXdLZXldID0gdXBkYXRlZDtcclxuICAgICAgICByZXR1cm4gaGFzTmV3S2V5O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdXBkYXRlT25lTXV0YWJseSh1cGRhdGUsIHN0YXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU1hbnlNdXRhYmx5KFt1cGRhdGVdLCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVzLCBzdGF0ZSkge1xyXG4gICAgICAgIHZhciBuZXdLZXlzID0ge307XHJcbiAgICAgICAgdmFyIHVwZGF0ZXNQZXJFbnRpdHkgPSB7fTtcclxuICAgICAgICB1cGRhdGVzLmZvckVhY2goZnVuY3Rpb24gKHVwZGF0ZSkge1xyXG4gICAgICAgICAgICBpZiAodXBkYXRlLmlkIGluIHN0YXRlLmVudGl0aWVzKSB7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVzUGVyRW50aXR5W3VwZGF0ZS5pZF0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHVwZGF0ZS5pZCxcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzOiBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdXBkYXRlc1BlckVudGl0eVt1cGRhdGUuaWRdID8gdXBkYXRlc1BlckVudGl0eVt1cGRhdGUuaWRdLmNoYW5nZXMgOiBudWxsKSwgdXBkYXRlLmNoYW5nZXMpXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdXBkYXRlcyA9IE9iamVjdC52YWx1ZXModXBkYXRlc1BlckVudGl0eSk7XHJcbiAgICAgICAgdmFyIGRpZE11dGF0ZUVudGl0aWVzID0gdXBkYXRlcy5sZW5ndGggPiAwO1xyXG4gICAgICAgIGlmIChkaWRNdXRhdGVFbnRpdGllcykge1xyXG4gICAgICAgICAgICB2YXIgZGlkTXV0YXRlSWRzID0gdXBkYXRlcy5maWx0ZXIoZnVuY3Rpb24gKHVwZGF0ZSkgeyByZXR1cm4gdGFrZU5ld0tleShuZXdLZXlzLCB1cGRhdGUsIHN0YXRlKTsgfSkubGVuZ3RoID4gMDtcclxuICAgICAgICAgICAgaWYgKGRpZE11dGF0ZUlkcykge1xyXG4gICAgICAgICAgICAgICAgc3RhdGUuaWRzID0gc3RhdGUuaWRzLm1hcChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIG5ld0tleXNbaWRdIHx8IGlkOyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVwc2VydE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiB1cHNlcnRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdXBzZXJ0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIF9jID0gc3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllcyhuZXdFbnRpdGllcywgc2VsZWN0SWQsIHN0YXRlKSwgYWRkZWQgPSBfY1swXSwgdXBkYXRlZCA9IF9jWzFdO1xyXG4gICAgICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKTtcclxuICAgICAgICBhZGRNYW55TXV0YWJseShhZGRlZCwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZW1vdmVBbGw6IGNyZWF0ZVNpbmdsZUFyZ3VtZW50U3RhdGVPcGVyYXRvcihyZW1vdmVBbGxNdXRhYmx5KSxcclxuICAgICAgICBhZGRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkT25lTXV0YWJseSksXHJcbiAgICAgICAgYWRkTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRNYW55TXV0YWJseSksXHJcbiAgICAgICAgc2V0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE9uZU11dGFibHkpLFxyXG4gICAgICAgIHNldE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0TWFueU11dGFibHkpLFxyXG4gICAgICAgIHNldEFsbDogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRBbGxNdXRhYmx5KSxcclxuICAgICAgICB1cGRhdGVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlT25lTXV0YWJseSksXHJcbiAgICAgICAgdXBkYXRlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVNYW55TXV0YWJseSksXHJcbiAgICAgICAgdXBzZXJ0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE9uZU11dGFibHkpLFxyXG4gICAgICAgIHVwc2VydE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0TWFueU11dGFibHkpLFxyXG4gICAgICAgIHJlbW92ZU9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihyZW1vdmVPbmVNdXRhYmx5KSxcclxuICAgICAgICByZW1vdmVNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHJlbW92ZU1hbnlNdXRhYmx5KVxyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvZW50aXRpZXMvc29ydGVkX3N0YXRlX2FkYXB0ZXIudHNcclxuZnVuY3Rpb24gY3JlYXRlU29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkLCBzb3J0KSB7XHJcbiAgICB2YXIgX2MgPSBjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCksIHJlbW92ZU9uZSA9IF9jLnJlbW92ZU9uZSwgcmVtb3ZlTWFueSA9IF9jLnJlbW92ZU1hbnksIHJlbW92ZUFsbCA9IF9jLnJlbW92ZUFsbDtcclxuICAgIGZ1bmN0aW9uIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBhZGRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgICAgICB2YXIgbW9kZWxzID0gbmV3RW50aXRpZXMuZmlsdGVyKGZ1bmN0aW9uIChtb2RlbCkgeyByZXR1cm4gIShzZWxlY3RJZFZhbHVlKG1vZGVsLCBzZWxlY3RJZCkgaW4gc3RhdGUuZW50aXRpZXMpOyB9KTtcclxuICAgICAgICBpZiAobW9kZWxzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICBtZXJnZShtb2RlbHMsIHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzZXRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gc2V0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNldE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xyXG4gICAgICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XHJcbiAgICAgICAgaWYgKG5ld0VudGl0aWVzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICBtZXJnZShuZXdFbnRpdGllcywgc3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNldEFsbE11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgICAgICBzdGF0ZS5lbnRpdGllcyA9IHt9O1xyXG4gICAgICAgIHN0YXRlLmlkcyA9IFtdO1xyXG4gICAgICAgIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB1cGRhdGVPbmVNdXRhYmx5KHVwZGF0ZSwgc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gdXBkYXRlTWFueU11dGFibHkoW3VwZGF0ZV0sIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRha2VVcGRhdGVkTW9kZWwobW9kZWxzLCB1cGRhdGUsIHN0YXRlKSB7XHJcbiAgICAgICAgaWYgKCEodXBkYXRlLmlkIGluIHN0YXRlLmVudGl0aWVzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvcmlnaW5hbDIgPSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xyXG4gICAgICAgIHZhciB1cGRhdGVkID0gT2JqZWN0LmFzc2lnbih7fSwgb3JpZ2luYWwyLCB1cGRhdGUuY2hhbmdlcyk7XHJcbiAgICAgICAgdmFyIG5ld0tleSA9IHNlbGVjdElkVmFsdWUodXBkYXRlZCwgc2VsZWN0SWQpO1xyXG4gICAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xyXG4gICAgICAgIG1vZGVscy5wdXNoKHVwZGF0ZWQpO1xyXG4gICAgICAgIHJldHVybiBuZXdLZXkgIT09IHVwZGF0ZS5pZDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIG1vZGVscyA9IFtdO1xyXG4gICAgICAgIHVwZGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAodXBkYXRlKSB7IHJldHVybiB0YWtlVXBkYXRlZE1vZGVsKG1vZGVscywgdXBkYXRlLCBzdGF0ZSk7IH0pO1xyXG4gICAgICAgIGlmIChtb2RlbHMubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgIG1lcmdlKG1vZGVscywgc3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVwc2VydE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiB1cHNlcnRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdXBzZXJ0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIF9jID0gc3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllcyhuZXdFbnRpdGllcywgc2VsZWN0SWQsIHN0YXRlKSwgYWRkZWQgPSBfY1swXSwgdXBkYXRlZCA9IF9jWzFdO1xyXG4gICAgICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKTtcclxuICAgICAgICBhZGRNYW55TXV0YWJseShhZGRlZCwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXJlQXJyYXlzRXF1YWwoYSwgYikge1xyXG4gICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoICYmIGkgPCBiLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChhW2ldID09PSBiW2ldKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbWVyZ2UobW9kZWxzLCBzdGF0ZSkge1xyXG4gICAgICAgIG1vZGVscy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RlbCkge1xyXG4gICAgICAgICAgICBzdGF0ZS5lbnRpdGllc1tzZWxlY3RJZChtb2RlbCldID0gbW9kZWw7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGFsbEVudGl0aWVzID0gT2JqZWN0LnZhbHVlcyhzdGF0ZS5lbnRpdGllcyk7XHJcbiAgICAgICAgYWxsRW50aXRpZXMuc29ydChzb3J0KTtcclxuICAgICAgICB2YXIgbmV3U29ydGVkSWRzID0gYWxsRW50aXRpZXMubWFwKHNlbGVjdElkKTtcclxuICAgICAgICB2YXIgaWRzID0gc3RhdGUuaWRzO1xyXG4gICAgICAgIGlmICghYXJlQXJyYXlzRXF1YWwoaWRzLCBuZXdTb3J0ZWRJZHMpKSB7XHJcbiAgICAgICAgICAgIHN0YXRlLmlkcyA9IG5ld1NvcnRlZElkcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlbW92ZU9uZTogcmVtb3ZlT25lLFxyXG4gICAgICAgIHJlbW92ZU1hbnk6IHJlbW92ZU1hbnksXHJcbiAgICAgICAgcmVtb3ZlQWxsOiByZW1vdmVBbGwsXHJcbiAgICAgICAgYWRkT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE9uZU11dGFibHkpLFxyXG4gICAgICAgIHVwZGF0ZU9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVPbmVNdXRhYmx5KSxcclxuICAgICAgICB1cHNlcnRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0T25lTXV0YWJseSksXHJcbiAgICAgICAgc2V0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE9uZU11dGFibHkpLFxyXG4gICAgICAgIHNldE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0TWFueU11dGFibHkpLFxyXG4gICAgICAgIHNldEFsbDogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRBbGxNdXRhYmx5KSxcclxuICAgICAgICBhZGRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE1hbnlNdXRhYmx5KSxcclxuICAgICAgICB1cGRhdGVNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU1hbnlNdXRhYmx5KSxcclxuICAgICAgICB1cHNlcnRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE1hbnlNdXRhYmx5KVxyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvZW50aXRpZXMvY3JlYXRlX2FkYXB0ZXIudHNcclxuZnVuY3Rpb24gY3JlYXRlRW50aXR5QWRhcHRlcihvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgdmFyIF9jID0gX19zcHJlYWRWYWx1ZXMoe1xyXG4gICAgICAgIHNvcnRDb21wYXJlcjogZmFsc2UsXHJcbiAgICAgICAgc2VsZWN0SWQ6IGZ1bmN0aW9uIChpbnN0YW5jZSkgeyByZXR1cm4gaW5zdGFuY2UuaWQ7IH1cclxuICAgIH0sIG9wdGlvbnMpLCBzZWxlY3RJZCA9IF9jLnNlbGVjdElkLCBzb3J0Q29tcGFyZXIgPSBfYy5zb3J0Q29tcGFyZXI7XHJcbiAgICB2YXIgc3RhdGVGYWN0b3J5ID0gY3JlYXRlSW5pdGlhbFN0YXRlRmFjdG9yeSgpO1xyXG4gICAgdmFyIHNlbGVjdG9yc0ZhY3RvcnkgPSBjcmVhdGVTZWxlY3RvcnNGYWN0b3J5KCk7XHJcbiAgICB2YXIgc3RhdGVBZGFwdGVyID0gc29ydENvbXBhcmVyID8gY3JlYXRlU29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkLCBzb3J0Q29tcGFyZXIpIDogY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpO1xyXG4gICAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHtcclxuICAgICAgICBzZWxlY3RJZDogc2VsZWN0SWQsXHJcbiAgICAgICAgc29ydENvbXBhcmVyOiBzb3J0Q29tcGFyZXJcclxuICAgIH0sIHN0YXRlRmFjdG9yeSksIHNlbGVjdG9yc0ZhY3RvcnkpLCBzdGF0ZUFkYXB0ZXIpO1xyXG59XHJcbi8vIHNyYy9uYW5vaWQudHNcclxudmFyIHVybEFscGhhYmV0ID0gXCJNb2R1bGVTeW1iaGFzT3duUHItMDEyMzQ1Njc4OUFCQ0RFRkdITlJWZmdjdGlVdnpfS3FZVEprTHhwWlhJalFXXCI7XHJcbnZhciBuYW5vaWQgPSBmdW5jdGlvbiAoc2l6ZSkge1xyXG4gICAgaWYgKHNpemUgPT09IHZvaWQgMCkgeyBzaXplID0gMjE7IH1cclxuICAgIHZhciBpZCA9IFwiXCI7XHJcbiAgICB2YXIgaSA9IHNpemU7XHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgaWQgKz0gdXJsQWxwaGFiZXRbTWF0aC5yYW5kb20oKSAqIDY0IHwgMF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaWQ7XHJcbn07XHJcbi8vIHNyYy9jcmVhdGVBc3luY1RodW5rLnRzXHJcbnZhciBjb21tb25Qcm9wZXJ0aWVzID0gW1xyXG4gICAgXCJuYW1lXCIsXHJcbiAgICBcIm1lc3NhZ2VcIixcclxuICAgIFwic3RhY2tcIixcclxuICAgIFwiY29kZVwiXHJcbl07XHJcbnZhciBSZWplY3RXaXRoVmFsdWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSZWplY3RXaXRoVmFsdWUocGF5bG9hZCwgbWV0YSkge1xyXG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XHJcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcclxuICAgIH1cclxuICAgIHJldHVybiBSZWplY3RXaXRoVmFsdWU7XHJcbn0oKSk7XHJcbnZhciBGdWxmaWxsV2l0aE1ldGEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBGdWxmaWxsV2l0aE1ldGEocGF5bG9hZCwgbWV0YSkge1xyXG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XHJcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcclxuICAgIH1cclxuICAgIHJldHVybiBGdWxmaWxsV2l0aE1ldGE7XHJcbn0oKSk7XHJcbnZhciBtaW5pU2VyaWFsaXplRXJyb3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICB2YXIgc2ltcGxlRXJyb3IgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGNvbW1vblByb3BlcnRpZXNfMSA9IGNvbW1vblByb3BlcnRpZXM7IF9pIDwgY29tbW9uUHJvcGVydGllc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBjb21tb25Qcm9wZXJ0aWVzXzFbX2ldO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlW3Byb3BlcnR5XSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgc2ltcGxlRXJyb3JbcHJvcGVydHldID0gdmFsdWVbcHJvcGVydHldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzaW1wbGVFcnJvcjtcclxuICAgIH1cclxuICAgIHJldHVybiB7IG1lc3NhZ2U6IFN0cmluZyh2YWx1ZSkgfTtcclxufTtcclxuZnVuY3Rpb24gY3JlYXRlQXN5bmNUaHVuayh0eXBlUHJlZml4LCBwYXlsb2FkQ3JlYXRvciwgb3B0aW9ucykge1xyXG4gICAgdmFyIGZ1bGZpbGxlZCA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvZnVsZmlsbGVkXCIsIGZ1bmN0aW9uIChwYXlsb2FkLCByZXF1ZXN0SWQsIGFyZywgbWV0YSkgeyByZXR1cm4gKHtcclxuICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxyXG4gICAgICAgIG1ldGE6IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG1ldGEgfHwge30pLCB7XHJcbiAgICAgICAgICAgIGFyZzogYXJnLFxyXG4gICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RJZCxcclxuICAgICAgICAgICAgcmVxdWVzdFN0YXR1czogXCJmdWxmaWxsZWRcIlxyXG4gICAgICAgIH0pXHJcbiAgICB9KTsgfSk7XHJcbiAgICB2YXIgcGVuZGluZyA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvcGVuZGluZ1wiLCBmdW5jdGlvbiAocmVxdWVzdElkLCBhcmcsIG1ldGEpIHsgcmV0dXJuICh7XHJcbiAgICAgICAgcGF5bG9hZDogdm9pZCAwLFxyXG4gICAgICAgIG1ldGE6IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG1ldGEgfHwge30pLCB7XHJcbiAgICAgICAgICAgIGFyZzogYXJnLFxyXG4gICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RJZCxcclxuICAgICAgICAgICAgcmVxdWVzdFN0YXR1czogXCJwZW5kaW5nXCJcclxuICAgICAgICB9KVxyXG4gICAgfSk7IH0pO1xyXG4gICAgdmFyIHJlamVjdGVkID0gY3JlYXRlQWN0aW9uKHR5cGVQcmVmaXggKyBcIi9yZWplY3RlZFwiLCBmdW5jdGlvbiAoZXJyb3IsIHJlcXVlc3RJZCwgYXJnLCBwYXlsb2FkLCBtZXRhKSB7IHJldHVybiAoe1xyXG4gICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXHJcbiAgICAgICAgZXJyb3I6IChvcHRpb25zICYmIG9wdGlvbnMuc2VyaWFsaXplRXJyb3IgfHwgbWluaVNlcmlhbGl6ZUVycm9yKShlcnJvciB8fCBcIlJlamVjdGVkXCIpLFxyXG4gICAgICAgIG1ldGE6IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG1ldGEgfHwge30pLCB7XHJcbiAgICAgICAgICAgIGFyZzogYXJnLFxyXG4gICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RJZCxcclxuICAgICAgICAgICAgcmVqZWN0ZWRXaXRoVmFsdWU6ICEhcGF5bG9hZCxcclxuICAgICAgICAgICAgcmVxdWVzdFN0YXR1czogXCJyZWplY3RlZFwiLFxyXG4gICAgICAgICAgICBhYm9ydGVkOiAoZXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yLm5hbWUpID09PSBcIkFib3J0RXJyb3JcIixcclxuICAgICAgICAgICAgY29uZGl0aW9uOiAoZXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yLm5hbWUpID09PSBcIkNvbmRpdGlvbkVycm9yXCJcclxuICAgICAgICB9KVxyXG4gICAgfSk7IH0pO1xyXG4gICAgdmFyIGRpc3BsYXllZFdhcm5pbmcgPSBmYWxzZTtcclxuICAgIHZhciBBQyA9IHR5cGVvZiBBYm9ydENvbnRyb2xsZXIgIT09IFwidW5kZWZpbmVkXCIgPyBBYm9ydENvbnRyb2xsZXIgOiAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gY2xhc3NfMSgpIHtcclxuICAgICAgICAgICAgdGhpcy5zaWduYWwgPSB7XHJcbiAgICAgICAgICAgICAgICBhYm9ydGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG9uYWJvcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRpc3BsYXllZFdhcm5pbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5ZWRXYXJuaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCJUaGlzIHBsYXRmb3JtIGRvZXMgbm90IGltcGxlbWVudCBBYm9ydENvbnRyb2xsZXIuIFxcbklmIHlvdSB3YW50IHRvIHVzZSB0aGUgQWJvcnRDb250cm9sbGVyIHRvIHJlYWN0IHRvIGBhYm9ydGAgZXZlbnRzLCBwbGVhc2UgY29uc2lkZXIgaW1wb3J0aW5nIGEgcG9seWZpbGwgbGlrZSAnYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsL2Rpc3QvYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsLW9ubHknLlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGNsYXNzXzE7XHJcbiAgICB9KCkpO1xyXG4gICAgZnVuY3Rpb24gYWN0aW9uQ3JlYXRvcihhcmcpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoLCBnZXRTdGF0ZSwgZXh0cmEpIHtcclxuICAgICAgICAgICAgdmFyIHJlcXVlc3RJZCA9IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmlkR2VuZXJhdG9yKSA/IG9wdGlvbnMuaWRHZW5lcmF0b3IoYXJnKSA6IG5hbm9pZCgpO1xyXG4gICAgICAgICAgICB2YXIgYWJvcnRDb250cm9sbGVyID0gbmV3IEFDKCk7XHJcbiAgICAgICAgICAgIHZhciBhYm9ydFJlYXNvbjtcclxuICAgICAgICAgICAgdmFyIGFib3J0ZWRQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKF8sIHJlamVjdCkgeyByZXR1cm4gYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVqZWN0KHsgbmFtZTogXCJBYm9ydEVycm9yXCIsIG1lc3NhZ2U6IGFib3J0UmVhc29uIHx8IFwiQWJvcnRlZFwiIH0pOyB9KTsgfSk7XHJcbiAgICAgICAgICAgIHZhciBzdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGFib3J0KHJlYXNvbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBhYm9ydFJlYXNvbiA9IHJlYXNvbjtcclxuICAgICAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBmaW5hbEFjdGlvbiwgY29uZGl0aW9uUmVzdWx0LCBlcnJfMSwgc2tpcERpc3BhdGNoO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbMCwgNCwgLCA1XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0ID0gKF9hID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5jb25kaXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMsIGFyZywgeyBnZXRTdGF0ZTogZ2V0U3RhdGUsIGV4dHJhOiBleHRyYSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVGhlbmFibGUoY29uZGl0aW9uUmVzdWx0KSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgY29uZGl0aW9uUmVzdWx0XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25SZXN1bHQgPSBfYy5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25kaXRpb25SZXN1bHQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiQ29uZGl0aW9uRXJyb3JcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQWJvcnRlZCBkdWUgdG8gY29uZGl0aW9uIGNhbGxiYWNrIHJldHVybmluZyBmYWxzZS5cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChwZW5kaW5nKHJlcXVlc3RJZCwgYXJnLCAoX2IgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmdldFBlbmRpbmdNZXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChvcHRpb25zLCB7IHJlcXVlc3RJZDogcmVxdWVzdElkLCBhcmc6IGFyZyB9LCB7IGdldFN0YXRlOiBnZXRTdGF0ZSwgZXh0cmE6IGV4dHJhIH0pKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5yYWNlKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0ZWRQcm9taXNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHBheWxvYWRDcmVhdG9yKGFyZywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoOiBkaXNwYXRjaCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRTdGF0ZTogZ2V0U3RhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IGV4dHJhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3RXaXRoVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgbWV0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlamVjdFdpdGhWYWx1ZSh2YWx1ZSwgbWV0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsV2l0aFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIG1ldGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGdWxmaWxsV2l0aE1ldGEodmFsdWUsIG1ldGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUmVqZWN0V2l0aFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEZ1bGZpbGxXaXRoTWV0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVsZmlsbGVkKHJlc3VsdC5wYXlsb2FkLCByZXF1ZXN0SWQsIGFyZywgcmVzdWx0Lm1ldGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVsZmlsbGVkKHJlc3VsdCwgcmVxdWVzdElkLCBhcmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsQWN0aW9uID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycl8xID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsQWN0aW9uID0gZXJyXzEgaW5zdGFuY2VvZiBSZWplY3RXaXRoVmFsdWUgPyByZWplY3RlZChudWxsLCByZXF1ZXN0SWQsIGFyZywgZXJyXzEucGF5bG9hZCwgZXJyXzEubWV0YSkgOiByZWplY3RlZChlcnJfMSwgcmVxdWVzdElkLCBhcmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBEaXNwYXRjaCA9IG9wdGlvbnMgJiYgIW9wdGlvbnMuZGlzcGF0Y2hDb25kaXRpb25SZWplY3Rpb24gJiYgcmVqZWN0ZWQubWF0Y2goZmluYWxBY3Rpb24pICYmIGZpbmFsQWN0aW9uLm1ldGEuY29uZGl0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2tpcERpc3BhdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKGZpbmFsQWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZpbmFsQWN0aW9uXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0oKTtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJvbWlzZSwge1xyXG4gICAgICAgICAgICAgICAgYWJvcnQ6IGFib3J0LFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdElkOiByZXF1ZXN0SWQsXHJcbiAgICAgICAgICAgICAgICBhcmc6IGFyZyxcclxuICAgICAgICAgICAgICAgIHVud3JhcDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4odW53cmFwUmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFjdGlvbkNyZWF0b3IsIHtcclxuICAgICAgICBwZW5kaW5nOiBwZW5kaW5nLFxyXG4gICAgICAgIHJlamVjdGVkOiByZWplY3RlZCxcclxuICAgICAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcclxuICAgICAgICB0eXBlUHJlZml4OiB0eXBlUHJlZml4XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiB1bndyYXBSZXN1bHQoYWN0aW9uKSB7XHJcbiAgICBpZiAoYWN0aW9uLm1ldGEgJiYgYWN0aW9uLm1ldGEucmVqZWN0ZWRXaXRoVmFsdWUpIHtcclxuICAgICAgICB0aHJvdyBhY3Rpb24ucGF5bG9hZDtcclxuICAgIH1cclxuICAgIGlmIChhY3Rpb24uZXJyb3IpIHtcclxuICAgICAgICB0aHJvdyBhY3Rpb24uZXJyb3I7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYWN0aW9uLnBheWxvYWQ7XHJcbn1cclxuZnVuY3Rpb24gaXNUaGVuYWJsZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xyXG59XHJcbi8vIHNyYy90c0hlbHBlcnMudHNcclxudmFyIGhhc01hdGNoRnVuY3Rpb24gPSBmdW5jdGlvbiAodikge1xyXG4gICAgcmV0dXJuIHYgJiYgdHlwZW9mIHYubWF0Y2ggPT09IFwiZnVuY3Rpb25cIjtcclxufTtcclxuLy8gc3JjL21hdGNoZXJzLnRzXHJcbnZhciBtYXRjaGVzID0gZnVuY3Rpb24gKG1hdGNoZXIsIGFjdGlvbikge1xyXG4gICAgaWYgKGhhc01hdGNoRnVuY3Rpb24obWF0Y2hlcikpIHtcclxuICAgICAgICByZXR1cm4gbWF0Y2hlci5tYXRjaChhY3Rpb24pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIoYWN0aW9uKTtcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gaXNBbnlPZigpIHtcclxuICAgIHZhciBtYXRjaGVycyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBtYXRjaGVyc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gbWF0Y2hlcnMuc29tZShmdW5jdGlvbiAobWF0Y2hlcikgeyByZXR1cm4gbWF0Y2hlcyhtYXRjaGVyLCBhY3Rpb24pOyB9KTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaXNBbGxPZigpIHtcclxuICAgIHZhciBtYXRjaGVycyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBtYXRjaGVyc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gbWF0Y2hlcnMuZXZlcnkoZnVuY3Rpb24gKG1hdGNoZXIpIHsgcmV0dXJuIG1hdGNoZXMobWF0Y2hlciwgYWN0aW9uKTsgfSk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgdmFsaWRTdGF0dXMpIHtcclxuICAgIGlmICghYWN0aW9uIHx8ICFhY3Rpb24ubWV0YSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB2YXIgaGFzVmFsaWRSZXF1ZXN0SWQgPSB0eXBlb2YgYWN0aW9uLm1ldGEucmVxdWVzdElkID09PSBcInN0cmluZ1wiO1xyXG4gICAgdmFyIGhhc1ZhbGlkUmVxdWVzdFN0YXR1cyA9IHZhbGlkU3RhdHVzLmluZGV4T2YoYWN0aW9uLm1ldGEucmVxdWVzdFN0YXR1cykgPiAtMTtcclxuICAgIHJldHVybiBoYXNWYWxpZFJlcXVlc3RJZCAmJiBoYXNWYWxpZFJlcXVlc3RTdGF0dXM7XHJcbn1cclxuZnVuY3Rpb24gaXNBc3luY1RodW5rQXJyYXkoYSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBhWzBdID09PSBcImZ1bmN0aW9uXCIgJiYgXCJwZW5kaW5nXCIgaW4gYVswXSAmJiBcImZ1bGZpbGxlZFwiIGluIGFbMF0gJiYgXCJyZWplY3RlZFwiIGluIGFbMF07XHJcbn1cclxuZnVuY3Rpb24gaXNQZW5kaW5nKCkge1xyXG4gICAgdmFyIGFzeW5jVGh1bmtzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFzeW5jVGh1bmtzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicGVuZGluZ1wiXSk7IH07XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xyXG4gICAgICAgIHJldHVybiBpc1BlbmRpbmcoKShhc3luY1RodW5rc1swXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIHZhciBtYXRjaGVycyA9IGFzeW5jVGh1bmtzLm1hcChmdW5jdGlvbiAoYXN5bmNUaHVuaykgeyByZXR1cm4gYXN5bmNUaHVuay5wZW5kaW5nOyB9KTtcclxuICAgICAgICB2YXIgY29tYmluZWRNYXRjaGVyID0gaXNBbnlPZi5hcHBseSh2b2lkIDAsIG1hdGNoZXJzKTtcclxuICAgICAgICByZXR1cm4gY29tYmluZWRNYXRjaGVyKGFjdGlvbik7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVqZWN0ZWQoKSB7XHJcbiAgICB2YXIgYXN5bmNUaHVua3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXN5bmNUaHVua3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCBbXCJyZWplY3RlZFwiXSk7IH07XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xyXG4gICAgICAgIHJldHVybiBpc1JlamVjdGVkKCkoYXN5bmNUaHVua3NbMF0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICB2YXIgbWF0Y2hlcnMgPSBhc3luY1RodW5rcy5tYXAoZnVuY3Rpb24gKGFzeW5jVGh1bmspIHsgcmV0dXJuIGFzeW5jVGh1bmsucmVqZWN0ZWQ7IH0pO1xyXG4gICAgICAgIHZhciBjb21iaW5lZE1hdGNoZXIgPSBpc0FueU9mLmFwcGx5KHZvaWQgMCwgbWF0Y2hlcnMpO1xyXG4gICAgICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaXNSZWplY3RlZFdpdGhWYWx1ZSgpIHtcclxuICAgIHZhciBhc3luY1RodW5rcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhc3luY1RodW5rc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgdmFyIGhhc0ZsYWcgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGFjdGlvbiAmJiBhY3Rpb24ubWV0YSAmJiBhY3Rpb24ubWV0YS5yZWplY3RlZFdpdGhWYWx1ZTtcclxuICAgIH07XHJcbiAgICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIGNvbWJpbmVkTWF0Y2hlciA9IGlzQWxsT2YoaXNSZWplY3RlZC5hcHBseSh2b2lkIDAsIGFzeW5jVGh1bmtzKSwgaGFzRmxhZyk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcclxuICAgICAgICByZXR1cm4gaXNSZWplY3RlZFdpdGhWYWx1ZSgpKGFzeW5jVGh1bmtzWzBdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIGNvbWJpbmVkTWF0Y2hlciA9IGlzQWxsT2YoaXNSZWplY3RlZC5hcHBseSh2b2lkIDAsIGFzeW5jVGh1bmtzKSwgaGFzRmxhZyk7XHJcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpc0Z1bGZpbGxlZCgpIHtcclxuICAgIHZhciBhc3luY1RodW5rcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhc3luY1RodW5rc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7IHJldHVybiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcImZ1bGZpbGxlZFwiXSk7IH07XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xyXG4gICAgICAgIHJldHVybiBpc0Z1bGZpbGxlZCgpKGFzeW5jVGh1bmtzWzBdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoZXJzID0gYXN5bmNUaHVua3MubWFwKGZ1bmN0aW9uIChhc3luY1RodW5rKSB7IHJldHVybiBhc3luY1RodW5rLmZ1bGZpbGxlZDsgfSk7XHJcbiAgICAgICAgdmFyIGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YuYXBwbHkodm9pZCAwLCBtYXRjaGVycyk7XHJcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpc0FzeW5jVGh1bmtBY3Rpb24oKSB7XHJcbiAgICB2YXIgYXN5bmNUaHVua3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXN5bmNUaHVua3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCBbXCJwZW5kaW5nXCIsIFwiZnVsZmlsbGVkXCIsIFwicmVqZWN0ZWRcIl0pOyB9O1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcclxuICAgICAgICByZXR1cm4gaXNBc3luY1RodW5rQWN0aW9uKCkoYXN5bmNUaHVua3NbMF0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICB2YXIgbWF0Y2hlcnMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGFzeW5jVGh1bmtzXzEgPSBhc3luY1RodW5rczsgX2kgPCBhc3luY1RodW5rc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgYXN5bmNUaHVuayA9IGFzeW5jVGh1bmtzXzFbX2ldO1xyXG4gICAgICAgICAgICBtYXRjaGVycy5wdXNoKGFzeW5jVGh1bmsucGVuZGluZywgYXN5bmNUaHVuay5yZWplY3RlZCwgYXN5bmNUaHVuay5mdWxmaWxsZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29tYmluZWRNYXRjaGVyID0gaXNBbnlPZi5hcHBseSh2b2lkIDAsIG1hdGNoZXJzKTtcclxuICAgICAgICByZXR1cm4gY29tYmluZWRNYXRjaGVyKGFjdGlvbik7XHJcbiAgICB9O1xyXG59XHJcbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvdXRpbHMudHNcclxudmFyIGFzc2VydEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmMsIGV4cGVjdGVkKSB7XHJcbiAgICBpZiAodHlwZW9mIGZ1bmMgIT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoZXhwZWN0ZWQgKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcclxuICAgIH1cclxufTtcclxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7XHJcbn07XHJcbnZhciBjYXRjaFJlamVjdGlvbiA9IGZ1bmN0aW9uIChwcm9taXNlLCBvbkVycm9yKSB7XHJcbiAgICBpZiAob25FcnJvciA9PT0gdm9pZCAwKSB7IG9uRXJyb3IgPSBub29wOyB9XHJcbiAgICBwcm9taXNlLmNhdGNoKG9uRXJyb3IpO1xyXG4gICAgcmV0dXJuIHByb21pc2U7XHJcbn07XHJcbnZhciBhZGRBYm9ydFNpZ25hbExpc3RlbmVyID0gZnVuY3Rpb24gKGFib3J0U2lnbmFsLCBjYWxsYmFjaykge1xyXG4gICAgYWJvcnRTaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGNhbGxiYWNrLCB7IG9uY2U6IHRydWUgfSk7XHJcbn07XHJcbnZhciBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uID0gZnVuY3Rpb24gKGFib3J0Q29udHJvbGxlciwgcmVhc29uKSB7XHJcbiAgICB2YXIgc2lnbmFsID0gYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcclxuICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICghKFwicmVhc29uXCIgaW4gc2lnbmFsKSkge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaWduYWwsIFwicmVhc29uXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHJlYXNvbixcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgYWJvcnRDb250cm9sbGVyLmFib3J0KHJlYXNvbik7XHJcbn07XHJcbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvZXhjZXB0aW9ucy50c1xyXG52YXIgdGFzayA9IFwidGFza1wiO1xyXG52YXIgbGlzdGVuZXIgPSBcImxpc3RlbmVyXCI7XHJcbnZhciBjb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xyXG52YXIgY2FuY2VsbGVkID0gXCJjYW5jZWxsZWRcIjtcclxudmFyIHRhc2tDYW5jZWxsZWQgPSBcInRhc2stXCIgKyBjYW5jZWxsZWQ7XHJcbnZhciB0YXNrQ29tcGxldGVkID0gXCJ0YXNrLVwiICsgY29tcGxldGVkO1xyXG52YXIgbGlzdGVuZXJDYW5jZWxsZWQgPSBsaXN0ZW5lciArIFwiLVwiICsgY2FuY2VsbGVkO1xyXG52YXIgbGlzdGVuZXJDb21wbGV0ZWQgPSBsaXN0ZW5lciArIFwiLVwiICsgY29tcGxldGVkO1xyXG52YXIgVGFza0Fib3J0RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUYXNrQWJvcnRFcnJvcihjb2RlKSB7XHJcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIlRhc2tBYm9ydEVycm9yXCI7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdGFzayArIFwiIFwiICsgY2FuY2VsbGVkICsgXCIgKHJlYXNvbjogXCIgKyBjb2RlICsgXCIpXCI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gVGFza0Fib3J0RXJyb3I7XHJcbn0oKSk7XHJcbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvdGFzay50c1xyXG52YXIgdmFsaWRhdGVBY3RpdmUgPSBmdW5jdGlvbiAoc2lnbmFsKSB7XHJcbiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVGFza0Fib3J0RXJyb3Ioc2lnbmFsLnJlYXNvbik7XHJcbiAgICB9XHJcbn07XHJcbnZhciBwcm9taXNpZnlBYm9ydFNpZ25hbCA9IGZ1bmN0aW9uIChzaWduYWwpIHtcclxuICAgIHJldHVybiBjYXRjaFJlamVjdGlvbihuZXcgUHJvbWlzZShmdW5jdGlvbiAoXywgcmVqZWN0KSB7XHJcbiAgICAgICAgdmFyIG5vdGlmeVJlamVjdGlvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlamVjdChuZXcgVGFza0Fib3J0RXJyb3Ioc2lnbmFsLnJlYXNvbikpOyB9O1xyXG4gICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xyXG4gICAgICAgICAgICBub3RpZnlSZWplY3Rpb24oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFkZEFib3J0U2lnbmFsTGlzdGVuZXIoc2lnbmFsLCBub3RpZnlSZWplY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH0pKTtcclxufTtcclxudmFyIHJ1blRhc2sgPSBmdW5jdGlvbiAodGFzazIsIGNsZWFuVXApIHsgcmV0dXJuIF9fYXN5bmModm9pZCAwLCBudWxsLCBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdmFsdWUsIGVycm9yXzE7XHJcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzAsIDMsIDQsIDVdKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UucmVzb2x2ZSgpXTtcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGFzazIoKV07XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBcIm9rXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICBlcnJvcl8xID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBlcnJvcl8xIGluc3RhbmNlb2YgVGFza0Fib3J0RXJyb3IgPyBcImNhbmNlbGxlZFwiIDogXCJyZWplY3RlZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JfMVxyXG4gICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICBjbGVhblVwID09IG51bGwgPyB2b2lkIDAgOiBjbGVhblVwKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xyXG4gICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufSk7IH07XHJcbnZhciBjcmVhdGVQYXVzZSA9IGZ1bmN0aW9uIChzaWduYWwpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAocHJvbWlzZSkge1xyXG4gICAgICAgIHJldHVybiBjYXRjaFJlamVjdGlvbihQcm9taXNlLnJhY2UoW3Byb21pc2lmeUFib3J0U2lnbmFsKHNpZ25hbCksIHByb21pc2VdKS50aGVuKGZ1bmN0aW9uIChvdXRwdXQpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVBY3RpdmUoc2lnbmFsKTtcclxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgICAgICB9KSk7XHJcbiAgICB9O1xyXG59O1xyXG52YXIgY3JlYXRlRGVsYXkgPSBmdW5jdGlvbiAoc2lnbmFsKSB7XHJcbiAgICB2YXIgcGF1c2UgPSBjcmVhdGVQYXVzZShzaWduYWwpO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0aW1lb3V0TXMpIHtcclxuICAgICAgICByZXR1cm4gcGF1c2UobmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmV0dXJuIHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dE1zKTsgfSkpO1xyXG4gICAgfTtcclxufTtcclxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS9pbmRleC50c1xyXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcclxudmFyIElOVEVSTkFMX05JTF9UT0tFTiA9IHt9O1xyXG52YXIgYWxtID0gXCJsaXN0ZW5lck1pZGRsZXdhcmVcIjtcclxudmFyIGNyZWF0ZUZvcmsgPSBmdW5jdGlvbiAocGFyZW50QWJvcnRTaWduYWwpIHtcclxuICAgIHZhciBsaW5rQ29udHJvbGxlcnMgPSBmdW5jdGlvbiAoY29udHJvbGxlcikgeyByZXR1cm4gYWRkQWJvcnRTaWduYWxMaXN0ZW5lcihwYXJlbnRBYm9ydFNpZ25hbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBwYXJlbnRBYm9ydFNpZ25hbC5yZWFzb24pOyB9KTsgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFza0V4ZWN1dG9yKSB7XHJcbiAgICAgICAgYXNzZXJ0RnVuY3Rpb24odGFza0V4ZWN1dG9yLCBcInRhc2tFeGVjdXRvclwiKTtcclxuICAgICAgICB2YXIgY2hpbGRBYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XHJcbiAgICAgICAgbGlua0NvbnRyb2xsZXJzKGNoaWxkQWJvcnRDb250cm9sbGVyKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gcnVuVGFzayhmdW5jdGlvbiAoKSB7IHJldHVybiBfX2FzeW5jKHZvaWQgMCwgbnVsbCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0MjtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVBY3RpdmUocGFyZW50QWJvcnRTaWduYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUFjdGl2ZShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0YXNrRXhlY3V0b3Ioe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdXNlOiBjcmVhdGVQYXVzZShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5OiBjcmVhdGVEZWxheShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQyID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUFjdGl2ZShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0Ml07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNoaWxkQWJvcnRDb250cm9sbGVyLCB0YXNrQ29tcGxldGVkKTsgfSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcmVzdWx0OiBjcmVhdGVQYXVzZShwYXJlbnRBYm9ydFNpZ25hbCkocmVzdWx0KSxcclxuICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNoaWxkQWJvcnRDb250cm9sbGVyLCB0YXNrQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG59O1xyXG52YXIgY3JlYXRlVGFrZVBhdHRlcm4gPSBmdW5jdGlvbiAoc3RhcnRMaXN0ZW5pbmcsIHNpZ25hbCkge1xyXG4gICAgdmFyIHRha2UgPSBmdW5jdGlvbiAocHJlZGljYXRlLCB0aW1lb3V0KSB7IHJldHVybiBfX2FzeW5jKHZvaWQgMCwgbnVsbCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB1bnN1YnNjcmliZSwgdHVwbGVQcm9taXNlLCBwcm9taXNlcywgb3V0cHV0O1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlQWN0aXZlKHNpZ25hbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB0dXBsZVByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSA9IHN0YXJ0TGlzdGVuaW5nKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWRpY2F0ZTogcHJlZGljYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0OiBmdW5jdGlvbiAoYWN0aW9uLCBsaXN0ZW5lckFwaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyQXBpLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJBcGkuZ2V0U3RhdGUoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJBcGkuZ2V0T3JpZ2luYWxTdGF0ZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNpZnlBYm9ydFNpZ25hbChzaWduYWwpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0dXBsZVByb21pc2VcclxuICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXR1cm4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0LCBudWxsKTsgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgX2MudHJ5cy5wdXNoKFsxLCAsIDMsIDRdKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLnJhY2UocHJvbWlzZXMpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBfYy5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVBY3RpdmUoc2lnbmFsKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgb3V0cHV0XTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7IH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGltZW91dCkgeyByZXR1cm4gY2F0Y2hSZWplY3Rpb24odGFrZShwcmVkaWNhdGUsIHRpbWVvdXQpKTsgfTtcclxufTtcclxudmFyIGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGUsIGFjdGlvbkNyZWF0b3IgPSBvcHRpb25zLmFjdGlvbkNyZWF0b3IsIG1hdGNoZXIgPSBvcHRpb25zLm1hdGNoZXIsIHByZWRpY2F0ZSA9IG9wdGlvbnMucHJlZGljYXRlLCBlZmZlY3QgPSBvcHRpb25zLmVmZmVjdDtcclxuICAgIGlmICh0eXBlKSB7XHJcbiAgICAgICAgcHJlZGljYXRlID0gY3JlYXRlQWN0aW9uKHR5cGUpLm1hdGNoO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYWN0aW9uQ3JlYXRvcikge1xyXG4gICAgICAgIHR5cGUgPSBhY3Rpb25DcmVhdG9yLnR5cGU7XHJcbiAgICAgICAgcHJlZGljYXRlID0gYWN0aW9uQ3JlYXRvci5tYXRjaDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG1hdGNoZXIpIHtcclxuICAgICAgICBwcmVkaWNhdGUgPSBtYXRjaGVyO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJlZGljYXRlKSB7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDcmVhdGluZyBvciByZW1vdmluZyBhIGxpc3RlbmVyIHJlcXVpcmVzIG9uZSBvZiB0aGUga25vd24gZmllbGRzIGZvciBtYXRjaGluZyBhbiBhY3Rpb25cIik7XHJcbiAgICB9XHJcbiAgICBhc3NlcnRGdW5jdGlvbihlZmZlY3QsIFwib3B0aW9ucy5saXN0ZW5lclwiKTtcclxuICAgIHJldHVybiB7IHByZWRpY2F0ZTogcHJlZGljYXRlLCB0eXBlOiB0eXBlLCBlZmZlY3Q6IGVmZmVjdCB9O1xyXG59O1xyXG52YXIgY3JlYXRlTGlzdGVuZXJFbnRyeSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICB2YXIgX2MgPSBnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tKG9wdGlvbnMpLCB0eXBlID0gX2MudHlwZSwgcHJlZGljYXRlID0gX2MucHJlZGljYXRlLCBlZmZlY3QgPSBfYy5lZmZlY3Q7XHJcbiAgICB2YXIgaWQgPSBuYW5vaWQoKTtcclxuICAgIHZhciBlbnRyeSA9IHtcclxuICAgICAgICBpZDogaWQsXHJcbiAgICAgICAgZWZmZWN0OiBlZmZlY3QsXHJcbiAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICBwcmVkaWNhdGU6IHByZWRpY2F0ZSxcclxuICAgICAgICBwZW5kaW5nOiBuZXcgU2V0KCksXHJcbiAgICAgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdWJzY3JpYmUgbm90IGluaXRpYWxpemVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gZW50cnk7XHJcbn07XHJcbnZhciBjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZSA9IGZ1bmN0aW9uIChsaXN0ZW5lck1hcCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBsaXN0ZW5lck1hcC5mb3JFYWNoKGNhbmNlbEFjdGl2ZUxpc3RlbmVycyk7XHJcbiAgICAgICAgbGlzdGVuZXJNYXAuY2xlYXIoKTtcclxuICAgIH07XHJcbn07XHJcbnZhciBzYWZlbHlOb3RpZnlFcnJvciA9IGZ1bmN0aW9uIChlcnJvckhhbmRsZXIsIGVycm9yVG9Ob3RpZnksIGVycm9ySW5mbykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBlcnJvckhhbmRsZXIoZXJyb3JUb05vdGlmeSwgZXJyb3JJbmZvKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvckhhbmRsZXJFcnJvcikge1xyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aHJvdyBlcnJvckhhbmRsZXJFcnJvcjtcclxuICAgICAgICB9LCAwKTtcclxuICAgIH1cclxufTtcclxudmFyIGFkZExpc3RlbmVyID0gY3JlYXRlQWN0aW9uKGFsbSArIFwiL2FkZFwiKTtcclxudmFyIGNsZWFyQWxsTGlzdGVuZXJzID0gY3JlYXRlQWN0aW9uKGFsbSArIFwiL3JlbW92ZUFsbFwiKTtcclxudmFyIHJlbW92ZUxpc3RlbmVyID0gY3JlYXRlQWN0aW9uKGFsbSArIFwiL3JlbW92ZVwiKTtcclxudmFyIGRlZmF1bHRFcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIF9fc3ByZWFkQXJyYXkoW2FsbSArIFwiL2Vycm9yXCJdLCBhcmdzKSk7XHJcbn07XHJcbnZhciBjYW5jZWxBY3RpdmVMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgIGVudHJ5LnBlbmRpbmcuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbGxlcikge1xyXG4gICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY29udHJvbGxlciwgbGlzdGVuZXJDYW5jZWxsZWQpO1xyXG4gICAgfSk7XHJcbn07XHJcbmZ1bmN0aW9uIGNyZWF0ZUxpc3RlbmVyTWlkZGxld2FyZShtaWRkbGV3YXJlT3B0aW9ucykge1xyXG4gICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgIGlmIChtaWRkbGV3YXJlT3B0aW9ucyA9PT0gdm9pZCAwKSB7IG1pZGRsZXdhcmVPcHRpb25zID0ge307IH1cclxuICAgIHZhciBsaXN0ZW5lck1hcCA9IG5ldyBNYXAoKTtcclxuICAgIHZhciBleHRyYSA9IG1pZGRsZXdhcmVPcHRpb25zLmV4dHJhLCBfYyA9IG1pZGRsZXdhcmVPcHRpb25zLm9uRXJyb3IsIG9uRXJyb3IgPSBfYyA9PT0gdm9pZCAwID8gZGVmYXVsdEVycm9ySGFuZGxlciA6IF9jO1xyXG4gICAgYXNzZXJ0RnVuY3Rpb24ob25FcnJvciwgXCJvbkVycm9yXCIpO1xyXG4gICAgdmFyIGluc2VydEVudHJ5ID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgZW50cnkudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBsaXN0ZW5lck1hcC5kZWxldGUoZW50cnkuaWQpOyB9O1xyXG4gICAgICAgIGxpc3RlbmVyTWFwLnNldChlbnRyeS5pZCwgZW50cnkpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2FuY2VsT3B0aW9ucykge1xyXG4gICAgICAgICAgICBlbnRyeS51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICBpZiAoY2FuY2VsT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogY2FuY2VsT3B0aW9ucy5jYW5jZWxBY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIGNhbmNlbEFjdGl2ZUxpc3RlbmVycyhlbnRyeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIHZhciBmaW5kTGlzdGVuZXJFbnRyeSA9IGZ1bmN0aW9uIChjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYyA9IEFycmF5LmZyb20obGlzdGVuZXJNYXAudmFsdWVzKCkpOyBfaSA8IF9jLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZW50cnkgPSBfY1tfaV07XHJcbiAgICAgICAgICAgIGlmIChjb21wYXJhdG9yKGVudHJ5KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2b2lkIDA7XHJcbiAgICB9O1xyXG4gICAgdmFyIHN0YXJ0TGlzdGVuaW5nID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZW50cnkgPSBmaW5kTGlzdGVuZXJFbnRyeShmdW5jdGlvbiAoZXhpc3RpbmdFbnRyeSkgeyByZXR1cm4gZXhpc3RpbmdFbnRyeS5lZmZlY3QgPT09IG9wdGlvbnMuZWZmZWN0OyB9KTtcclxuICAgICAgICBpZiAoIWVudHJ5KSB7XHJcbiAgICAgICAgICAgIGVudHJ5ID0gY3JlYXRlTGlzdGVuZXJFbnRyeShvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluc2VydEVudHJ5KGVudHJ5KTtcclxuICAgIH07XHJcbiAgICB2YXIgc3RvcExpc3RlbmluZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9jID0gZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbShvcHRpb25zKSwgdHlwZSA9IF9jLnR5cGUsIGVmZmVjdCA9IF9jLmVmZmVjdCwgcHJlZGljYXRlID0gX2MucHJlZGljYXRlO1xyXG4gICAgICAgIHZhciBlbnRyeSA9IGZpbmRMaXN0ZW5lckVudHJ5KGZ1bmN0aW9uIChlbnRyeTIpIHtcclxuICAgICAgICAgICAgdmFyIG1hdGNoUHJlZGljYXRlT3JUeXBlID0gdHlwZW9mIHR5cGUgPT09IFwic3RyaW5nXCIgPyBlbnRyeTIudHlwZSA9PT0gdHlwZSA6IGVudHJ5Mi5wcmVkaWNhdGUgPT09IHByZWRpY2F0ZTtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoUHJlZGljYXRlT3JUeXBlICYmIGVudHJ5Mi5lZmZlY3QgPT09IGVmZmVjdDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoZW50cnkpIHtcclxuICAgICAgICAgICAgZW50cnkudW5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2FuY2VsQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBjYW5jZWxBY3RpdmVMaXN0ZW5lcnMoZW50cnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAhIWVudHJ5O1xyXG4gICAgfTtcclxuICAgIHZhciBub3RpZnlMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbnRyeSwgYWN0aW9uLCBhcGksIGdldE9yaWdpbmFsU3RhdGUpIHsgcmV0dXJuIF9fYXN5bmMoX3RoaXMsIG51bGwsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaW50ZXJuYWxUYXNrQ29udHJvbGxlciwgdGFrZSwgbGlzdGVuZXJFcnJvcl8xO1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIGludGVybmFsVGFza0NvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFrZSA9IGNyZWF0ZVRha2VQYXR0ZXJuKHN0YXJ0TGlzdGVuaW5nLCBpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbMSwgMywgNCwgNV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LnBlbmRpbmcuYWRkKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UucmVzb2x2ZShlbnRyeS5lZmZlY3QoYWN0aW9uLCBhc3NpZ24oe30sIGFwaSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0T3JpZ2luYWxTdGF0ZTogZ2V0T3JpZ2luYWxTdGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbjogZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGltZW91dCkgeyByZXR1cm4gdGFrZShwcmVkaWNhdGUsIHRpbWVvdXQpLnRoZW4oQm9vbGVhbik7IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWtlOiB0YWtlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXk6IGNyZWF0ZURlbGF5KGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdXNlOiBjcmVhdGVQYXVzZShpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYTogZXh0cmEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yazogY3JlYXRlRm9yayhpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZTogZW50cnkudW5zdWJzY3JpYmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lck1hcC5zZXQoZW50cnkuaWQsIGVudHJ5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxBY3RpdmVMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5wZW5kaW5nLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2xsZXIsIF8sIHNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlciAhPT0gaW50ZXJuYWxUYXNrQ29udHJvbGxlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBsaXN0ZW5lckNhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQuZGVsZXRlKGNvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIF9jLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lckVycm9yXzEgPSBfYy5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobGlzdGVuZXJFcnJvcl8xIGluc3RhbmNlb2YgVGFza0Fib3J0RXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhZmVseU5vdGlmeUVycm9yKG9uRXJyb3IsIGxpc3RlbmVyRXJyb3JfMSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFpc2VkQnk6IFwiZWZmZWN0XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oaW50ZXJuYWxUYXNrQ29udHJvbGxlciwgbGlzdGVuZXJDb21wbGV0ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LnBlbmRpbmcuZGVsZXRlKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7IH07XHJcbiAgICB2YXIgY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUgPSBjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZShsaXN0ZW5lck1hcCk7XHJcbiAgICB2YXIgbWlkZGxld2FyZSA9IGZ1bmN0aW9uIChhcGkpIHsgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKGFkZExpc3RlbmVyLm1hdGNoKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0TGlzdGVuaW5nKGFjdGlvbi5wYXlsb2FkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNsZWFyQWxsTGlzdGVuZXJzLm1hdGNoKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVtb3ZlTGlzdGVuZXIubWF0Y2goYWN0aW9uKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RvcExpc3RlbmluZyhhY3Rpb24ucGF5bG9hZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvcmlnaW5hbFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XHJcbiAgICAgICAgdmFyIGdldE9yaWdpbmFsU3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbFN0YXRlID09PSBJTlRFUk5BTF9OSUxfVE9LRU4pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihhbG0gKyBcIjogZ2V0T3JpZ2luYWxTdGF0ZSBjYW4gb25seSBiZSBjYWxsZWQgc3luY2hyb25vdXNseVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxTdGF0ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gbmV4dChhY3Rpb24pO1xyXG4gICAgICAgICAgICBpZiAobGlzdGVuZXJNYXAuc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSBhcGkuZ2V0U3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lckVudHJpZXMgPSBBcnJheS5mcm9tKGxpc3RlbmVyTWFwLnZhbHVlcygpKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgbGlzdGVuZXJFbnRyaWVzXzEgPSBsaXN0ZW5lckVudHJpZXM7IF9pIDwgbGlzdGVuZXJFbnRyaWVzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gbGlzdGVuZXJFbnRyaWVzXzFbX2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBydW5MaXN0ZW5lciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bkxpc3RlbmVyID0gZW50cnkucHJlZGljYXRlKGFjdGlvbiwgY3VycmVudFN0YXRlLCBvcmlnaW5hbFN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKHByZWRpY2F0ZUVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bkxpc3RlbmVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhZmVseU5vdGlmeUVycm9yKG9uRXJyb3IsIHByZWRpY2F0ZUVycm9yLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWlzZWRCeTogXCJwcmVkaWNhdGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFydW5MaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbm90aWZ5TGlzdGVuZXIoZW50cnksIGFjdGlvbiwgYXBpLCBnZXRPcmlnaW5hbFN0YXRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgb3JpZ2luYWxTdGF0ZSA9IElOVEVSTkFMX05JTF9UT0tFTjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07IH07IH07XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG1pZGRsZXdhcmU6IG1pZGRsZXdhcmUsXHJcbiAgICAgICAgc3RhcnRMaXN0ZW5pbmc6IHN0YXJ0TGlzdGVuaW5nLFxyXG4gICAgICAgIHN0b3BMaXN0ZW5pbmc6IHN0b3BMaXN0ZW5pbmcsXHJcbiAgICAgICAgY2xlYXJMaXN0ZW5lcnM6IGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlXHJcbiAgICB9O1xyXG59XHJcbi8vIHNyYy9pbmRleC50c1xyXG5lbmFibGVFUzUoKTtcclxuZXhwb3J0IHsgTWlkZGxld2FyZUFycmF5LCBUYXNrQWJvcnRFcnJvciwgYWRkTGlzdGVuZXIsIGNsZWFyQWxsTGlzdGVuZXJzLCBjb25maWd1cmVTdG9yZSwgY3JlYXRlQWN0aW9uLCBjcmVhdGVBc3luY1RodW5rLCBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvciwgY3JlYXRlRW50aXR5QWRhcHRlciwgY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLCBjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUsIGRlZmF1bHQyIGFzIGNyZWF0ZU5leHRTdGF0ZSwgY3JlYXRlUmVkdWNlciwgY3JlYXRlU2VsZWN0b3IyIGFzIGNyZWF0ZVNlbGVjdG9yLCBjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUsIGNyZWF0ZVNsaWNlLCBjdXJyZW50MiBhcyBjdXJyZW50LCBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUsIGZyZWV6ZSwgZ2V0RGVmYXVsdE1pZGRsZXdhcmUsIGdldFR5cGUsIGlzQWxsT2YsIGlzQW55T2YsIGlzQXN5bmNUaHVua0FjdGlvbiwgaXNEcmFmdDQgYXMgaXNEcmFmdCwgaXNGdWxmaWxsZWQsIGlzSW1tdXRhYmxlRGVmYXVsdCwgaXNQZW5kaW5nLCBpc1BsYWluLCBpc1BsYWluT2JqZWN0LCBpc1JlamVjdGVkLCBpc1JlamVjdGVkV2l0aFZhbHVlLCBtaW5pU2VyaWFsaXplRXJyb3IsIG5hbm9pZCwgb3JpZ2luYWwsIHJlbW92ZUxpc3RlbmVyLCB1bndyYXBSZXN1bHQgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkdXgtdG9vbGtpdC5lc20uanMubWFwIiwidmFyIGNyZWF0ZVN5bWJvbCA9IGZ1bmN0aW9uIGNyZWF0ZVN5bWJvbChuYW1lKSB7XG4gIHJldHVybiBcIkBAcmVkdXgtc2FnYS9cIiArIG5hbWU7XG59O1xuXG52YXIgQ0FOQ0VMID1cbi8qI19fUFVSRV9fKi9cbmNyZWF0ZVN5bWJvbCgnQ0FOQ0VMX1BST01JU0UnKTtcbnZhciBDSEFOTkVMX0VORF9UWVBFID1cbi8qI19fUFVSRV9fKi9cbmNyZWF0ZVN5bWJvbCgnQ0hBTk5FTF9FTkQnKTtcbnZhciBJTyA9XG4vKiNfX1BVUkVfXyovXG5jcmVhdGVTeW1ib2woJ0lPJyk7XG52YXIgTUFUQ0ggPVxuLyojX19QVVJFX18qL1xuY3JlYXRlU3ltYm9sKCdNQVRDSCcpO1xudmFyIE1VTFRJQ0FTVCA9XG4vKiNfX1BVUkVfXyovXG5jcmVhdGVTeW1ib2woJ01VTFRJQ0FTVCcpO1xudmFyIFNBR0FfQUNUSU9OID1cbi8qI19fUFVSRV9fKi9cbmNyZWF0ZVN5bWJvbCgnU0FHQV9BQ1RJT04nKTtcbnZhciBTRUxGX0NBTkNFTExBVElPTiA9XG4vKiNfX1BVUkVfXyovXG5jcmVhdGVTeW1ib2woJ1NFTEZfQ0FOQ0VMTEFUSU9OJyk7XG52YXIgVEFTSyA9XG4vKiNfX1BVUkVfXyovXG5jcmVhdGVTeW1ib2woJ1RBU0snKTtcbnZhciBUQVNLX0NBTkNFTCA9XG4vKiNfX1BVUkVfXyovXG5jcmVhdGVTeW1ib2woJ1RBU0tfQ0FOQ0VMJyk7XG52YXIgVEVSTUlOQVRFID1cbi8qI19fUFVSRV9fKi9cbmNyZWF0ZVN5bWJvbCgnVEVSTUlOQVRFJyk7XG52YXIgU0FHQV9MT0NBVElPTiA9XG4vKiNfX1BVUkVfXyovXG5jcmVhdGVTeW1ib2woJ0xPQ0FUSU9OJyk7XG5cbmV4cG9ydCB7IENBTkNFTCwgQ0hBTk5FTF9FTkRfVFlQRSwgSU8sIE1BVENILCBNVUxUSUNBU1QsIFNBR0FfQUNUSU9OLCBTQUdBX0xPQ0FUSU9OLCBTRUxGX0NBTkNFTExBVElPTiwgVEFTSywgVEFTS19DQU5DRUwsIFRFUk1JTkFURSB9O1xuIiwiaW1wb3J0IHsgVEFTSywgU0FHQV9BQ1RJT04sIE1VTFRJQ0FTVCwgSU8gfSBmcm9tICdAcmVkdXgtc2FnYS9zeW1ib2xzJztcblxudmFyIHVuZGVmID0gZnVuY3Rpb24gdW5kZWYodikge1xuICByZXR1cm4gdiA9PT0gbnVsbCB8fCB2ID09PSB1bmRlZmluZWQ7XG59O1xudmFyIG5vdFVuZGVmID0gZnVuY3Rpb24gbm90VW5kZWYodikge1xuICByZXR1cm4gdiAhPT0gbnVsbCAmJiB2ICE9PSB1bmRlZmluZWQ7XG59O1xudmFyIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKGYpIHtcbiAgcmV0dXJuIHR5cGVvZiBmID09PSAnZnVuY3Rpb24nO1xufTtcbnZhciBudW1iZXIgPSBmdW5jdGlvbiBudW1iZXIobikge1xuICByZXR1cm4gdHlwZW9mIG4gPT09ICdudW1iZXInO1xufTtcbnZhciBzdHJpbmcgPSBmdW5jdGlvbiBzdHJpbmcocykge1xuICByZXR1cm4gdHlwZW9mIHMgPT09ICdzdHJpbmcnO1xufTtcbnZhciBhcnJheSA9IEFycmF5LmlzQXJyYXk7XG52YXIgb2JqZWN0ID0gZnVuY3Rpb24gb2JqZWN0KG9iaikge1xuICByZXR1cm4gb2JqICYmICFhcnJheShvYmopICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnO1xufTtcbnZhciBwcm9taXNlID0gZnVuY3Rpb24gcHJvbWlzZShwKSB7XG4gIHJldHVybiBwICYmIGZ1bmMocC50aGVuKTtcbn07XG52YXIgaXRlcmF0b3IgPSBmdW5jdGlvbiBpdGVyYXRvcihpdCkge1xuICByZXR1cm4gaXQgJiYgZnVuYyhpdC5uZXh0KSAmJiBmdW5jKGl0LnRocm93KTtcbn07XG52YXIgaXRlcmFibGUgPSBmdW5jdGlvbiBpdGVyYWJsZShpdCkge1xuICByZXR1cm4gaXQgJiYgZnVuYyhTeW1ib2wpID8gZnVuYyhpdFtTeW1ib2wuaXRlcmF0b3JdKSA6IGFycmF5KGl0KTtcbn07XG52YXIgdGFzayA9IGZ1bmN0aW9uIHRhc2sodCkge1xuICByZXR1cm4gdCAmJiB0W1RBU0tdO1xufTtcbnZhciBzYWdhQWN0aW9uID0gZnVuY3Rpb24gc2FnYUFjdGlvbihhKSB7XG4gIHJldHVybiBCb29sZWFuKGEgJiYgYVtTQUdBX0FDVElPTl0pO1xufTtcbnZhciBvYnNlcnZhYmxlID0gZnVuY3Rpb24gb2JzZXJ2YWJsZShvYikge1xuICByZXR1cm4gb2IgJiYgZnVuYyhvYi5zdWJzY3JpYmUpO1xufTtcbnZhciBidWZmZXIgPSBmdW5jdGlvbiBidWZmZXIoYnVmKSB7XG4gIHJldHVybiBidWYgJiYgZnVuYyhidWYuaXNFbXB0eSkgJiYgZnVuYyhidWYudGFrZSkgJiYgZnVuYyhidWYucHV0KTtcbn07XG52YXIgcGF0dGVybiA9IGZ1bmN0aW9uIHBhdHRlcm4ocGF0KSB7XG4gIHJldHVybiBwYXQgJiYgKHN0cmluZyhwYXQpIHx8IHN5bWJvbChwYXQpIHx8IGZ1bmMocGF0KSB8fCBhcnJheShwYXQpICYmIHBhdC5ldmVyeShwYXR0ZXJuKSk7XG59O1xudmFyIGNoYW5uZWwgPSBmdW5jdGlvbiBjaGFubmVsKGNoKSB7XG4gIHJldHVybiBjaCAmJiBmdW5jKGNoLnRha2UpICYmIGZ1bmMoY2guY2xvc2UpO1xufTtcbnZhciBzdHJpbmdhYmxlRnVuYyA9IGZ1bmN0aW9uIHN0cmluZ2FibGVGdW5jKGYpIHtcbiAgcmV0dXJuIGZ1bmMoZikgJiYgZi5oYXNPd25Qcm9wZXJ0eSgndG9TdHJpbmcnKTtcbn07XG52YXIgc3ltYm9sID0gZnVuY3Rpb24gc3ltYm9sKHN5bSkge1xuICByZXR1cm4gQm9vbGVhbihzeW0pICYmIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgc3ltLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgc3ltICE9PSBTeW1ib2wucHJvdG90eXBlO1xufTtcbnZhciBtdWx0aWNhc3QgPSBmdW5jdGlvbiBtdWx0aWNhc3QoY2gpIHtcbiAgcmV0dXJuIGNoYW5uZWwoY2gpICYmIGNoW01VTFRJQ0FTVF07XG59O1xudmFyIGVmZmVjdCA9IGZ1bmN0aW9uIGVmZmVjdChlZmYpIHtcbiAgcmV0dXJuIGVmZiAmJiBlZmZbSU9dO1xufTtcblxuZXhwb3J0IHsgYXJyYXksIGJ1ZmZlciwgY2hhbm5lbCwgZWZmZWN0LCBmdW5jLCBpdGVyYWJsZSwgaXRlcmF0b3IsIG11bHRpY2FzdCwgbm90VW5kZWYsIG51bWJlciwgb2JqZWN0LCBvYnNlcnZhYmxlLCBwYXR0ZXJuLCBwcm9taXNlLCBzYWdhQWN0aW9uLCBzdHJpbmcsIHN0cmluZ2FibGVGdW5jLCBzeW1ib2wsIHRhc2ssIHVuZGVmIH07XG4iLCJpbXBvcnQgeyBDQU5DRUwgfSBmcm9tICdAcmVkdXgtc2FnYS9zeW1ib2xzJztcblxuZnVuY3Rpb24gZGVsYXlQKG1zLCB2YWwpIHtcbiAgaWYgKHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgdmFsID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciB0aW1lb3V0SWQ7XG4gIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KHJlc29sdmUsIG1zLCB2YWwpO1xuICB9KTtcblxuICBwcm9taXNlW0NBTkNFTF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gIH07XG5cbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlbGF5UDtcbiIsImltcG9ydCB7IFRBU0tfQ0FOQ0VMLCBURVJNSU5BVEUsIFNBR0FfTE9DQVRJT04sIFNBR0FfQUNUSU9OLCBJTywgU0VMRl9DQU5DRUxMQVRJT04gfSBmcm9tICdAcmVkdXgtc2FnYS9zeW1ib2xzJztcbmltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCB7IGFycmF5LCBub3RVbmRlZiwgcGF0dGVybiwgbXVsdGljYXN0LCBjaGFubmVsLCB1bmRlZiwgZWZmZWN0LCB0YXNrLCBmdW5jLCBidWZmZXIsIHN0cmluZywgb2JqZWN0IH0gZnJvbSAnQHJlZHV4LXNhZ2EvaXMnO1xuaW1wb3J0IGRlbGF5UCBmcm9tICdAcmVkdXgtc2FnYS9kZWxheS1wJztcblxudmFyIGtvbnN0ID0gZnVuY3Rpb24ga29uc3Qodikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB2O1xuICB9O1xufTtcbnZhciBrVHJ1ZSA9XG4vKiNfX1BVUkVfXyovXG5rb25zdCh0cnVlKTtcblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgbm9vcCA9XG4gIC8qI19fUFVSRV9fKi9cbiAgbmV3IFByb3h5KG5vb3AsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCgpIHtcbiAgICAgIHRocm93IGludGVybmFsRXJyKCdUaGVyZSB3YXMgYW4gYXR0ZW1wdCB0byBhc3NpZ24gYSBwcm9wZXJ0eSB0byBpbnRlcm5hbCBgbm9vcGAgZnVuY3Rpb24uJyk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIGlkZW50aXR5KHYpIHtcbiAgcmV0dXJuIHY7XG59O1xudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbic7XG52YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9IGhhc1N5bWJvbCAmJiBTeW1ib2wuYXN5bmNJdGVyYXRvciA/IFN5bWJvbC5hc3luY0l0ZXJhdG9yIDogJ0BAYXN5bmNJdGVyYXRvcic7XG5mdW5jdGlvbiBjaGVjayh2YWx1ZSwgcHJlZGljYXRlLCBlcnJvcikge1xuICBpZiAoIXByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICB9XG59XG52YXIgYXNzaWduV2l0aFN5bWJvbHMgPSBmdW5jdGlvbiBhc3NpZ25XaXRoU3ltYm9scyh0YXJnZXQsIHNvdXJjZSkge1xuICBfZXh0ZW5kcyh0YXJnZXQsIHNvdXJjZSk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgdGFyZ2V0W3NdID0gc291cmNlW3NdO1xuICAgIH0pO1xuICB9XG59O1xudmFyIGZsYXRNYXAgPSBmdW5jdGlvbiBmbGF0TWFwKG1hcHBlciwgYXJyKSB7XG4gIHZhciBfcmVmO1xuXG4gIHJldHVybiAoX3JlZiA9IFtdKS5jb25jYXQuYXBwbHkoX3JlZiwgYXJyLm1hcChtYXBwZXIpKTtcbn07XG5mdW5jdGlvbiByZW1vdmUoYXJyYXksIGl0ZW0pIHtcbiAgdmFyIGluZGV4ID0gYXJyYXkuaW5kZXhPZihpdGVtKTtcblxuICBpZiAoaW5kZXggPj0gMCkge1xuICAgIGFycmF5LnNwbGljZShpbmRleCwgMSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG9uY2UoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIGZuKCk7XG4gIH07XG59XG5cbnZhciBrVGhyb3cgPSBmdW5jdGlvbiBrVGhyb3coZXJyKSB7XG4gIHRocm93IGVycjtcbn07XG5cbnZhciBrUmV0dXJuID0gZnVuY3Rpb24ga1JldHVybih2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBkb25lOiB0cnVlXG4gIH07XG59O1xuXG5mdW5jdGlvbiBtYWtlSXRlcmF0b3IobmV4dCwgdGhybywgbmFtZSkge1xuICBpZiAodGhybyA9PT0gdm9pZCAwKSB7XG4gICAgdGhybyA9IGtUaHJvdztcbiAgfVxuXG4gIGlmIChuYW1lID09PSB2b2lkIDApIHtcbiAgICBuYW1lID0gJ2l0ZXJhdG9yJztcbiAgfVxuXG4gIHZhciBpdGVyYXRvciA9IHtcbiAgICBtZXRhOiB7XG4gICAgICBuYW1lOiBuYW1lXG4gICAgfSxcbiAgICBuZXh0OiBuZXh0LFxuICAgIHRocm93OiB0aHJvLFxuICAgIHJldHVybjoga1JldHVybixcbiAgICBpc1NhZ2FJdGVyYXRvcjogdHJ1ZVxuICB9O1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJykge1xuICAgIGl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBpdGVyYXRvcjtcbn1cbmZ1bmN0aW9uIGxvZ0Vycm9yKGVycm9yLCBfcmVmMikge1xuICB2YXIgc2FnYVN0YWNrID0gX3JlZjIuc2FnYVN0YWNrO1xuXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSovXG4gIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICBjb25zb2xlLmVycm9yKHNhZ2FTdGFjayk7XG59XG52YXIgaW50ZXJuYWxFcnIgPSBmdW5jdGlvbiBpbnRlcm5hbEVycihlcnIpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcihcIlxcbiAgcmVkdXgtc2FnYTogRXJyb3IgY2hlY2tpbmcgaG9va3MgZGV0ZWN0ZWQgYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBUaGlzIGlzIGxpa2VseSBhIGJ1Z1xcbiAgaW4gcmVkdXgtc2FnYSBjb2RlIGFuZCBub3QgeW91cnMuIFRoYW5rcyBmb3IgcmVwb3J0aW5nIHRoaXMgaW4gdGhlIHByb2plY3QncyBnaXRodWIgcmVwby5cXG4gIEVycm9yOiBcIiArIGVyciArIFwiXFxuXCIpO1xufTtcbnZhciBjcmVhdGVTZXRDb250ZXh0V2FybmluZyA9IGZ1bmN0aW9uIGNyZWF0ZVNldENvbnRleHRXYXJuaW5nKGN0eCwgcHJvcHMpIHtcbiAgcmV0dXJuIChjdHggPyBjdHggKyAnLicgOiAnJykgKyBcInNldENvbnRleHQocHJvcHMpOiBhcmd1bWVudCBcIiArIHByb3BzICsgXCIgaXMgbm90IGEgcGxhaW4gb2JqZWN0XCI7XG59O1xudmFyIEZST1pFTl9BQ1RJT05fRVJST1IgPSBcIllvdSBjYW4ndCBwdXQgKGEuay5hLiBkaXNwYXRjaCBmcm9tIHNhZ2EpIGZyb3plbiBhY3Rpb25zLlxcbldlIGhhdmUgdG8gZGVmaW5lIGEgc3BlY2lhbCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBvbiB0aG9zZSBhY3Rpb25zIGZvciBzY2hlZHVsaW5nIHB1cnBvc2VzLlxcbk90aGVyd2lzZSB5b3Ugd291bGRuJ3QgYmUgYWJsZSB0byBjb21tdW5pY2F0ZSBwcm9wZXJseSBiZXR3ZWVuIHNhZ2FzICYgb3RoZXIgc3Vic2NyaWJlcnMgKGFjdGlvbiBvcmRlcmluZyB3b3VsZCBiZWNvbWUgZmFyIGxlc3MgcHJlZGljdGFibGUpLlxcbklmIHlvdSBhcmUgdXNpbmcgcmVkdXggYW5kIHlvdSBjYXJlIGFib3V0IHRoaXMgYmVoYXZpb3VyIChmcm96ZW4gYWN0aW9ucyksXFxudGhlbiB5b3UgbWlnaHQgd2FudCB0byBzd2l0Y2ggdG8gZnJlZXppbmcgYWN0aW9ucyBpbiBhIG1pZGRsZXdhcmUgcmF0aGVyIHRoYW4gaW4gYWN0aW9uIGNyZWF0b3IuXFxuRXhhbXBsZSBpbXBsZW1lbnRhdGlvbjpcXG5cXG5jb25zdCBmcmVlemVBY3Rpb25zID0gc3RvcmUgPT4gbmV4dCA9PiBhY3Rpb24gPT4gbmV4dChPYmplY3QuZnJlZXplKGFjdGlvbikpXFxuXCI7IC8vIGNyZWF0ZXMgZW1wdHksIGJ1dCBub3QtaG9sZXkgYXJyYXlcblxudmFyIGNyZWF0ZUVtcHR5QXJyYXkgPSBmdW5jdGlvbiBjcmVhdGVFbXB0eUFycmF5KG4pIHtcbiAgcmV0dXJuIEFycmF5LmFwcGx5KG51bGwsIG5ldyBBcnJheShuKSk7XG59O1xudmFyIHdyYXBTYWdhRGlzcGF0Y2ggPSBmdW5jdGlvbiB3cmFwU2FnYURpc3BhdGNoKGRpc3BhdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrKGFjdGlvbiwgZnVuY3Rpb24gKGFjKSB7XG4gICAgICAgIHJldHVybiAhT2JqZWN0LmlzRnJvemVuKGFjKTtcbiAgICAgIH0sIEZST1pFTl9BQ1RJT05fRVJST1IpO1xuICAgIH1cblxuICAgIHJldHVybiBkaXNwYXRjaChPYmplY3QuZGVmaW5lUHJvcGVydHkoYWN0aW9uLCBTQUdBX0FDVElPTiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KSk7XG4gIH07XG59O1xudmFyIHNob3VsZFRlcm1pbmF0ZSA9IGZ1bmN0aW9uIHNob3VsZFRlcm1pbmF0ZShyZXMpIHtcbiAgcmV0dXJuIHJlcyA9PT0gVEVSTUlOQVRFO1xufTtcbnZhciBzaG91bGRDYW5jZWwgPSBmdW5jdGlvbiBzaG91bGRDYW5jZWwocmVzKSB7XG4gIHJldHVybiByZXMgPT09IFRBU0tfQ0FOQ0VMO1xufTtcbnZhciBzaG91bGRDb21wbGV0ZSA9IGZ1bmN0aW9uIHNob3VsZENvbXBsZXRlKHJlcykge1xuICByZXR1cm4gc2hvdWxkVGVybWluYXRlKHJlcykgfHwgc2hvdWxkQ2FuY2VsKHJlcyk7XG59O1xuZnVuY3Rpb24gY3JlYXRlQWxsU3R5bGVDaGlsZENhbGxiYWNrcyhzaGFwZSwgcGFyZW50Q2FsbGJhY2spIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzaGFwZSk7XG4gIHZhciB0b3RhbENvdW50ID0ga2V5cy5sZW5ndGg7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaGVjayh0b3RhbENvdW50LCBmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIGMgPiAwO1xuICAgIH0sICdjcmVhdGVBbGxTdHlsZUNoaWxkQ2FsbGJhY2tzOiBnZXQgYW4gZW1wdHkgYXJyYXkgb3Igb2JqZWN0Jyk7XG4gIH1cblxuICB2YXIgY29tcGxldGVkQ291bnQgPSAwO1xuICB2YXIgY29tcGxldGVkO1xuICB2YXIgcmVzdWx0cyA9IGFycmF5KHNoYXBlKSA/IGNyZWF0ZUVtcHR5QXJyYXkodG90YWxDb3VudCkgOiB7fTtcbiAgdmFyIGNoaWxkQ2FsbGJhY2tzID0ge307XG5cbiAgZnVuY3Rpb24gY2hlY2tFbmQoKSB7XG4gICAgaWYgKGNvbXBsZXRlZENvdW50ID09PSB0b3RhbENvdW50KSB7XG4gICAgICBjb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgcGFyZW50Q2FsbGJhY2socmVzdWx0cyk7XG4gICAgfVxuICB9XG5cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgY2hDYkF0S2V5ID0gZnVuY3Rpb24gY2hDYkF0S2V5KHJlcywgaXNFcnIpIHtcbiAgICAgIGlmIChjb21wbGV0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNFcnIgfHwgc2hvdWxkQ29tcGxldGUocmVzKSkge1xuICAgICAgICBwYXJlbnRDYWxsYmFjay5jYW5jZWwoKTtcbiAgICAgICAgcGFyZW50Q2FsbGJhY2socmVzLCBpc0Vycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRzW2tleV0gPSByZXM7XG4gICAgICAgIGNvbXBsZXRlZENvdW50Kys7XG4gICAgICAgIGNoZWNrRW5kKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNoQ2JBdEtleS5jYW5jZWwgPSBub29wO1xuICAgIGNoaWxkQ2FsbGJhY2tzW2tleV0gPSBjaENiQXRLZXk7XG4gIH0pO1xuXG4gIHBhcmVudENhbGxiYWNrLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNvbXBsZXRlZCkge1xuICAgICAgY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBjaGlsZENhbGxiYWNrc1trZXldLmNhbmNlbCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBjaGlsZENhbGxiYWNrcztcbn1cbmZ1bmN0aW9uIGdldE1ldGFJbmZvKGZuKSB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogZm4ubmFtZSB8fCAnYW5vbnltb3VzJyxcbiAgICBsb2NhdGlvbjogZ2V0TG9jYXRpb24oZm4pXG4gIH07XG59XG5mdW5jdGlvbiBnZXRMb2NhdGlvbihpbnN0cnVtZW50ZWQpIHtcbiAgcmV0dXJuIGluc3RydW1lbnRlZFtTQUdBX0xPQ0FUSU9OXTtcbn1cblxudmFyIEJVRkZFUl9PVkVSRkxPVyA9IFwiQ2hhbm5lbCdzIEJ1ZmZlciBvdmVyZmxvdyFcIjtcbnZhciBPTl9PVkVSRkxPV19USFJPVyA9IDE7XG52YXIgT05fT1ZFUkZMT1dfRFJPUCA9IDI7XG52YXIgT05fT1ZFUkZMT1dfU0xJREUgPSAzO1xudmFyIE9OX09WRVJGTE9XX0VYUEFORCA9IDQ7XG52YXIgemVyb0J1ZmZlciA9IHtcbiAgaXNFbXB0eToga1RydWUsXG4gIHB1dDogbm9vcCxcbiAgdGFrZTogbm9vcFxufTtcblxuZnVuY3Rpb24gcmluZ0J1ZmZlcihsaW1pdCwgb3ZlcmZsb3dBY3Rpb24pIHtcbiAgaWYgKGxpbWl0ID09PSB2b2lkIDApIHtcbiAgICBsaW1pdCA9IDEwO1xuICB9XG5cbiAgdmFyIGFyciA9IG5ldyBBcnJheShsaW1pdCk7XG4gIHZhciBsZW5ndGggPSAwO1xuICB2YXIgcHVzaEluZGV4ID0gMDtcbiAgdmFyIHBvcEluZGV4ID0gMDtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2goaXQpIHtcbiAgICBhcnJbcHVzaEluZGV4XSA9IGl0O1xuICAgIHB1c2hJbmRleCA9IChwdXNoSW5kZXggKyAxKSAlIGxpbWl0O1xuICAgIGxlbmd0aCsrO1xuICB9O1xuXG4gIHZhciB0YWtlID0gZnVuY3Rpb24gdGFrZSgpIHtcbiAgICBpZiAobGVuZ3RoICE9IDApIHtcbiAgICAgIHZhciBpdCA9IGFycltwb3BJbmRleF07XG4gICAgICBhcnJbcG9wSW5kZXhdID0gbnVsbDtcbiAgICAgIGxlbmd0aC0tO1xuICAgICAgcG9wSW5kZXggPSAocG9wSW5kZXggKyAxKSAlIGxpbWl0O1xuICAgICAgcmV0dXJuIGl0O1xuICAgIH1cbiAgfTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcblxuICAgIHdoaWxlIChsZW5ndGgpIHtcbiAgICAgIGl0ZW1zLnB1c2godGFrZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBpc0VtcHR5OiBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgICAgcmV0dXJuIGxlbmd0aCA9PSAwO1xuICAgIH0sXG4gICAgcHV0OiBmdW5jdGlvbiBwdXQoaXQpIHtcbiAgICAgIGlmIChsZW5ndGggPCBsaW1pdCkge1xuICAgICAgICBwdXNoKGl0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkb3VibGVkTGltaXQ7XG5cbiAgICAgICAgc3dpdGNoIChvdmVyZmxvd0FjdGlvbikge1xuICAgICAgICAgIGNhc2UgT05fT1ZFUkZMT1dfVEhST1c6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoQlVGRkVSX09WRVJGTE9XKTtcblxuICAgICAgICAgIGNhc2UgT05fT1ZFUkZMT1dfU0xJREU6XG4gICAgICAgICAgICBhcnJbcHVzaEluZGV4XSA9IGl0O1xuICAgICAgICAgICAgcHVzaEluZGV4ID0gKHB1c2hJbmRleCArIDEpICUgbGltaXQ7XG4gICAgICAgICAgICBwb3BJbmRleCA9IHB1c2hJbmRleDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBPTl9PVkVSRkxPV19FWFBBTkQ6XG4gICAgICAgICAgICBkb3VibGVkTGltaXQgPSAyICogbGltaXQ7XG4gICAgICAgICAgICBhcnIgPSBmbHVzaCgpO1xuICAgICAgICAgICAgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgICAgICAgICAgIHB1c2hJbmRleCA9IGFyci5sZW5ndGg7XG4gICAgICAgICAgICBwb3BJbmRleCA9IDA7XG4gICAgICAgICAgICBhcnIubGVuZ3RoID0gZG91YmxlZExpbWl0O1xuICAgICAgICAgICAgbGltaXQgPSBkb3VibGVkTGltaXQ7XG4gICAgICAgICAgICBwdXNoKGl0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDogLy8gRFJPUFxuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHRha2U6IHRha2UsXG4gICAgZmx1c2g6IGZsdXNoXG4gIH07XG59XG5cbnZhciBub25lID0gZnVuY3Rpb24gbm9uZSgpIHtcbiAgcmV0dXJuIHplcm9CdWZmZXI7XG59O1xudmFyIGZpeGVkID0gZnVuY3Rpb24gZml4ZWQobGltaXQpIHtcbiAgcmV0dXJuIHJpbmdCdWZmZXIobGltaXQsIE9OX09WRVJGTE9XX1RIUk9XKTtcbn07XG52YXIgZHJvcHBpbmcgPSBmdW5jdGlvbiBkcm9wcGluZyhsaW1pdCkge1xuICByZXR1cm4gcmluZ0J1ZmZlcihsaW1pdCwgT05fT1ZFUkZMT1dfRFJPUCk7XG59O1xudmFyIHNsaWRpbmcgPSBmdW5jdGlvbiBzbGlkaW5nKGxpbWl0KSB7XG4gIHJldHVybiByaW5nQnVmZmVyKGxpbWl0LCBPTl9PVkVSRkxPV19TTElERSk7XG59O1xudmFyIGV4cGFuZGluZyA9IGZ1bmN0aW9uIGV4cGFuZGluZyhpbml0aWFsU2l6ZSkge1xuICByZXR1cm4gcmluZ0J1ZmZlcihpbml0aWFsU2l6ZSwgT05fT1ZFUkZMT1dfRVhQQU5EKTtcbn07XG5cbnZhciBidWZmZXJzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIG5vbmU6IG5vbmUsXG4gIGZpeGVkOiBmaXhlZCxcbiAgZHJvcHBpbmc6IGRyb3BwaW5nLFxuICBzbGlkaW5nOiBzbGlkaW5nLFxuICBleHBhbmRpbmc6IGV4cGFuZGluZ1xufSk7XG5cbnZhciBUQUtFID0gJ1RBS0UnO1xudmFyIFBVVCA9ICdQVVQnO1xudmFyIEFMTCA9ICdBTEwnO1xudmFyIFJBQ0UgPSAnUkFDRSc7XG52YXIgQ0FMTCA9ICdDQUxMJztcbnZhciBDUFMgPSAnQ1BTJztcbnZhciBGT1JLID0gJ0ZPUksnO1xudmFyIEpPSU4gPSAnSk9JTic7XG52YXIgQ0FOQ0VMID0gJ0NBTkNFTCc7XG52YXIgU0VMRUNUID0gJ1NFTEVDVCc7XG52YXIgQUNUSU9OX0NIQU5ORUwgPSAnQUNUSU9OX0NIQU5ORUwnO1xudmFyIENBTkNFTExFRCA9ICdDQU5DRUxMRUQnO1xudmFyIEZMVVNIID0gJ0ZMVVNIJztcbnZhciBHRVRfQ09OVEVYVCA9ICdHRVRfQ09OVEVYVCc7XG52YXIgU0VUX0NPTlRFWFQgPSAnU0VUX0NPTlRFWFQnO1xuXG52YXIgZWZmZWN0VHlwZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgVEFLRTogVEFLRSxcbiAgUFVUOiBQVVQsXG4gIEFMTDogQUxMLFxuICBSQUNFOiBSQUNFLFxuICBDQUxMOiBDQUxMLFxuICBDUFM6IENQUyxcbiAgRk9SSzogRk9SSyxcbiAgSk9JTjogSk9JTixcbiAgQ0FOQ0VMOiBDQU5DRUwsXG4gIFNFTEVDVDogU0VMRUNULFxuICBBQ1RJT05fQ0hBTk5FTDogQUNUSU9OX0NIQU5ORUwsXG4gIENBTkNFTExFRDogQ0FOQ0VMTEVELFxuICBGTFVTSDogRkxVU0gsXG4gIEdFVF9DT05URVhUOiBHRVRfQ09OVEVYVCxcbiAgU0VUX0NPTlRFWFQ6IFNFVF9DT05URVhUXG59KTtcblxudmFyIFRFU1RfSElOVCA9ICdcXG4oSElOVDogaWYgeW91IGFyZSBnZXR0aW5nIHRoZXNlIGVycm9ycyBpbiB0ZXN0cywgY29uc2lkZXIgdXNpbmcgY3JlYXRlTW9ja1Rhc2sgZnJvbSBAcmVkdXgtc2FnYS90ZXN0aW5nLXV0aWxzKSc7XG5cbnZhciBtYWtlRWZmZWN0ID0gZnVuY3Rpb24gbWFrZUVmZmVjdCh0eXBlLCBwYXlsb2FkKSB7XG4gIHZhciBfcmVmO1xuXG4gIHJldHVybiBfcmVmID0ge30sIF9yZWZbSU9dID0gdHJ1ZSwgX3JlZi5jb21iaW5hdG9yID0gZmFsc2UsIF9yZWYudHlwZSA9IHR5cGUsIF9yZWYucGF5bG9hZCA9IHBheWxvYWQsIF9yZWY7XG59O1xuXG52YXIgaXNGb3JrRWZmZWN0ID0gZnVuY3Rpb24gaXNGb3JrRWZmZWN0KGVmZikge1xuICByZXR1cm4gZWZmZWN0KGVmZikgJiYgZWZmLnR5cGUgPT09IEZPUks7XG59O1xuXG52YXIgZGV0YWNoID0gZnVuY3Rpb24gZGV0YWNoKGVmZikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNoZWNrKGVmZiwgaXNGb3JrRWZmZWN0LCAnZGV0YWNoKGVmZik6IGFyZ3VtZW50IG11c3QgYmUgYSBmb3JrIGVmZmVjdCcpO1xuICB9XG5cbiAgcmV0dXJuIG1ha2VFZmZlY3QoRk9SSywgX2V4dGVuZHMoe30sIGVmZi5wYXlsb2FkLCB7XG4gICAgZGV0YWNoZWQ6IHRydWVcbiAgfSkpO1xufTtcbmZ1bmN0aW9uIHRha2UocGF0dGVybk9yQ2hhbm5lbCwgbXVsdGljYXN0UGF0dGVybikge1xuICBpZiAocGF0dGVybk9yQ2hhbm5lbCA9PT0gdm9pZCAwKSB7XG4gICAgcGF0dGVybk9yQ2hhbm5lbCA9ICcqJztcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjaGVjayhhcmd1bWVudHNbMF0sIG5vdFVuZGVmLCAndGFrZShwYXR0ZXJuT3JDaGFubmVsKTogcGF0dGVybk9yQ2hhbm5lbCBpcyB1bmRlZmluZWQnKTtcbiAgfVxuXG4gIGlmIChwYXR0ZXJuKHBhdHRlcm5PckNoYW5uZWwpKSB7XG4gICAgcmV0dXJuIG1ha2VFZmZlY3QoVEFLRSwge1xuICAgICAgcGF0dGVybjogcGF0dGVybk9yQ2hhbm5lbFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKG11bHRpY2FzdChwYXR0ZXJuT3JDaGFubmVsKSAmJiBub3RVbmRlZihtdWx0aWNhc3RQYXR0ZXJuKSAmJiBwYXR0ZXJuKG11bHRpY2FzdFBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIG1ha2VFZmZlY3QoVEFLRSwge1xuICAgICAgY2hhbm5lbDogcGF0dGVybk9yQ2hhbm5lbCxcbiAgICAgIHBhdHRlcm46IG11bHRpY2FzdFBhdHRlcm5cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChjaGFubmVsKHBhdHRlcm5PckNoYW5uZWwpKSB7XG4gICAgcmV0dXJuIG1ha2VFZmZlY3QoVEFLRSwge1xuICAgICAgY2hhbm5lbDogcGF0dGVybk9yQ2hhbm5lbFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0YWtlKHBhdHRlcm5PckNoYW5uZWwpOiBhcmd1bWVudCBcIiArIHBhdHRlcm5PckNoYW5uZWwgKyBcIiBpcyBub3QgdmFsaWQgY2hhbm5lbCBvciBhIHZhbGlkIHBhdHRlcm5cIik7XG4gIH1cbn1cbnZhciB0YWtlTWF5YmUgPSBmdW5jdGlvbiB0YWtlTWF5YmUoKSB7XG4gIHZhciBlZmYgPSB0YWtlLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgZWZmLnBheWxvYWQubWF5YmUgPSB0cnVlO1xuICByZXR1cm4gZWZmO1xufTtcbmZ1bmN0aW9uIHB1dChjaGFubmVsJDEsIGFjdGlvbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgY2hlY2soY2hhbm5lbCQxLCBub3RVbmRlZiwgJ3B1dChjaGFubmVsLCBhY3Rpb24pOiBhcmd1bWVudCBjaGFubmVsIGlzIHVuZGVmaW5lZCcpO1xuICAgICAgY2hlY2soY2hhbm5lbCQxLCBjaGFubmVsLCBcInB1dChjaGFubmVsLCBhY3Rpb24pOiBhcmd1bWVudCBcIiArIGNoYW5uZWwkMSArIFwiIGlzIG5vdCBhIHZhbGlkIGNoYW5uZWxcIik7XG4gICAgICBjaGVjayhhY3Rpb24sIG5vdFVuZGVmLCAncHV0KGNoYW5uZWwsIGFjdGlvbik6IGFyZ3VtZW50IGFjdGlvbiBpcyB1bmRlZmluZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hlY2soY2hhbm5lbCQxLCBub3RVbmRlZiwgJ3B1dChhY3Rpb24pOiBhcmd1bWVudCBhY3Rpb24gaXMgdW5kZWZpbmVkJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHVuZGVmKGFjdGlvbikpIHtcbiAgICBhY3Rpb24gPSBjaGFubmVsJDE7IC8vIGB1bmRlZmluZWRgIGluc3RlYWQgb2YgYG51bGxgIHRvIG1ha2UgZGVmYXVsdCBwYXJhbWV0ZXIgd29ya1xuXG4gICAgY2hhbm5lbCQxID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIG1ha2VFZmZlY3QoUFVULCB7XG4gICAgY2hhbm5lbDogY2hhbm5lbCQxLFxuICAgIGFjdGlvbjogYWN0aW9uXG4gIH0pO1xufVxudmFyIHB1dFJlc29sdmUgPSBmdW5jdGlvbiBwdXRSZXNvbHZlKCkge1xuICB2YXIgZWZmID0gcHV0LmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgZWZmLnBheWxvYWQucmVzb2x2ZSA9IHRydWU7XG4gIHJldHVybiBlZmY7XG59O1xuZnVuY3Rpb24gYWxsKGVmZmVjdHMpIHtcbiAgdmFyIGVmZiA9IG1ha2VFZmZlY3QoQUxMLCBlZmZlY3RzKTtcbiAgZWZmLmNvbWJpbmF0b3IgPSB0cnVlO1xuICByZXR1cm4gZWZmO1xufVxuZnVuY3Rpb24gcmFjZShlZmZlY3RzKSB7XG4gIHZhciBlZmYgPSBtYWtlRWZmZWN0KFJBQ0UsIGVmZmVjdHMpO1xuICBlZmYuY29tYmluYXRvciA9IHRydWU7XG4gIHJldHVybiBlZmY7XG59IC8vIHRoaXMgbWF0Y2ggZ2V0Rm5DYWxsRGVzY3JpcHRvciBsb2dpY1xuXG52YXIgdmFsaWRhdGVGbkRlc2NyaXB0b3IgPSBmdW5jdGlvbiB2YWxpZGF0ZUZuRGVzY3JpcHRvcihlZmZlY3ROYW1lLCBmbkRlc2NyaXB0b3IpIHtcbiAgY2hlY2soZm5EZXNjcmlwdG9yLCBub3RVbmRlZiwgZWZmZWN0TmFtZSArIFwiOiBhcmd1bWVudCBmbiBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKTtcblxuICBpZiAoZnVuYyhmbkRlc2NyaXB0b3IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvbnRleHQgPSBudWxsO1xuICB2YXIgZm47XG5cbiAgaWYgKGFycmF5KGZuRGVzY3JpcHRvcikpIHtcbiAgICBjb250ZXh0ID0gZm5EZXNjcmlwdG9yWzBdO1xuICAgIGZuID0gZm5EZXNjcmlwdG9yWzFdO1xuICAgIGNoZWNrKGZuLCBub3RVbmRlZiwgZWZmZWN0TmFtZSArIFwiOiBhcmd1bWVudCBvZiB0eXBlIFtjb250ZXh0LCBmbl0gaGFzIHVuZGVmaW5lZCBvciBudWxsIGBmbmBcIik7XG4gIH0gZWxzZSBpZiAob2JqZWN0KGZuRGVzY3JpcHRvcikpIHtcbiAgICBjb250ZXh0ID0gZm5EZXNjcmlwdG9yLmNvbnRleHQ7XG4gICAgZm4gPSBmbkRlc2NyaXB0b3IuZm47XG4gICAgY2hlY2soZm4sIG5vdFVuZGVmLCBlZmZlY3ROYW1lICsgXCI6IGFyZ3VtZW50IG9mIHR5cGUge2NvbnRleHQsIGZufSBoYXMgdW5kZWZpbmVkIG9yIG51bGwgYGZuYFwiKTtcbiAgfSBlbHNlIHtcbiAgICBjaGVjayhmbkRlc2NyaXB0b3IsIGZ1bmMsIGVmZmVjdE5hbWUgKyBcIjogYXJndW1lbnQgZm4gaXMgbm90IGZ1bmN0aW9uXCIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjb250ZXh0ICYmIHN0cmluZyhmbikpIHtcbiAgICBjaGVjayhjb250ZXh0W2ZuXSwgZnVuYywgZWZmZWN0TmFtZSArIFwiOiBjb250ZXh0IGFyZ3VtZW50cyBoYXMgbm8gc3VjaCBtZXRob2QgLSBcXFwiXCIgKyBmbiArIFwiXFxcIlwiKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjaGVjayhmbiwgZnVuYywgZWZmZWN0TmFtZSArIFwiOiB1bnBhY2tlZCBmbiBhcmd1bWVudCAoZnJvbSBbY29udGV4dCwgZm5dIG9yIHtjb250ZXh0LCBmbn0pIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xufTtcblxuZnVuY3Rpb24gZ2V0Rm5DYWxsRGVzY3JpcHRvcihmbkRlc2NyaXB0b3IsIGFyZ3MpIHtcbiAgdmFyIGNvbnRleHQgPSBudWxsO1xuICB2YXIgZm47XG5cbiAgaWYgKGZ1bmMoZm5EZXNjcmlwdG9yKSkge1xuICAgIGZuID0gZm5EZXNjcmlwdG9yO1xuICB9IGVsc2Uge1xuICAgIGlmIChhcnJheShmbkRlc2NyaXB0b3IpKSB7XG4gICAgICBjb250ZXh0ID0gZm5EZXNjcmlwdG9yWzBdO1xuICAgICAgZm4gPSBmbkRlc2NyaXB0b3JbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQgPSBmbkRlc2NyaXB0b3IuY29udGV4dDtcbiAgICAgIGZuID0gZm5EZXNjcmlwdG9yLmZuO1xuICAgIH1cblxuICAgIGlmIChjb250ZXh0ICYmIHN0cmluZyhmbikgJiYgZnVuYyhjb250ZXh0W2ZuXSkpIHtcbiAgICAgIGZuID0gY29udGV4dFtmbl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgIGZuOiBmbixcbiAgICBhcmdzOiBhcmdzXG4gIH07XG59XG5cbnZhciBpc05vdERlbGF5RWZmZWN0ID0gZnVuY3Rpb24gaXNOb3REZWxheUVmZmVjdChmbikge1xuICByZXR1cm4gZm4gIT09IGRlbGF5O1xufTtcblxuZnVuY3Rpb24gY2FsbChmbkRlc2NyaXB0b3IpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgYXJnMCA9IHR5cGVvZiBhcmdzWzBdID09PSAnbnVtYmVyJyA/IGFyZ3NbMF0gOiAnbXMnO1xuICAgIGNoZWNrKGZuRGVzY3JpcHRvciwgaXNOb3REZWxheUVmZmVjdCwgXCJpbnN0ZWFkIG9mIHdyaXRpbmcgYHlpZWxkIGNhbGwoZGVsYXksIFwiICsgYXJnMCArIFwiKWAgd2hlcmUgZGVsYXkgaXMgYW4gZWZmZWN0IGZyb20gYHJlZHV4LXNhZ2EvZWZmZWN0c2AgeW91IHNob3VsZCB3cml0ZSBgeWllbGQgZGVsYXkoXCIgKyBhcmcwICsgXCIpYFwiKTtcbiAgICB2YWxpZGF0ZUZuRGVzY3JpcHRvcignY2FsbCcsIGZuRGVzY3JpcHRvcik7XG4gIH1cblxuICByZXR1cm4gbWFrZUVmZmVjdChDQUxMLCBnZXRGbkNhbGxEZXNjcmlwdG9yKGZuRGVzY3JpcHRvciwgYXJncykpO1xufVxuZnVuY3Rpb24gYXBwbHkoY29udGV4dCwgZm4sIGFyZ3MpIHtcbiAgaWYgKGFyZ3MgPT09IHZvaWQgMCkge1xuICAgIGFyZ3MgPSBbXTtcbiAgfVxuXG4gIHZhciBmbkRlc2NyaXB0b3IgPSBbY29udGV4dCwgZm5dO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFsaWRhdGVGbkRlc2NyaXB0b3IoJ2FwcGx5JywgZm5EZXNjcmlwdG9yKTtcbiAgfVxuXG4gIHJldHVybiBtYWtlRWZmZWN0KENBTEwsIGdldEZuQ2FsbERlc2NyaXB0b3IoW2NvbnRleHQsIGZuXSwgYXJncykpO1xufVxuZnVuY3Rpb24gY3BzKGZuRGVzY3JpcHRvcikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRm5EZXNjcmlwdG9yKCdjcHMnLCBmbkRlc2NyaXB0b3IpO1xuICB9XG5cbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG5cbiAgcmV0dXJuIG1ha2VFZmZlY3QoQ1BTLCBnZXRGbkNhbGxEZXNjcmlwdG9yKGZuRGVzY3JpcHRvciwgYXJncykpO1xufVxuZnVuY3Rpb24gZm9yayhmbkRlc2NyaXB0b3IpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YWxpZGF0ZUZuRGVzY3JpcHRvcignZm9yaycsIGZuRGVzY3JpcHRvcik7XG4gICAgY2hlY2soZm5EZXNjcmlwdG9yLCBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICByZXR1cm4gIWVmZmVjdChhcmcpO1xuICAgIH0sICdmb3JrOiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhbiBlZmZlY3QnKTtcbiAgfVxuXG4gIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgYXJnc1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgfVxuXG4gIHJldHVybiBtYWtlRWZmZWN0KEZPUkssIGdldEZuQ2FsbERlc2NyaXB0b3IoZm5EZXNjcmlwdG9yLCBhcmdzKSk7XG59XG5mdW5jdGlvbiBzcGF3bihmbkRlc2NyaXB0b3IpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YWxpZGF0ZUZuRGVzY3JpcHRvcignc3Bhd24nLCBmbkRlc2NyaXB0b3IpO1xuICB9XG5cbiAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40ID4gMSA/IF9sZW40IC0gMSA6IDApLCBfa2V5NCA9IDE7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICBhcmdzW19rZXk0IC0gMV0gPSBhcmd1bWVudHNbX2tleTRdO1xuICB9XG5cbiAgcmV0dXJuIGRldGFjaChmb3JrLmFwcGx5KHZvaWQgMCwgW2ZuRGVzY3JpcHRvcl0uY29uY2F0KGFyZ3MpKSk7XG59XG5mdW5jdGlvbiBqb2luKHRhc2tPclRhc2tzKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pvaW4oLi4udGFza3MpIGlzIG5vdCBzdXBwb3J0ZWQgYW55IG1vcmUuIFBsZWFzZSB1c2Ugam9pbihbLi4udGFza3NdKSB0byBqb2luIG11bHRpcGxlIHRhc2tzLicpO1xuICAgIH1cblxuICAgIGlmIChhcnJheSh0YXNrT3JUYXNrcykpIHtcbiAgICAgIHRhc2tPclRhc2tzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgY2hlY2sodCwgdGFzaywgXCJqb2luKFsuLi50YXNrc10pOiBhcmd1bWVudCBcIiArIHQgKyBcIiBpcyBub3QgYSB2YWxpZCBUYXNrIG9iamVjdCBcIiArIFRFU1RfSElOVCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hlY2sodGFza09yVGFza3MsIHRhc2ssIFwiam9pbih0YXNrKTogYXJndW1lbnQgXCIgKyB0YXNrT3JUYXNrcyArIFwiIGlzIG5vdCBhIHZhbGlkIFRhc2sgb2JqZWN0IFwiICsgVEVTVF9ISU5UKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWFrZUVmZmVjdChKT0lOLCB0YXNrT3JUYXNrcyk7XG59XG5mdW5jdGlvbiBjYW5jZWwodGFza09yVGFza3MpIHtcbiAgaWYgKHRhc2tPclRhc2tzID09PSB2b2lkIDApIHtcbiAgICB0YXNrT3JUYXNrcyA9IFNFTEZfQ0FOQ0VMTEFUSU9OO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2FuY2VsKC4uLnRhc2tzKSBpcyBub3Qgc3VwcG9ydGVkIGFueSBtb3JlLiBQbGVhc2UgdXNlIGNhbmNlbChbLi4udGFza3NdKSB0byBjYW5jZWwgbXVsdGlwbGUgdGFza3MuJyk7XG4gICAgfVxuXG4gICAgaWYgKGFycmF5KHRhc2tPclRhc2tzKSkge1xuICAgICAgdGFza09yVGFza3MuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICBjaGVjayh0LCB0YXNrLCBcImNhbmNlbChbLi4udGFza3NdKTogYXJndW1lbnQgXCIgKyB0ICsgXCIgaXMgbm90IGEgdmFsaWQgVGFzayBvYmplY3QgXCIgKyBURVNUX0hJTlQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0YXNrT3JUYXNrcyAhPT0gU0VMRl9DQU5DRUxMQVRJT04gJiYgbm90VW5kZWYodGFza09yVGFza3MpKSB7XG4gICAgICBjaGVjayh0YXNrT3JUYXNrcywgdGFzaywgXCJjYW5jZWwodGFzayk6IGFyZ3VtZW50IFwiICsgdGFza09yVGFza3MgKyBcIiBpcyBub3QgYSB2YWxpZCBUYXNrIG9iamVjdCBcIiArIFRFU1RfSElOVCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1ha2VFZmZlY3QoQ0FOQ0VMLCB0YXNrT3JUYXNrcyk7XG59XG5mdW5jdGlvbiBzZWxlY3Qoc2VsZWN0b3IpIHtcbiAgaWYgKHNlbGVjdG9yID09PSB2b2lkIDApIHtcbiAgICBzZWxlY3RvciA9IGlkZW50aXR5O1xuICB9XG5cbiAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41ID4gMSA/IF9sZW41IC0gMSA6IDApLCBfa2V5NSA9IDE7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICBhcmdzW19rZXk1IC0gMV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNoZWNrKGFyZ3VtZW50c1swXSwgbm90VW5kZWYsICdzZWxlY3Qoc2VsZWN0b3IsIFsuLi5dKTogYXJndW1lbnQgc2VsZWN0b3IgaXMgdW5kZWZpbmVkJyk7XG4gICAgY2hlY2soc2VsZWN0b3IsIGZ1bmMsIFwic2VsZWN0KHNlbGVjdG9yLCBbLi4uXSk6IGFyZ3VtZW50IFwiICsgc2VsZWN0b3IgKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHJldHVybiBtYWtlRWZmZWN0KFNFTEVDVCwge1xuICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICBhcmdzOiBhcmdzXG4gIH0pO1xufVxuLyoqXG4gIGNoYW5uZWwocGF0dGVybiwgW2J1ZmZlcl0pICAgID0+IGNyZWF0ZXMgYSBwcm94eSBjaGFubmVsIGZvciBzdG9yZSBhY3Rpb25zXG4qKi9cblxuZnVuY3Rpb24gYWN0aW9uQ2hhbm5lbChwYXR0ZXJuJDEsIGJ1ZmZlciQxKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2hlY2socGF0dGVybiQxLCBwYXR0ZXJuLCAnYWN0aW9uQ2hhbm5lbChwYXR0ZXJuLC4uLik6IGFyZ3VtZW50IHBhdHRlcm4gaXMgbm90IHZhbGlkJyk7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNoZWNrKGJ1ZmZlciQxLCBub3RVbmRlZiwgJ2FjdGlvbkNoYW5uZWwocGF0dGVybiwgYnVmZmVyKTogYXJndW1lbnQgYnVmZmVyIGlzIHVuZGVmaW5lZCcpO1xuICAgICAgY2hlY2soYnVmZmVyJDEsIGJ1ZmZlciwgXCJhY3Rpb25DaGFubmVsKHBhdHRlcm4sIGJ1ZmZlcik6IGFyZ3VtZW50IFwiICsgYnVmZmVyJDEgKyBcIiBpcyBub3QgYSB2YWxpZCBidWZmZXJcIik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1ha2VFZmZlY3QoQUNUSU9OX0NIQU5ORUwsIHtcbiAgICBwYXR0ZXJuOiBwYXR0ZXJuJDEsXG4gICAgYnVmZmVyOiBidWZmZXIkMVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNhbmNlbGxlZCgpIHtcbiAgcmV0dXJuIG1ha2VFZmZlY3QoQ0FOQ0VMTEVELCB7fSk7XG59XG5mdW5jdGlvbiBmbHVzaChjaGFubmVsJDEpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaGVjayhjaGFubmVsJDEsIGNoYW5uZWwsIFwiZmx1c2goY2hhbm5lbCk6IGFyZ3VtZW50IFwiICsgY2hhbm5lbCQxICsgXCIgaXMgbm90IHZhbGlkIGNoYW5uZWxcIik7XG4gIH1cblxuICByZXR1cm4gbWFrZUVmZmVjdChGTFVTSCwgY2hhbm5lbCQxKTtcbn1cbmZ1bmN0aW9uIGdldENvbnRleHQocHJvcCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNoZWNrKHByb3AsIHN0cmluZywgXCJnZXRDb250ZXh0KHByb3ApOiBhcmd1bWVudCBcIiArIHByb3AgKyBcIiBpcyBub3QgYSBzdHJpbmdcIik7XG4gIH1cblxuICByZXR1cm4gbWFrZUVmZmVjdChHRVRfQ09OVEVYVCwgcHJvcCk7XG59XG5mdW5jdGlvbiBzZXRDb250ZXh0KHByb3BzKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2hlY2socHJvcHMsIG9iamVjdCwgY3JlYXRlU2V0Q29udGV4dFdhcm5pbmcobnVsbCwgcHJvcHMpKTtcbiAgfVxuXG4gIHJldHVybiBtYWtlRWZmZWN0KFNFVF9DT05URVhULCBwcm9wcyk7XG59XG52YXIgZGVsYXkgPVxuLyojX19QVVJFX18qL1xuY2FsbC5iaW5kKG51bGwsIGRlbGF5UCk7XG5cbmV4cG9ydCB7IGFwcGx5IGFzICQsIEFMTCBhcyBBLCBsb2dFcnJvciBhcyBCLCBDQUxMIGFzIEMsIHdyYXBTYWdhRGlzcGF0Y2ggYXMgRCwgaWRlbnRpdHkgYXMgRSwgRk9SSyBhcyBGLCBHRVRfQ09OVEVYVCBhcyBHLCBidWZmZXJzIGFzIEgsIGRldGFjaCBhcyBJLCBKT0lOIGFzIEosIHRha2UgYXMgSywgZm9yayBhcyBMLCBjYW5jZWwgYXMgTSwgY2FsbCBhcyBOLCBhY3Rpb25DaGFubmVsIGFzIE8sIFBVVCBhcyBQLCBzbGlkaW5nIGFzIFEsIFJBQ0UgYXMgUiwgU0VMRUNUIGFzIFMsIFRBS0UgYXMgVCwgZGVsYXkgYXMgVSwgcmFjZSBhcyBWLCBlZmZlY3RUeXBlcyBhcyBXLCB0YWtlTWF5YmUgYXMgWCwgcHV0IGFzIFksIHB1dFJlc29sdmUgYXMgWiwgYWxsIGFzIF8sIENQUyBhcyBhLCBjcHMgYXMgYTAsIHNwYXduIGFzIGExLCBqb2luIGFzIGEyLCBzZWxlY3QgYXMgYTMsIGNhbmNlbGxlZCBhcyBhNCwgZmx1c2ggYXMgYTUsIGdldENvbnRleHQgYXMgYTYsIHNldENvbnRleHQgYXMgYTcsIENBTkNFTCBhcyBiLCBjaGVjayBhcyBjLCBBQ1RJT05fQ0hBTk5FTCBhcyBkLCBleHBhbmRpbmcgYXMgZSwgQ0FOQ0VMTEVEIGFzIGYsIEZMVVNIIGFzIGcsIFNFVF9DT05URVhUIGFzIGgsIGludGVybmFsRXJyIGFzIGksIGdldE1ldGFJbmZvIGFzIGosIGtUcnVlIGFzIGssIGNyZWF0ZUFsbFN0eWxlQ2hpbGRDYWxsYmFja3MgYXMgbCwgY3JlYXRlRW1wdHlBcnJheSBhcyBtLCBub25lIGFzIG4sIG9uY2UgYXMgbywgYXNzaWduV2l0aFN5bWJvbHMgYXMgcCwgbWFrZUl0ZXJhdG9yIGFzIHEsIHJlbW92ZSBhcyByLCBzaG91bGRDb21wbGV0ZSBhcyBzLCBub29wIGFzIHQsIGZsYXRNYXAgYXMgdSwgZ2V0TG9jYXRpb24gYXMgdiwgY3JlYXRlU2V0Q29udGV4dFdhcm5pbmcgYXMgdywgYXN5bmNJdGVyYXRvclN5bWJvbCBhcyB4LCBzaG91bGRDYW5jZWwgYXMgeSwgc2hvdWxkVGVybWluYXRlIGFzIHogfTtcbiIsImZ1bmN0aW9uIGRlZmVycmVkKCkge1xuICB2YXIgZGVmID0ge307XG4gIGRlZi5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGRlZi5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICBkZWYucmVqZWN0ID0gcmVqZWN0O1xuICB9KTtcbiAgcmV0dXJuIGRlZjtcbn1cbmZ1bmN0aW9uIGFycmF5T2ZEZWZlcnJlZChsZW5ndGgpIHtcbiAgdmFyIGFyciA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBhcnIucHVzaChkZWZlcnJlZCgpKTtcbiAgfVxuXG4gIHJldHVybiBhcnI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmVycmVkO1xuZXhwb3J0IHsgYXJyYXlPZkRlZmVycmVkIH07XG4iLCJpbXBvcnQgeyBDSEFOTkVMX0VORF9UWVBFLCBNVUxUSUNBU1QsIE1BVENILCBTQUdBX0FDVElPTiwgQ0FOQ0VMLCBTRUxGX0NBTkNFTExBVElPTiwgVEVSTUlOQVRFLCBUQVNLLCBUQVNLX0NBTkNFTCwgSU8gfSBmcm9tICdAcmVkdXgtc2FnYS9zeW1ib2xzJztcbmV4cG9ydCB7IENBTkNFTCwgU0FHQV9MT0NBVElPTiB9IGZyb20gJ0ByZWR1eC1zYWdhL3N5bWJvbHMnO1xuaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UnO1xuaW1wb3J0IHsgc3RyaW5nIGFzIHN0cmluZyQxLCBhcnJheSBhcyBhcnJheSQxLCBzdHJpbmdhYmxlRnVuYywgZnVuYywgc3ltYm9sIGFzIHN5bWJvbCQxLCBidWZmZXIsIG5vdFVuZGVmLCBwcm9taXNlLCBpdGVyYXRvciwgdW5kZWYsIG9iamVjdCwgY2hhbm5lbCBhcyBjaGFubmVsJDEgfSBmcm9tICdAcmVkdXgtc2FnYS9pcyc7XG5pbXBvcnQgeyBrIGFzIGtUcnVlLCBlIGFzIGV4cGFuZGluZywgYyBhcyBjaGVjaywgbyBhcyBvbmNlLCByIGFzIHJlbW92ZSwgbiBhcyBub25lLCBpIGFzIGludGVybmFsRXJyLCBUIGFzIFRBS0UsIFAgYXMgUFVULCBBIGFzIEFMTCwgUiBhcyBSQUNFLCBDIGFzIENBTEwsIGEgYXMgQ1BTLCBGIGFzIEZPUkssIEogYXMgSk9JTiwgYiBhcyBDQU5DRUwkMSwgUyBhcyBTRUxFQ1QsIGQgYXMgQUNUSU9OX0NIQU5ORUwsIGYgYXMgQ0FOQ0VMTEVEJDEsIGcgYXMgRkxVU0gsIEcgYXMgR0VUX0NPTlRFWFQsIGggYXMgU0VUX0NPTlRFWFQsIGogYXMgZ2V0TWV0YUluZm8sIGwgYXMgY3JlYXRlQWxsU3R5bGVDaGlsZENhbGxiYWNrcywgbSBhcyBjcmVhdGVFbXB0eUFycmF5LCBwIGFzIGFzc2lnbldpdGhTeW1ib2xzLCBxIGFzIG1ha2VJdGVyYXRvciwgcyBhcyBzaG91bGRDb21wbGV0ZSwgdCBhcyBub29wLCB1IGFzIGZsYXRNYXAsIHYgYXMgZ2V0TG9jYXRpb24sIHcgYXMgY3JlYXRlU2V0Q29udGV4dFdhcm5pbmcsIHggYXMgYXN5bmNJdGVyYXRvclN5bWJvbCwgeSBhcyBzaG91bGRDYW5jZWwsIHogYXMgc2hvdWxkVGVybWluYXRlLCBCIGFzIGxvZ0Vycm9yLCBEIGFzIHdyYXBTYWdhRGlzcGF0Y2gsIEUgYXMgaWRlbnRpdHkgfSBmcm9tICcuL2lvLTZkZTE1NmYzLmpzJztcbmV4cG9ydCB7IEggYXMgYnVmZmVycywgSSBhcyBkZXRhY2ggfSBmcm9tICcuL2lvLTZkZTE1NmYzLmpzJztcbmltcG9ydCB7IGNvbXBvc2UgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgZGVmZXJyZWQgZnJvbSAnQHJlZHV4LXNhZ2EvZGVmZXJyZWQnO1xuaW1wb3J0ICdAcmVkdXgtc2FnYS9kZWxheS1wJztcblxudmFyIHF1ZXVlID0gW107XG4vKipcbiAgVmFyaWFibGUgdG8gaG9sZCBhIGNvdW50aW5nIHNlbWFwaG9yZVxuICAtIEluY3JlbWVudGluZyBhZGRzIGEgbG9jayBhbmQgcHV0cyB0aGUgc2NoZWR1bGVyIGluIGEgYHN1c3BlbmRlZGAgc3RhdGUgKGlmIGl0J3Mgbm90XG4gICAgYWxyZWFkeSBzdXNwZW5kZWQpXG4gIC0gRGVjcmVtZW50aW5nIHJlbGVhc2VzIGEgbG9jay4gWmVybyBsb2NrcyBwdXRzIHRoZSBzY2hlZHVsZXIgaW4gYSBgcmVsZWFzZWRgIHN0YXRlLiBUaGlzXG4gICAgdHJpZ2dlcnMgZmx1c2hpbmcgdGhlIHF1ZXVlZCB0YXNrcy5cbioqL1xuXG52YXIgc2VtYXBob3JlID0gMDtcbi8qKlxuICBFeGVjdXRlcyBhIHRhc2sgJ2F0b21pY2FsbHknLiBUYXNrcyBzY2hlZHVsZWQgZHVyaW5nIHRoaXMgZXhlY3V0aW9uIHdpbGwgYmUgcXVldWVkXG4gIGFuZCBmbHVzaGVkIGFmdGVyIHRoaXMgdGFzayBoYXMgZmluaXNoZWQgKGFzc3VtaW5nIHRoZSBzY2hlZHVsZXIgZW5kdXAgaW4gYSByZWxlYXNlZFxuICBzdGF0ZSkuXG4qKi9cblxuZnVuY3Rpb24gZXhlYyh0YXNrKSB7XG4gIHRyeSB7XG4gICAgc3VzcGVuZCgpO1xuICAgIHRhc2soKTtcbiAgfSBmaW5hbGx5IHtcbiAgICByZWxlYXNlKCk7XG4gIH1cbn1cbi8qKlxuICBFeGVjdXRlcyBvciBxdWV1ZXMgYSB0YXNrIGRlcGVuZGluZyBvbiB0aGUgc3RhdGUgb2YgdGhlIHNjaGVkdWxlciAoYHN1c3BlbmRlZGAgb3IgYHJlbGVhc2VkYClcbioqL1xuXG5cbmZ1bmN0aW9uIGFzYXAodGFzaykge1xuICBxdWV1ZS5wdXNoKHRhc2spO1xuXG4gIGlmICghc2VtYXBob3JlKSB7XG4gICAgc3VzcGVuZCgpO1xuICAgIGZsdXNoKCk7XG4gIH1cbn1cbi8qKlxuICogUHV0cyB0aGUgc2NoZWR1bGVyIGluIGEgYHN1c3BlbmRlZGAgc3RhdGUgYW5kIGV4ZWN1dGVzIGEgdGFzayBpbW1lZGlhdGVseS5cbiAqL1xuXG5mdW5jdGlvbiBpbW1lZGlhdGVseSh0YXNrKSB7XG4gIHRyeSB7XG4gICAgc3VzcGVuZCgpO1xuICAgIHJldHVybiB0YXNrKCk7XG4gIH0gZmluYWxseSB7XG4gICAgZmx1c2goKTtcbiAgfVxufVxuLyoqXG4gIFB1dHMgdGhlIHNjaGVkdWxlciBpbiBhIGBzdXNwZW5kZWRgIHN0YXRlLiBTY2hlZHVsZWQgdGFza3Mgd2lsbCBiZSBxdWV1ZWQgdW50aWwgdGhlXG4gIHNjaGVkdWxlciBpcyByZWxlYXNlZC5cbioqL1xuXG5mdW5jdGlvbiBzdXNwZW5kKCkge1xuICBzZW1hcGhvcmUrKztcbn1cbi8qKlxuICBQdXRzIHRoZSBzY2hlZHVsZXIgaW4gYSBgcmVsZWFzZWRgIHN0YXRlLlxuKiovXG5cblxuZnVuY3Rpb24gcmVsZWFzZSgpIHtcbiAgc2VtYXBob3JlLS07XG59XG4vKipcbiAgUmVsZWFzZXMgdGhlIGN1cnJlbnQgbG9jay4gRXhlY3V0ZXMgYWxsIHF1ZXVlZCB0YXNrcyBpZiB0aGUgc2NoZWR1bGVyIGlzIGluIHRoZSByZWxlYXNlZCBzdGF0ZS5cbioqL1xuXG5cbmZ1bmN0aW9uIGZsdXNoKCkge1xuICByZWxlYXNlKCk7XG4gIHZhciB0YXNrO1xuXG4gIHdoaWxlICghc2VtYXBob3JlICYmICh0YXNrID0gcXVldWUuc2hpZnQoKSkgIT09IHVuZGVmaW5lZCkge1xuICAgIGV4ZWModGFzayk7XG4gIH1cbn1cblxudmFyIGFycmF5ID0gZnVuY3Rpb24gYXJyYXkocGF0dGVybnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHJldHVybiBwYXR0ZXJucy5zb21lKGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gbWF0Y2hlcihwKShpbnB1dCk7XG4gICAgfSk7XG4gIH07XG59O1xudmFyIHByZWRpY2F0ZSA9IGZ1bmN0aW9uIHByZWRpY2F0ZShfcHJlZGljYXRlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICByZXR1cm4gX3ByZWRpY2F0ZShpbnB1dCk7XG4gIH07XG59O1xudmFyIHN0cmluZyA9IGZ1bmN0aW9uIHN0cmluZyhwYXR0ZXJuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQudHlwZSA9PT0gU3RyaW5nKHBhdHRlcm4pO1xuICB9O1xufTtcbnZhciBzeW1ib2wgPSBmdW5jdGlvbiBzeW1ib2wocGF0dGVybikge1xuICByZXR1cm4gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnR5cGUgPT09IHBhdHRlcm47XG4gIH07XG59O1xudmFyIHdpbGRjYXJkID0gZnVuY3Rpb24gd2lsZGNhcmQoKSB7XG4gIHJldHVybiBrVHJ1ZTtcbn07XG5mdW5jdGlvbiBtYXRjaGVyKHBhdHRlcm4pIHtcbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIHZhciBtYXRjaGVyQ3JlYXRvciA9IHBhdHRlcm4gPT09ICcqJyA/IHdpbGRjYXJkIDogc3RyaW5nJDEocGF0dGVybikgPyBzdHJpbmcgOiBhcnJheSQxKHBhdHRlcm4pID8gYXJyYXkgOiBzdHJpbmdhYmxlRnVuYyhwYXR0ZXJuKSA/IHN0cmluZyA6IGZ1bmMocGF0dGVybikgPyBwcmVkaWNhdGUgOiBzeW1ib2wkMShwYXR0ZXJuKSA/IHN5bWJvbCA6IG51bGw7XG5cbiAgaWYgKG1hdGNoZXJDcmVhdG9yID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwYXR0ZXJuOiBcIiArIHBhdHRlcm4pO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXJDcmVhdG9yKHBhdHRlcm4pO1xufVxuXG52YXIgRU5EID0ge1xuICB0eXBlOiBDSEFOTkVMX0VORF9UWVBFXG59O1xudmFyIGlzRW5kID0gZnVuY3Rpb24gaXNFbmQoYSkge1xuICByZXR1cm4gYSAmJiBhLnR5cGUgPT09IENIQU5ORUxfRU5EX1RZUEU7XG59O1xudmFyIENMT1NFRF9DSEFOTkVMX1dJVEhfVEFLRVJTID0gJ0Nhbm5vdCBoYXZlIGEgY2xvc2VkIGNoYW5uZWwgd2l0aCBwZW5kaW5nIHRha2Vycyc7XG52YXIgSU5WQUxJRF9CVUZGRVIgPSAnaW52YWxpZCBidWZmZXIgcGFzc2VkIHRvIGNoYW5uZWwgZmFjdG9yeSBmdW5jdGlvbic7XG52YXIgVU5ERUZJTkVEX0lOUFVUX0VSUk9SID0gXCJTYWdhIG9yIGNoYW5uZWwgd2FzIHByb3ZpZGVkIHdpdGggYW4gdW5kZWZpbmVkIGFjdGlvblxcbkhpbnRzOlxcbiAgLSBjaGVjayB0aGF0IHlvdXIgQWN0aW9uIENyZWF0b3IgcmV0dXJucyBhIG5vbi11bmRlZmluZWQgdmFsdWVcXG4gIC0gaWYgdGhlIFNhZ2Egd2FzIHN0YXJ0ZWQgdXNpbmcgcnVuU2FnYSwgY2hlY2sgdGhhdCB5b3VyIHN1YnNjcmliZSBzb3VyY2UgcHJvdmlkZXMgdGhlIGFjdGlvbiB0byBpdHMgbGlzdGVuZXJzXCI7XG5mdW5jdGlvbiBjaGFubmVsKGJ1ZmZlciQxKSB7XG4gIGlmIChidWZmZXIkMSA9PT0gdm9pZCAwKSB7XG4gICAgYnVmZmVyJDEgPSBleHBhbmRpbmcoKTtcbiAgfVxuXG4gIHZhciBjbG9zZWQgPSBmYWxzZTtcbiAgdmFyIHRha2VycyA9IFtdO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2hlY2soYnVmZmVyJDEsIGJ1ZmZlciwgSU5WQUxJRF9CVUZGRVIpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tGb3JiaWRkZW5TdGF0ZXMoKSB7XG4gICAgaWYgKGNsb3NlZCAmJiB0YWtlcnMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBpbnRlcm5hbEVycihDTE9TRURfQ0hBTk5FTF9XSVRIX1RBS0VSUyk7XG4gICAgfVxuXG4gICAgaWYgKHRha2Vycy5sZW5ndGggJiYgIWJ1ZmZlciQxLmlzRW1wdHkoKSkge1xuICAgICAgdGhyb3cgaW50ZXJuYWxFcnIoJ0Nhbm5vdCBoYXZlIHBlbmRpbmcgdGFrZXJzIHdpdGggbm9uIGVtcHR5IGJ1ZmZlcicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHB1dChpbnB1dCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjaGVja0ZvcmJpZGRlblN0YXRlcygpO1xuICAgICAgY2hlY2soaW5wdXQsIG5vdFVuZGVmLCBVTkRFRklORURfSU5QVVRfRVJST1IpO1xuICAgIH1cblxuICAgIGlmIChjbG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGFrZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZmZlciQxLnB1dChpbnB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGNiID0gdGFrZXJzLnNoaWZ0KCk7XG4gICAgY2IoaW5wdXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGFrZShjYikge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjaGVja0ZvcmJpZGRlblN0YXRlcygpO1xuICAgICAgY2hlY2soY2IsIGZ1bmMsIFwiY2hhbm5lbC50YWtlJ3MgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIGlmIChjbG9zZWQgJiYgYnVmZmVyJDEuaXNFbXB0eSgpKSB7XG4gICAgICBjYihFTkQpO1xuICAgIH0gZWxzZSBpZiAoIWJ1ZmZlciQxLmlzRW1wdHkoKSkge1xuICAgICAgY2IoYnVmZmVyJDEudGFrZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFrZXJzLnB1c2goY2IpO1xuXG4gICAgICBjYi5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZSh0YWtlcnMsIGNiKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2goY2IpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY2hlY2tGb3JiaWRkZW5TdGF0ZXMoKTtcbiAgICAgIGNoZWNrKGNiLCBmdW5jLCBcImNoYW5uZWwuZmx1c2gnIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICBpZiAoY2xvc2VkICYmIGJ1ZmZlciQxLmlzRW1wdHkoKSkge1xuICAgICAgY2IoRU5EKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYihidWZmZXIkMS5mbHVzaCgpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjaGVja0ZvcmJpZGRlblN0YXRlcygpO1xuICAgIH1cblxuICAgIGlmIChjbG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjbG9zZWQgPSB0cnVlO1xuICAgIHZhciBhcnIgPSB0YWtlcnM7XG4gICAgdGFrZXJzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgdGFrZXIgPSBhcnJbaV07XG4gICAgICB0YWtlcihFTkQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdGFrZTogdGFrZSxcbiAgICBwdXQ6IHB1dCxcbiAgICBmbHVzaDogZmx1c2gsXG4gICAgY2xvc2U6IGNsb3NlXG4gIH07XG59XG5mdW5jdGlvbiBldmVudENoYW5uZWwoc3Vic2NyaWJlLCBidWZmZXIpIHtcbiAgaWYgKGJ1ZmZlciA9PT0gdm9pZCAwKSB7XG4gICAgYnVmZmVyID0gbm9uZSgpO1xuICB9XG5cbiAgdmFyIGNsb3NlZCA9IGZhbHNlO1xuICB2YXIgdW5zdWJzY3JpYmU7XG4gIHZhciBjaGFuID0gY2hhbm5lbChidWZmZXIpO1xuXG4gIHZhciBjbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGlmIChjbG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjbG9zZWQgPSB0cnVlO1xuXG4gICAgaWYgKGZ1bmModW5zdWJzY3JpYmUpKSB7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIGNoYW4uY2xvc2UoKTtcbiAgfTtcblxuICB1bnN1YnNjcmliZSA9IHN1YnNjcmliZShmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAoaXNFbmQoaW5wdXQpKSB7XG4gICAgICBjbG9zZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNoYW4ucHV0KGlucHV0KTtcbiAgfSk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaGVjayh1bnN1YnNjcmliZSwgZnVuYywgJ2luIGV2ZW50Q2hhbm5lbDogc3Vic2NyaWJlIHNob3VsZCByZXR1cm4gYSBmdW5jdGlvbiB0byB1bnN1YnNjcmliZScpO1xuICB9XG5cbiAgdW5zdWJzY3JpYmUgPSBvbmNlKHVuc3Vic2NyaWJlKTtcblxuICBpZiAoY2xvc2VkKSB7XG4gICAgdW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdGFrZTogY2hhbi50YWtlLFxuICAgIGZsdXNoOiBjaGFuLmZsdXNoLFxuICAgIGNsb3NlOiBjbG9zZVxuICB9O1xufVxuZnVuY3Rpb24gbXVsdGljYXN0Q2hhbm5lbCgpIHtcbiAgdmFyIF9yZWY7XG5cbiAgdmFyIGNsb3NlZCA9IGZhbHNlO1xuICB2YXIgY3VycmVudFRha2VycyA9IFtdO1xuICB2YXIgbmV4dFRha2VycyA9IGN1cnJlbnRUYWtlcnM7XG5cbiAgZnVuY3Rpb24gY2hlY2tGb3JiaWRkZW5TdGF0ZXMoKSB7XG4gICAgaWYgKGNsb3NlZCAmJiBuZXh0VGFrZXJzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgaW50ZXJuYWxFcnIoQ0xPU0VEX0NIQU5ORUxfV0lUSF9UQUtFUlMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbnN1cmVDYW5NdXRhdGVOZXh0VGFrZXJzID0gZnVuY3Rpb24gZW5zdXJlQ2FuTXV0YXRlTmV4dFRha2VycygpIHtcbiAgICBpZiAobmV4dFRha2VycyAhPT0gY3VycmVudFRha2Vycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5leHRUYWtlcnMgPSBjdXJyZW50VGFrZXJzLnNsaWNlKCk7XG4gIH07XG5cbiAgdmFyIGNsb3NlID0gZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrRm9yYmlkZGVuU3RhdGVzKCk7XG4gICAgfVxuXG4gICAgY2xvc2VkID0gdHJ1ZTtcbiAgICB2YXIgdGFrZXJzID0gY3VycmVudFRha2VycyA9IG5leHRUYWtlcnM7XG4gICAgbmV4dFRha2VycyA9IFtdO1xuICAgIHRha2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0YWtlcikge1xuICAgICAgdGFrZXIoRU5EKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gX3JlZiA9IHt9LCBfcmVmW01VTFRJQ0FTVF0gPSB0cnVlLCBfcmVmLnB1dCA9IGZ1bmN0aW9uIHB1dChpbnB1dCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjaGVja0ZvcmJpZGRlblN0YXRlcygpO1xuICAgICAgY2hlY2soaW5wdXQsIG5vdFVuZGVmLCBVTkRFRklORURfSU5QVVRfRVJST1IpO1xuICAgIH1cblxuICAgIGlmIChjbG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNFbmQoaW5wdXQpKSB7XG4gICAgICBjbG9zZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0YWtlcnMgPSBjdXJyZW50VGFrZXJzID0gbmV4dFRha2VycztcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0YWtlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciB0YWtlciA9IHRha2Vyc1tpXTtcblxuICAgICAgaWYgKHRha2VyW01BVENIXShpbnB1dCkpIHtcbiAgICAgICAgdGFrZXIuY2FuY2VsKCk7XG4gICAgICAgIHRha2VyKGlucHV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIF9yZWYudGFrZSA9IGZ1bmN0aW9uIHRha2UoY2IsIG1hdGNoZXIpIHtcbiAgICBpZiAobWF0Y2hlciA9PT0gdm9pZCAwKSB7XG4gICAgICBtYXRjaGVyID0gd2lsZGNhcmQ7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrRm9yYmlkZGVuU3RhdGVzKCk7XG4gICAgfVxuXG4gICAgaWYgKGNsb3NlZCkge1xuICAgICAgY2IoRU5EKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYltNQVRDSF0gPSBtYXRjaGVyO1xuICAgIGVuc3VyZUNhbk11dGF0ZU5leHRUYWtlcnMoKTtcbiAgICBuZXh0VGFrZXJzLnB1c2goY2IpO1xuICAgIGNiLmNhbmNlbCA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgICAgZW5zdXJlQ2FuTXV0YXRlTmV4dFRha2VycygpO1xuICAgICAgcmVtb3ZlKG5leHRUYWtlcnMsIGNiKTtcbiAgICB9KTtcbiAgfSwgX3JlZi5jbG9zZSA9IGNsb3NlLCBfcmVmO1xufVxuZnVuY3Rpb24gc3RkQ2hhbm5lbCgpIHtcbiAgdmFyIGNoYW4gPSBtdWx0aWNhc3RDaGFubmVsKCk7XG4gIHZhciBwdXQgPSBjaGFuLnB1dDtcblxuICBjaGFuLnB1dCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmIChpbnB1dFtTQUdBX0FDVElPTl0pIHtcbiAgICAgIHB1dChpbnB1dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICBwdXQoaW5wdXQpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBjaGFuO1xufVxuXG52YXIgUlVOTklORyA9IDA7XG52YXIgQ0FOQ0VMTEVEID0gMTtcbnZhciBBQk9SVEVEID0gMjtcbnZhciBET05FID0gMztcblxuZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UocHJvbWlzZSwgY2IpIHtcbiAgdmFyIGNhbmNlbFByb21pc2UgPSBwcm9taXNlW0NBTkNFTF07XG5cbiAgaWYgKGZ1bmMoY2FuY2VsUHJvbWlzZSkpIHtcbiAgICBjYi5jYW5jZWwgPSBjYW5jZWxQcm9taXNlO1xuICB9XG5cbiAgcHJvbWlzZS50aGVuKGNiLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBjYihlcnJvciwgdHJ1ZSk7XG4gIH0pO1xufVxuXG52YXIgY3VycmVudCA9IDA7XG52YXIgbmV4dFNhZ2FJZCA9IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiArK2N1cnJlbnQ7XG59KTtcblxudmFyIF9lZmZlY3RSdW5uZXJNYXA7XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yTWV0YUluZm8oaXRlcmF0b3IsIGZuKSB7XG4gIGlmIChpdGVyYXRvci5pc1NhZ2FJdGVyYXRvcikge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBpdGVyYXRvci5tZXRhLm5hbWVcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGdldE1ldGFJbmZvKGZuKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGFza0l0ZXJhdG9yKF9yZWYpIHtcbiAgdmFyIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsXG4gICAgICBmbiA9IF9yZWYuZm4sXG4gICAgICBhcmdzID0gX3JlZi5hcmdzO1xuXG4gIC8vIGNhdGNoIHN5bmNocm9ub3VzIGZhaWx1cmVzOyBzZWUgIzE1MiBhbmQgIzQ0MVxuICB0cnkge1xuICAgIHZhciByZXN1bHQgPSBmbi5hcHBseShjb250ZXh0LCBhcmdzKTsgLy8gaS5lLiBhIGdlbmVyYXRvciBmdW5jdGlvbiByZXR1cm5zIGFuIGl0ZXJhdG9yXG5cbiAgICBpZiAoaXRlcmF0b3IocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB2YXIgcmVzb2x2ZWQgPSBmYWxzZTtcblxuICAgIHZhciBuZXh0ID0gZnVuY3Rpb24gbmV4dChhcmcpIHtcbiAgICAgIGlmICghcmVzb2x2ZWQpIHtcbiAgICAgICAgcmVzb2x2ZWQgPSB0cnVlOyAvLyBPbmx5IHByb21pc2VzIHJldHVybmVkIGZyb20gZm9yayB3aWxsIGJlIGludGVycHJldGVkLiBTZWUgIzE1NzNcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiByZXN1bHQsXG4gICAgICAgICAgZG9uZTogIXByb21pc2UocmVzdWx0KVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogYXJnLFxuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIG1ha2VJdGVyYXRvcihuZXh0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gZG8gbm90IGJ1YmJsZSB1cCBzeW5jaHJvbm91cyBmYWlsdXJlcyBmb3IgZGV0YWNoZWQgZm9ya3NcbiAgICAvLyBpbnN0ZWFkIGNyZWF0ZSBhIGZhaWxlZCB0YXNrLiBTZWUgIzE1MiBhbmQgIzQ0MVxuICAgIHJldHVybiBtYWtlSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJ1blB1dEVmZmVjdChlbnYsIF9yZWYyLCBjYikge1xuICB2YXIgY2hhbm5lbCA9IF9yZWYyLmNoYW5uZWwsXG4gICAgICBhY3Rpb24gPSBfcmVmMi5hY3Rpb24sXG4gICAgICByZXNvbHZlID0gX3JlZjIucmVzb2x2ZTtcblxuICAvKipcbiAgIFNjaGVkdWxlIHRoZSBwdXQgaW4gY2FzZSBhbm90aGVyIHNhZ2EgaXMgaG9sZGluZyBhIGxvY2suXG4gICBUaGUgcHV0IHdpbGwgYmUgZXhlY3V0ZWQgYXRvbWljYWxseS4gaWUgbmVzdGVkIHB1dHMgd2lsbCBleGVjdXRlIGFmdGVyXG4gICB0aGlzIHB1dCBoYXMgdGVybWluYXRlZC5cbiAgICoqL1xuICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IChjaGFubmVsID8gY2hhbm5lbC5wdXQgOiBlbnYuZGlzcGF0Y2gpKGFjdGlvbik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNiKGVycm9yLCB0cnVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocmVzb2x2ZSAmJiBwcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgIHJlc29sdmVQcm9taXNlKHJlc3VsdCwgY2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYihyZXN1bHQpO1xuICAgIH1cbiAgfSk7IC8vIFB1dCBlZmZlY3RzIGFyZSBub24gY2FuY2VsbGFibGVzXG59XG5cbmZ1bmN0aW9uIHJ1blRha2VFZmZlY3QoZW52LCBfcmVmMywgY2IpIHtcbiAgdmFyIF9yZWYzJGNoYW5uZWwgPSBfcmVmMy5jaGFubmVsLFxuICAgICAgY2hhbm5lbCA9IF9yZWYzJGNoYW5uZWwgPT09IHZvaWQgMCA/IGVudi5jaGFubmVsIDogX3JlZjMkY2hhbm5lbCxcbiAgICAgIHBhdHRlcm4gPSBfcmVmMy5wYXR0ZXJuLFxuICAgICAgbWF5YmUgPSBfcmVmMy5tYXliZTtcblxuICB2YXIgdGFrZUNiID0gZnVuY3Rpb24gdGFrZUNiKGlucHV0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGNiKGlucHV0LCB0cnVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNFbmQoaW5wdXQpICYmICFtYXliZSkge1xuICAgICAgY2IoVEVSTUlOQVRFKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYihpbnB1dCk7XG4gIH07XG5cbiAgdHJ5IHtcbiAgICBjaGFubmVsLnRha2UodGFrZUNiLCBub3RVbmRlZihwYXR0ZXJuKSA/IG1hdGNoZXIocGF0dGVybikgOiBudWxsKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2IoZXJyLCB0cnVlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjYi5jYW5jZWwgPSB0YWtlQ2IuY2FuY2VsO1xufVxuXG5mdW5jdGlvbiBydW5DYWxsRWZmZWN0KGVudiwgX3JlZjQsIGNiLCBfcmVmNSkge1xuICB2YXIgY29udGV4dCA9IF9yZWY0LmNvbnRleHQsXG4gICAgICBmbiA9IF9yZWY0LmZuLFxuICAgICAgYXJncyA9IF9yZWY0LmFyZ3M7XG4gIHZhciB0YXNrID0gX3JlZjUudGFzaztcblxuICAvLyBjYXRjaCBzeW5jaHJvbm91cyBmYWlsdXJlczsgc2VlICMxNTJcbiAgdHJ5IHtcbiAgICB2YXIgcmVzdWx0ID0gZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XG5cbiAgICBpZiAocHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICByZXNvbHZlUHJvbWlzZShyZXN1bHQsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXRlcmF0b3IocmVzdWx0KSkge1xuICAgICAgLy8gcmVzb2x2ZSBpdGVyYXRvclxuICAgICAgcHJvYyhlbnYsIHJlc3VsdCwgdGFzay5jb250ZXh0LCBjdXJyZW50LCBnZXRNZXRhSW5mbyhmbiksXG4gICAgICAvKiBpc1Jvb3QgKi9cbiAgICAgIGZhbHNlLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2IocmVzdWx0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjYihlcnJvciwgdHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcnVuQ1BTRWZmZWN0KGVudiwgX3JlZjYsIGNiKSB7XG4gIHZhciBjb250ZXh0ID0gX3JlZjYuY29udGV4dCxcbiAgICAgIGZuID0gX3JlZjYuZm4sXG4gICAgICBhcmdzID0gX3JlZjYuYXJncztcblxuICAvLyBDUFMgKGllIG5vZGUgc3R5bGUgZnVuY3Rpb25zKSBjYW4gZGVmaW5lIHRoZWlyIG93biBjYW5jZWxsYXRpb24gbG9naWNcbiAgLy8gYnkgc2V0dGluZyBjYW5jZWwgZmllbGQgb24gdGhlIGNiXG4gIC8vIGNhdGNoIHN5bmNocm9ub3VzIGZhaWx1cmVzOyBzZWUgIzE1MlxuICB0cnkge1xuICAgIHZhciBjcHNDYiA9IGZ1bmN0aW9uIGNwc0NiKGVyciwgcmVzKSB7XG4gICAgICBpZiAodW5kZWYoZXJyKSkge1xuICAgICAgICBjYihyZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IoZXJyLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm4uYXBwbHkoY29udGV4dCwgYXJncy5jb25jYXQoY3BzQ2IpKTtcblxuICAgIGlmIChjcHNDYi5jYW5jZWwpIHtcbiAgICAgIGNiLmNhbmNlbCA9IGNwc0NiLmNhbmNlbDtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY2IoZXJyb3IsIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJ1bkZvcmtFZmZlY3QoZW52LCBfcmVmNywgY2IsIF9yZWY4KSB7XG4gIHZhciBjb250ZXh0ID0gX3JlZjcuY29udGV4dCxcbiAgICAgIGZuID0gX3JlZjcuZm4sXG4gICAgICBhcmdzID0gX3JlZjcuYXJncyxcbiAgICAgIGRldGFjaGVkID0gX3JlZjcuZGV0YWNoZWQ7XG4gIHZhciBwYXJlbnQgPSBfcmVmOC50YXNrO1xuICB2YXIgdGFza0l0ZXJhdG9yID0gY3JlYXRlVGFza0l0ZXJhdG9yKHtcbiAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgIGZuOiBmbixcbiAgICBhcmdzOiBhcmdzXG4gIH0pO1xuICB2YXIgbWV0YSA9IGdldEl0ZXJhdG9yTWV0YUluZm8odGFza0l0ZXJhdG9yLCBmbik7XG4gIGltbWVkaWF0ZWx5KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2hpbGQgPSBwcm9jKGVudiwgdGFza0l0ZXJhdG9yLCBwYXJlbnQuY29udGV4dCwgY3VycmVudCwgbWV0YSwgZGV0YWNoZWQsIHVuZGVmaW5lZCk7XG5cbiAgICBpZiAoZGV0YWNoZWQpIHtcbiAgICAgIGNiKGNoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNoaWxkLmlzUnVubmluZygpKSB7XG4gICAgICAgIHBhcmVudC5xdWV1ZS5hZGRUYXNrKGNoaWxkKTtcbiAgICAgICAgY2IoY2hpbGQpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZC5pc0Fib3J0ZWQoKSkge1xuICAgICAgICBwYXJlbnQucXVldWUuYWJvcnQoY2hpbGQuZXJyb3IoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYihjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9KTsgLy8gRm9yayBlZmZlY3RzIGFyZSBub24gY2FuY2VsbGFibGVzXG59XG5cbmZ1bmN0aW9uIHJ1bkpvaW5FZmZlY3QoZW52LCB0YXNrT3JUYXNrcywgY2IsIF9yZWY5KSB7XG4gIHZhciB0YXNrID0gX3JlZjkudGFzaztcblxuICB2YXIgam9pblNpbmdsZVRhc2sgPSBmdW5jdGlvbiBqb2luU2luZ2xlVGFzayh0YXNrVG9Kb2luLCBjYikge1xuICAgIGlmICh0YXNrVG9Kb2luLmlzUnVubmluZygpKSB7XG4gICAgICB2YXIgam9pbmVyID0ge1xuICAgICAgICB0YXNrOiB0YXNrLFxuICAgICAgICBjYjogY2JcbiAgICAgIH07XG5cbiAgICAgIGNiLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRhc2tUb0pvaW4uaXNSdW5uaW5nKCkpIHJlbW92ZSh0YXNrVG9Kb2luLmpvaW5lcnMsIGpvaW5lcik7XG4gICAgICB9O1xuXG4gICAgICB0YXNrVG9Kb2luLmpvaW5lcnMucHVzaChqb2luZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGFza1RvSm9pbi5pc0Fib3J0ZWQoKSkge1xuICAgICAgICBjYih0YXNrVG9Kb2luLmVycm9yKCksIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IodGFza1RvSm9pbi5yZXN1bHQoKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGlmIChhcnJheSQxKHRhc2tPclRhc2tzKSkge1xuICAgIGlmICh0YXNrT3JUYXNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNiKFtdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRDYWxsYmFja3MgPSBjcmVhdGVBbGxTdHlsZUNoaWxkQ2FsbGJhY2tzKHRhc2tPclRhc2tzLCBjYik7XG4gICAgdGFza09yVGFza3MuZm9yRWFjaChmdW5jdGlvbiAodCwgaSkge1xuICAgICAgam9pblNpbmdsZVRhc2sodCwgY2hpbGRDYWxsYmFja3NbaV0pO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGpvaW5TaW5nbGVUYXNrKHRhc2tPclRhc2tzLCBjYik7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FuY2VsU2luZ2xlVGFzayh0YXNrVG9DYW5jZWwpIHtcbiAgaWYgKHRhc2tUb0NhbmNlbC5pc1J1bm5pbmcoKSkge1xuICAgIHRhc2tUb0NhbmNlbC5jYW5jZWwoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBydW5DYW5jZWxFZmZlY3QoZW52LCB0YXNrT3JUYXNrcywgY2IsIF9yZWYxMCkge1xuICB2YXIgdGFzayA9IF9yZWYxMC50YXNrO1xuXG4gIGlmICh0YXNrT3JUYXNrcyA9PT0gU0VMRl9DQU5DRUxMQVRJT04pIHtcbiAgICBjYW5jZWxTaW5nbGVUYXNrKHRhc2spO1xuICB9IGVsc2UgaWYgKGFycmF5JDEodGFza09yVGFza3MpKSB7XG4gICAgdGFza09yVGFza3MuZm9yRWFjaChjYW5jZWxTaW5nbGVUYXNrKTtcbiAgfSBlbHNlIHtcbiAgICBjYW5jZWxTaW5nbGVUYXNrKHRhc2tPclRhc2tzKTtcbiAgfVxuXG4gIGNiKCk7IC8vIGNhbmNlbCBlZmZlY3RzIGFyZSBub24gY2FuY2VsbGFibGVzXG59XG5cbmZ1bmN0aW9uIHJ1bkFsbEVmZmVjdChlbnYsIGVmZmVjdHMsIGNiLCBfcmVmMTEpIHtcbiAgdmFyIGRpZ2VzdEVmZmVjdCA9IF9yZWYxMS5kaWdlc3RFZmZlY3Q7XG4gIHZhciBlZmZlY3RJZCA9IGN1cnJlbnQ7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZWZmZWN0cyk7XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgY2IoYXJyYXkkMShlZmZlY3RzKSA/IFtdIDoge30pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjaGlsZENhbGxiYWNrcyA9IGNyZWF0ZUFsbFN0eWxlQ2hpbGRDYWxsYmFja3MoZWZmZWN0cywgY2IpO1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGRpZ2VzdEVmZmVjdChlZmZlY3RzW2tleV0sIGVmZmVjdElkLCBjaGlsZENhbGxiYWNrc1trZXldLCBrZXkpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcnVuUmFjZUVmZmVjdChlbnYsIGVmZmVjdHMsIGNiLCBfcmVmMTIpIHtcbiAgdmFyIGRpZ2VzdEVmZmVjdCA9IF9yZWYxMi5kaWdlc3RFZmZlY3Q7XG4gIHZhciBlZmZlY3RJZCA9IGN1cnJlbnQ7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZWZmZWN0cyk7XG4gIHZhciByZXNwb25zZSA9IGFycmF5JDEoZWZmZWN0cykgPyBjcmVhdGVFbXB0eUFycmF5KGtleXMubGVuZ3RoKSA6IHt9O1xuICB2YXIgY2hpbGRDYnMgPSB7fTtcbiAgdmFyIGNvbXBsZXRlZCA9IGZhbHNlO1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBjaENiQXRLZXkgPSBmdW5jdGlvbiBjaENiQXRLZXkocmVzLCBpc0Vycikge1xuICAgICAgaWYgKGNvbXBsZXRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0VyciB8fCBzaG91bGRDb21wbGV0ZShyZXMpKSB7XG4gICAgICAgIC8vIFJhY2UgQXV0byBjYW5jZWxsYXRpb25cbiAgICAgICAgY2IuY2FuY2VsKCk7XG4gICAgICAgIGNiKHJlcywgaXNFcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IuY2FuY2VsKCk7XG4gICAgICAgIGNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIHJlc3BvbnNlW2tleV0gPSByZXM7XG4gICAgICAgIGNiKHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY2hDYkF0S2V5LmNhbmNlbCA9IG5vb3A7XG4gICAgY2hpbGRDYnNba2V5XSA9IGNoQ2JBdEtleTtcbiAgfSk7XG5cbiAgY2IuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHByZXZlbnRzIHVubmVjZXNzYXJ5IGNhbmNlbGxhdGlvblxuICAgIGlmICghY29tcGxldGVkKSB7XG4gICAgICBjb21wbGV0ZWQgPSB0cnVlO1xuICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkQ2JzW2tleV0uY2FuY2VsKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoY29tcGxldGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGlnZXN0RWZmZWN0KGVmZmVjdHNba2V5XSwgZWZmZWN0SWQsIGNoaWxkQ2JzW2tleV0sIGtleSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBydW5TZWxlY3RFZmZlY3QoZW52LCBfcmVmMTMsIGNiKSB7XG4gIHZhciBzZWxlY3RvciA9IF9yZWYxMy5zZWxlY3RvcixcbiAgICAgIGFyZ3MgPSBfcmVmMTMuYXJncztcblxuICB0cnkge1xuICAgIHZhciBzdGF0ZSA9IHNlbGVjdG9yLmFwcGx5KHZvaWQgMCwgW2Vudi5nZXRTdGF0ZSgpXS5jb25jYXQoYXJncykpO1xuICAgIGNiKHN0YXRlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjYihlcnJvciwgdHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcnVuQ2hhbm5lbEVmZmVjdChlbnYsIF9yZWYxNCwgY2IpIHtcbiAgdmFyIHBhdHRlcm4gPSBfcmVmMTQucGF0dGVybixcbiAgICAgIGJ1ZmZlciA9IF9yZWYxNC5idWZmZXI7XG4gIHZhciBjaGFuID0gY2hhbm5lbChidWZmZXIpO1xuICB2YXIgbWF0Y2ggPSBtYXRjaGVyKHBhdHRlcm4pO1xuXG4gIHZhciB0YWtlciA9IGZ1bmN0aW9uIHRha2VyKGFjdGlvbikge1xuICAgIGlmICghaXNFbmQoYWN0aW9uKSkge1xuICAgICAgZW52LmNoYW5uZWwudGFrZSh0YWtlciwgbWF0Y2gpO1xuICAgIH1cblxuICAgIGNoYW4ucHV0KGFjdGlvbik7XG4gIH07XG5cbiAgdmFyIGNsb3NlID0gY2hhbi5jbG9zZTtcblxuICBjaGFuLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHRha2VyLmNhbmNlbCgpO1xuICAgIGNsb3NlKCk7XG4gIH07XG5cbiAgZW52LmNoYW5uZWwudGFrZSh0YWtlciwgbWF0Y2gpO1xuICBjYihjaGFuKTtcbn1cblxuZnVuY3Rpb24gcnVuQ2FuY2VsbGVkRWZmZWN0KGVudiwgZGF0YSwgY2IsIF9yZWYxNSkge1xuICB2YXIgdGFzayA9IF9yZWYxNS50YXNrO1xuICBjYih0YXNrLmlzQ2FuY2VsbGVkKCkpO1xufVxuXG5mdW5jdGlvbiBydW5GbHVzaEVmZmVjdChlbnYsIGNoYW5uZWwsIGNiKSB7XG4gIGNoYW5uZWwuZmx1c2goY2IpO1xufVxuXG5mdW5jdGlvbiBydW5HZXRDb250ZXh0RWZmZWN0KGVudiwgcHJvcCwgY2IsIF9yZWYxNikge1xuICB2YXIgdGFzayA9IF9yZWYxNi50YXNrO1xuICBjYih0YXNrLmNvbnRleHRbcHJvcF0pO1xufVxuXG5mdW5jdGlvbiBydW5TZXRDb250ZXh0RWZmZWN0KGVudiwgcHJvcHMsIGNiLCBfcmVmMTcpIHtcbiAgdmFyIHRhc2sgPSBfcmVmMTcudGFzaztcbiAgYXNzaWduV2l0aFN5bWJvbHModGFzay5jb250ZXh0LCBwcm9wcyk7XG4gIGNiKCk7XG59XG5cbnZhciBlZmZlY3RSdW5uZXJNYXAgPSAoX2VmZmVjdFJ1bm5lck1hcCA9IHt9LCBfZWZmZWN0UnVubmVyTWFwW1RBS0VdID0gcnVuVGFrZUVmZmVjdCwgX2VmZmVjdFJ1bm5lck1hcFtQVVRdID0gcnVuUHV0RWZmZWN0LCBfZWZmZWN0UnVubmVyTWFwW0FMTF0gPSBydW5BbGxFZmZlY3QsIF9lZmZlY3RSdW5uZXJNYXBbUkFDRV0gPSBydW5SYWNlRWZmZWN0LCBfZWZmZWN0UnVubmVyTWFwW0NBTExdID0gcnVuQ2FsbEVmZmVjdCwgX2VmZmVjdFJ1bm5lck1hcFtDUFNdID0gcnVuQ1BTRWZmZWN0LCBfZWZmZWN0UnVubmVyTWFwW0ZPUktdID0gcnVuRm9ya0VmZmVjdCwgX2VmZmVjdFJ1bm5lck1hcFtKT0lOXSA9IHJ1bkpvaW5FZmZlY3QsIF9lZmZlY3RSdW5uZXJNYXBbQ0FOQ0VMJDFdID0gcnVuQ2FuY2VsRWZmZWN0LCBfZWZmZWN0UnVubmVyTWFwW1NFTEVDVF0gPSBydW5TZWxlY3RFZmZlY3QsIF9lZmZlY3RSdW5uZXJNYXBbQUNUSU9OX0NIQU5ORUxdID0gcnVuQ2hhbm5lbEVmZmVjdCwgX2VmZmVjdFJ1bm5lck1hcFtDQU5DRUxMRUQkMV0gPSBydW5DYW5jZWxsZWRFZmZlY3QsIF9lZmZlY3RSdW5uZXJNYXBbRkxVU0hdID0gcnVuRmx1c2hFZmZlY3QsIF9lZmZlY3RSdW5uZXJNYXBbR0VUX0NPTlRFWFRdID0gcnVuR2V0Q29udGV4dEVmZmVjdCwgX2VmZmVjdFJ1bm5lck1hcFtTRVRfQ09OVEVYVF0gPSBydW5TZXRDb250ZXh0RWZmZWN0LCBfZWZmZWN0UnVubmVyTWFwKTtcblxuLyoqXG4gVXNlZCB0byB0cmFjayBhIHBhcmVudCB0YXNrIGFuZCBpdHMgZm9ya3NcbiBJbiB0aGUgZm9yayBtb2RlbCwgZm9ya2VkIHRhc2tzIGFyZSBhdHRhY2hlZCBieSBkZWZhdWx0IHRvIHRoZWlyIHBhcmVudFxuIFdlIG1vZGVsIHRoaXMgdXNpbmcgdGhlIGNvbmNlcHQgb2YgUGFyZW50IHRhc2sgJiYgbWFpbiBUYXNrXG4gbWFpbiB0YXNrIGlzIHRoZSBtYWluIGZsb3cgb2YgdGhlIGN1cnJlbnQgR2VuZXJhdG9yLCB0aGUgcGFyZW50IHRhc2tzIGlzIHRoZVxuIGFnZ3JlZ2F0aW9uIG9mIHRoZSBtYWluIHRhc2tzICsgYWxsIGl0cyBmb3JrZWQgdGFza3MuXG4gVGh1cyB0aGUgd2hvbGUgbW9kZWwgcmVwcmVzZW50cyBhbiBleGVjdXRpb24gdHJlZSB3aXRoIG11bHRpcGxlIGJyYW5jaGVzICh2cyB0aGVcbiBsaW5lYXIgZXhlY3V0aW9uIHRyZWUgaW4gc2VxdWVudGlhbCAobm9uIHBhcmFsbGVsKSBwcm9ncmFtbWluZylcblxuIEEgcGFyZW50IHRhc2tzIGhhcyB0aGUgZm9sbG93aW5nIHNlbWFudGljc1xuIC0gSXQgY29tcGxldGVzIGlmIGFsbCBpdHMgZm9ya3MgZWl0aGVyIGNvbXBsZXRlIG9yIGFsbCBjYW5jZWxsZWRcbiAtIElmIGl0J3MgY2FuY2VsbGVkLCBhbGwgZm9ya3MgYXJlIGNhbmNlbGxlZCBhcyB3ZWxsXG4gLSBJdCBhYm9ydHMgaWYgYW55IHVuY2F1Z2h0IGVycm9yIGJ1YmJsZXMgdXAgZnJvbSBmb3Jrc1xuIC0gSWYgaXQgY29tcGxldGVzLCB0aGUgcmV0dXJuIHZhbHVlIGlzIHRoZSBvbmUgcmV0dXJuZWQgYnkgdGhlIG1haW4gdGFza1xuICoqL1xuXG5mdW5jdGlvbiBmb3JrUXVldWUobWFpblRhc2ssIG9uQWJvcnQsIGNvbnQpIHtcbiAgdmFyIHRhc2tzID0gW107XG4gIHZhciByZXN1bHQ7XG4gIHZhciBjb21wbGV0ZWQgPSBmYWxzZTtcbiAgYWRkVGFzayhtYWluVGFzayk7XG5cbiAgdmFyIGdldFRhc2tzID0gZnVuY3Rpb24gZ2V0VGFza3MoKSB7XG4gICAgcmV0dXJuIHRhc2tzO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFib3J0KGVycikge1xuICAgIG9uQWJvcnQoKTtcbiAgICBjYW5jZWxBbGwoKTtcbiAgICBjb250KGVyciwgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRUYXNrKHRhc2spIHtcbiAgICB0YXNrcy5wdXNoKHRhc2spO1xuXG4gICAgdGFzay5jb250ID0gZnVuY3Rpb24gKHJlcywgaXNFcnIpIHtcbiAgICAgIGlmIChjb21wbGV0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZW1vdmUodGFza3MsIHRhc2spO1xuICAgICAgdGFzay5jb250ID0gbm9vcDtcblxuICAgICAgaWYgKGlzRXJyKSB7XG4gICAgICAgIGFib3J0KHJlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGFzayA9PT0gbWFpblRhc2spIHtcbiAgICAgICAgICByZXN1bHQgPSByZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgY29udChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbEFsbCgpIHtcbiAgICBpZiAoY29tcGxldGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29tcGxldGVkID0gdHJ1ZTtcbiAgICB0YXNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICB0LmNvbnQgPSBub29wO1xuICAgICAgdC5jYW5jZWwoKTtcbiAgICB9KTtcbiAgICB0YXNrcyA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhZGRUYXNrOiBhZGRUYXNrLFxuICAgIGNhbmNlbEFsbDogY2FuY2VsQWxsLFxuICAgIGFib3J0OiBhYm9ydCxcbiAgICBnZXRUYXNrczogZ2V0VGFza3NcbiAgfTtcbn1cblxuLy8gdGhlcmUgY2FuIGJlIG9ubHkgYSBzaW5nbGUgc2FnYSBlcnJvciBjcmVhdGVkIGF0IGFueSBnaXZlbiBtb21lbnRcblxuZnVuY3Rpb24gZm9ybWF0TG9jYXRpb24oZmlsZU5hbWUsIGxpbmVOdW1iZXIpIHtcbiAgcmV0dXJuIGZpbGVOYW1lICsgXCI/XCIgKyBsaW5lTnVtYmVyO1xufVxuXG5mdW5jdGlvbiBlZmZlY3RMb2NhdGlvbkFzU3RyaW5nKGVmZmVjdCkge1xuICB2YXIgbG9jYXRpb24gPSBnZXRMb2NhdGlvbihlZmZlY3QpO1xuXG4gIGlmIChsb2NhdGlvbikge1xuICAgIHZhciBjb2RlID0gbG9jYXRpb24uY29kZSxcbiAgICAgICAgZmlsZU5hbWUgPSBsb2NhdGlvbi5maWxlTmFtZSxcbiAgICAgICAgbGluZU51bWJlciA9IGxvY2F0aW9uLmxpbmVOdW1iZXI7XG4gICAgdmFyIHNvdXJjZSA9IGNvZGUgKyBcIiAgXCIgKyBmb3JtYXRMb2NhdGlvbihmaWxlTmFtZSwgbGluZU51bWJlcik7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gc2FnYUxvY2F0aW9uQXNTdHJpbmcoc2FnYU1ldGEpIHtcbiAgdmFyIG5hbWUgPSBzYWdhTWV0YS5uYW1lLFxuICAgICAgbG9jYXRpb24gPSBzYWdhTWV0YS5sb2NhdGlvbjtcblxuICBpZiAobG9jYXRpb24pIHtcbiAgICByZXR1cm4gbmFtZSArIFwiICBcIiArIGZvcm1hdExvY2F0aW9uKGxvY2F0aW9uLmZpbGVOYW1lLCBsb2NhdGlvbi5saW5lTnVtYmVyKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lO1xufVxuXG5mdW5jdGlvbiBjYW5jZWxsZWRUYXNrc0FzU3RyaW5nKHNhZ2FTdGFjaykge1xuICB2YXIgY2FuY2VsbGVkVGFza3MgPSBmbGF0TWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIGkuY2FuY2VsbGVkVGFza3M7XG4gIH0sIHNhZ2FTdGFjayk7XG5cbiAgaWYgKCFjYW5jZWxsZWRUYXNrcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICByZXR1cm4gWydUYXNrcyBjYW5jZWxsZWQgZHVlIHRvIGVycm9yOiddLmNvbmNhdChjYW5jZWxsZWRUYXNrcykuam9pbignXFxuJyk7XG59XG5cbnZhciBjcmFzaGVkRWZmZWN0ID0gbnVsbDtcbnZhciBzYWdhU3RhY2sgPSBbXTtcbnZhciBhZGRTYWdhRnJhbWUgPSBmdW5jdGlvbiBhZGRTYWdhRnJhbWUoZnJhbWUpIHtcbiAgZnJhbWUuY3Jhc2hlZEVmZmVjdCA9IGNyYXNoZWRFZmZlY3Q7XG4gIHNhZ2FTdGFjay5wdXNoKGZyYW1lKTtcbn07XG52YXIgY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgY3Jhc2hlZEVmZmVjdCA9IG51bGw7XG4gIHNhZ2FTdGFjay5sZW5ndGggPSAwO1xufTsgLy8gdGhpcyBzZXRzIGNyYXNoZWQgZWZmZWN0IGZvciB0aGUgc29vbi10by1iZS1yZXBvcnRlZCBzYWdhIGZyYW1lXG4vLyB0aGlzIHNsaWdodGx5IHN0cmVhdGNoZXMgdGhlIHNpbmdsZXRvbiBuYXR1cmUgb2YgdGhpcyBtb2R1bGUgaW50byB3cm9uZyBkaXJlY3Rpb25cbi8vIGFzIGl0J3MgZXZlbiBsZXNzIG9idmlvdXMgd2hhdCdzIHRoZSBkYXRhIGZsb3cgaGVyZSwgYnV0IGl0IGlzIHdoYXQgaXQgaXMgZm9yIG5vd1xuXG52YXIgc2V0Q3Jhc2hlZEVmZmVjdCA9IGZ1bmN0aW9uIHNldENyYXNoZWRFZmZlY3QoZWZmZWN0KSB7XG4gIGNyYXNoZWRFZmZlY3QgPSBlZmZlY3Q7XG59O1xuLyoqXG4gIEByZXR1cm5zIHtzdHJpbmd9XG5cbiAgQGV4YW1wbGVcbiAgVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIHRhc2sgZXJyb3JJblB1dFNhZ2Ege3BhdGhUb0ZpbGV9XG4gIHdoZW4gZXhlY3V0aW5nIGVmZmVjdCBwdXQoe3R5cGU6ICdSRURVQ0VSX0FDVElPTl9FUlJPUl9JTl9QVVQnfSkge3BhdGhUb0ZpbGV9XG4gICAgICBjcmVhdGVkIGJ5IGZldGNoU2FnYSB7cGF0aFRvRmlsZX1cbiAgICAgIGNyZWF0ZWQgYnkgcm9vdFNhZ2Ege3BhdGhUb0ZpbGV9XG4qL1xuXG52YXIgdG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgdmFyIGZpcnN0U2FnYSA9IHNhZ2FTdGFja1swXSxcbiAgICAgIG90aGVyU2FnYXMgPSBzYWdhU3RhY2suc2xpY2UoMSk7XG4gIHZhciBjcmFzaGVkRWZmZWN0TG9jYXRpb24gPSBmaXJzdFNhZ2EuY3Jhc2hlZEVmZmVjdCA/IGVmZmVjdExvY2F0aW9uQXNTdHJpbmcoZmlyc3RTYWdhLmNyYXNoZWRFZmZlY3QpIDogbnVsbDtcbiAgdmFyIGVycm9yTWVzc2FnZSA9IFwiVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIHRhc2sgXCIgKyBzYWdhTG9jYXRpb25Bc1N0cmluZyhmaXJzdFNhZ2EubWV0YSkgKyAoY3Jhc2hlZEVmZmVjdExvY2F0aW9uID8gXCIgXFxuIHdoZW4gZXhlY3V0aW5nIGVmZmVjdCBcIiArIGNyYXNoZWRFZmZlY3RMb2NhdGlvbiA6ICcnKTtcbiAgcmV0dXJuIFtlcnJvck1lc3NhZ2VdLmNvbmNhdChvdGhlclNhZ2FzLm1hcChmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBcIiAgICBjcmVhdGVkIGJ5IFwiICsgc2FnYUxvY2F0aW9uQXNTdHJpbmcocy5tZXRhKTtcbiAgfSksIFtjYW5jZWxsZWRUYXNrc0FzU3RyaW5nKHNhZ2FTdGFjayldKS5qb2luKCdcXG4nKTtcbn07XG5cbmZ1bmN0aW9uIG5ld1Rhc2soZW52LCBtYWluVGFzaywgcGFyZW50Q29udGV4dCwgcGFyZW50RWZmZWN0SWQsIG1ldGEsIGlzUm9vdCwgY29udCkge1xuICB2YXIgX3Rhc2s7XG5cbiAgaWYgKGNvbnQgPT09IHZvaWQgMCkge1xuICAgIGNvbnQgPSBub29wO1xuICB9XG5cbiAgdmFyIHN0YXR1cyA9IFJVTk5JTkc7XG4gIHZhciB0YXNrUmVzdWx0O1xuICB2YXIgdGFza0Vycm9yO1xuICB2YXIgZGVmZXJyZWRFbmQgPSBudWxsO1xuICB2YXIgY2FuY2VsbGVkRHVlVG9FcnJvclRhc2tzID0gW107XG4gIHZhciBjb250ZXh0ID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRDb250ZXh0KTtcbiAgdmFyIHF1ZXVlID0gZm9ya1F1ZXVlKG1haW5UYXNrLCBmdW5jdGlvbiBvbkFib3J0KCkge1xuICAgIGNhbmNlbGxlZER1ZVRvRXJyb3JUYXNrcy5wdXNoLmFwcGx5KGNhbmNlbGxlZER1ZVRvRXJyb3JUYXNrcywgcXVldWUuZ2V0VGFza3MoKS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0Lm1ldGEubmFtZTtcbiAgICB9KSk7XG4gIH0sIGVuZCk7XG4gIC8qKlxuICAgVGhpcyBtYXkgYmUgY2FsbGVkIGJ5IGEgcGFyZW50IGdlbmVyYXRvciB0byB0cmlnZ2VyL3Byb3BhZ2F0ZSBjYW5jZWxsYXRpb25cbiAgIGNhbmNlbCBhbGwgcGVuZGluZyB0YXNrcyAoaW5jbHVkaW5nIHRoZSBtYWluIHRhc2spLCB0aGVuIGVuZCB0aGUgY3VycmVudCB0YXNrLlxuICAgIENhbmNlbGxhdGlvbiBwcm9wYWdhdGVzIGRvd24gdG8gdGhlIHdob2xlIGV4ZWN1dGlvbiB0cmVlIGhlbGQgYnkgdGhpcyBQYXJlbnQgdGFza1xuICAgSXQncyBhbHNvIHByb3BhZ2F0ZWQgdG8gYWxsIGpvaW5lcnMgb2YgdGhpcyB0YXNrIGFuZCB0aGVpciBleGVjdXRpb24gdHJlZS9qb2luZXJzXG4gICAgQ2FuY2VsbGF0aW9uIGlzIG5vb3AgZm9yIHRlcm1pbmF0ZWQvQ2FuY2VsbGVkIHRhc2tzIHRhc2tzXG4gICAqKi9cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHN0YXR1cyA9PT0gUlVOTklORykge1xuICAgICAgLy8gU2V0dGluZyBzdGF0dXMgdG8gQ0FOQ0VMTEVEIGRvZXMgbm90IG5lY2Vzc2FyaWx5IG1lYW4gdGhhdCB0aGUgdGFzay9pdGVyYXRvcnMgYXJlIHN0b3BwZWRcbiAgICAgIC8vIGVmZmVjdHMgaW4gdGhlIGl0ZXJhdG9yJ3MgZmluYWxseSBibG9jayB3aWxsIHN0aWxsIGJlIGV4ZWN1dGVkXG4gICAgICBzdGF0dXMgPSBDQU5DRUxMRUQ7XG4gICAgICBxdWV1ZS5jYW5jZWxBbGwoKTsgLy8gRW5kaW5nIHdpdGggYSBUQVNLX0NBTkNFTCB3aWxsIHByb3BhZ2F0ZSB0aGUgQ2FuY2VsbGF0aW9uIHRvIGFsbCBqb2luZXJzXG5cbiAgICAgIGVuZChUQVNLX0NBTkNFTCwgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZChyZXN1bHQsIGlzRXJyKSB7XG4gICAgaWYgKCFpc0Vycikge1xuICAgICAgLy8gVGhlIHN0YXR1cyBoZXJlIG1heSBiZSBSVU5OSU5HIG9yIENBTkNFTExFRFxuICAgICAgLy8gSWYgdGhlIHN0YXR1cyBpcyBDQU5DRUxMRUQsIHRoZW4gd2UgZG8gbm90IG5lZWQgdG8gY2hhbmdlIGl0IGhlcmVcbiAgICAgIGlmIChyZXN1bHQgPT09IFRBU0tfQ0FOQ0VMKSB7XG4gICAgICAgIHN0YXR1cyA9IENBTkNFTExFRDtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdHVzICE9PSBDQU5DRUxMRUQpIHtcbiAgICAgICAgc3RhdHVzID0gRE9ORTtcbiAgICAgIH1cblxuICAgICAgdGFza1Jlc3VsdCA9IHJlc3VsdDtcbiAgICAgIGRlZmVycmVkRW5kICYmIGRlZmVycmVkRW5kLnJlc29sdmUocmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdHVzID0gQUJPUlRFRDtcbiAgICAgIGFkZFNhZ2FGcmFtZSh7XG4gICAgICAgIG1ldGE6IG1ldGEsXG4gICAgICAgIGNhbmNlbGxlZFRhc2tzOiBjYW5jZWxsZWREdWVUb0Vycm9yVGFza3NcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGFzay5pc1Jvb3QpIHtcbiAgICAgICAgdmFyIHNhZ2FTdGFjayA9IHRvU3RyaW5nKCk7IC8vIHdlJ3ZlIGR1bXBlZCB0aGUgc2FnYSBzdGFjayB0byBzdHJpbmcgYW5kIGFyZSBwYXNzaW5nIGl0IHRvIHVzZXIncyBjb2RlXG4gICAgICAgIC8vIHdlIGtub3cgdGhhdCBpdCB3b24ndCBiZSBuZWVkZWQgYW55bW9yZSBhbmQgd2UgbmVlZCB0byBjbGVhciBpdFxuXG4gICAgICAgIGNsZWFyKCk7XG4gICAgICAgIGVudi5vbkVycm9yKHJlc3VsdCwge1xuICAgICAgICAgIHNhZ2FTdGFjazogc2FnYVN0YWNrXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0YXNrRXJyb3IgPSByZXN1bHQ7XG4gICAgICBkZWZlcnJlZEVuZCAmJiBkZWZlcnJlZEVuZC5yZWplY3QocmVzdWx0KTtcbiAgICB9XG5cbiAgICB0YXNrLmNvbnQocmVzdWx0LCBpc0Vycik7XG4gICAgdGFzay5qb2luZXJzLmZvckVhY2goZnVuY3Rpb24gKGpvaW5lcikge1xuICAgICAgam9pbmVyLmNiKHJlc3VsdCwgaXNFcnIpO1xuICAgIH0pO1xuICAgIHRhc2suam9pbmVycyA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRDb250ZXh0KHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrKHByb3BzLCBvYmplY3QsIGNyZWF0ZVNldENvbnRleHRXYXJuaW5nKCd0YXNrJywgcHJvcHMpKTtcbiAgICB9XG5cbiAgICBhc3NpZ25XaXRoU3ltYm9scyhjb250ZXh0LCBwcm9wcyk7XG4gIH1cblxuICBmdW5jdGlvbiB0b1Byb21pc2UoKSB7XG4gICAgaWYgKGRlZmVycmVkRW5kKSB7XG4gICAgICByZXR1cm4gZGVmZXJyZWRFbmQucHJvbWlzZTtcbiAgICB9XG5cbiAgICBkZWZlcnJlZEVuZCA9IGRlZmVycmVkKCk7XG5cbiAgICBpZiAoc3RhdHVzID09PSBBQk9SVEVEKSB7XG4gICAgICBkZWZlcnJlZEVuZC5yZWplY3QodGFza0Vycm9yKTtcbiAgICB9IGVsc2UgaWYgKHN0YXR1cyAhPT0gUlVOTklORykge1xuICAgICAgZGVmZXJyZWRFbmQucmVzb2x2ZSh0YXNrUmVzdWx0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVmZXJyZWRFbmQucHJvbWlzZTtcbiAgfVxuXG4gIHZhciB0YXNrID0gKF90YXNrID0ge30sIF90YXNrW1RBU0tdID0gdHJ1ZSwgX3Rhc2suaWQgPSBwYXJlbnRFZmZlY3RJZCwgX3Rhc2subWV0YSA9IG1ldGEsIF90YXNrLmlzUm9vdCA9IGlzUm9vdCwgX3Rhc2suY29udGV4dCA9IGNvbnRleHQsIF90YXNrLmpvaW5lcnMgPSBbXSwgX3Rhc2sucXVldWUgPSBxdWV1ZSwgX3Rhc2suY2FuY2VsID0gY2FuY2VsLCBfdGFzay5jb250ID0gY29udCwgX3Rhc2suZW5kID0gZW5kLCBfdGFzay5zZXRDb250ZXh0ID0gc2V0Q29udGV4dCwgX3Rhc2sudG9Qcm9taXNlID0gdG9Qcm9taXNlLCBfdGFzay5pc1J1bm5pbmcgPSBmdW5jdGlvbiBpc1J1bm5pbmcoKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gUlVOTklORztcbiAgfSwgX3Rhc2suaXNDYW5jZWxsZWQgPSBmdW5jdGlvbiBpc0NhbmNlbGxlZCgpIHtcbiAgICByZXR1cm4gc3RhdHVzID09PSBDQU5DRUxMRUQgfHwgc3RhdHVzID09PSBSVU5OSU5HICYmIG1haW5UYXNrLnN0YXR1cyA9PT0gQ0FOQ0VMTEVEO1xuICB9LCBfdGFzay5pc0Fib3J0ZWQgPSBmdW5jdGlvbiBpc0Fib3J0ZWQoKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gQUJPUlRFRDtcbiAgfSwgX3Rhc2sucmVzdWx0ID0gZnVuY3Rpb24gcmVzdWx0KCkge1xuICAgIHJldHVybiB0YXNrUmVzdWx0O1xuICB9LCBfdGFzay5lcnJvciA9IGZ1bmN0aW9uIGVycm9yKCkge1xuICAgIHJldHVybiB0YXNrRXJyb3I7XG4gIH0sIF90YXNrKTtcbiAgcmV0dXJuIHRhc2s7XG59XG5cbmZ1bmN0aW9uIHByb2MoZW52LCBpdGVyYXRvciQxLCBwYXJlbnRDb250ZXh0LCBwYXJlbnRFZmZlY3RJZCwgbWV0YSwgaXNSb290LCBjb250KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGl0ZXJhdG9yJDFbYXN5bmNJdGVyYXRvclN5bWJvbF0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWR1eC1zYWdhIGRvZXNuJ3Qgc3VwcG9ydCBhc3luYyBnZW5lcmF0b3JzLCBwbGVhc2UgdXNlIG9ubHkgcmVndWxhciBvbmVzXCIpO1xuICB9XG5cbiAgdmFyIGZpbmFsUnVuRWZmZWN0ID0gZW52LmZpbmFsaXplUnVuRWZmZWN0KHJ1bkVmZmVjdCk7XG4gIC8qKlxuICAgIFRyYWNrcyB0aGUgY3VycmVudCBlZmZlY3QgY2FuY2VsbGF0aW9uXG4gICAgRWFjaCB0aW1lIHRoZSBnZW5lcmF0b3IgcHJvZ3Jlc3Nlcy4gY2FsbGluZyBydW5FZmZlY3Qgd2lsbCBzZXQgYSBuZXcgdmFsdWVcbiAgICBvbiBpdC4gSXQgYWxsb3dzIHByb3BhZ2F0aW5nIGNhbmNlbGxhdGlvbiB0byBjaGlsZCBlZmZlY3RzXG4gICoqL1xuXG4gIG5leHQuY2FuY2VsID0gbm9vcDtcbiAgLyoqIENyZWF0ZXMgYSBtYWluIHRhc2sgdG8gdHJhY2sgdGhlIG1haW4gZmxvdyAqL1xuXG4gIHZhciBtYWluVGFzayA9IHtcbiAgICBtZXRhOiBtZXRhLFxuICAgIGNhbmNlbDogY2FuY2VsTWFpbixcbiAgICBzdGF0dXM6IFJVTk5JTkdcbiAgfTtcbiAgLyoqXG4gICBDcmVhdGVzIGEgbmV3IHRhc2sgZGVzY3JpcHRvciBmb3IgdGhpcyBnZW5lcmF0b3IuXG4gICBBIHRhc2sgaXMgdGhlIGFnZ3JlZ2F0aW9uIG9mIGl0J3MgbWFpblRhc2sgYW5kIGFsbCBpdCdzIGZvcmtlZCB0YXNrcy5cbiAgICoqL1xuXG4gIHZhciB0YXNrID0gbmV3VGFzayhlbnYsIG1haW5UYXNrLCBwYXJlbnRDb250ZXh0LCBwYXJlbnRFZmZlY3RJZCwgbWV0YSwgaXNSb290LCBjb250KTtcbiAgdmFyIGV4ZWN1dGluZ0NvbnRleHQgPSB7XG4gICAgdGFzazogdGFzayxcbiAgICBkaWdlc3RFZmZlY3Q6IGRpZ2VzdEVmZmVjdFxuICB9O1xuICAvKipcbiAgICBjYW5jZWxsYXRpb24gb2YgdGhlIG1haW4gdGFzay4gV2UnbGwgc2ltcGx5IHJlc3VtZSB0aGUgR2VuZXJhdG9yIHdpdGggYSBUQVNLX0NBTkNFTFxuICAqKi9cblxuICBmdW5jdGlvbiBjYW5jZWxNYWluKCkge1xuICAgIGlmIChtYWluVGFzay5zdGF0dXMgPT09IFJVTk5JTkcpIHtcbiAgICAgIG1haW5UYXNrLnN0YXR1cyA9IENBTkNFTExFRDtcbiAgICAgIG5leHQoVEFTS19DQU5DRUwpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICBhdHRhY2hlcyBjYW5jZWxsYXRpb24gbG9naWMgdG8gdGhpcyB0YXNrJ3MgY29udGludWF0aW9uXG4gICAgdGhpcyB3aWxsIHBlcm1pdCBjYW5jZWxsYXRpb24gdG8gcHJvcGFnYXRlIGRvd24gdGhlIGNhbGwgY2hhaW5cbiAgKiovXG5cblxuICBpZiAoY29udCkge1xuICAgIGNvbnQuY2FuY2VsID0gdGFzay5jYW5jZWw7XG4gIH0gLy8ga2lja3MgdXAgdGhlIGdlbmVyYXRvclxuXG5cbiAgbmV4dCgpOyAvLyB0aGVuIHJldHVybiB0aGUgdGFzayBkZXNjcmlwdG9yIHRvIHRoZSBjYWxsZXJcblxuICByZXR1cm4gdGFzaztcbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIGdlbmVyYXRvciBkcml2ZXJcbiAgICogSXQncyBhIHJlY3Vyc2l2ZSBhc3luYy9jb250aW51YXRpb24gZnVuY3Rpb24gd2hpY2ggY2FsbHMgaXRzZWxmXG4gICAqIHVudGlsIHRoZSBnZW5lcmF0b3IgdGVybWluYXRlcyBvciB0aHJvd3NcbiAgICogQHBhcmFtIHtpbnRlcm5hbCBjb21tYW5kcyhUQVNLX0NBTkNFTCB8IFRFUk1JTkFURSkgfCBhbnl9IGFyZyAtIHZhbHVlLCBnZW5lcmF0b3Igd2lsbCBiZSByZXN1bWVkIHdpdGguXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNFcnIgLSB0aGUgZmxhZyBzaG93cyBpZiBlZmZlY3QgZmluaXNoZWQgd2l0aCBhbiBlcnJvclxuICAgKlxuICAgKiByZWNlaXZlcyBlaXRoZXIgKGNvbW1hbmQgfCBlZmZlY3QgcmVzdWx0LCBmYWxzZSkgb3IgKGFueSB0aHJvd24gdGhpbmcsIHRydWUpXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG5leHQoYXJnLCBpc0Vycikge1xuICAgIHRyeSB7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBpZiAoaXNFcnIpIHtcbiAgICAgICAgcmVzdWx0ID0gaXRlcmF0b3IkMS50aHJvdyhhcmcpOyAvLyB1c2VyIGhhbmRsZWQgdGhlIGVycm9yLCB3ZSBjYW4gY2xlYXIgYm9va2tlcHQgdmFsdWVzXG5cbiAgICAgICAgY2xlYXIoKTtcbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkQ2FuY2VsKGFyZykpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAgZ2V0dGluZyBUQVNLX0NBTkNFTCBhdXRvbWF0aWNhbGx5IGNhbmNlbHMgdGhlIG1haW4gdGFza1xuICAgICAgICAgIFdlIGNhbiBnZXQgdGhpcyB2YWx1ZSBoZXJlXG4gICAgICAgICAgIC0gQnkgY2FuY2VsbGluZyB0aGUgcGFyZW50IHRhc2sgbWFudWFsbHlcbiAgICAgICAgICAtIEJ5IGpvaW5pbmcgYSBDYW5jZWxsZWQgdGFza1xuICAgICAgICAqKi9cbiAgICAgICAgbWFpblRhc2suc3RhdHVzID0gQ0FOQ0VMTEVEO1xuICAgICAgICAvKipcbiAgICAgICAgICBDYW5jZWxzIHRoZSBjdXJyZW50IGVmZmVjdDsgdGhpcyB3aWxsIHByb3BhZ2F0ZSB0aGUgY2FuY2VsbGF0aW9uIGRvd24gdG8gYW55IGNhbGxlZCB0YXNrc1xuICAgICAgICAqKi9cblxuICAgICAgICBuZXh0LmNhbmNlbCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICBJZiB0aGlzIEdlbmVyYXRvciBoYXMgYSBgcmV0dXJuYCBtZXRob2QgdGhlbiBpbnZva2VzIGl0XG4gICAgICAgICAgVGhpcyB3aWxsIGp1bXAgdG8gdGhlIGZpbmFsbHkgYmxvY2tcbiAgICAgICAgKiovXG5cbiAgICAgICAgcmVzdWx0ID0gZnVuYyhpdGVyYXRvciQxLnJldHVybikgPyBpdGVyYXRvciQxLnJldHVybihUQVNLX0NBTkNFTCkgOiB7XG4gICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogVEFTS19DQU5DRUxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkVGVybWluYXRlKGFyZykpIHtcbiAgICAgICAgLy8gV2UgZ2V0IFRFUk1JTkFURSBmbGFnLCBpLmUuIGJ5IHRha2luZyBmcm9tIGEgY2hhbm5lbCB0aGF0IGVuZGVkIHVzaW5nIGB0YWtlYCAoYW5kIG5vdCBgdGFrZW1gIHVzZWQgdG8gdHJhcCBFbmQgb2YgY2hhbm5lbHMpXG4gICAgICAgIHJlc3VsdCA9IGZ1bmMoaXRlcmF0b3IkMS5yZXR1cm4pID8gaXRlcmF0b3IkMS5yZXR1cm4oKSA6IHtcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBpdGVyYXRvciQxLm5leHQoYXJnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyZXN1bHQuZG9uZSkge1xuICAgICAgICBkaWdlc3RFZmZlY3QocmVzdWx0LnZhbHVlLCBwYXJlbnRFZmZlY3RJZCwgbmV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKipcbiAgICAgICAgICBUaGlzIEdlbmVyYXRvciBoYXMgZW5kZWQsIHRlcm1pbmF0ZSB0aGUgbWFpbiB0YXNrIGFuZCBub3RpZnkgdGhlIGZvcmsgcXVldWVcbiAgICAgICAgKiovXG4gICAgICAgIGlmIChtYWluVGFzay5zdGF0dXMgIT09IENBTkNFTExFRCkge1xuICAgICAgICAgIG1haW5UYXNrLnN0YXR1cyA9IERPTkU7XG4gICAgICAgIH1cblxuICAgICAgICBtYWluVGFzay5jb250KHJlc3VsdC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChtYWluVGFzay5zdGF0dXMgPT09IENBTkNFTExFRCkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgbWFpblRhc2suc3RhdHVzID0gQUJPUlRFRDtcbiAgICAgIG1haW5UYXNrLmNvbnQoZXJyb3IsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJ1bkVmZmVjdChlZmZlY3QsIGVmZmVjdElkLCBjdXJyQ2IpIHtcbiAgICAvKipcbiAgICAgIGVhY2ggZWZmZWN0IHJ1bm5lciBtdXN0IGF0dGFjaCBpdHMgb3duIGxvZ2ljIG9mIGNhbmNlbGxhdGlvbiB0byB0aGUgcHJvdmlkZWQgY2FsbGJhY2tcbiAgICAgIGl0IGFsbG93cyB0aGlzIGdlbmVyYXRvciB0byBwcm9wYWdhdGUgY2FuY2VsbGF0aW9uIGRvd253YXJkLlxuICAgICAgIEFUVEVOVElPTiEgZWZmZWN0IHJ1bm5lcnMgbXVzdCBzZXR1cCB0aGUgY2FuY2VsIGxvZ2ljIGJ5IHNldHRpbmcgY2IuY2FuY2VsID0gW2NhbmNlbE1ldGhvZF1cbiAgICAgIEFuZCB0aGUgc2V0dXAgbXVzdCBvY2N1ciBiZWZvcmUgY2FsbGluZyB0aGUgY2FsbGJhY2tcbiAgICAgICBUaGlzIGlzIGEgc29ydCBvZiBpbnZlcnNpb24gb2YgY29udHJvbDogY2FsbGVkIGFzeW5jIGZ1bmN0aW9ucyBhcmUgcmVzcG9uc2libGVcbiAgICAgIG9mIGNvbXBsZXRpbmcgdGhlIGZsb3cgYnkgY2FsbGluZyB0aGUgcHJvdmlkZWQgY29udGludWF0aW9uOyB3aGlsZSBjYWxsZXIgZnVuY3Rpb25zXG4gICAgICBhcmUgcmVzcG9uc2libGUgZm9yIGFib3J0aW5nIHRoZSBjdXJyZW50IGZsb3cgYnkgY2FsbGluZyB0aGUgYXR0YWNoZWQgY2FuY2VsIGZ1bmN0aW9uXG4gICAgICAgTGlicmFyeSB1c2VycyBjYW4gYXR0YWNoIHRoZWlyIG93biBjYW5jZWxsYXRpb24gbG9naWMgdG8gcHJvbWlzZXMgYnkgZGVmaW5pbmcgYVxuICAgICAgcHJvbWlzZVtDQU5DRUxdIG1ldGhvZCBpbiB0aGVpciByZXR1cm5lZCBwcm9taXNlc1xuICAgICAgQVRURU5USU9OISBjYWxsaW5nIGNhbmNlbCBtdXN0IGhhdmUgbm8gZWZmZWN0IG9uIGFuIGFscmVhZHkgY29tcGxldGVkIG9yIGNhbmNlbGxlZCBlZmZlY3RcbiAgICAqKi9cbiAgICBpZiAocHJvbWlzZShlZmZlY3QpKSB7XG4gICAgICByZXNvbHZlUHJvbWlzZShlZmZlY3QsIGN1cnJDYik7XG4gICAgfSBlbHNlIGlmIChpdGVyYXRvcihlZmZlY3QpKSB7XG4gICAgICAvLyByZXNvbHZlIGl0ZXJhdG9yXG4gICAgICBwcm9jKGVudiwgZWZmZWN0LCB0YXNrLmNvbnRleHQsIGVmZmVjdElkLCBtZXRhLFxuICAgICAgLyogaXNSb290ICovXG4gICAgICBmYWxzZSwgY3VyckNiKTtcbiAgICB9IGVsc2UgaWYgKGVmZmVjdCAmJiBlZmZlY3RbSU9dKSB7XG4gICAgICB2YXIgZWZmZWN0UnVubmVyID0gZWZmZWN0UnVubmVyTWFwW2VmZmVjdC50eXBlXTtcbiAgICAgIGVmZmVjdFJ1bm5lcihlbnYsIGVmZmVjdC5wYXlsb2FkLCBjdXJyQ2IsIGV4ZWN1dGluZ0NvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIHJldHVybmVkIGFzIGlzXG4gICAgICBjdXJyQ2IoZWZmZWN0KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkaWdlc3RFZmZlY3QoZWZmZWN0LCBwYXJlbnRFZmZlY3RJZCwgY2IsIGxhYmVsKSB7XG4gICAgaWYgKGxhYmVsID09PSB2b2lkIDApIHtcbiAgICAgIGxhYmVsID0gJyc7XG4gICAgfVxuXG4gICAgdmFyIGVmZmVjdElkID0gbmV4dFNhZ2FJZCgpO1xuICAgIGVudi5zYWdhTW9uaXRvciAmJiBlbnYuc2FnYU1vbml0b3IuZWZmZWN0VHJpZ2dlcmVkKHtcbiAgICAgIGVmZmVjdElkOiBlZmZlY3RJZCxcbiAgICAgIHBhcmVudEVmZmVjdElkOiBwYXJlbnRFZmZlY3RJZCxcbiAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgIGVmZmVjdDogZWZmZWN0XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICBjb21wbGV0aW9uIGNhbGxiYWNrIGFuZCBjYW5jZWwgY2FsbGJhY2sgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZVxuICAgICAgV2UgY2FuJ3QgY2FuY2VsIGFuIGFscmVhZHkgY29tcGxldGVkIGVmZmVjdFxuICAgICAgQW5kIFdlIGNhbid0IGNvbXBsZXRlIGFuIGFscmVhZHkgY2FuY2VsbGVkIGVmZmVjdElkXG4gICAgKiovXG5cbiAgICB2YXIgZWZmZWN0U2V0dGxlZDsgLy8gQ29tcGxldGlvbiBjYWxsYmFjayBwYXNzZWQgdG8gdGhlIGFwcHJvcHJpYXRlIGVmZmVjdCBydW5uZXJcblxuICAgIGZ1bmN0aW9uIGN1cnJDYihyZXMsIGlzRXJyKSB7XG4gICAgICBpZiAoZWZmZWN0U2V0dGxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGVmZmVjdFNldHRsZWQgPSB0cnVlO1xuICAgICAgY2IuY2FuY2VsID0gbm9vcDsgLy8gZGVmZW5zaXZlIG1lYXN1cmVcblxuICAgICAgaWYgKGVudi5zYWdhTW9uaXRvcikge1xuICAgICAgICBpZiAoaXNFcnIpIHtcbiAgICAgICAgICBlbnYuc2FnYU1vbml0b3IuZWZmZWN0UmVqZWN0ZWQoZWZmZWN0SWQsIHJlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW52LnNhZ2FNb25pdG9yLmVmZmVjdFJlc29sdmVkKGVmZmVjdElkLCByZXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Vycikge1xuICAgICAgICBzZXRDcmFzaGVkRWZmZWN0KGVmZmVjdCk7XG4gICAgICB9XG5cbiAgICAgIGNiKHJlcywgaXNFcnIpO1xuICAgIH0gLy8gdHJhY2tzIGRvd24gdGhlIGN1cnJlbnQgY2FuY2VsXG5cblxuICAgIGN1cnJDYi5jYW5jZWwgPSBub29wOyAvLyBzZXR1cCBjYW5jZWxsYXRpb24gbG9naWMgb24gdGhlIHBhcmVudCBjYlxuXG4gICAgY2IuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gcHJldmVudHMgY2FuY2VsbGluZyBhbiBhbHJlYWR5IGNvbXBsZXRlZCBlZmZlY3RcbiAgICAgIGlmIChlZmZlY3RTZXR0bGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZWZmZWN0U2V0dGxlZCA9IHRydWU7XG4gICAgICBjdXJyQ2IuY2FuY2VsKCk7IC8vIHByb3BhZ2F0ZXMgY2FuY2VsIGRvd253YXJkXG5cbiAgICAgIGN1cnJDYi5jYW5jZWwgPSBub29wOyAvLyBkZWZlbnNpdmUgbWVhc3VyZVxuXG4gICAgICBlbnYuc2FnYU1vbml0b3IgJiYgZW52LnNhZ2FNb25pdG9yLmVmZmVjdENhbmNlbGxlZChlZmZlY3RJZCk7XG4gICAgfTtcblxuICAgIGZpbmFsUnVuRWZmZWN0KGVmZmVjdCwgZWZmZWN0SWQsIGN1cnJDYik7XG4gIH1cbn1cblxudmFyIFJVTl9TQUdBX1NJR05BVFVSRSA9ICdydW5TYWdhKG9wdGlvbnMsIHNhZ2EsIC4uLmFyZ3MpJztcbnZhciBOT05fR0VORVJBVE9SX0VSUiA9IFJVTl9TQUdBX1NJR05BVFVSRSArIFwiOiBzYWdhIGFyZ3VtZW50IG11c3QgYmUgYSBHZW5lcmF0b3IgZnVuY3Rpb24hXCI7XG5mdW5jdGlvbiBydW5TYWdhKF9yZWYsIHNhZ2EpIHtcbiAgdmFyIF9yZWYkY2hhbm5lbCA9IF9yZWYuY2hhbm5lbCxcbiAgICAgIGNoYW5uZWwgPSBfcmVmJGNoYW5uZWwgPT09IHZvaWQgMCA/IHN0ZENoYW5uZWwoKSA6IF9yZWYkY2hhbm5lbCxcbiAgICAgIGRpc3BhdGNoID0gX3JlZi5kaXNwYXRjaCxcbiAgICAgIGdldFN0YXRlID0gX3JlZi5nZXRTdGF0ZSxcbiAgICAgIF9yZWYkY29udGV4dCA9IF9yZWYuY29udGV4dCxcbiAgICAgIGNvbnRleHQgPSBfcmVmJGNvbnRleHQgPT09IHZvaWQgMCA/IHt9IDogX3JlZiRjb250ZXh0LFxuICAgICAgc2FnYU1vbml0b3IgPSBfcmVmLnNhZ2FNb25pdG9yLFxuICAgICAgZWZmZWN0TWlkZGxld2FyZXMgPSBfcmVmLmVmZmVjdE1pZGRsZXdhcmVzLFxuICAgICAgX3JlZiRvbkVycm9yID0gX3JlZi5vbkVycm9yLFxuICAgICAgb25FcnJvciA9IF9yZWYkb25FcnJvciA9PT0gdm9pZCAwID8gbG9nRXJyb3IgOiBfcmVmJG9uRXJyb3I7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaGVjayhzYWdhLCBmdW5jLCBOT05fR0VORVJBVE9SX0VSUik7XG4gIH1cblxuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgaXRlcmF0b3IkMSA9IHNhZ2EuYXBwbHkodm9pZCAwLCBhcmdzKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNoZWNrKGl0ZXJhdG9yJDEsIGl0ZXJhdG9yLCBOT05fR0VORVJBVE9SX0VSUik7XG4gIH1cblxuICB2YXIgZWZmZWN0SWQgPSBuZXh0U2FnYUlkKCk7XG5cbiAgaWYgKHNhZ2FNb25pdG9yKSB7XG4gICAgLy8gbW9uaXRvcnMgYXJlIGV4cGVjdGVkIHRvIGhhdmUgYSBjZXJ0YWluIGludGVyZmFjZSwgbGV0J3MgZmlsbC1pbiBhbnkgbWlzc2luZyBvbmVzXG4gICAgc2FnYU1vbml0b3Iucm9vdFNhZ2FTdGFydGVkID0gc2FnYU1vbml0b3Iucm9vdFNhZ2FTdGFydGVkIHx8IG5vb3A7XG4gICAgc2FnYU1vbml0b3IuZWZmZWN0VHJpZ2dlcmVkID0gc2FnYU1vbml0b3IuZWZmZWN0VHJpZ2dlcmVkIHx8IG5vb3A7XG4gICAgc2FnYU1vbml0b3IuZWZmZWN0UmVzb2x2ZWQgPSBzYWdhTW9uaXRvci5lZmZlY3RSZXNvbHZlZCB8fCBub29wO1xuICAgIHNhZ2FNb25pdG9yLmVmZmVjdFJlamVjdGVkID0gc2FnYU1vbml0b3IuZWZmZWN0UmVqZWN0ZWQgfHwgbm9vcDtcbiAgICBzYWdhTW9uaXRvci5lZmZlY3RDYW5jZWxsZWQgPSBzYWdhTW9uaXRvci5lZmZlY3RDYW5jZWxsZWQgfHwgbm9vcDtcbiAgICBzYWdhTW9uaXRvci5hY3Rpb25EaXNwYXRjaGVkID0gc2FnYU1vbml0b3IuYWN0aW9uRGlzcGF0Y2hlZCB8fCBub29wO1xuICAgIHNhZ2FNb25pdG9yLnJvb3RTYWdhU3RhcnRlZCh7XG4gICAgICBlZmZlY3RJZDogZWZmZWN0SWQsXG4gICAgICBzYWdhOiBzYWdhLFxuICAgICAgYXJnczogYXJnc1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAobm90VW5kZWYoZGlzcGF0Y2gpKSB7XG4gICAgICBjaGVjayhkaXNwYXRjaCwgZnVuYywgJ2Rpc3BhdGNoIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIGlmIChub3RVbmRlZihnZXRTdGF0ZSkpIHtcbiAgICAgIGNoZWNrKGdldFN0YXRlLCBmdW5jLCAnZ2V0U3RhdGUgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKG5vdFVuZGVmKGVmZmVjdE1pZGRsZXdhcmVzKSkge1xuICAgICAgdmFyIE1JRERMRVdBUkVfVFlQRV9FUlJPUiA9ICdlZmZlY3RNaWRkbGV3YXJlcyBtdXN0IGJlIGFuIGFycmF5IG9mIGZ1bmN0aW9ucyc7XG4gICAgICBjaGVjayhlZmZlY3RNaWRkbGV3YXJlcywgYXJyYXkkMSwgTUlERExFV0FSRV9UWVBFX0VSUk9SKTtcbiAgICAgIGVmZmVjdE1pZGRsZXdhcmVzLmZvckVhY2goZnVuY3Rpb24gKGVmZmVjdE1pZGRsZXdhcmUpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrKGVmZmVjdE1pZGRsZXdhcmUsIGZ1bmMsIE1JRERMRVdBUkVfVFlQRV9FUlJPUik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjaGVjayhvbkVycm9yLCBmdW5jLCAnb25FcnJvciBwYXNzZWQgdG8gdGhlIHJlZHV4LXNhZ2EgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIH1cblxuICB2YXIgZmluYWxpemVSdW5FZmZlY3Q7XG5cbiAgaWYgKGVmZmVjdE1pZGRsZXdhcmVzKSB7XG4gICAgdmFyIG1pZGRsZXdhcmUgPSBjb21wb3NlLmFwcGx5KHZvaWQgMCwgZWZmZWN0TWlkZGxld2FyZXMpO1xuXG4gICAgZmluYWxpemVSdW5FZmZlY3QgPSBmdW5jdGlvbiBmaW5hbGl6ZVJ1bkVmZmVjdChydW5FZmZlY3QpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZWZmZWN0LCBlZmZlY3RJZCwgY3VyckNiKSB7XG4gICAgICAgIHZhciBwbGFpblJ1bkVmZmVjdCA9IGZ1bmN0aW9uIHBsYWluUnVuRWZmZWN0KGVmZikge1xuICAgICAgICAgIHJldHVybiBydW5FZmZlY3QoZWZmLCBlZmZlY3RJZCwgY3VyckNiKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbWlkZGxld2FyZShwbGFpblJ1bkVmZmVjdCkoZWZmZWN0KTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBmaW5hbGl6ZVJ1bkVmZmVjdCA9IGlkZW50aXR5O1xuICB9XG5cbiAgdmFyIGVudiA9IHtcbiAgICBjaGFubmVsOiBjaGFubmVsLFxuICAgIGRpc3BhdGNoOiB3cmFwU2FnYURpc3BhdGNoKGRpc3BhdGNoKSxcbiAgICBnZXRTdGF0ZTogZ2V0U3RhdGUsXG4gICAgc2FnYU1vbml0b3I6IHNhZ2FNb25pdG9yLFxuICAgIG9uRXJyb3I6IG9uRXJyb3IsXG4gICAgZmluYWxpemVSdW5FZmZlY3Q6IGZpbmFsaXplUnVuRWZmZWN0XG4gIH07XG4gIHJldHVybiBpbW1lZGlhdGVseShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRhc2sgPSBwcm9jKGVudiwgaXRlcmF0b3IkMSwgY29udGV4dCwgZWZmZWN0SWQsIGdldE1ldGFJbmZvKHNhZ2EpLFxuICAgIC8qIGlzUm9vdCAqL1xuICAgIHRydWUsIHVuZGVmaW5lZCk7XG5cbiAgICBpZiAoc2FnYU1vbml0b3IpIHtcbiAgICAgIHNhZ2FNb25pdG9yLmVmZmVjdFJlc29sdmVkKGVmZmVjdElkLCB0YXNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFzaztcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNhZ2FNaWRkbGV3YXJlRmFjdG9yeShfdGVtcCkge1xuICB2YXIgX3JlZiA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wLFxuICAgICAgX3JlZiRjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxuICAgICAgY29udGV4dCA9IF9yZWYkY29udGV4dCA9PT0gdm9pZCAwID8ge30gOiBfcmVmJGNvbnRleHQsXG4gICAgICBfcmVmJGNoYW5uZWwgPSBfcmVmLmNoYW5uZWwsXG4gICAgICBjaGFubmVsID0gX3JlZiRjaGFubmVsID09PSB2b2lkIDAgPyBzdGRDaGFubmVsKCkgOiBfcmVmJGNoYW5uZWwsXG4gICAgICBzYWdhTW9uaXRvciA9IF9yZWYuc2FnYU1vbml0b3IsXG4gICAgICBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgW1wiY29udGV4dFwiLCBcImNoYW5uZWxcIiwgXCJzYWdhTW9uaXRvclwiXSk7XG5cbiAgdmFyIGJvdW5kUnVuU2FnYTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNoZWNrKGNoYW5uZWwsIGNoYW5uZWwkMSwgJ29wdGlvbnMuY2hhbm5lbCBwYXNzZWQgdG8gdGhlIFNhZ2EgbWlkZGxld2FyZSBpcyBub3QgYSBjaGFubmVsJyk7XG4gIH1cblxuICBmdW5jdGlvbiBzYWdhTWlkZGxld2FyZShfcmVmMikge1xuICAgIHZhciBnZXRTdGF0ZSA9IF9yZWYyLmdldFN0YXRlLFxuICAgICAgICBkaXNwYXRjaCA9IF9yZWYyLmRpc3BhdGNoO1xuICAgIGJvdW5kUnVuU2FnYSA9IHJ1blNhZ2EuYmluZChudWxsLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgIGNoYW5uZWw6IGNoYW5uZWwsXG4gICAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgICBnZXRTdGF0ZTogZ2V0U3RhdGUsXG4gICAgICBzYWdhTW9uaXRvcjogc2FnYU1vbml0b3JcbiAgICB9KSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICBpZiAoc2FnYU1vbml0b3IgJiYgc2FnYU1vbml0b3IuYWN0aW9uRGlzcGF0Y2hlZCkge1xuICAgICAgICAgIHNhZ2FNb25pdG9yLmFjdGlvbkRpc3BhdGNoZWQoYWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXh0KGFjdGlvbik7IC8vIGhpdCByZWR1Y2Vyc1xuXG4gICAgICAgIGNoYW5uZWwucHV0KGFjdGlvbik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICBzYWdhTWlkZGxld2FyZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWJvdW5kUnVuU2FnYSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCZWZvcmUgcnVubmluZyBhIFNhZ2EsIHlvdSBtdXN0IG1vdW50IHRoZSBTYWdhIG1pZGRsZXdhcmUgb24gdGhlIFN0b3JlIHVzaW5nIGFwcGx5TWlkZGxld2FyZScpO1xuICAgIH1cblxuICAgIHJldHVybiBib3VuZFJ1blNhZ2EuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHNhZ2FNaWRkbGV3YXJlLnNldENvbnRleHQgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY2hlY2socHJvcHMsIG9iamVjdCwgY3JlYXRlU2V0Q29udGV4dFdhcm5pbmcoJ3NhZ2FNaWRkbGV3YXJlJywgcHJvcHMpKTtcbiAgICB9XG5cbiAgICBhc3NpZ25XaXRoU3ltYm9scyhjb250ZXh0LCBwcm9wcyk7XG4gIH07XG5cbiAgcmV0dXJuIHNhZ2FNaWRkbGV3YXJlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzYWdhTWlkZGxld2FyZUZhY3Rvcnk7XG5leHBvcnQgeyBFTkQsIGNoYW5uZWwsIGV2ZW50Q2hhbm5lbCwgaXNFbmQsIG11bHRpY2FzdENoYW5uZWwsIHJ1blNhZ2EsIHN0ZENoYW5uZWwgfTtcbiIsImltcG9ydCBjcmVhdGVTYWdhTWlkZGxld2FyZV9fZGVmYXVsdCBmcm9tICdAcmVkdXgtc2FnYS9jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0ByZWR1eC1zYWdhL2NvcmUnO1xuXG5cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlU2FnYU1pZGRsZXdhcmVfX2RlZmF1bHQ7XG4iLCJpbXBvcnQgSW1tdXRhYmxlIGZyb20gJ2ltbXV0YWJsZSc7XHJcblxyXG5pbXBvcnQgeyBTQVZFX1BPTFlHT05TIH0gZnJvbSAnLi4vYWN0aW9ucy9wb2x5Z29ucyc7XHJcblxyXG4vLyBzZWUgc2FnYXMvaW5kZXguanMgZm9yIHBvbHlnb24gaW5pdGlhbCBzdGF0ZVxyXG5jb25zdCBpbml0aWFsU3RhdGUgPSBJbW11dGFibGUuZnJvbUpTKHtcclxuICBwb2x5Z29uczogW10sXHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgKHN0YXRlID0gaW5pdGlhbFN0YXRlLCBhY3Rpb24pID0+IHtcclxuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XHJcbiAgICBjYXNlIFNBVkVfUE9MWUdPTlM6IHtcclxuICAgICAgY29uc3QgeyBwYXlsb2FkOiB7IHBvbHlnb25zIH0gfSA9IGFjdGlvbjtcclxuXHJcbiAgICAgIHJldHVybiBzdGF0ZS5zZXQoJ3BvbHlnb25zJywgcG9seWdvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBzdGF0ZTtcclxuICB9XHJcbn07XHJcbiIsImltcG9ydCBJbW11dGFibGUgZnJvbSAnaW1tdXRhYmxlJztcclxuXHJcbmltcG9ydCB7IFNFVF9TVEFHRV9CT1VORFMgfSBmcm9tICcuLi9hY3Rpb25zL3NpbXVsYXRpb24nO1xyXG5cclxuY29uc3QgaW5pdGlhbFN0YXRlID0gSW1tdXRhYmxlLmZyb21KUyh7XHJcbiAgd2lkdGg6IDAsXHJcbiAgaGVpZ2h0OiAwLFxyXG59KTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IChzdGF0ZSA9IGluaXRpYWxTdGF0ZSwgYWN0aW9uKSA9PiB7XHJcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xyXG4gICAgY2FzZSBTRVRfU1RBR0VfQk9VTkRTOiB7XHJcbiAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gYWN0aW9uLnBheWxvYWQ7XHJcblxyXG4gICAgICByZXR1cm4gc3RhdGUuc2V0KCd3aWR0aCcsIHdpZHRoKVxyXG4gICAgICAgIC5zZXQoJ2hlaWdodCcsIGhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gIH1cclxufTtcclxuIiwiaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdCc7XHJcblxyXG5pbXBvcnQgcG9seWdvbnMgZnJvbSAnLi9wb2x5Z29ucyc7XHJcbmltcG9ydCBzaW11bGF0aW9uIGZyb20gJy4vc2ltdWxhdGlvbic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjb21iaW5lUmVkdWNlcnMoe1xyXG4gIHBvbHlnb25zLFxyXG4gIHNpbXVsYXRpb24sXHJcbn0pO1xyXG4iLCJpbXBvcnQgJ0ByZWR1eC1zYWdhL3N5bWJvbHMnO1xuaW1wb3J0ICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCB7IGNoYW5uZWwsIHN0cmluZ2FibGVGdW5jLCBmdW5jLCBub3RVbmRlZiB9IGZyb20gJ0ByZWR1eC1zYWdhL2lzJztcbmltcG9ydCB7IHEgYXMgbWFrZUl0ZXJhdG9yLCBLIGFzIHRha2UsIEwgYXMgZm9yaywgTSBhcyBjYW5jZWwsIE4gYXMgY2FsbCwgTyBhcyBhY3Rpb25DaGFubmVsLCBRIGFzIHNsaWRpbmcsIFUgYXMgZGVsYXksIFYgYXMgcmFjZSwgYyBhcyBjaGVjayB9IGZyb20gJy4vaW8tNmRlMTU2ZjMuanMnO1xuZXhwb3J0IHsgTyBhcyBhY3Rpb25DaGFubmVsLCBfIGFzIGFsbCwgJCBhcyBhcHBseSwgTiBhcyBjYWxsLCBNIGFzIGNhbmNlbCwgYTQgYXMgY2FuY2VsbGVkLCBhMCBhcyBjcHMsIFUgYXMgZGVsYXksIFcgYXMgZWZmZWN0VHlwZXMsIGE1IGFzIGZsdXNoLCBMIGFzIGZvcmssIGE2IGFzIGdldENvbnRleHQsIGEyIGFzIGpvaW4sIFkgYXMgcHV0LCBaIGFzIHB1dFJlc29sdmUsIFYgYXMgcmFjZSwgYTMgYXMgc2VsZWN0LCBhNyBhcyBzZXRDb250ZXh0LCBhMSBhcyBzcGF3biwgSyBhcyB0YWtlLCBYIGFzIHRha2VNYXliZSB9IGZyb20gJy4vaW8tNmRlMTU2ZjMuanMnO1xuaW1wb3J0ICdAcmVkdXgtc2FnYS9kZWxheS1wJztcblxudmFyIGRvbmUgPSBmdW5jdGlvbiBkb25lKHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZG9uZTogdHJ1ZSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cbnZhciBxRW5kID0ge307XG5mdW5jdGlvbiBzYWZlTmFtZShwYXR0ZXJuT3JDaGFubmVsKSB7XG4gIGlmIChjaGFubmVsKHBhdHRlcm5PckNoYW5uZWwpKSB7XG4gICAgcmV0dXJuICdjaGFubmVsJztcbiAgfVxuXG4gIGlmIChzdHJpbmdhYmxlRnVuYyhwYXR0ZXJuT3JDaGFubmVsKSkge1xuICAgIHJldHVybiBTdHJpbmcocGF0dGVybk9yQ2hhbm5lbCk7XG4gIH1cblxuICBpZiAoZnVuYyhwYXR0ZXJuT3JDaGFubmVsKSkge1xuICAgIHJldHVybiBwYXR0ZXJuT3JDaGFubmVsLm5hbWU7XG4gIH1cblxuICByZXR1cm4gU3RyaW5nKHBhdHRlcm5PckNoYW5uZWwpO1xufVxuZnVuY3Rpb24gZnNtSXRlcmF0b3IoZnNtLCBzdGFydFN0YXRlLCBuYW1lKSB7XG4gIHZhciBzdGF0ZVVwZGF0ZXIsXG4gICAgICBlcnJvclN0YXRlLFxuICAgICAgZWZmZWN0LFxuICAgICAgbmV4dFN0YXRlID0gc3RhcnRTdGF0ZTtcblxuICBmdW5jdGlvbiBuZXh0KGFyZywgZXJyb3IpIHtcbiAgICBpZiAobmV4dFN0YXRlID09PSBxRW5kKSB7XG4gICAgICByZXR1cm4gZG9uZShhcmcpO1xuICAgIH1cblxuICAgIGlmIChlcnJvciAmJiAhZXJyb3JTdGF0ZSkge1xuICAgICAgbmV4dFN0YXRlID0gcUVuZDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZVVwZGF0ZXIgJiYgc3RhdGVVcGRhdGVyKGFyZyk7XG4gICAgICB2YXIgY3VycmVudFN0YXRlID0gZXJyb3IgPyBmc21bZXJyb3JTdGF0ZV0oZXJyb3IpIDogZnNtW25leHRTdGF0ZV0oKTtcbiAgICAgIG5leHRTdGF0ZSA9IGN1cnJlbnRTdGF0ZS5uZXh0U3RhdGU7XG4gICAgICBlZmZlY3QgPSBjdXJyZW50U3RhdGUuZWZmZWN0O1xuICAgICAgc3RhdGVVcGRhdGVyID0gY3VycmVudFN0YXRlLnN0YXRlVXBkYXRlcjtcbiAgICAgIGVycm9yU3RhdGUgPSBjdXJyZW50U3RhdGUuZXJyb3JTdGF0ZTtcbiAgICAgIHJldHVybiBuZXh0U3RhdGUgPT09IHFFbmQgPyBkb25lKGFyZykgOiBlZmZlY3Q7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1ha2VJdGVyYXRvcihuZXh0LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICByZXR1cm4gbmV4dChudWxsLCBlcnJvcik7XG4gIH0sIG5hbWUpO1xufVxuXG5mdW5jdGlvbiB0YWtlRXZlcnkocGF0dGVybk9yQ2hhbm5lbCwgd29ya2VyKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHZhciB5VGFrZSA9IHtcbiAgICBkb25lOiBmYWxzZSxcbiAgICB2YWx1ZTogdGFrZShwYXR0ZXJuT3JDaGFubmVsKVxuICB9O1xuXG4gIHZhciB5Rm9yayA9IGZ1bmN0aW9uIHlGb3JrKGFjKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgdmFsdWU6IGZvcmsuYXBwbHkodm9pZCAwLCBbd29ya2VyXS5jb25jYXQoYXJncywgW2FjXSkpXG4gICAgfTtcbiAgfTtcblxuICB2YXIgYWN0aW9uLFxuICAgICAgc2V0QWN0aW9uID0gZnVuY3Rpb24gc2V0QWN0aW9uKGFjKSB7XG4gICAgcmV0dXJuIGFjdGlvbiA9IGFjO1xuICB9O1xuXG4gIHJldHVybiBmc21JdGVyYXRvcih7XG4gICAgcTE6IGZ1bmN0aW9uIHExKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dFN0YXRlOiAncTInLFxuICAgICAgICBlZmZlY3Q6IHlUYWtlLFxuICAgICAgICBzdGF0ZVVwZGF0ZXI6IHNldEFjdGlvblxuICAgICAgfTtcbiAgICB9LFxuICAgIHEyOiBmdW5jdGlvbiBxMigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHRTdGF0ZTogJ3ExJyxcbiAgICAgICAgZWZmZWN0OiB5Rm9yayhhY3Rpb24pXG4gICAgICB9O1xuICAgIH1cbiAgfSwgJ3ExJywgXCJ0YWtlRXZlcnkoXCIgKyBzYWZlTmFtZShwYXR0ZXJuT3JDaGFubmVsKSArIFwiLCBcIiArIHdvcmtlci5uYW1lICsgXCIpXCIpO1xufVxuXG5mdW5jdGlvbiB0YWtlTGF0ZXN0KHBhdHRlcm5PckNoYW5uZWwsIHdvcmtlcikge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgeVRha2UgPSB7XG4gICAgZG9uZTogZmFsc2UsXG4gICAgdmFsdWU6IHRha2UocGF0dGVybk9yQ2hhbm5lbClcbiAgfTtcblxuICB2YXIgeUZvcmsgPSBmdW5jdGlvbiB5Rm9yayhhYykge1xuICAgIHJldHVybiB7XG4gICAgICBkb25lOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBmb3JrLmFwcGx5KHZvaWQgMCwgW3dvcmtlcl0uY29uY2F0KGFyZ3MsIFthY10pKVxuICAgIH07XG4gIH07XG5cbiAgdmFyIHlDYW5jZWwgPSBmdW5jdGlvbiB5Q2FuY2VsKHRhc2spIHtcbiAgICByZXR1cm4ge1xuICAgICAgZG9uZTogZmFsc2UsXG4gICAgICB2YWx1ZTogY2FuY2VsKHRhc2spXG4gICAgfTtcbiAgfTtcblxuICB2YXIgdGFzaywgYWN0aW9uO1xuXG4gIHZhciBzZXRUYXNrID0gZnVuY3Rpb24gc2V0VGFzayh0KSB7XG4gICAgcmV0dXJuIHRhc2sgPSB0O1xuICB9O1xuXG4gIHZhciBzZXRBY3Rpb24gPSBmdW5jdGlvbiBzZXRBY3Rpb24oYWMpIHtcbiAgICByZXR1cm4gYWN0aW9uID0gYWM7XG4gIH07XG5cbiAgcmV0dXJuIGZzbUl0ZXJhdG9yKHtcbiAgICBxMTogZnVuY3Rpb24gcTEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0U3RhdGU6ICdxMicsXG4gICAgICAgIGVmZmVjdDogeVRha2UsXG4gICAgICAgIHN0YXRlVXBkYXRlcjogc2V0QWN0aW9uXG4gICAgICB9O1xuICAgIH0sXG4gICAgcTI6IGZ1bmN0aW9uIHEyKCkge1xuICAgICAgcmV0dXJuIHRhc2sgPyB7XG4gICAgICAgIG5leHRTdGF0ZTogJ3EzJyxcbiAgICAgICAgZWZmZWN0OiB5Q2FuY2VsKHRhc2spXG4gICAgICB9IDoge1xuICAgICAgICBuZXh0U3RhdGU6ICdxMScsXG4gICAgICAgIGVmZmVjdDogeUZvcmsoYWN0aW9uKSxcbiAgICAgICAgc3RhdGVVcGRhdGVyOiBzZXRUYXNrXG4gICAgICB9O1xuICAgIH0sXG4gICAgcTM6IGZ1bmN0aW9uIHEzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dFN0YXRlOiAncTEnLFxuICAgICAgICBlZmZlY3Q6IHlGb3JrKGFjdGlvbiksXG4gICAgICAgIHN0YXRlVXBkYXRlcjogc2V0VGFza1xuICAgICAgfTtcbiAgICB9XG4gIH0sICdxMScsIFwidGFrZUxhdGVzdChcIiArIHNhZmVOYW1lKHBhdHRlcm5PckNoYW5uZWwpICsgXCIsIFwiICsgd29ya2VyLm5hbWUgKyBcIilcIik7XG59XG5cbmZ1bmN0aW9uIHRha2VMZWFkaW5nKHBhdHRlcm5PckNoYW5uZWwsIHdvcmtlcikge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgeVRha2UgPSB7XG4gICAgZG9uZTogZmFsc2UsXG4gICAgdmFsdWU6IHRha2UocGF0dGVybk9yQ2hhbm5lbClcbiAgfTtcblxuICB2YXIgeUNhbGwgPSBmdW5jdGlvbiB5Q2FsbChhYykge1xuICAgIHJldHVybiB7XG4gICAgICBkb25lOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBjYWxsLmFwcGx5KHZvaWQgMCwgW3dvcmtlcl0uY29uY2F0KGFyZ3MsIFthY10pKVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGFjdGlvbjtcblxuICB2YXIgc2V0QWN0aW9uID0gZnVuY3Rpb24gc2V0QWN0aW9uKGFjKSB7XG4gICAgcmV0dXJuIGFjdGlvbiA9IGFjO1xuICB9O1xuXG4gIHJldHVybiBmc21JdGVyYXRvcih7XG4gICAgcTE6IGZ1bmN0aW9uIHExKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dFN0YXRlOiAncTInLFxuICAgICAgICBlZmZlY3Q6IHlUYWtlLFxuICAgICAgICBzdGF0ZVVwZGF0ZXI6IHNldEFjdGlvblxuICAgICAgfTtcbiAgICB9LFxuICAgIHEyOiBmdW5jdGlvbiBxMigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHRTdGF0ZTogJ3ExJyxcbiAgICAgICAgZWZmZWN0OiB5Q2FsbChhY3Rpb24pXG4gICAgICB9O1xuICAgIH1cbiAgfSwgJ3ExJywgXCJ0YWtlTGVhZGluZyhcIiArIHNhZmVOYW1lKHBhdHRlcm5PckNoYW5uZWwpICsgXCIsIFwiICsgd29ya2VyLm5hbWUgKyBcIilcIik7XG59XG5cbmZ1bmN0aW9uIHRocm90dGxlKGRlbGF5TGVuZ3RoLCBwYXR0ZXJuLCB3b3JrZXIpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDMgPyBfbGVuIC0gMyA6IDApLCBfa2V5ID0gMzsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDNdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIGFjdGlvbiwgY2hhbm5lbDtcbiAgdmFyIHlBY3Rpb25DaGFubmVsID0ge1xuICAgIGRvbmU6IGZhbHNlLFxuICAgIHZhbHVlOiBhY3Rpb25DaGFubmVsKHBhdHRlcm4sIHNsaWRpbmcoMSkpXG4gIH07XG5cbiAgdmFyIHlUYWtlID0gZnVuY3Rpb24geVRha2UoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHRha2UoY2hhbm5lbClcbiAgICB9O1xuICB9O1xuXG4gIHZhciB5Rm9yayA9IGZ1bmN0aW9uIHlGb3JrKGFjKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgdmFsdWU6IGZvcmsuYXBwbHkodm9pZCAwLCBbd29ya2VyXS5jb25jYXQoYXJncywgW2FjXSkpXG4gICAgfTtcbiAgfTtcblxuICB2YXIgeURlbGF5ID0ge1xuICAgIGRvbmU6IGZhbHNlLFxuICAgIHZhbHVlOiBkZWxheShkZWxheUxlbmd0aClcbiAgfTtcblxuICB2YXIgc2V0QWN0aW9uID0gZnVuY3Rpb24gc2V0QWN0aW9uKGFjKSB7XG4gICAgcmV0dXJuIGFjdGlvbiA9IGFjO1xuICB9O1xuXG4gIHZhciBzZXRDaGFubmVsID0gZnVuY3Rpb24gc2V0Q2hhbm5lbChjaCkge1xuICAgIHJldHVybiBjaGFubmVsID0gY2g7XG4gIH07XG5cbiAgcmV0dXJuIGZzbUl0ZXJhdG9yKHtcbiAgICBxMTogZnVuY3Rpb24gcTEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0U3RhdGU6ICdxMicsXG4gICAgICAgIGVmZmVjdDogeUFjdGlvbkNoYW5uZWwsXG4gICAgICAgIHN0YXRlVXBkYXRlcjogc2V0Q2hhbm5lbFxuICAgICAgfTtcbiAgICB9LFxuICAgIHEyOiBmdW5jdGlvbiBxMigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHRTdGF0ZTogJ3EzJyxcbiAgICAgICAgZWZmZWN0OiB5VGFrZSgpLFxuICAgICAgICBzdGF0ZVVwZGF0ZXI6IHNldEFjdGlvblxuICAgICAgfTtcbiAgICB9LFxuICAgIHEzOiBmdW5jdGlvbiBxMygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHRTdGF0ZTogJ3E0JyxcbiAgICAgICAgZWZmZWN0OiB5Rm9yayhhY3Rpb24pXG4gICAgICB9O1xuICAgIH0sXG4gICAgcTQ6IGZ1bmN0aW9uIHE0KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dFN0YXRlOiAncTInLFxuICAgICAgICBlZmZlY3Q6IHlEZWxheVxuICAgICAgfTtcbiAgICB9XG4gIH0sICdxMScsIFwidGhyb3R0bGUoXCIgKyBzYWZlTmFtZShwYXR0ZXJuKSArIFwiLCBcIiArIHdvcmtlci5uYW1lICsgXCIpXCIpO1xufVxuXG5mdW5jdGlvbiByZXRyeShtYXhUcmllcywgZGVsYXlMZW5ndGgsIGZuKSB7XG4gIHZhciBjb3VudGVyID0gbWF4VHJpZXM7XG5cbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDMgPyBfbGVuIC0gMyA6IDApLCBfa2V5ID0gMzsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDNdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIHlDYWxsID0ge1xuICAgIGRvbmU6IGZhbHNlLFxuICAgIHZhbHVlOiBjYWxsLmFwcGx5KHZvaWQgMCwgW2ZuXS5jb25jYXQoYXJncykpXG4gIH07XG4gIHZhciB5RGVsYXkgPSB7XG4gICAgZG9uZTogZmFsc2UsXG4gICAgdmFsdWU6IGRlbGF5KGRlbGF5TGVuZ3RoKVxuICB9O1xuICByZXR1cm4gZnNtSXRlcmF0b3Ioe1xuICAgIHExOiBmdW5jdGlvbiBxMSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHRTdGF0ZTogJ3EyJyxcbiAgICAgICAgZWZmZWN0OiB5Q2FsbCxcbiAgICAgICAgZXJyb3JTdGF0ZTogJ3ExMCdcbiAgICAgIH07XG4gICAgfSxcbiAgICBxMjogZnVuY3Rpb24gcTIoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0U3RhdGU6IHFFbmRcbiAgICAgIH07XG4gICAgfSxcbiAgICBxMTA6IGZ1bmN0aW9uIHExMChlcnJvcikge1xuICAgICAgY291bnRlciAtPSAxO1xuXG4gICAgICBpZiAoY291bnRlciA8PSAwKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0U3RhdGU6ICdxMScsXG4gICAgICAgIGVmZmVjdDogeURlbGF5XG4gICAgICB9O1xuICAgIH1cbiAgfSwgJ3ExJywgXCJyZXRyeShcIiArIGZuLm5hbWUgKyBcIilcIik7XG59XG5cbmZ1bmN0aW9uIGRlYm91bmNlSGVscGVyKGRlbGF5TGVuZ3RoLCBwYXR0ZXJuT3JDaGFubmVsLCB3b3JrZXIpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDMgPyBfbGVuIC0gMyA6IDApLCBfa2V5ID0gMzsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDNdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIGFjdGlvbiwgcmFjZU91dHB1dDtcbiAgdmFyIHlUYWtlID0ge1xuICAgIGRvbmU6IGZhbHNlLFxuICAgIHZhbHVlOiB0YWtlKHBhdHRlcm5PckNoYW5uZWwpXG4gIH07XG4gIHZhciB5UmFjZSA9IHtcbiAgICBkb25lOiBmYWxzZSxcbiAgICB2YWx1ZTogcmFjZSh7XG4gICAgICBhY3Rpb246IHRha2UocGF0dGVybk9yQ2hhbm5lbCksXG4gICAgICBkZWJvdW5jZTogZGVsYXkoZGVsYXlMZW5ndGgpXG4gICAgfSlcbiAgfTtcblxuICB2YXIgeUZvcmsgPSBmdW5jdGlvbiB5Rm9yayhhYykge1xuICAgIHJldHVybiB7XG4gICAgICBkb25lOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBmb3JrLmFwcGx5KHZvaWQgMCwgW3dvcmtlcl0uY29uY2F0KGFyZ3MsIFthY10pKVxuICAgIH07XG4gIH07XG5cbiAgdmFyIHlOb29wID0gZnVuY3Rpb24geU5vb3AodmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZG9uZTogZmFsc2UsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9O1xuICB9O1xuXG4gIHZhciBzZXRBY3Rpb24gPSBmdW5jdGlvbiBzZXRBY3Rpb24oYWMpIHtcbiAgICByZXR1cm4gYWN0aW9uID0gYWM7XG4gIH07XG5cbiAgdmFyIHNldFJhY2VPdXRwdXQgPSBmdW5jdGlvbiBzZXRSYWNlT3V0cHV0KHJvKSB7XG4gICAgcmV0dXJuIHJhY2VPdXRwdXQgPSBybztcbiAgfTtcblxuICByZXR1cm4gZnNtSXRlcmF0b3Ioe1xuICAgIHExOiBmdW5jdGlvbiBxMSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHRTdGF0ZTogJ3EyJyxcbiAgICAgICAgZWZmZWN0OiB5VGFrZSxcbiAgICAgICAgc3RhdGVVcGRhdGVyOiBzZXRBY3Rpb25cbiAgICAgIH07XG4gICAgfSxcbiAgICBxMjogZnVuY3Rpb24gcTIoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0U3RhdGU6ICdxMycsXG4gICAgICAgIGVmZmVjdDogeVJhY2UsXG4gICAgICAgIHN0YXRlVXBkYXRlcjogc2V0UmFjZU91dHB1dFxuICAgICAgfTtcbiAgICB9LFxuICAgIHEzOiBmdW5jdGlvbiBxMygpIHtcbiAgICAgIHJldHVybiByYWNlT3V0cHV0LmRlYm91bmNlID8ge1xuICAgICAgICBuZXh0U3RhdGU6ICdxMScsXG4gICAgICAgIGVmZmVjdDogeUZvcmsoYWN0aW9uKVxuICAgICAgfSA6IHtcbiAgICAgICAgbmV4dFN0YXRlOiAncTInLFxuICAgICAgICBlZmZlY3Q6IHlOb29wKHJhY2VPdXRwdXQuYWN0aW9uKSxcbiAgICAgICAgc3RhdGVVcGRhdGVyOiBzZXRBY3Rpb25cbiAgICAgIH07XG4gICAgfVxuICB9LCAncTEnLCBcImRlYm91bmNlKFwiICsgc2FmZU5hbWUocGF0dGVybk9yQ2hhbm5lbCkgKyBcIiwgXCIgKyB3b3JrZXIubmFtZSArIFwiKVwiKTtcbn1cblxudmFyIHZhbGlkYXRlVGFrZUVmZmVjdCA9IGZ1bmN0aW9uIHZhbGlkYXRlVGFrZUVmZmVjdChmbiwgcGF0dGVybk9yQ2hhbm5lbCwgd29ya2VyKSB7XG4gIGNoZWNrKHBhdHRlcm5PckNoYW5uZWwsIG5vdFVuZGVmLCBmbi5uYW1lICsgXCIgcmVxdWlyZXMgYSBwYXR0ZXJuIG9yIGNoYW5uZWxcIik7XG4gIGNoZWNrKHdvcmtlciwgbm90VW5kZWYsIGZuLm5hbWUgKyBcIiByZXF1aXJlcyBhIHNhZ2EgcGFyYW1ldGVyXCIpO1xufTtcblxuZnVuY3Rpb24gdGFrZUV2ZXJ5JDEocGF0dGVybk9yQ2hhbm5lbCwgd29ya2VyKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFsaWRhdGVUYWtlRWZmZWN0KHRha2VFdmVyeSQxLCBwYXR0ZXJuT3JDaGFubmVsLCB3b3JrZXIpO1xuICB9XG5cbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGZvcmsuYXBwbHkodm9pZCAwLCBbdGFrZUV2ZXJ5LCBwYXR0ZXJuT3JDaGFubmVsLCB3b3JrZXJdLmNvbmNhdChhcmdzKSk7XG59XG5mdW5jdGlvbiB0YWtlTGF0ZXN0JDEocGF0dGVybk9yQ2hhbm5lbCwgd29ya2VyKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFsaWRhdGVUYWtlRWZmZWN0KHRha2VMYXRlc3QkMSwgcGF0dGVybk9yQ2hhbm5lbCwgd29ya2VyKTtcbiAgfVxuXG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuXG4gIHJldHVybiBmb3JrLmFwcGx5KHZvaWQgMCwgW3Rha2VMYXRlc3QsIHBhdHRlcm5PckNoYW5uZWwsIHdvcmtlcl0uY29uY2F0KGFyZ3MpKTtcbn1cbmZ1bmN0aW9uIHRha2VMZWFkaW5nJDEocGF0dGVybk9yQ2hhbm5lbCwgd29ya2VyKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFsaWRhdGVUYWtlRWZmZWN0KHRha2VMZWFkaW5nJDEsIHBhdHRlcm5PckNoYW5uZWwsIHdvcmtlcik7XG4gIH1cblxuICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMgPiAyID8gX2xlbjMgLSAyIDogMCksIF9rZXkzID0gMjsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgIGFyZ3NbX2tleTMgLSAyXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gIH1cblxuICByZXR1cm4gZm9yay5hcHBseSh2b2lkIDAsIFt0YWtlTGVhZGluZywgcGF0dGVybk9yQ2hhbm5lbCwgd29ya2VyXS5jb25jYXQoYXJncykpO1xufVxuZnVuY3Rpb24gdGhyb3R0bGUkMShtcywgcGF0dGVybiwgd29ya2VyKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2hlY2socGF0dGVybiwgbm90VW5kZWYsICd0aHJvdHRsZSByZXF1aXJlcyBhIHBhdHRlcm4nKTtcbiAgICBjaGVjayh3b3JrZXIsIG5vdFVuZGVmLCAndGhyb3R0bGUgcmVxdWlyZXMgYSBzYWdhIHBhcmFtZXRlcicpO1xuICB9XG5cbiAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40ID4gMyA/IF9sZW40IC0gMyA6IDApLCBfa2V5NCA9IDM7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICBhcmdzW19rZXk0IC0gM10gPSBhcmd1bWVudHNbX2tleTRdO1xuICB9XG5cbiAgcmV0dXJuIGZvcmsuYXBwbHkodm9pZCAwLCBbdGhyb3R0bGUsIG1zLCBwYXR0ZXJuLCB3b3JrZXJdLmNvbmNhdChhcmdzKSk7XG59XG5mdW5jdGlvbiByZXRyeSQxKG1heFRyaWVzLCBkZWxheUxlbmd0aCwgd29ya2VyKSB7XG4gIGZvciAodmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNSA+IDMgPyBfbGVuNSAtIDMgOiAwKSwgX2tleTUgPSAzOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgYXJnc1tfa2V5NSAtIDNdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgfVxuXG4gIHJldHVybiBjYWxsLmFwcGx5KHZvaWQgMCwgW3JldHJ5LCBtYXhUcmllcywgZGVsYXlMZW5ndGgsIHdvcmtlcl0uY29uY2F0KGFyZ3MpKTtcbn1cbmZ1bmN0aW9uIGRlYm91bmNlKGRlbGF5TGVuZ3RoLCBwYXR0ZXJuLCB3b3JrZXIpIHtcbiAgZm9yICh2YXIgX2xlbjYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42ID4gMyA/IF9sZW42IC0gMyA6IDApLCBfa2V5NiA9IDM7IF9rZXk2IDwgX2xlbjY7IF9rZXk2KyspIHtcbiAgICBhcmdzW19rZXk2IC0gM10gPSBhcmd1bWVudHNbX2tleTZdO1xuICB9XG5cbiAgcmV0dXJuIGZvcmsuYXBwbHkodm9pZCAwLCBbZGVib3VuY2VIZWxwZXIsIGRlbGF5TGVuZ3RoLCBwYXR0ZXJuLCB3b3JrZXJdLmNvbmNhdChhcmdzKSk7XG59XG5cbmV4cG9ydCB7IGRlYm91bmNlLCByZXRyeSQxIGFzIHJldHJ5LCB0YWtlRXZlcnkkMSBhcyB0YWtlRXZlcnksIHRha2VMYXRlc3QkMSBhcyB0YWtlTGF0ZXN0LCB0YWtlTGVhZGluZyQxIGFzIHRha2VMZWFkaW5nLCB0aHJvdHRsZSQxIGFzIHRocm90dGxlIH07XG4iLCJleHBvcnQgKiBmcm9tICdAcmVkdXgtc2FnYS9jb3JlL2VmZmVjdHMnO1xuIiwiaW1wb3J0IEltbXV0YWJsZSBmcm9tICdpbW11dGFibGUnO1xyXG5cclxuaW1wb3J0IHsgUG9seWdvbiwgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgnO1xyXG5pbXBvcnQgKiBhcyBtYXRoVXRpbHMgZnJvbSAnLi4vbWF0aC91dGlscyc7XHJcblxyXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVSYW5kb21Qb2x5Z29uID0gKCkgPT4ge1xyXG4gIHJldHVybiBJbW11dGFibGUuZnJvbUpTKFxyXG4gICAgUG9seWdvbi5nZW5lcmF0ZVJhbmRvbShcclxuICAgICAgbWF0aFV0aWxzLnJhbmRSYW5nZUludCgzLCA2ICsgMSksXHJcbiAgICApLFxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVSYW5kb21WZWN0b3IgPSAocmFuZ2VMZW5ndGhTdGFydCA9IDEsIHJhbmdlTGVuZ3RoRW5kID0gNSkgPT4ge1xyXG4gIHJldHVybiBJbW11dGFibGUuZnJvbUpTKFxyXG4gICAgVmVjdG9yMi5nZW5lcmF0ZVJhbmRvbShyYW5nZUxlbmd0aFN0YXJ0LCByYW5nZUxlbmd0aEVuZCksXHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZW5lcmF0ZVJhbmRvbVZlY3RvckZyb21Db29yZHMgPSAoXHJcbiAgcmFuZ2VYU3RhcnQsXHJcbiAgcmFuZ2VYRW5kLFxyXG4gIHJhbmdlWVN0YXJ0LFxyXG4gIHJhbmdlWUVuZCxcclxuKSA9PiB7XHJcbiAgcmV0dXJuIEltbXV0YWJsZS5mcm9tSlMoXHJcbiAgICBWZWN0b3IyLmdlbmVyYXRlUmFuZG9tRnJvbUNvb3JkcyhcclxuICAgICAgcmFuZ2VYU3RhcnQsXHJcbiAgICAgIHJhbmdlWEVuZCxcclxuICAgICAgcmFuZ2VZU3RhcnQsXHJcbiAgICAgIHJhbmdlWUVuZCxcclxuICAgICksXHJcbiAgKTtcclxufTtcclxuIiwiaW1wb3J0IHtcclxuICBwdXQsXHJcbiAgdGFrZUV2ZXJ5LFxyXG4gIGFsbCxcclxuICBzZWxlY3QsXHJcbn0gZnJvbSAncmVkdXgtc2FnYS9lZmZlY3RzJztcclxuaW1wb3J0IEltbXV0YWJsZSBmcm9tICdpbW11dGFibGUnO1xyXG5cclxuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgnO1xyXG5cclxuaW1wb3J0IHsgU0VUX1NUQUdFX0JPVU5EUyB9IGZyb20gJy4uL2FjdGlvbnMvc2ltdWxhdGlvbic7XHJcbmltcG9ydCB7IHNhdmVQb2x5Z29ucywgVVBEQVRFX1BPTFlHT05TIH0gZnJvbSAnLi4vYWN0aW9ucy9wb2x5Z29ucyc7XHJcblxyXG5pbXBvcnQgeyBnZXRQb2x5Z29uTGlzdCB9IGZyb20gJy4uL3NlbGVjdG9ycy9wb2x5Z29ucyc7XHJcbmltcG9ydCB7IGdldFN0YWdlQm91bmRzLCBnZXRTdGFnZUJvcmRlcmluZ0xpbmVzIH0gZnJvbSAnLi4vc2VsZWN0b3JzL3NpbXVsYXRpb24nO1xyXG5cclxuaW1wb3J0IHsgZ2VuZXJhdGVSYW5kb21Qb2x5Z29uLCBnZW5lcmF0ZVJhbmRvbVZlY3RvciB9IGZyb20gJy4uL3V0aWxzL3JhbmRvbUpzb24nO1xyXG5pbXBvcnQgKiBhcyBtYXRoVXRpbHMgZnJvbSAnLi4vbWF0aC91dGlscyc7XHJcblxyXG5jb25zdCBDSVJDTEVfUkFESUFOUyA9IDIgKiBNYXRoLlBJO1xyXG5jb25zdCBPTUVHQV9SQU5HRV9QRVJDRU5UQUdFID0gMC4xNTtcclxuY29uc3QgT01FR0FfUkFOR0VfQUJTID0gQ0lSQ0xFX1JBRElBTlMgKiBPTUVHQV9SQU5HRV9QRVJDRU5UQUdFO1xyXG5cclxuY29uc3QgTUlOX1BPU0lUSU9OX1ggPSAxMDA7XHJcbmxldCBNQVhfUE9TSVRJT05fWDtcclxuXHJcbmNvbnN0IE1JTl9QT1NJVElPTl9ZID0gMTAwO1xyXG5sZXQgTUFYX1BPU0lUSU9OX1k7XHJcblxyXG5sZXQgbG9vcCA9IDA7XHJcblxyXG5jb25zdCBnZXRQb2x5Z29uSW5pdGlhbFN0YXRlID0gKGlkLCBwb3NpdGlvbikgPT4ge1xyXG4gIGNvbnN0IHBvbHlnb24gPSBnZW5lcmF0ZVJhbmRvbVBvbHlnb24oKTtcclxuXHJcbiAgcmV0dXJuIEltbXV0YWJsZS5mcm9tSlMoe1xyXG4gICAgaWQsXHJcbiAgICBwb2x5Z29uLFxyXG4gICAgcmFkaXVzOiBwb2x5Z29uLnJhZGl1cyxcclxuICAgIG1hc3M6IG1hdGhVdGlscy5yYW5kUmFuZ2VJbnQoNSwgMjApLCAvLyBrZ1xyXG4gICAgcG9zaXRpb24sXHJcbiAgICByb3RhdGlvbjogMCxcclxuICAgIHZlbG9jaXR5OiBnZW5lcmF0ZVJhbmRvbVZlY3Rvcig3NSwgMTUwKSwgLy8gbWFnbml0dWRlOiBzcGVlZCBwZXIgc2Vjb25kXHJcbiAgICBhbmd1bGFyVmVsb2NpdHk6XHJcbiAgICAgIG1hdGhVdGlscy5yYW5kUmFuZ2VGbG9hdCgtT01FR0FfUkFOR0VfQUJTLCBPTUVHQV9SQU5HRV9BQlMpLCAvLyByYWRpYW5zIHBlciBzZWNvbmRcclxuICB9KTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiogZ2VuZXJhdGVQb2x5Z29ucyhhY3Rpb24pIHtcclxuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGFjdGlvbi5wYXlsb2FkO1xyXG5cclxuICBNQVhfUE9TSVRJT05fWCA9IHdpZHRoIC0gMTAwO1xyXG4gIE1BWF9QT1NJVElPTl9ZID0gaGVpZ2h0IC0gMTAwO1xyXG5cclxuICBjb25zdCBwb2x5MVhSYW5nZSA9IFtNSU5fUE9TSVRJT05fWCwgd2lkdGggLyAyXTtcclxuICBjb25zdCBwb2x5MlhSYW5nZSA9IFt3aWR0aCAvIDIsIE1BWF9QT1NJVElPTl9YXTtcclxuXHJcbiAgY29uc3QgcG9seTFQb3NpdGlvbiA9IFZlY3RvcjIuZ2VuZXJhdGVSYW5kb21Gcm9tQ29vcmRzKFxyXG4gICAgcG9seTFYUmFuZ2VbMF0sXHJcbiAgICBwb2x5MVhSYW5nZVsxXSxcclxuICAgIDAsXHJcbiAgICBoZWlnaHQsXHJcbiAgKTtcclxuXHJcbiAgY29uc3QgcG9seTJQb3NpdGlvbiA9IFZlY3RvcjIuZ2VuZXJhdGVSYW5kb21Gcm9tQ29vcmRzKFxyXG4gICAgcG9seTJYUmFuZ2VbMF0sXHJcbiAgICBwb2x5MlhSYW5nZVsxXSxcclxuICAgIDAsXHJcbiAgICBoZWlnaHQsXHJcbiAgKTtcclxuXHJcbiAgY29uc3QgcG9seTEgPSBnZXRQb2x5Z29uSW5pdGlhbFN0YXRlKDEsIHBvbHkxUG9zaXRpb24uaW52ZXJ0WSg1NDApKTtcclxuICBjb25zdCBwb2x5MiA9IGdldFBvbHlnb25Jbml0aWFsU3RhdGUoMiwgcG9seTJQb3NpdGlvbi5pbnZlcnRZKDU0MCkpO1xyXG5cclxuICBjb25zdCBwb2x5Z29ucyA9IEltbXV0YWJsZS5mcm9tSlMoW3BvbHkxLCBwb2x5Ml0pO1xyXG5cclxuICB5aWVsZCBwdXQoc2F2ZVBvbHlnb25zKHBvbHlnb25zKSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiogdXBkYXRlUG9seWdvbnMoYWN0aW9uKSB7XHJcbiAgY29uc3QgeyBwYXlsb2FkOiB7IGRlbHRhVGltZSB9IH0gPSBhY3Rpb247XHJcbiAgY29uc3QgZGVsdGFTZWNvbmRzID0gZGVsdGFUaW1lIC8gMzYwMDtcclxuXHJcbiAgbGV0IHBvbHlnb25zID0geWllbGQgc2VsZWN0KGdldFBvbHlnb25MaXN0KTtcclxuICBjb25zdCBzdGFnZUJvdW5kcyA9IHlpZWxkIHNlbGVjdChnZXRTdGFnZUJvdW5kcyk7XHJcbiAgY29uc3Qgc3RhZ2VCb3JkZXJpbmdMaW5lcyA9IHlpZWxkIHNlbGVjdChnZXRTdGFnZUJvcmRlcmluZ0xpbmVzKTtcclxuXHJcbiAgY29uc3QgcG9seUNvbGxpc2lvbnNDaGVja2VkID0gW107XHJcblxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9seWdvbnMuc2l6ZTsgaSArPSAxKSB7XHJcbiAgICBsb29wICs9IDE7XHJcblxyXG4gICAgY29uc3QgcG9seWdvbiA9IHBvbHlnb25zLmdldChpKTtcclxuICAgIGNvbnN0IHZlbG9jaXR5ID0gcG9seWdvbi5nZXQoJ3ZlbG9jaXR5Jyk7XHJcblxyXG4gICAgY29uc3QgcG9zaXRpb25EZWx0YSA9IHZlbG9jaXR5Lm11bHRpcGx5U2NhbGFyKGRlbHRhU2Vjb25kcyk7XHJcbiAgICBjb25zdCBuZXdQb3NpdGlvbiA9IHBvbHlnb24uZ2V0KCdwb3NpdGlvbicpLmFkZFZlY3Rvcihwb3NpdGlvbkRlbHRhKTtcclxuICAgIHBvbHlnb25zID0gcG9seWdvbnMuc2V0SW4oW2ksICdwb3NpdGlvbiddLCBuZXdQb3NpdGlvbik7XHJcblxyXG4gICAgY29uc3Qgcm90YXRpb25EZWx0YSA9IHBvbHlnb24uZ2V0KCdhbmd1bGFyVmVsb2NpdHknKSAqIGRlbHRhU2Vjb25kcztcclxuICAgIGNvbnN0IG5ld1JvdGF0aW9uID0gcG9seWdvbi5nZXQoJ3JvdGF0aW9uJykgKyByb3RhdGlvbkRlbHRhO1xyXG4gICAgcG9seWdvbnMgPSBwb2x5Z29ucy5zZXRJbihbaSwgJ3JvdGF0aW9uJ10sIG5ld1JvdGF0aW9uKTtcclxuXHJcbiAgICBjb25zdCBtYXRoUG9seWdvbiA9IHBvbHlnb24uZ2V0KCdwb2x5Z29uJyk7XHJcbiAgICBtYXRoUG9seWdvbi5yb3RhdGUocm90YXRpb25EZWx0YSk7XHJcbiAgICBjb25zdCBwb2x5TGluZXMgPSBtYXRoUG9seWdvbi5nZXRMaW5lcyhuZXdQb3NpdGlvbik7XHJcblxyXG4gICAgY29uc3QgaGl0VG9wTGluZSA9IHBvbHlMaW5lcy5zb21lKChsaW5lKSA9PiB7XHJcbiAgICAgIHJldHVybiBsaW5lLmNhbGN1bGF0ZVNlZ21lbnRJbnRlcnNlY3Rpb24oc3RhZ2VCb3JkZXJpbmdMaW5lcy5nZXQoJ3RvcExpbmUnKSk7XHJcbiAgICB9KSAmJiB2ZWxvY2l0eS55IDwgMDtcclxuXHJcbiAgICBjb25zdCBoaXRSaWdodExpbmUgPSBwb2x5TGluZXMuc29tZSgobGluZSkgPT4ge1xyXG4gICAgICByZXR1cm4gbGluZS5jYWxjdWxhdGVTZWdtZW50SW50ZXJzZWN0aW9uKHN0YWdlQm9yZGVyaW5nTGluZXMuZ2V0KCdyaWdodExpbmUnKSk7XHJcbiAgICB9KSAmJiB2ZWxvY2l0eS54ID4gMDtcclxuXHJcbiAgICBjb25zdCBoaXRCb3R0b21MaW5lID0gcG9seUxpbmVzLnNvbWUoKGxpbmUpID0+IHtcclxuICAgICAgcmV0dXJuIGxpbmUuY2FsY3VsYXRlU2VnbWVudEludGVyc2VjdGlvbihzdGFnZUJvcmRlcmluZ0xpbmVzLmdldCgnYm90dG9tTGluZScpKTtcclxuICAgIH0pICYmIHZlbG9jaXR5LnkgPiAwO1xyXG5cclxuICAgIGNvbnN0IGhpdExlZnRMaW5lID0gcG9seUxpbmVzLnNvbWUoKGxpbmUpID0+IHtcclxuICAgICAgcmV0dXJuIGxpbmUuY2FsY3VsYXRlU2VnbWVudEludGVyc2VjdGlvbihzdGFnZUJvcmRlcmluZ0xpbmVzLmdldCgnbGVmdExpbmUnKSk7XHJcbiAgICB9KSAmJiB2ZWxvY2l0eS54IDwgMDtcclxuXHJcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBvbHlnb25zLnNpemU7IGogKz0gMSkge1xyXG4gICAgICBpZiAoaiA9PT0gaSkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgcG9seUNvbGxpc2lvbnNDaGVja2VkLnNvbWUoKHNldCkgPT4ge1xyXG4gICAgICAgICAgcmV0dXJuIHNldC5oYXMoaSkgJiYgc2V0LmhhcyhqKTtcclxuICAgICAgICB9KVxyXG4gICAgICApIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcG9seUNvbGxpc2lvbnNDaGVja2VkLnB1c2gobmV3IFNldChbaSwgal0pKTtcclxuXHJcbiAgICAgIGxldCBpbnRlcnNlY3Rpb247XHJcblxyXG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IHBvbHlMaW5lcy5zaXplOyBrICs9IDEpIHtcclxuICAgICAgICBjb25zdCBsaW5lID0gcG9seUxpbmVzLmdldChrKTtcclxuICAgICAgICBjb25zdCBvdGhlclBvbHlnb25MaW5lcyA9IHBvbHlnb25zLmdldEluKFtqLCAncG9seWdvbiddKVxyXG4gICAgICAgICAgLmdldExpbmVzKHBvbHlnb25zLmdldEluKFtqLCAncG9zaXRpb24nXSkpO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBsID0gMDsgbCA8IG90aGVyUG9seWdvbkxpbmVzLnNpemU7IGwgKz0gMSkge1xyXG4gICAgICAgICAgY29uc3Qgb3RoZXJMaW5lID0gb3RoZXJQb2x5Z29uTGluZXMuZ2V0KGwpO1xyXG4gICAgICAgICAgY29uc3QgX2ludGVyc2VjdGlvbiA9IGxpbmUuY2FsY3VsYXRlU2VnbWVudEludGVyc2VjdGlvbihvdGhlckxpbmUpO1xyXG4gICAgICAgICAgaWYgKF9pbnRlcnNlY3Rpb24pIHtcclxuICAgICAgICAgICAgaW50ZXJzZWN0aW9uID0gX2ludGVyc2VjdGlvbjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaW50ZXJzZWN0aW9uKSB7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpbnRlcnNlY3Rpb24pIHtcclxuICAgICAgICBjb25zdCBjdXJyZW50UG9seWdvbk1hc3MgPSBwb2x5Z29ucy5nZXRJbihbaSwgJ21hc3MnXSk7XHJcbiAgICAgICAgY29uc3Qgb3RoZXJQb2x5Z29uTWFzcyA9IHBvbHlnb25zLmdldEluKFtqLCAnbWFzcyddKTtcclxuICAgICAgICBjb25zdCBjdXJyZW50UG9seWdvbkluaXRpYWxWZWxvY2l0eSA9IHBvbHlnb25zLmdldEluKFtpLCAndmVsb2NpdHknXSk7XHJcbiAgICAgICAgY29uc3Qgb3RoZXJQb2x5Z29uSW5pdGlhbFZlbG9jaXR5ID0gcG9seWdvbnMuZ2V0SW4oW2osICd2ZWxvY2l0eSddKTtcclxuXHJcbiAgICAgICAgY29uc3QgbXVsdGlwbGllcjEgPSAoXHJcbiAgICAgICAgICAoY3VycmVudFBvbHlnb25NYXNzIC0gb3RoZXJQb2x5Z29uTWFzcylcclxuICAgICAgICAgIC8gKGN1cnJlbnRQb2x5Z29uTWFzcyArIG90aGVyUG9seWdvbk1hc3MpXHJcbiAgICAgICAgKTtcclxuICAgICAgICBjb25zdCBtdWx0aXBsaWVyMiA9IChcclxuICAgICAgICAgICgyICogb3RoZXJQb2x5Z29uTWFzcylcclxuICAgICAgICAgIC8gKGN1cnJlbnRQb2x5Z29uTWFzcyArIG90aGVyUG9seWdvbk1hc3MpXHJcbiAgICAgICAgKTtcclxuICAgICAgICBjb25zdCBtdWx0aXBsaWVyMyA9IChcclxuICAgICAgICAgICgyICogY3VycmVudFBvbHlnb25NYXNzKVxyXG4gICAgICAgICAgLyAoY3VycmVudFBvbHlnb25NYXNzICsgb3RoZXJQb2x5Z29uTWFzcylcclxuICAgICAgICApO1xyXG4gICAgICAgIGNvbnN0IG11bHRpcGxpZXI0ID0gKFxyXG4gICAgICAgICAgKG90aGVyUG9seWdvbk1hc3MgLSBjdXJyZW50UG9seWdvbk1hc3MpXHJcbiAgICAgICAgICAvIChjdXJyZW50UG9seWdvbk1hc3MgKyBvdGhlclBvbHlnb25NYXNzKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRQb2x5Z29uTmV3VmVsb2NpdHkgPSBjdXJyZW50UG9seWdvbkluaXRpYWxWZWxvY2l0eS5tdWx0aXBseVNjYWxhcihtdWx0aXBsaWVyMSlcclxuICAgICAgICAgIC5hZGRWZWN0b3Iob3RoZXJQb2x5Z29uSW5pdGlhbFZlbG9jaXR5Lm11bHRpcGx5U2NhbGFyKG11bHRpcGxpZXIyKSk7XHJcbiAgICAgICAgY29uc3Qgb3RoZXJQb2x5Z29uTmV3VmVsb2NpdHkgPSBjdXJyZW50UG9seWdvbkluaXRpYWxWZWxvY2l0eS5tdWx0aXBseVNjYWxhcihtdWx0aXBsaWVyMylcclxuICAgICAgICAgIC5hZGRWZWN0b3Iob3RoZXJQb2x5Z29uSW5pdGlhbFZlbG9jaXR5Lm11bHRpcGx5U2NhbGFyKG11bHRpcGxpZXI0KSk7XHJcblxyXG4gICAgICAgIHBvbHlnb25zID0gcG9seWdvbnMuc2V0SW4oW2ksICd2ZWxvY2l0eSddLCBjdXJyZW50UG9seWdvbk5ld1ZlbG9jaXR5KTtcclxuICAgICAgICBwb2x5Z29ucyA9IHBvbHlnb25zLnNldEluKFtqLCAndmVsb2NpdHknXSwgb3RoZXJQb2x5Z29uTmV3VmVsb2NpdHkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGhpdFRvcExpbmUgfHwgaGl0Qm90dG9tTGluZSkge1xyXG4gICAgICBjb25zdCBtdWx0aXBsaWVyID0gbmV3IFZlY3RvcjIoeyB4OiAxLCB5OiAtMSB9KTsgLy8gaW52ZXJ0IFkgY29tcG9uZW50XHJcbiAgICAgIGNvbnN0IG5ld1ZlbG9jaXR5ID0gcG9seWdvbnMuZ2V0SW4oW2ksICd2ZWxvY2l0eSddKS5tdWx0aXBseVZlY3RvcihtdWx0aXBsaWVyKTtcclxuICAgICAgcG9seWdvbnMgPSBwb2x5Z29ucy5zZXRJbihbaSwgJ3ZlbG9jaXR5J10sIG5ld1ZlbG9jaXR5KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaGl0UmlnaHRMaW5lIHx8IGhpdExlZnRMaW5lKSB7XHJcbiAgICAgIGNvbnN0IG11bHRpcGxpZXIgPSBuZXcgVmVjdG9yMih7IHg6IC0xLCB5OiAxIH0pOyAvLyBpbnZlcnQgWCBjb21wb25lbnRcclxuICAgICAgY29uc3QgbmV3VmVsb2NpdHkgPSBwb2x5Z29ucy5nZXRJbihbaSwgJ3ZlbG9jaXR5J10pLm11bHRpcGx5VmVjdG9yKG11bHRpcGxpZXIpO1xyXG4gICAgICBwb2x5Z29ucyA9IHBvbHlnb25zLnNldEluKFtpLCAndmVsb2NpdHknXSwgbmV3VmVsb2NpdHkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3QgZGVidWdTdHIgPSBwb2x5Z29ucy5tYXAoKHBvbHksIGkpID0+IHtcclxuICAgIGNvbnN0IHJlcyA9IFtgUE9MWSAke2l9YF07XHJcbiAgICByZXMucHVzaChgcG9zaXRpb246ICR7SlNPTi5zdHJpbmdpZnkocG9seS5nZXQoJ3Bvc2l0aW9uJykudGVzdGFibGVPYmooKSl9YCk7XHJcbiAgICByZXMucHVzaChgdmVsb2NpdHk6ICR7SlNPTi5zdHJpbmdpZnkocG9seS5nZXQoJ3ZlbG9jaXR5JykudGVzdGFibGVPYmooKSl9YCk7XHJcbiAgICByZXR1cm4gcmVzLmpvaW4oJ1xcbicpO1xyXG4gIH0pLnRvSlMoKS5qb2luKCdcXG4nKTtcclxuXHJcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RlYnVnVmlldycpXHJcbiAgICAuaW5uZXJUZXh0ID0gZGVidWdTdHI7XHJcblxyXG4gIHlpZWxkIHB1dChzYXZlUG9seWdvbnMocG9seWdvbnMpKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uKiB3YXRjaCgpIHtcclxuICB5aWVsZCB0YWtlRXZlcnkoU0VUX1NUQUdFX0JPVU5EUywgZ2VuZXJhdGVQb2x5Z29ucyk7XHJcbiAgeWllbGQgdGFrZUV2ZXJ5KFVQREFURV9QT0xZR09OUywgdXBkYXRlUG9seWdvbnMpO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiogcm9vdFNhZ2EoKSB7XHJcbiAgeWllbGQgYWxsKFtcclxuICAgIHdhdGNoKCksXHJcbiAgXSk7XHJcbn1cclxuIiwiaW1wb3J0IHsgY29uZmlndXJlU3RvcmUsIGFwcGx5TWlkZGxld2FyZSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xyXG5pbXBvcnQgY3JlYXRlU2FnYU1pZGRsZXdhcmUgZnJvbSAncmVkdXgtc2FnYSc7XHJcblxyXG5pbXBvcnQgcm9vdFJlZHVjZXIgZnJvbSAnLi4vcmVkdWNlcnMnO1xyXG5pbXBvcnQgcm9vdFNhZ2EgZnJvbSAnLi4vc2FnYXMnO1xyXG5cclxuY29uc3Qgc2FnYU1pZGRsZXdhcmUgPSBjcmVhdGVTYWdhTWlkZGxld2FyZSgpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY29uZmlndXJlU3RvcmUoe1xyXG4gIHJlZHVjZXI6IHJvb3RSZWR1Y2VyLFxyXG4gIG1pZGRsZXdhcmU6IFtzYWdhTWlkZGxld2FyZV0sXHJcbn0pO1xyXG5cclxuc2FnYU1pZGRsZXdhcmUucnVuKHJvb3RTYWdhKTtcclxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgUHJvdmlkZXIgfSBmcm9tICdyZWFjdC1yZWR1eCc7XHJcblxyXG5pbXBvcnQgeyBEYXNoYm9hcmRUZW1wbGF0ZSB9IGZyb20gJy4uL3RlbXBsYXRlcy9EYXNoYm9hcmRUZW1wbGF0ZSc7XHJcblxyXG5pbXBvcnQgeyBTaW11bGF0aW9uVmlldyB9IGZyb20gJy4vU2ltdWxhdGlvblZpZXcnO1xyXG5pbXBvcnQgeyBDb250ZW50VmlldyB9IGZyb20gJy4vQ29udGVudFZpZXcnO1xyXG5cclxuaW1wb3J0IHN0b3JlIGZyb20gJy4uL3N0b3JlJztcclxuXHJcbmV4cG9ydCBjb25zdCBBcHAgPSAoeyAuLi5wcm9wcyB9KSA9PiB7XHJcbiAgcmV0dXJuIChcclxuICAgIDxQcm92aWRlciBzdG9yZT17c3RvcmV9PlxyXG4gICAgICA8RGFzaGJvYXJkVGVtcGxhdGVcclxuICAgICAgICBTaW11bGF0aW9uVmlldz17U2ltdWxhdGlvblZpZXd9XHJcbiAgICAgICAgQ29udGVudFZpZXc9e0NvbnRlbnRWaWV3fVxyXG4gICAgICAvPlxyXG4gICAgPC9Qcm92aWRlcj5cclxuICApO1xyXG59O1xyXG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBjcmVhdGVSb290IH0gZnJvbSAncmVhY3QtZG9tL2NsaWVudCc7XHJcblxyXG5pbXBvcnQgeyBBcHAgfSBmcm9tICcuL2NvbXBvbmVudHMvQXBwJztcclxuXHJcbmNvbnN0IHJvb3QgPSBjcmVhdGVSb290KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhcHAnKSk7XHJcbnJvb3QucmVuZGVyKDxBcHAgLz4pO1xyXG4iXSwibmFtZXMiOlsiZGFyayIsImRhcmtCbHVlIiwibGlnaHRCbHVlIiwiYm9yZGVyUmFkaXVzIiwiZGlhbERpbWVuc2lvbnMiLCJkaWFsQmFzZURpbWVuc2lvbnNQeCIsIkRJQUxfVFlQRVMiLCJTQ0FMQVIiLCJDT09SRFMiLCJBTkdMRSIsIlZFQ1RPUiIsIlJlYWN0Iiwic3R5bGVkIiwiUHJvcFR5cGVzIiwiQ29udGFpbmVyIiwiUm93IiwiQ29sIiwidWlDb25zdGFudHMiLCJTdHlsZWRDb250YWluZXIiLCJDb250ZW50Q29udGFpbmVyIiwiZGl2IiwiVG9wQ29udGFpbmVyIiwiRGVmYXVsdFNpbXVsYXRpb25WaWV3IiwiRGVmYXVsdENvbnRlbnRWaWV3IiwiRGVmYXVsdFNpbXVsYXRpb25WaWV3Q29tcG9uZW50IiwicHJvcHMiLCJEZWZhdWx0Q29udGVudFZpZXdDb21wb25lbnQiLCJEYXNoYm9hcmRUZW1wbGF0ZSIsIlNpbXVsYXRpb25WaWV3IiwiQ29udGVudFZpZXciLCJkZWZhdWx0UHJvcHMiLCJwcm9wVHlwZXMiLCJlbGVtZW50VHlwZSIsIkVQU0lMT04iLCJjb25zdGFudHMiLCJkZWdyZWVzVG9SYWRpYW5zIiwiZGVncmVlcyIsIk1hdGgiLCJQSSIsInJhZGlhbnNUb0RlZ3JlZXMiLCJyYWRpYW5zIiwicmFuZFJhbmdlRmxvYXQiLCJtaW4iLCJtYXgiLCJyYW5kb20iLCJyYW5kUmFuZ2VJbnQiLCJfbWluIiwiY2VpbCIsIl9tYXgiLCJmbG9vciIsImNsYW1wRmxvYXQiLCJuIiwiYXBwcm94aW1hdGVseSIsInZhbHVlIiwibWF0aFV0aWxzIiwiVmVjdG9yMiIsIngiLCJ5IiwidmVjdG9yIiwic2NhbGFyIiwic3FydCIsIndvcmxkSGVpZ2h0IiwidmVjdG9yMSIsInZlY3RvcjIiLCJkaXN0YW5jZVdpdGhNaWRwb2ludCIsImRpc3RhbmNlVG8iLCJkaXN0YW5jZVdpdGhvdXRNaWRwb2ludCIsImRpZmZlcmVuY2UiLCJhbmdsZVJhZGlhbnMiLCJjb3MiLCJzaW4iLCJhbmdsZSIsInJhZGl1cyIsImF0YW4iLCJtYWduaXR1ZGUiLCJyYW5nZUxlbmd0aFN0YXJ0IiwicmFuZ2VMZW5ndGhFbmQiLCJyYW5nZVJhZGlhbnNTdGFydCIsInJhbmdlUmFkaWFuc0VuZCIsImxlbmd0aCIsInBvbGFyQ29vcmRpbmF0ZXMiLCJyYW5nZVhTdGFydCIsInJhbmdlWEVuZCIsInJhbmdlWVN0YXJ0IiwicmFuZ2VZRW5kIiwiTGluZSIsInBvaW50MSIsInBvaW50MiIsInNsb3BlIiwieUludGVyY2VwdCIsIm90aGVyTGluZSIsImJvdGhWZXJ0aWNhbCIsIk51bWJlciIsImlzTmFOIiwic2FtZVNsb3BlcyIsInNvbHZlWSIsInNhbWVZSW50ZXJjZXB0cyIsImludGVyc2VjdGlvbiIsImNhbGN1bGF0ZUludGVyc2VjdGlvbiIsImVxdWFsTGluZXMiLCJvdmVybGFwcGluZ1NlZ21lbnRzIiwiaXNCZXR3ZWVuIiwidGVzdGFibGVPYmoiLCJkZW5vbWluYXRvciIsIk5hTiIsIkltbXV0YWJsZSIsIlBvbHlnb24iLCJwb2ludHMiLCJtYXAiLCJwb2ludCIsImZsYXQiLCJwb3NpdGlvbiIsImZyb21KUyIsImkiLCJuZXh0SW5kZXgiLCJhZGRWZWN0b3IiLCJyb3RhdGUiLCJuQ29ybmVycyIsInN0ZXAiLCJwcmV2IiwibmV4dCIsImNvb3JkcyIsInB1c2giLCJLb252YVBvbHlnb24iLCJwb2x5Z29uIiwiZ2V0S29udmFQb2ludHMiLCJDb21wb25lbnQiLCJpbnN0YW5jZU9mIiwiaXNSZXF1aXJlZCIsIlNFVF9TVEFHRV9CT1VORFMiLCJzZXRTdGFnZUJvdW5kcyIsIndpZHRoIiwiaGVpZ2h0IiwidHlwZSIsInBheWxvYWQiLCJTQVZFX1BPTFlHT05TIiwiVVBEQVRFX1BPTFlHT05TIiwic2F2ZVBvbHlnb25zIiwicG9seWdvbnMiLCJ1cGRhdGVQb2x5Z29ucyIsImRlbHRhVGltZSIsImNyZWF0ZVNlbGVjdG9yIiwiZ2V0UG9seWdvbnMiLCJzdGF0ZSIsImdldFBvbHlnb25MaXN0IiwiZ2V0IiwiZ2V0U2ltdWxhdGlvblN0YXRlIiwic2ltdWxhdGlvbiIsImdldFN0YWdlQm91bmRzIiwic2ltdWxhdGlvblN0YXRlIiwiZ2V0U3RhZ2VCb3JkZXJpbmdMaW5lcyIsImJvdW5kcyIsInRvSlMiLCJ0b3BMaW5lIiwicmlnaHRMaW5lIiwiYm90dG9tTGluZSIsImxlZnRMaW5lIiwiTWVhc3VyZSIsImNvbm5lY3QiLCJMYXllciIsIlN0YWdlIiwiUGFkZGVkQ29udGFpbmVyIiwiRlJBTUVfTEVOR1RIIiwiU2ltdWxhdGlvblZpZXdDbHMiLCJub3ciLCJkZWx0YSIsImxhc3RUaW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiYW5pbWF0ZUZyYW1lIiwicmVjdCIsIl93aWR0aCIsIm1lYXN1cmVSZWYiLCJNYXAiLCJMaXN0IiwiZnVuYyIsIm1hcFN0YXRlVG9Qcm9wcyIsIm1hcERpc3BhdGNoVG9Qcm9wcyIsImRpc3BhdGNoIiwiZGlhbEJhc2VEaW1lbnNpb25zIiwiRGlhbEJhc2UiLCJzcGFuIiwiZm9udFNpemUiLCJTY2FsYXJEaWFsIiwibnVtYmVyIiwiQ29vcmRzRGlhbCIsInJvdW5kIiwidXNlUmVmIiwiQ2lyY2xlIiwiQXJjIiwiVGV4dCIsIkFuZ2xlRGlhbCIsInRleHQiLCJkaW1IYWx2ZWQiLCJfYW5nbGUiLCJjdXJyZW50IiwidG9TdHJpbmciLCJtYXhWZWN0b3JMZW5ndGgiLCJWZWN0b3JEaWFsIiwicmFuZ2UiLCJsZW5ndGhEaXZpZGVyIiwiY3JlYXRlUmVmIiwic2V0U3RhdGUiLCJzY2FsZWRWZWN0b3IiLCJkaXZpZGVTY2FsYXIiLCJEaWFsTGF5b3V0IiwiRGlhbFBhbmVsIiwiRGlhbEhlYWRlciIsIkRpYWxDb250YWluZXIiLCJEaWFsVW5pdCIsIkRpYWwiLCJsYWJlbCIsInVuaXQiLCJzdHJpbmciLCJvbmVPZlR5cGUiLCJvbmVPZiIsInVzZVNlbGVjdG9yIiwiV3JhcHBlciIsImZpcnN0UG9seWdvbiIsImluaXRpYWxTdGF0ZSIsImFjdGlvbiIsInNldCIsImNvbWJpbmVSZWR1Y2VycyIsImdlbmVyYXRlUmFuZG9tUG9seWdvbiIsImdlbmVyYXRlUmFuZG9tIiwiZ2VuZXJhdGVSYW5kb21WZWN0b3IiLCJnZW5lcmF0ZVJhbmRvbVZlY3RvckZyb21Db29yZHMiLCJnZW5lcmF0ZVJhbmRvbUZyb21Db29yZHMiLCJnZW5lcmF0ZVBvbHlnb25zIiwid2F0Y2giLCJyb290U2FnYSIsInB1dCIsInRha2VFdmVyeSIsImFsbCIsInNlbGVjdCIsIkNJUkNMRV9SQURJQU5TIiwiT01FR0FfUkFOR0VfUEVSQ0VOVEFHRSIsIk9NRUdBX1JBTkdFX0FCUyIsIk1JTl9QT1NJVElPTl9YIiwiTUFYX1BPU0lUSU9OX1giLCJNSU5fUE9TSVRJT05fWSIsIk1BWF9QT1NJVElPTl9ZIiwibG9vcCIsImdldFBvbHlnb25Jbml0aWFsU3RhdGUiLCJpZCIsIm1hc3MiLCJyb3RhdGlvbiIsInZlbG9jaXR5IiwiYW5ndWxhclZlbG9jaXR5IiwicG9seTFYUmFuZ2UiLCJwb2x5MlhSYW5nZSIsInBvbHkxUG9zaXRpb24iLCJwb2x5MlBvc2l0aW9uIiwicG9seTEiLCJpbnZlcnRZIiwicG9seTIiLCJkZWx0YVNlY29uZHMiLCJzdGFnZUJvdW5kcyIsInN0YWdlQm9yZGVyaW5nTGluZXMiLCJwb2x5Q29sbGlzaW9uc0NoZWNrZWQiLCJwb3NpdGlvbkRlbHRhIiwibXVsdGlwbHlTY2FsYXIiLCJuZXdQb3NpdGlvbiIsInNldEluIiwicm90YXRpb25EZWx0YSIsIm5ld1JvdGF0aW9uIiwibWF0aFBvbHlnb24iLCJwb2x5TGluZXMiLCJnZXRMaW5lcyIsImhpdFRvcExpbmUiLCJzb21lIiwibGluZSIsImNhbGN1bGF0ZVNlZ21lbnRJbnRlcnNlY3Rpb24iLCJoaXRSaWdodExpbmUiLCJoaXRCb3R0b21MaW5lIiwiaGl0TGVmdExpbmUiLCJqIiwiaGFzIiwiU2V0IiwiayIsInNpemUiLCJvdGhlclBvbHlnb25MaW5lcyIsImdldEluIiwibCIsIl9pbnRlcnNlY3Rpb24iLCJjdXJyZW50UG9seWdvbk1hc3MiLCJvdGhlclBvbHlnb25NYXNzIiwiY3VycmVudFBvbHlnb25Jbml0aWFsVmVsb2NpdHkiLCJvdGhlclBvbHlnb25Jbml0aWFsVmVsb2NpdHkiLCJtdWx0aXBsaWVyMSIsIm11bHRpcGxpZXIyIiwibXVsdGlwbGllcjMiLCJtdWx0aXBsaWVyNCIsImN1cnJlbnRQb2x5Z29uTmV3VmVsb2NpdHkiLCJvdGhlclBvbHlnb25OZXdWZWxvY2l0eSIsIm11bHRpcGxpZXIiLCJuZXdWZWxvY2l0eSIsIm11bHRpcGx5VmVjdG9yIiwiZGVidWdTdHIiLCJwb2x5IiwicmVzIiwiSlNPTiIsInN0cmluZ2lmeSIsImpvaW4iLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiaW5uZXJUZXh0IiwiY29uZmlndXJlU3RvcmUiLCJhcHBseU1pZGRsZXdhcmUiLCJjcmVhdGVTYWdhTWlkZGxld2FyZSIsInJvb3RSZWR1Y2VyIiwic2FnYU1pZGRsZXdhcmUiLCJyZWR1Y2VyIiwibWlkZGxld2FyZSIsInJ1biIsIlByb3ZpZGVyIiwic3RvcmUiLCJBcHAiLCJjcmVhdGVSb290Iiwicm9vdCIsInJlbmRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///27\n")},184:(module,exports)=>{eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n  Copyright (c) 2018 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames() {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tif (arg.length) {\n\t\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\t\tif (inner) {\n\t\t\t\t\t\tclasses.push(inner);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tif (arg.toString === Object.prototype.toString) {\n\t\t\t\t\tfor (var key in arg) {\n\t\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tclasses.push(arg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif ( true && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (true) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\t\t\treturn classNames;\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQjs7QUFFaEI7QUFDQTs7QUFFQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSyxLQUE2QjtBQUNsQztBQUNBO0FBQ0EsR0FBRyxTQUFTLElBQTRFO0FBQ3hGO0FBQ0EsRUFBRSxpQ0FBcUIsRUFBRSxtQ0FBRTtBQUMzQjtBQUNBLEdBQUc7QUFBQSxrR0FBQztBQUNKLEdBQUcsS0FBSyxFQUVOO0FBQ0YsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanM/NGQyNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAgQ29weXJpZ2h0IChjKSAyMDE4IEplZCBXYXRzb24uXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgc2VlXG4gIGh0dHA6Ly9qZWR3YXRzb24uZ2l0aHViLmlvL2NsYXNzbmFtZXNcbiovXG4vKiBnbG9iYWwgZGVmaW5lICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0ZnVuY3Rpb24gY2xhc3NOYW1lcygpIHtcblx0XHR2YXIgY2xhc3NlcyA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRpZiAoIWFyZykgY29udGludWU7XG5cblx0XHRcdHZhciBhcmdUeXBlID0gdHlwZW9mIGFyZztcblxuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnIHx8IGFyZ1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChhcmcpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0aWYgKGFyZy5sZW5ndGgpIHtcblx0XHRcdFx0XHR2YXIgaW5uZXIgPSBjbGFzc05hbWVzLmFwcGx5KG51bGwsIGFyZyk7XG5cdFx0XHRcdFx0aWYgKGlubmVyKSB7XG5cdFx0XHRcdFx0XHRjbGFzc2VzLnB1c2goaW5uZXIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRpZiAoYXJnLnRvU3RyaW5nID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGFyZykge1xuXHRcdFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKGFyZywga2V5KSAmJiBhcmdba2V5XSkge1xuXHRcdFx0XHRcdFx0XHRjbGFzc2VzLnB1c2goa2V5KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGFyZy50b1N0cmluZygpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjbGFzc2VzLmpvaW4oJyAnKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdGNsYXNzTmFtZXMuZGVmYXVsdCA9IGNsYXNzTmFtZXM7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG5cdFx0ZGVmaW5lKCdjbGFzc25hbWVzJywgW10sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBjbGFzc05hbWVzO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcblx0fVxufSgpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///184\n")},679:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar reactIs = __webpack_require__(864);\n\n/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar REACT_STATICS = {\n  childContextTypes: true,\n  contextType: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  getDerivedStateFromError: true,\n  getDerivedStateFromProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true\n};\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n};\nvar FORWARD_REF_STATICS = {\n  '$$typeof': true,\n  render: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true\n};\nvar MEMO_STATICS = {\n  '$$typeof': true,\n  compare: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n  type: true\n};\nvar TYPE_STATICS = {};\nTYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;\nTYPE_STATICS[reactIs.Memo] = MEMO_STATICS;\n\nfunction getStatics(component) {\n  // React v16.11 and below\n  if (reactIs.isMemo(component)) {\n    return MEMO_STATICS;\n  } // React v16.12 and above\n\n\n  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;\n}\n\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n  if (typeof sourceComponent !== 'string') {\n    // don't hoist over string (html) components\n    if (objectPrototype) {\n      var inheritedComponent = getPrototypeOf(sourceComponent);\n\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n      }\n    }\n\n    var keys = getOwnPropertyNames(sourceComponent);\n\n    if (getOwnPropertySymbols) {\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n    }\n\n    var targetStatics = getStatics(targetComponent);\n    var sourceStatics = getStatics(sourceComponent);\n\n    for (var i = 0; i < keys.length; ++i) {\n      var key = keys[i];\n\n      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n\n        try {\n          // Avoid failures from read-only properties\n          defineProperty(targetComponent, key, descriptor);\n        } catch (e) {}\n      }\n    }\n  }\n\n  return targetComponent;\n}\n\nmodule.exports = hoistNonReactStatics;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjc5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyxHQUFVOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9kaXN0L2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzLmNqcy5qcz9kYTZhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDE1LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG52YXIgUkVBQ1RfU1RBVElDUyA9IHtcbiAgY2hpbGRDb250ZXh0VHlwZXM6IHRydWUsXG4gIGNvbnRleHRUeXBlOiB0cnVlLFxuICBjb250ZXh0VHlwZXM6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIGdldERlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yOiB0cnVlLFxuICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM6IHRydWUsXG4gIG1peGluczogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlLFxuICB0eXBlOiB0cnVlXG59O1xudmFyIEtOT1dOX1NUQVRJQ1MgPSB7XG4gIG5hbWU6IHRydWUsXG4gIGxlbmd0aDogdHJ1ZSxcbiAgcHJvdG90eXBlOiB0cnVlLFxuICBjYWxsZXI6IHRydWUsXG4gIGNhbGxlZTogdHJ1ZSxcbiAgYXJndW1lbnRzOiB0cnVlLFxuICBhcml0eTogdHJ1ZVxufTtcbnZhciBGT1JXQVJEX1JFRl9TVEFUSUNTID0ge1xuICAnJCR0eXBlb2YnOiB0cnVlLFxuICByZW5kZXI6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZVxufTtcbnZhciBNRU1PX1NUQVRJQ1MgPSB7XG4gICckJHR5cGVvZic6IHRydWUsXG4gIGNvbXBhcmU6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbiAgdHlwZTogdHJ1ZVxufTtcbnZhciBUWVBFX1NUQVRJQ1MgPSB7fTtcblRZUEVfU1RBVElDU1tyZWFjdElzLkZvcndhcmRSZWZdID0gRk9SV0FSRF9SRUZfU1RBVElDUztcblRZUEVfU1RBVElDU1tyZWFjdElzLk1lbW9dID0gTUVNT19TVEFUSUNTO1xuXG5mdW5jdGlvbiBnZXRTdGF0aWNzKGNvbXBvbmVudCkge1xuICAvLyBSZWFjdCB2MTYuMTEgYW5kIGJlbG93XG4gIGlmIChyZWFjdElzLmlzTWVtbyhjb21wb25lbnQpKSB7XG4gICAgcmV0dXJuIE1FTU9fU1RBVElDUztcbiAgfSAvLyBSZWFjdCB2MTYuMTIgYW5kIGFib3ZlXG5cblxuICByZXR1cm4gVFlQRV9TVEFUSUNTW2NvbXBvbmVudFsnJCR0eXBlb2YnXV0gfHwgUkVBQ1RfU1RBVElDUztcbn1cblxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgb2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbmZ1bmN0aW9uIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgc291cmNlQ29tcG9uZW50LCBibGFja2xpc3QpIHtcbiAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZG9uJ3QgaG9pc3Qgb3ZlciBzdHJpbmcgKGh0bWwpIGNvbXBvbmVudHNcbiAgICBpZiAob2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICB2YXIgaW5oZXJpdGVkQ29tcG9uZW50ID0gZ2V0UHJvdG90eXBlT2Yoc291cmNlQ29tcG9uZW50KTtcblxuICAgICAgaWYgKGluaGVyaXRlZENvbXBvbmVudCAmJiBpbmhlcml0ZWRDb21wb25lbnQgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIGluaGVyaXRlZENvbXBvbmVudCwgYmxhY2tsaXN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXMoc291cmNlQ29tcG9uZW50KTtcblxuICAgIGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlQ29tcG9uZW50KSk7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldFN0YXRpY3MgPSBnZXRTdGF0aWNzKHRhcmdldENvbXBvbmVudCk7XG4gICAgdmFyIHNvdXJjZVN0YXRpY3MgPSBnZXRTdGF0aWNzKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoIUtOT1dOX1NUQVRJQ1Nba2V5XSAmJiAhKGJsYWNrbGlzdCAmJiBibGFja2xpc3Rba2V5XSkgJiYgIShzb3VyY2VTdGF0aWNzICYmIHNvdXJjZVN0YXRpY3Nba2V5XSkgJiYgISh0YXJnZXRTdGF0aWNzICYmIHRhcmdldFN0YXRpY3Nba2V5XSkpIHtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlQ29tcG9uZW50LCBrZXkpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gQXZvaWQgZmFpbHVyZXMgZnJvbSByZWFkLW9ubHkgcHJvcGVydGllc1xuICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldENvbXBvbmVudCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhvaXN0Tm9uUmVhY3RTdGF0aWNzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///679\n")},703:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = __webpack_require__(414);\n\nfunction emptyFunction() {}\nfunction emptyFunctionWithReset() {}\nemptyFunctionWithReset.resetWarningCache = emptyFunction;\n\nmodule.exports = function() {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret) {\n      // It is still safe when called from React.\n      return;\n    }\n    var err = new Error(\n      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n      'Use PropTypes.checkPropTypes() to call them. ' +\n      'Read more at http://fb.me/use-check-prop-types'\n    );\n    err.name = 'Invariant Violation';\n    throw err;\n  };\n  shim.isRequired = shim;\n  function getShim() {\n    return shim;\n  };\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n  var ReactPropTypes = {\n    array: shim,\n    bigint: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    elementType: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim,\n\n    checkPropTypes: emptyFunctionWithReset,\n    resetWarningCache: emptyFunction\n  };\n\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzAzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYiwyQkFBMkIsbUJBQU8sQ0FBQyxHQUE0Qjs7QUFFL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzP2Q3YTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fVxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvbldpdGhSZXNldCgpIHt9XG5lbXB0eUZ1bmN0aW9uV2l0aFJlc2V0LnJlc2V0V2FybmluZ0NhY2hlID0gZW1wdHlGdW5jdGlvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gc2hpbShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgIGlmIChzZWNyZXQgPT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAvLyBJdCBpcyBzdGlsbCBzYWZlIHdoZW4gY2FsbGVkIGZyb20gUmVhY3QuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAnVXNlIFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICApO1xuICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIHRocm93IGVycjtcbiAgfTtcbiAgc2hpbS5pc1JlcXVpcmVkID0gc2hpbTtcbiAgZnVuY3Rpb24gZ2V0U2hpbSgpIHtcbiAgICByZXR1cm4gc2hpbTtcbiAgfTtcbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBzaGltLFxuICAgIGJpZ2ludDogc2hpbSxcbiAgICBib29sOiBzaGltLFxuICAgIGZ1bmM6IHNoaW0sXG4gICAgbnVtYmVyOiBzaGltLFxuICAgIG9iamVjdDogc2hpbSxcbiAgICBzdHJpbmc6IHNoaW0sXG4gICAgc3ltYm9sOiBzaGltLFxuXG4gICAgYW55OiBzaGltLFxuICAgIGFycmF5T2Y6IGdldFNoaW0sXG4gICAgZWxlbWVudDogc2hpbSxcbiAgICBlbGVtZW50VHlwZTogc2hpbSxcbiAgICBpbnN0YW5jZU9mOiBnZXRTaGltLFxuICAgIG5vZGU6IHNoaW0sXG4gICAgb2JqZWN0T2Y6IGdldFNoaW0sXG4gICAgb25lT2Y6IGdldFNoaW0sXG4gICAgb25lT2ZUeXBlOiBnZXRTaGltLFxuICAgIHNoYXBlOiBnZXRTaGltLFxuICAgIGV4YWN0OiBnZXRTaGltLFxuXG4gICAgY2hlY2tQcm9wVHlwZXM6IGVtcHR5RnVuY3Rpb25XaXRoUmVzZXQsXG4gICAgcmVzZXRXYXJuaW5nQ2FjaGU6IGVtcHR5RnVuY3Rpb25cbiAgfTtcblxuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///703\n")},697:(module,__unused_webpack_exports,__webpack_require__)=>{eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (false) { var throwOnDirectAccess, ReactIs; } else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = __webpack_require__(703)();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjk3LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLEtBQXFDLEVBQUUscUNBTzFDLENBQUM7QUFDRjtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsR0FBNEI7QUFDdkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzP2Q3YmMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShSZWFjdElzLmlzRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///697\n")},414:module=>{"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzPzU5YjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///414\n")},448:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('/**\n * @license React\n * react-dom.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/*\n Modernizr 3.0.0pre (Custom Build) | MIT\n*/\nvar aa=__webpack_require__(294),ba=__webpack_require__(840);function p(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var da=new Set,ea={};function fa(a,b){ha(a,b);ha(a+"Capture",b)}\nfunction ha(a,b){ea[a]=b;for(a=0;a<b.length;a++)da.add(b[a])}\nvar ia=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),ja=Object.prototype.hasOwnProperty,ka=/^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$/,la=\n{},ma={};function na(a){if(ja.call(ma,a))return!0;if(ja.call(la,a))return!1;if(ka.test(a))return ma[a]=!0;la[a]=!0;return!1}function oa(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}\nfunction pa(a,b,c,d){if(null===b||"undefined"===typeof b||oa(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function t(a,b,c,d,e,f,g){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f;this.removeEmptyString=g}var z={};\n"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){z[a]=new t(a,0,!1,a,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];z[b]=new t(b,1,!1,a[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){z[a]=new t(a,2,!1,a.toLowerCase(),null,!1,!1)});\n["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){z[a]=new t(a,2,!1,a,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){z[a]=new t(a,3,!1,a.toLowerCase(),null,!1,!1)});\n["checked","multiple","muted","selected"].forEach(function(a){z[a]=new t(a,3,!0,a,null,!1,!1)});["capture","download"].forEach(function(a){z[a]=new t(a,4,!1,a,null,!1,!1)});["cols","rows","size","span"].forEach(function(a){z[a]=new t(a,6,!1,a,null,!1,!1)});["rowSpan","start"].forEach(function(a){z[a]=new t(a,5,!1,a.toLowerCase(),null,!1,!1)});var qa=/[\\-:]([a-z])/g;function ra(a){return a[1].toUpperCase()}\n"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=a.replace(qa,\nra);z[b]=new t(b,1,!1,a,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(qa,ra);z[b]=new t(b,1,!1,a,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(qa,ra);z[b]=new t(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(a){z[a]=new t(a,1,!1,a.toLowerCase(),null,!1,!1)});\nz.xlinkHref=new t("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(a){z[a]=new t(a,1,!1,a.toLowerCase(),null,!0,!0)});\nfunction sa(a,b,c,d){var e=z.hasOwnProperty(b)?z[b]:null;if(null!==e?0!==e.type:d||!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1])pa(b,c,e,d)&&(c=null),d||null===e?na(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c)))}\nvar ta=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,ua=Symbol.for("react.element"),va=Symbol.for("react.portal"),wa=Symbol.for("react.fragment"),xa=Symbol.for("react.strict_mode"),za=Symbol.for("react.profiler"),Aa=Symbol.for("react.provider"),Ba=Symbol.for("react.context"),Ca=Symbol.for("react.forward_ref"),Da=Symbol.for("react.suspense"),Ea=Symbol.for("react.suspense_list"),Fa=Symbol.for("react.memo"),Ga=Symbol.for("react.lazy");Symbol.for("react.scope");Symbol.for("react.debug_trace_mode");\nvar Ha=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden");Symbol.for("react.cache");Symbol.for("react.tracing_marker");var Ia=Symbol.iterator;function Ja(a){if(null===a||"object"!==typeof a)return null;a=Ia&&a[Ia]||a["@@iterator"];return"function"===typeof a?a:null}var A=Object.assign,Ka;function La(a){if(void 0===Ka)try{throw Error();}catch(c){var b=c.stack.trim().match(/\\n( *(at )?)/);Ka=b&&b[1]||""}return"\\n"+Ka+a}var Ma=!1;\nfunction Na(a,b){if(!a||Ma)return"";Ma=!0;var c=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(b)if(b=function(){throw Error();},Object.defineProperty(b.prototype,"props",{set:function(){throw Error();}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(b,[])}catch(l){var d=l}Reflect.construct(a,[],b)}else{try{b.call()}catch(l){d=l}a.call(b.prototype)}else{try{throw Error();}catch(l){d=l}a()}}catch(l){if(l&&d&&"string"===typeof l.stack){for(var e=l.stack.split("\\n"),\nf=d.stack.split("\\n"),g=e.length-1,h=f.length-1;1<=g&&0<=h&&e[g]!==f[h];)h--;for(;1<=g&&0<=h;g--,h--)if(e[g]!==f[h]){if(1!==g||1!==h){do if(g--,h--,0>h||e[g]!==f[h]){var k="\\n"+e[g].replace(" at new "," at ");a.displayName&&k.includes("<anonymous>")&&(k=k.replace("<anonymous>",a.displayName));return k}while(1<=g&&0<=h)}break}}}finally{Ma=!1,Error.prepareStackTrace=c}return(a=a?a.displayName||a.name:"")?La(a):""}\nfunction Oa(a){switch(a.tag){case 5:return La(a.type);case 16:return La("Lazy");case 13:return La("Suspense");case 19:return La("SuspenseList");case 0:case 2:case 15:return a=Na(a.type,!1),a;case 11:return a=Na(a.type.render,!1),a;case 1:return a=Na(a.type,!0),a;default:return""}}\nfunction Pa(a){if(null==a)return null;if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case wa:return"Fragment";case va:return"Portal";case za:return"Profiler";case xa:return"StrictMode";case Da:return"Suspense";case Ea:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Ba:return(a.displayName||"Context")+".Consumer";case Aa:return(a._context.displayName||"Context")+".Provider";case Ca:var b=a.render;a=a.displayName;a||(a=b.displayName||\nb.name||"",a=""!==a?"ForwardRef("+a+")":"ForwardRef");return a;case Fa:return b=a.displayName||null,null!==b?b:Pa(a.type)||"Memo";case Ga:b=a._payload;a=a._init;try{return Pa(a(b))}catch(c){}}return null}\nfunction Qa(a){var b=a.type;switch(a.tag){case 24:return"Cache";case 9:return(b.displayName||"Context")+".Consumer";case 10:return(b._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return a=b.render,a=a.displayName||a.name||"",b.displayName||(""!==a?"ForwardRef("+a+")":"ForwardRef");case 7:return"Fragment";case 5:return b;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Pa(b);case 8:return b===xa?"StrictMode":"Mode";case 22:return"Offscreen";\ncase 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof b)return b.displayName||b.name||null;if("string"===typeof b)return b}return null}function Ra(a){switch(typeof a){case "boolean":case "number":case "string":case "undefined":return a;case "object":return a;default:return""}}\nfunction Sa(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}\nfunction Ta(a){var b=Sa(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=\nnull;delete a[b]}}}}function Ua(a){a._valueTracker||(a._valueTracker=Ta(a))}function Va(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Sa(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Wa(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}\nfunction Xa(a,b){var c=b.checked;return A({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}function Ya(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=Ra(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function Za(a,b){b=b.checked;null!=b&&sa(a,"checked",b,!1)}\nfunction $a(a,b){Za(a,b);var c=Ra(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?bb(a,b.type,c):b.hasOwnProperty("defaultValue")&&bb(a,b.type,Ra(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}\nfunction cb(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}\nfunction bb(a,b,c){if("number"!==b||Wa(a.ownerDocument)!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}var db=Array.isArray;\nfunction eb(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+Ra(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}\nfunction fb(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(p(91));return A({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function gb(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(p(92));if(db(c)){if(1<c.length)throw Error(p(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:Ra(c)}}\nfunction hb(a,b){var c=Ra(b.value),d=Ra(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function ib(a){var b=a.textContent;b===a._wrapperState.initialValue&&""!==b&&null!==b&&(a.value=b)}function jb(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}\nfunction kb(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?jb(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}\nvar lb,mb=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{lb=lb||document.createElement("div");lb.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=lb.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}});\nfunction nb(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b}\nvar ob={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,\nzoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},pb=["Webkit","ms","Moz","O"];Object.keys(ob).forEach(function(a){pb.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);ob[b]=ob[a]})});function qb(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||ob.hasOwnProperty(a)&&ob[a]?(""+b).trim():b+"px"}\nfunction rb(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=qb(c,b[c],d);"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}var sb=A({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});\nfunction tb(a,b){if(b){if(sb[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(p(137,a));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(p(60));if("object"!==typeof b.dangerouslySetInnerHTML||!("__html"in b.dangerouslySetInnerHTML))throw Error(p(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(p(62));}}\nfunction ub(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;default:return!0}}var vb=null;function wb(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}var xb=null,yb=null,zb=null;\nfunction Ab(a){if(a=Bb(a)){if("function"!==typeof xb)throw Error(p(280));var b=a.stateNode;b&&(b=Cb(b),xb(a.stateNode,a.type,b))}}function Db(a){yb?zb?zb.push(a):zb=[a]:yb=a}function Eb(){if(yb){var a=yb,b=zb;zb=yb=null;Ab(a);if(b)for(a=0;a<b.length;a++)Ab(b[a])}}function Fb(a,b){return a(b)}function Gb(){}var Hb=!1;function Ib(a,b,c){if(Hb)return a(b,c);Hb=!0;try{return Fb(a,b,c)}finally{if(Hb=!1,null!==yb||null!==zb)Gb(),Eb()}}\nfunction Jb(a,b){var c=a.stateNode;if(null===c)return null;var d=Cb(c);if(null===d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==\ntypeof c)throw Error(p(231,b,typeof c));return c}var Kb=!1;if(ia)try{var Lb={};Object.defineProperty(Lb,"passive",{get:function(){Kb=!0}});window.addEventListener("test",Lb,Lb);window.removeEventListener("test",Lb,Lb)}catch(a){Kb=!1}function Mb(a,b,c,d,e,f,g,h,k){var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l)}catch(n){this.onError(n)}}var Nb=!1,Ob=null,Pb=!1,Qb=null,Rb={onError:function(a){Nb=!0;Ob=a}};function Sb(a,b,c,d,e,f,g,h,k){Nb=!1;Ob=null;Mb.apply(Rb,arguments)}\nfunction Tb(a,b,c,d,e,f,g,h,k){Sb.apply(this,arguments);if(Nb){if(Nb){var l=Ob;Nb=!1;Ob=null}else throw Error(p(198));Pb||(Pb=!0,Qb=l)}}function Ub(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.flags&4098)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Vb(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Wb(a){if(Ub(a)!==a)throw Error(p(188));}\nfunction Xb(a){var b=a.alternate;if(!b){b=Ub(a);if(null===b)throw Error(p(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Wb(e),a;if(f===d)return Wb(e),b;f=f.sibling}throw Error(p(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===\nc){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(p(189));}}if(c.alternate!==d)throw Error(p(190));}if(3!==c.tag)throw Error(p(188));return c.stateNode.current===c?a:b}function Yb(a){a=Xb(a);return null!==a?Zb(a):null}function Zb(a){if(5===a.tag||6===a.tag)return a;for(a=a.child;null!==a;){var b=Zb(a);if(null!==b)return b;a=a.sibling}return null}\nvar $b=ba.unstable_scheduleCallback,ac=ba.unstable_cancelCallback,bc=ba.unstable_shouldYield,cc=ba.unstable_requestPaint,B=ba.unstable_now,dc=ba.unstable_getCurrentPriorityLevel,ec=ba.unstable_ImmediatePriority,fc=ba.unstable_UserBlockingPriority,gc=ba.unstable_NormalPriority,hc=ba.unstable_LowPriority,ic=ba.unstable_IdlePriority,jc=null,kc=null;function lc(a){if(kc&&"function"===typeof kc.onCommitFiberRoot)try{kc.onCommitFiberRoot(jc,a,void 0,128===(a.current.flags&128))}catch(b){}}\nvar nc=Math.clz32?Math.clz32:mc,oc=Math.log,pc=Math.LN2;function mc(a){a>>>=0;return 0===a?32:31-(oc(a)/pc|0)|0}var qc=64,rc=4194304;\nfunction sc(a){switch(a&-a){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return a&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return a&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;\ndefault:return a}}function tc(a,b){var c=a.pendingLanes;if(0===c)return 0;var d=0,e=a.suspendedLanes,f=a.pingedLanes,g=c&268435455;if(0!==g){var h=g&~e;0!==h?d=sc(h):(f&=g,0!==f&&(d=sc(f)))}else g=c&~e,0!==g?d=sc(g):0!==f&&(d=sc(f));if(0===d)return 0;if(0!==b&&b!==d&&0===(b&e)&&(e=d&-d,f=b&-b,e>=f||16===e&&0!==(f&4194240)))return b;0!==(d&4)&&(d|=c&16);b=a.entangledLanes;if(0!==b)for(a=a.entanglements,b&=d;0<b;)c=31-nc(b),e=1<<c,d|=a[c],b&=~e;return d}\nfunction uc(a,b){switch(a){case 1:case 2:case 4:return b+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return b+5E3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}\nfunction vc(a,b){for(var c=a.suspendedLanes,d=a.pingedLanes,e=a.expirationTimes,f=a.pendingLanes;0<f;){var g=31-nc(f),h=1<<g,k=e[g];if(-1===k){if(0===(h&c)||0!==(h&d))e[g]=uc(h,b)}else k<=b&&(a.expiredLanes|=h);f&=~h}}function wc(a){a=a.pendingLanes&-1073741825;return 0!==a?a:a&1073741824?1073741824:0}function xc(){var a=qc;qc<<=1;0===(qc&4194240)&&(qc=64);return a}function yc(a){for(var b=[],c=0;31>c;c++)b.push(a);return b}\nfunction zc(a,b,c){a.pendingLanes|=b;536870912!==b&&(a.suspendedLanes=0,a.pingedLanes=0);a=a.eventTimes;b=31-nc(b);a[b]=c}function Ac(a,b){var c=a.pendingLanes&~b;a.pendingLanes=b;a.suspendedLanes=0;a.pingedLanes=0;a.expiredLanes&=b;a.mutableReadLanes&=b;a.entangledLanes&=b;b=a.entanglements;var d=a.eventTimes;for(a=a.expirationTimes;0<c;){var e=31-nc(c),f=1<<e;b[e]=0;d[e]=-1;a[e]=-1;c&=~f}}\nfunction Bc(a,b){var c=a.entangledLanes|=b;for(a=a.entanglements;c;){var d=31-nc(c),e=1<<d;e&b|a[d]&b&&(a[d]|=b);c&=~e}}var C=0;function Cc(a){a&=-a;return 1<a?4<a?0!==(a&268435455)?16:536870912:4:1}var Dc,Ec,Fc,Gc,Hc,Ic=!1,Jc=[],Kc=null,Lc=null,Mc=null,Nc=new Map,Oc=new Map,Pc=[],Qc="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");\nfunction Rc(a,b){switch(a){case "focusin":case "focusout":Kc=null;break;case "dragenter":case "dragleave":Lc=null;break;case "mouseover":case "mouseout":Mc=null;break;case "pointerover":case "pointerout":Nc.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Oc.delete(b.pointerId)}}\nfunction Sc(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a={blockedOn:b,domEventName:c,eventSystemFlags:d,nativeEvent:f,targetContainers:[e]},null!==b&&(b=Bb(b),null!==b&&Ec(b)),a;a.eventSystemFlags|=d;b=a.targetContainers;null!==e&&-1===b.indexOf(e)&&b.push(e);return a}\nfunction Tc(a,b,c,d,e){switch(b){case "focusin":return Kc=Sc(Kc,a,b,c,d,e),!0;case "dragenter":return Lc=Sc(Lc,a,b,c,d,e),!0;case "mouseover":return Mc=Sc(Mc,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Nc.set(f,Sc(Nc.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Oc.set(f,Sc(Oc.get(f)||null,a,b,c,d,e)),!0}return!1}\nfunction Uc(a){var b=Vc(a.target);if(null!==b){var c=Ub(b);if(null!==c)if(b=c.tag,13===b){if(b=Vb(c),null!==b){a.blockedOn=b;Hc(a.priority,function(){Fc(c)});return}}else if(3===b&&c.stateNode.current.memoizedState.isDehydrated){a.blockedOn=3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}\nfunction Wc(a){if(null!==a.blockedOn)return!1;for(var b=a.targetContainers;0<b.length;){var c=Xc(a.domEventName,a.eventSystemFlags,b[0],a.nativeEvent);if(null===c){c=a.nativeEvent;var d=new c.constructor(c.type,c);vb=d;c.target.dispatchEvent(d);vb=null}else return b=Bb(c),null!==b&&Ec(b),a.blockedOn=c,!1;b.shift()}return!0}function Yc(a,b,c){Wc(a)&&c.delete(b)}function Zc(){Ic=!1;null!==Kc&&Wc(Kc)&&(Kc=null);null!==Lc&&Wc(Lc)&&(Lc=null);null!==Mc&&Wc(Mc)&&(Mc=null);Nc.forEach(Yc);Oc.forEach(Yc)}\nfunction $c(a,b){a.blockedOn===b&&(a.blockedOn=null,Ic||(Ic=!0,ba.unstable_scheduleCallback(ba.unstable_NormalPriority,Zc)))}\nfunction ad(a){function b(b){return $c(b,a)}if(0<Jc.length){$c(Jc[0],a);for(var c=1;c<Jc.length;c++){var d=Jc[c];d.blockedOn===a&&(d.blockedOn=null)}}null!==Kc&&$c(Kc,a);null!==Lc&&$c(Lc,a);null!==Mc&&$c(Mc,a);Nc.forEach(b);Oc.forEach(b);for(c=0;c<Pc.length;c++)d=Pc[c],d.blockedOn===a&&(d.blockedOn=null);for(;0<Pc.length&&(c=Pc[0],null===c.blockedOn);)Uc(c),null===c.blockedOn&&Pc.shift()}var bd=ta.ReactCurrentBatchConfig,cd=!0;\nfunction dd(a,b,c,d){var e=C,f=bd.transition;bd.transition=null;try{C=1,ed(a,b,c,d)}finally{C=e,bd.transition=f}}function fd(a,b,c,d){var e=C,f=bd.transition;bd.transition=null;try{C=4,ed(a,b,c,d)}finally{C=e,bd.transition=f}}\nfunction ed(a,b,c,d){if(cd){var e=Xc(a,b,c,d);if(null===e)gd(a,b,d,hd,c),Rc(a,d);else if(Tc(e,a,b,c,d))d.stopPropagation();else if(Rc(a,d),b&4&&-1<Qc.indexOf(a)){for(;null!==e;){var f=Bb(e);null!==f&&Dc(f);f=Xc(a,b,c,d);null===f&&gd(a,b,d,hd,c);if(f===e)break;e=f}null!==e&&d.stopPropagation()}else gd(a,b,d,null,c)}}var hd=null;\nfunction Xc(a,b,c,d){hd=null;a=wb(d);a=Vc(a);if(null!==a)if(b=Ub(a),null===b)a=null;else if(c=b.tag,13===c){a=Vb(b);if(null!==a)return a;a=null}else if(3===c){if(b.stateNode.current.memoizedState.isDehydrated)return 3===b.tag?b.stateNode.containerInfo:null;a=null}else b!==a&&(a=null);hd=a;return null}\nfunction id(a){switch(a){case "cancel":case "click":case "close":case "contextmenu":case "copy":case "cut":case "auxclick":case "dblclick":case "dragend":case "dragstart":case "drop":case "focusin":case "focusout":case "input":case "invalid":case "keydown":case "keypress":case "keyup":case "mousedown":case "mouseup":case "paste":case "pause":case "play":case "pointercancel":case "pointerdown":case "pointerup":case "ratechange":case "reset":case "resize":case "seeked":case "submit":case "touchcancel":case "touchend":case "touchstart":case "volumechange":case "change":case "selectionchange":case "textInput":case "compositionstart":case "compositionend":case "compositionupdate":case "beforeblur":case "afterblur":case "beforeinput":case "blur":case "fullscreenchange":case "focus":case "hashchange":case "popstate":case "select":case "selectstart":return 1;case "drag":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "mousemove":case "mouseout":case "mouseover":case "pointermove":case "pointerout":case "pointerover":case "scroll":case "toggle":case "touchmove":case "wheel":case "mouseenter":case "mouseleave":case "pointerenter":case "pointerleave":return 4;\ncase "message":switch(dc()){case ec:return 1;case fc:return 4;case gc:case hc:return 16;case ic:return 536870912;default:return 16}default:return 16}}var jd=null,kd=null,ld=null;function md(){if(ld)return ld;var a,b=kd,c=b.length,d,e="value"in jd?jd.value:jd.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return ld=e.slice(a,1<d?1-d:void 0)}\nfunction nd(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function od(){return!0}function pd(){return!1}\nfunction qd(a){function b(b,d,e,f,g){this._reactName=b;this._targetInst=e;this.type=d;this.nativeEvent=f;this.target=g;this.currentTarget=null;for(var c in a)a.hasOwnProperty(c)&&(b=a[c],this[c]=b?b(f):f[c]);this.isDefaultPrevented=(null!=f.defaultPrevented?f.defaultPrevented:!1===f.returnValue)?od:pd;this.isPropagationStopped=pd;return this}A(b.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&\n(a.returnValue=!1),this.isDefaultPrevented=od)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=od)},persist:function(){},isPersistent:od});return b}\nvar rd={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},sd=qd(rd),td=A({},rd,{view:0,detail:0}),ud=qd(td),vd,wd,xd,zd=A({},td,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:yd,button:0,buttons:0,relatedTarget:function(a){return void 0===a.relatedTarget?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){if("movementX"in\na)return a.movementX;a!==xd&&(xd&&"mousemove"===a.type?(vd=a.screenX-xd.screenX,wd=a.screenY-xd.screenY):wd=vd=0,xd=a);return vd},movementY:function(a){return"movementY"in a?a.movementY:wd}}),Ad=qd(zd),Bd=A({},zd,{dataTransfer:0}),Cd=qd(Bd),Dd=A({},td,{relatedTarget:0}),Ed=qd(Dd),Fd=A({},rd,{animationName:0,elapsedTime:0,pseudoElement:0}),Gd=qd(Fd),Hd=A({},rd,{clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),Id=qd(Hd),Jd=A({},rd,{data:0}),Kd=qd(Jd),Ld={Esc:"Escape",\nSpacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Md={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",\n119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Nd={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Od(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Nd[a])?!!b[a]:!1}function yd(){return Od}\nvar Pd=A({},td,{key:function(a){if(a.key){var b=Ld[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=nd(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?Md[a.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:yd,charCode:function(a){return"keypress"===a.type?nd(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===\na.type?nd(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),Qd=qd(Pd),Rd=A({},zd,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Sd=qd(Rd),Td=A({},td,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:yd}),Ud=qd(Td),Vd=A({},rd,{propertyName:0,elapsedTime:0,pseudoElement:0}),Wd=qd(Vd),Xd=A({},zd,{deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},\ndeltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),Yd=qd(Xd),Zd=[9,13,27,32],$d=ia&&"CompositionEvent"in window,ae=null;ia&&"documentMode"in document&&(ae=document.documentMode);var be=ia&&"TextEvent"in window&&!ae,ce=ia&&(!$d||ae&&8<ae&&11>=ae),de=String.fromCharCode(32),ee=!1;\nfunction fe(a,b){switch(a){case "keyup":return-1!==Zd.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "focusout":return!0;default:return!1}}function ge(a){a=a.detail;return"object"===typeof a&&"data"in a?a.data:null}var he=!1;function ie(a,b){switch(a){case "compositionend":return ge(b);case "keypress":if(32!==b.which)return null;ee=!0;return de;case "textInput":return a=b.data,a===de&&ee?null:a;default:return null}}\nfunction je(a,b){if(he)return"compositionend"===a||!$d&&fe(a,b)?(a=md(),ld=kd=jd=null,he=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "compositionend":return ce&&"ko"!==b.locale?null:b.data;default:return null}}\nvar ke={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function le(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!ke[a.type]:"textarea"===b?!0:!1}function me(a,b,c,d){Db(d);b=ne(b,"onChange");0<b.length&&(c=new sd("onChange","change",null,c,d),a.push({event:c,listeners:b}))}var oe=null,pe=null;function qe(a){re(a,0)}function se(a){var b=te(a);if(Va(b))return a}\nfunction ue(a,b){if("change"===a)return b}var ve=!1;if(ia){var we;if(ia){var xe="oninput"in document;if(!xe){var ye=document.createElement("div");ye.setAttribute("oninput","return;");xe="function"===typeof ye.oninput}we=xe}else we=!1;ve=we&&(!document.documentMode||9<document.documentMode)}function ze(){oe&&(oe.detachEvent("onpropertychange",Ae),pe=oe=null)}function Ae(a){if("value"===a.propertyName&&se(pe)){var b=[];me(b,pe,a,wb(a));Ib(qe,b)}}\nfunction Be(a,b,c){"focusin"===a?(ze(),oe=b,pe=c,oe.attachEvent("onpropertychange",Ae)):"focusout"===a&&ze()}function Ce(a){if("selectionchange"===a||"keyup"===a||"keydown"===a)return se(pe)}function De(a,b){if("click"===a)return se(b)}function Ee(a,b){if("input"===a||"change"===a)return se(b)}function Fe(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var Ge="function"===typeof Object.is?Object.is:Fe;\nfunction He(a,b){if(Ge(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++){var e=c[d];if(!ja.call(b,e)||!Ge(a[e],b[e]))return!1}return!0}function Ie(a){for(;a&&a.firstChild;)a=a.firstChild;return a}\nfunction Je(a,b){var c=Ie(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=Ie(c)}}function Ke(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?Ke(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}\nfunction Le(){for(var a=window,b=Wa();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wa(a.document)}return b}function Me(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}\nfunction Ne(a){var b=Le(),c=a.focusedElem,d=a.selectionRange;if(b!==c&&c&&c.ownerDocument&&Ke(c.ownerDocument.documentElement,c)){if(null!==d&&Me(c))if(b=d.start,a=d.end,void 0===a&&(a=b),"selectionStart"in c)c.selectionStart=b,c.selectionEnd=Math.min(a,c.value.length);else if(a=(b=c.ownerDocument||document)&&b.defaultView||window,a.getSelection){a=a.getSelection();var e=c.textContent.length,f=Math.min(d.start,e);d=void 0===d.end?f:Math.min(d.end,e);!a.extend&&f>d&&(e=d,d=f,f=e);e=Je(c,f);var g=Je(c,\nd);e&&g&&(1!==a.rangeCount||a.anchorNode!==e.node||a.anchorOffset!==e.offset||a.focusNode!==g.node||a.focusOffset!==g.offset)&&(b=b.createRange(),b.setStart(e.node,e.offset),a.removeAllRanges(),f>d?(a.addRange(b),a.extend(g.node,g.offset)):(b.setEnd(g.node,g.offset),a.addRange(b)))}b=[];for(a=c;a=a.parentNode;)1===a.nodeType&&b.push({element:a,left:a.scrollLeft,top:a.scrollTop});"function"===typeof c.focus&&c.focus();for(c=0;c<b.length;c++)a=b[c],a.element.scrollLeft=a.left,a.element.scrollTop=a.top}}\nvar Oe=ia&&"documentMode"in document&&11>=document.documentMode,Pe=null,Qe=null,Re=null,Se=!1;\nfunction Te(a,b,c){var d=c.window===c?c.document:9===c.nodeType?c:c.ownerDocument;Se||null==Pe||Pe!==Wa(d)||(d=Pe,"selectionStart"in d&&Me(d)?d={start:d.selectionStart,end:d.selectionEnd}:(d=(d.ownerDocument&&d.ownerDocument.defaultView||window).getSelection(),d={anchorNode:d.anchorNode,anchorOffset:d.anchorOffset,focusNode:d.focusNode,focusOffset:d.focusOffset}),Re&&He(Re,d)||(Re=d,d=ne(Qe,"onSelect"),0<d.length&&(b=new sd("onSelect","select",null,b,c),a.push({event:b,listeners:d}),b.target=Pe)))}\nfunction Ue(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}var Ve={animationend:Ue("Animation","AnimationEnd"),animationiteration:Ue("Animation","AnimationIteration"),animationstart:Ue("Animation","AnimationStart"),transitionend:Ue("Transition","TransitionEnd")},We={},Xe={};\nia&&(Xe=document.createElement("div").style,"AnimationEvent"in window||(delete Ve.animationend.animation,delete Ve.animationiteration.animation,delete Ve.animationstart.animation),"TransitionEvent"in window||delete Ve.transitionend.transition);function Ye(a){if(We[a])return We[a];if(!Ve[a])return a;var b=Ve[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Xe)return We[a]=b[c];return a}var Ze=Ye("animationend"),$e=Ye("animationiteration"),af=Ye("animationstart"),bf=Ye("transitionend"),cf=new Map,df="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");\nfunction ef(a,b){cf.set(a,b);fa(b,[a])}for(var ff=0;ff<df.length;ff++){var gf=df[ff],hf=gf.toLowerCase(),jf=gf[0].toUpperCase()+gf.slice(1);ef(hf,"on"+jf)}ef(Ze,"onAnimationEnd");ef($e,"onAnimationIteration");ef(af,"onAnimationStart");ef("dblclick","onDoubleClick");ef("focusin","onFocus");ef("focusout","onBlur");ef(bf,"onTransitionEnd");ha("onMouseEnter",["mouseout","mouseover"]);ha("onMouseLeave",["mouseout","mouseover"]);ha("onPointerEnter",["pointerout","pointerover"]);\nha("onPointerLeave",["pointerout","pointerover"]);fa("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));fa("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));fa("onBeforeInput",["compositionend","keypress","textInput","paste"]);fa("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));fa("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));\nfa("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var kf="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),lf=new Set("cancel close invalid load scroll toggle".split(" ").concat(kf));\nfunction mf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=c;Tb(d,b,void 0,a);a.currentTarget=null}\nfunction re(a,b){b=0!==(b&4);for(var c=0;c<a.length;c++){var d=a[c],e=d.event;d=d.listeners;a:{var f=void 0;if(b)for(var g=d.length-1;0<=g;g--){var h=d[g],k=h.instance,l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;mf(e,h,l);f=k}else for(g=0;g<d.length;g++){h=d[g];k=h.instance;l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;mf(e,h,l);f=k}}}if(Pb)throw a=Qb,Pb=!1,Qb=null,a;}\nfunction D(a,b){var c=b[nf];void 0===c&&(c=b[nf]=new Set);var d=a+"__bubble";c.has(d)||(of(b,a,2,!1),c.add(d))}function pf(a,b,c){var d=0;b&&(d|=4);of(c,a,d,b)}var qf="_reactListening"+Math.random().toString(36).slice(2);function rf(a){if(!a[qf]){a[qf]=!0;da.forEach(function(b){"selectionchange"!==b&&(lf.has(b)||pf(b,!1,a),pf(b,!0,a))});var b=9===a.nodeType?a:a.ownerDocument;null===b||b[qf]||(b[qf]=!0,pf("selectionchange",!1,b))}}\nfunction of(a,b,c,d){switch(id(b)){case 1:var e=dd;break;case 4:e=fd;break;default:e=ed}c=e.bind(null,b,c,a);e=void 0;!Kb||"touchstart"!==b&&"touchmove"!==b&&"wheel"!==b||(e=!0);d?void 0!==e?a.addEventListener(b,c,{capture:!0,passive:e}):a.addEventListener(b,c,!0):void 0!==e?a.addEventListener(b,c,{passive:e}):a.addEventListener(b,c,!1)}\nfunction gd(a,b,c,d,e){var f=d;if(0===(b&1)&&0===(b&2)&&null!==d)a:for(;;){if(null===d)return;var g=d.tag;if(3===g||4===g){var h=d.stateNode.containerInfo;if(h===e||8===h.nodeType&&h.parentNode===e)break;if(4===g)for(g=d.return;null!==g;){var k=g.tag;if(3===k||4===k)if(k=g.stateNode.containerInfo,k===e||8===k.nodeType&&k.parentNode===e)return;g=g.return}for(;null!==h;){g=Vc(h);if(null===g)return;k=g.tag;if(5===k||6===k){d=f=g;continue a}h=h.parentNode}}d=d.return}Ib(function(){var d=f,e=wb(c),g=[];\na:{var h=cf.get(a);if(void 0!==h){var k=sd,m=a;switch(a){case "keypress":if(0===nd(c))break a;case "keydown":case "keyup":k=Qd;break;case "focusin":m="focus";k=Ed;break;case "focusout":m="blur";k=Ed;break;case "beforeblur":case "afterblur":k=Ed;break;case "click":if(2===c.button)break a;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":k=Ad;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":k=\nCd;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":k=Ud;break;case Ze:case $e:case af:k=Gd;break;case bf:k=Wd;break;case "scroll":k=ud;break;case "wheel":k=Yd;break;case "copy":case "cut":case "paste":k=Id;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":k=Sd}var w=0!==(b&4),J=!w&&"scroll"===a,v=w?null!==h?h+"Capture":null:h;w=[];for(var x=d,r;null!==\nx;){r=x;var F=r.stateNode;5===r.tag&&null!==F&&(r=F,null!==v&&(F=Jb(x,v),null!=F&&w.push(sf(x,F,r))));if(J)break;x=x.return}0<w.length&&(h=new k(h,m,null,c,e),g.push({event:h,listeners:w}))}}if(0===(b&7)){a:{h="mouseover"===a||"pointerover"===a;k="mouseout"===a||"pointerout"===a;if(h&&c!==vb&&(m=c.relatedTarget||c.fromElement)&&(Vc(m)||m[tf]))break a;if(k||h){h=e.window===e?e:(h=e.ownerDocument)?h.defaultView||h.parentWindow:window;if(k){if(m=c.relatedTarget||c.toElement,k=d,m=m?Vc(m):null,null!==\nm&&(J=Ub(m),m!==J||5!==m.tag&&6!==m.tag))m=null}else k=null,m=d;if(k!==m){w=Ad;F="onMouseLeave";v="onMouseEnter";x="mouse";if("pointerout"===a||"pointerover"===a)w=Sd,F="onPointerLeave",v="onPointerEnter",x="pointer";J=null==k?h:te(k);r=null==m?h:te(m);h=new w(F,x+"leave",k,c,e);h.target=J;h.relatedTarget=r;F=null;Vc(e)===d&&(w=new w(v,x+"enter",m,c,e),w.target=r,w.relatedTarget=J,F=w);J=F;if(k&&m)b:{w=k;v=m;x=0;for(r=w;r;r=uf(r))x++;r=0;for(F=v;F;F=uf(F))r++;for(;0<x-r;)w=uf(w),x--;for(;0<r-x;)v=\nuf(v),r--;for(;x--;){if(w===v||null!==v&&w===v.alternate)break b;w=uf(w);v=uf(v)}w=null}else w=null;null!==k&&vf(g,h,k,w,!1);null!==m&&null!==J&&vf(g,J,m,w,!0)}}}a:{h=d?te(d):window;k=h.nodeName&&h.nodeName.toLowerCase();if("select"===k||"input"===k&&"file"===h.type)var Z=ue;else if(le(h))if(ve)Z=Ee;else{Z=Ce;var ya=Be}else(k=h.nodeName)&&"input"===k.toLowerCase()&&("checkbox"===h.type||"radio"===h.type)&&(Z=De);if(Z&&(Z=Z(a,d))){me(g,Z,c,e);break a}ya&&ya(a,h,d);"focusout"===a&&(ya=h._wrapperState)&&\nya.controlled&&"number"===h.type&&bb(h,"number",h.value)}ya=d?te(d):window;switch(a){case "focusin":if(le(ya)||"true"===ya.contentEditable)Pe=ya,Qe=d,Re=null;break;case "focusout":Re=Qe=Pe=null;break;case "mousedown":Se=!0;break;case "contextmenu":case "mouseup":case "dragend":Se=!1;Te(g,c,e);break;case "selectionchange":if(Oe)break;case "keydown":case "keyup":Te(g,c,e)}var ab;if($d)b:{switch(a){case "compositionstart":var ca="onCompositionStart";break b;case "compositionend":ca="onCompositionEnd";\nbreak b;case "compositionupdate":ca="onCompositionUpdate";break b}ca=void 0}else he?fe(a,c)&&(ca="onCompositionEnd"):"keydown"===a&&229===c.keyCode&&(ca="onCompositionStart");ca&&(ce&&"ko"!==c.locale&&(he||"onCompositionStart"!==ca?"onCompositionEnd"===ca&&he&&(ab=md()):(jd=e,kd="value"in jd?jd.value:jd.textContent,he=!0)),ya=ne(d,ca),0<ya.length&&(ca=new Kd(ca,a,null,c,e),g.push({event:ca,listeners:ya}),ab?ca.data=ab:(ab=ge(c),null!==ab&&(ca.data=ab))));if(ab=be?ie(a,c):je(a,c))d=ne(d,"onBeforeInput"),\n0<d.length&&(e=new Kd("onBeforeInput","beforeinput",null,c,e),g.push({event:e,listeners:d}),e.data=ab)}re(g,b)})}function sf(a,b,c){return{instance:a,listener:b,currentTarget:c}}function ne(a,b){for(var c=b+"Capture",d=[];null!==a;){var e=a,f=e.stateNode;5===e.tag&&null!==f&&(e=f,f=Jb(a,c),null!=f&&d.unshift(sf(a,f,e)),f=Jb(a,b),null!=f&&d.push(sf(a,f,e)));a=a.return}return d}function uf(a){if(null===a)return null;do a=a.return;while(a&&5!==a.tag);return a?a:null}\nfunction vf(a,b,c,d,e){for(var f=b._reactName,g=[];null!==c&&c!==d;){var h=c,k=h.alternate,l=h.stateNode;if(null!==k&&k===d)break;5===h.tag&&null!==l&&(h=l,e?(k=Jb(c,f),null!=k&&g.unshift(sf(c,k,h))):e||(k=Jb(c,f),null!=k&&g.push(sf(c,k,h))));c=c.return}0!==g.length&&a.push({event:b,listeners:g})}var wf=/\\r\\n?/g,xf=/\\u0000|\\uFFFD/g;function yf(a){return("string"===typeof a?a:""+a).replace(wf,"\\n").replace(xf,"")}function zf(a,b,c){b=yf(b);if(yf(a)!==b&&c)throw Error(p(425));}function Af(){}\nvar Bf=null,Cf=null;function Df(a,b){return"textarea"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}\nvar Ef="function"===typeof setTimeout?setTimeout:void 0,Ff="function"===typeof clearTimeout?clearTimeout:void 0,Gf="function"===typeof Promise?Promise:void 0,If="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof Gf?function(a){return Gf.resolve(null).then(a).catch(Hf)}:Ef;function Hf(a){setTimeout(function(){throw a;})}\nfunction Jf(a,b){var c=b,d=0;do{var e=c.nextSibling;a.removeChild(c);if(e&&8===e.nodeType)if(c=e.data,"/$"===c){if(0===d){a.removeChild(e);ad(b);return}d--}else"$"!==c&&"$?"!==c&&"$!"!==c||d++;c=e}while(c);ad(b)}function Kf(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break;if(8===b){b=a.data;if("$"===b||"$!"===b||"$?"===b)break;if("/$"===b)return null}}return a}\nfunction Lf(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if("$"===c||"$!"===c||"$?"===c){if(0===b)return a;b--}else"/$"===c&&b++}a=a.previousSibling}return null}var Mf=Math.random().toString(36).slice(2),Nf="__reactFiber$"+Mf,Of="__reactProps$"+Mf,tf="__reactContainer$"+Mf,nf="__reactEvents$"+Mf,Pf="__reactListeners$"+Mf,Qf="__reactHandles$"+Mf;\nfunction Vc(a){var b=a[Nf];if(b)return b;for(var c=a.parentNode;c;){if(b=c[tf]||c[Nf]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=Lf(a);null!==a;){if(c=a[Nf])return c;a=Lf(a)}return b}a=c;c=a.parentNode}return null}function Bb(a){a=a[Nf]||a[tf];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function te(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(p(33));}function Cb(a){return a[Of]||null}var Rf=[],Sf=-1;function Tf(a){return{current:a}}\nfunction E(a){0>Sf||(a.current=Rf[Sf],Rf[Sf]=null,Sf--)}function G(a,b){Sf++;Rf[Sf]=a.current;a.current=b}var Uf={},H=Tf(Uf),Vf=Tf(!1),Wf=Uf;function Xf(a,b){var c=a.type.contextTypes;if(!c)return Uf;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}\nfunction Yf(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Zf(){E(Vf);E(H)}function $f(a,b,c){if(H.current!==Uf)throw Error(p(168));G(H,b);G(Vf,c)}function ag(a,b,c){var d=a.stateNode;b=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in b))throw Error(p(108,Qa(a)||"Unknown",e));return A({},c,d)}\nfunction bg(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Uf;Wf=H.current;G(H,a);G(Vf,Vf.current);return!0}function cg(a,b,c){var d=a.stateNode;if(!d)throw Error(p(169));c?(a=ag(a,b,Wf),d.__reactInternalMemoizedMergedChildContext=a,E(Vf),E(H),G(H,a)):E(Vf);G(Vf,c)}var dg=null,eg=!1,fg=!1;function gg(a){null===dg?dg=[a]:dg.push(a)}function hg(a){eg=!0;gg(a)}\nfunction ig(){if(!fg&&null!==dg){fg=!0;var a=0,b=C;try{var c=dg;for(C=1;a<c.length;a++){var d=c[a];do d=d(!0);while(null!==d)}dg=null;eg=!1}catch(e){throw null!==dg&&(dg=dg.slice(a+1)),$b(ec,ig),e;}finally{C=b,fg=!1}}return null}var jg=ta.ReactCurrentBatchConfig;function kg(a,b){if(a&&a.defaultProps){b=A({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c]);return b}return b}var lg=Tf(null),mg=null,ng=null,og=null;function pg(){og=ng=mg=null}\nfunction qg(a){var b=lg.current;E(lg);a._currentValue=b}function rg(a,b,c){for(;null!==a;){var d=a.alternate;(a.childLanes&b)!==b?(a.childLanes|=b,null!==d&&(d.childLanes|=b)):null!==d&&(d.childLanes&b)!==b&&(d.childLanes|=b);if(a===c)break;a=a.return}}function sg(a,b){mg=a;og=ng=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(0!==(a.lanes&b)&&(tg=!0),a.firstContext=null)}\nfunction ug(a){var b=a._currentValue;if(og!==a)if(a={context:a,memoizedValue:b,next:null},null===ng){if(null===mg)throw Error(p(308));ng=a;mg.dependencies={lanes:0,firstContext:a}}else ng=ng.next=a;return b}var vg=null,wg=!1;function xg(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}\nfunction yg(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,effects:a.effects})}function zg(a,b){return{eventTime:a,lane:b,tag:0,payload:null,callback:null,next:null}}\nfunction Ag(a,b){var c=a.updateQueue;null!==c&&(c=c.shared,Bg(a)?(a=c.interleaved,null===a?(b.next=b,null===vg?vg=[c]:vg.push(c)):(b.next=a.next,a.next=b),c.interleaved=b):(a=c.pending,null===a?b.next=b:(b.next=a.next,a.next=b),c.pending=b))}function Cg(a,b,c){b=b.updateQueue;if(null!==b&&(b=b.shared,0!==(c&4194240))){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;Bc(a,c)}}\nfunction Dg(a,b){var c=a.updateQueue,d=a.alternate;if(null!==d&&(d=d.updateQueue,c===d)){var e=null,f=null;c=c.firstBaseUpdate;if(null!==c){do{var g={eventTime:c.eventTime,lane:c.lane,tag:c.tag,payload:c.payload,callback:c.callback,next:null};null===f?e=f=g:f=f.next=g;c=c.next}while(null!==c);null===f?e=f=b:f=f.next=b}else e=f=b;c={baseState:d.baseState,firstBaseUpdate:e,lastBaseUpdate:f,shared:d.shared,effects:d.effects};a.updateQueue=c;return}a=c.lastBaseUpdate;null===a?c.firstBaseUpdate=b:a.next=\nb;c.lastBaseUpdate=b}\nfunction Eg(a,b,c,d){var e=a.updateQueue;wg=!1;var f=e.firstBaseUpdate,g=e.lastBaseUpdate,h=e.shared.pending;if(null!==h){e.shared.pending=null;var k=h,l=k.next;k.next=null;null===g?f=l:g.next=l;g=k;var n=a.alternate;null!==n&&(n=n.updateQueue,h=n.lastBaseUpdate,h!==g&&(null===h?n.firstBaseUpdate=l:h.next=l,n.lastBaseUpdate=k))}if(null!==f){var u=e.baseState;g=0;n=l=k=null;h=f;do{var q=h.lane,y=h.eventTime;if((d&q)===q){null!==n&&(n=n.next={eventTime:y,lane:0,tag:h.tag,payload:h.payload,callback:h.callback,\nnext:null});a:{var m=a,w=h;q=b;y=c;switch(w.tag){case 1:m=w.payload;if("function"===typeof m){u=m.call(y,u,q);break a}u=m;break a;case 3:m.flags=m.flags&-65537|128;case 0:m=w.payload;q="function"===typeof m?m.call(y,u,q):m;if(null===q||void 0===q)break a;u=A({},u,q);break a;case 2:wg=!0}}null!==h.callback&&0!==h.lane&&(a.flags|=64,q=e.effects,null===q?e.effects=[h]:q.push(h))}else y={eventTime:y,lane:q,tag:h.tag,payload:h.payload,callback:h.callback,next:null},null===n?(l=n=y,k=u):n=n.next=y,g|=q;\nh=h.next;if(null===h)if(h=e.shared.pending,null===h)break;else q=h,h=q.next,q.next=null,e.lastBaseUpdate=q,e.shared.pending=null}while(1);null===n&&(k=u);e.baseState=k;e.firstBaseUpdate=l;e.lastBaseUpdate=n;b=e.shared.interleaved;if(null!==b){e=b;do g|=e.lane,e=e.next;while(e!==b)}else null===f&&(e.shared.lanes=0);Fg|=g;a.lanes=g;a.memoizedState=u}}\nfunction Gg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=c;if("function"!==typeof e)throw Error(p(191,e));e.call(d)}}}var Hg=(new aa.Component).refs;function Ig(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:A({},b,c);a.memoizedState=c;0===a.lanes&&(a.updateQueue.baseState=c)}\nvar Mg={isMounted:function(a){return(a=a._reactInternals)?Ub(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternals;var d=Jg(),e=Kg(a),f=zg(d,e);f.payload=b;void 0!==c&&null!==c&&(f.callback=c);Ag(a,f);b=Lg(a,e,d);null!==b&&Cg(b,a,e)},enqueueReplaceState:function(a,b,c){a=a._reactInternals;var d=Jg(),e=Kg(a),f=zg(d,e);f.tag=1;f.payload=b;void 0!==c&&null!==c&&(f.callback=c);Ag(a,f);b=Lg(a,e,d);null!==b&&Cg(b,a,e)},enqueueForceUpdate:function(a,b){a=a._reactInternals;var c=Jg(),d=Kg(a),e=zg(c,\nd);e.tag=2;void 0!==b&&null!==b&&(e.callback=b);Ag(a,e);b=Lg(a,d,c);null!==b&&Cg(b,a,d)}};function Ng(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!He(c,d)||!He(e,f):!0}\nfunction Og(a,b,c){var d=!1,e=Uf;var f=b.contextType;"object"===typeof f&&null!==f?f=ug(f):(e=Yf(b)?Wf:H.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Xf(a,e):Uf);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mg;a.stateNode=b;b._reactInternals=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}\nfunction Pg(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mg.enqueueReplaceState(b,b.state,null)}\nfunction Qg(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=Hg;xg(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=ug(f):(f=Yf(b)?Wf:H.current,e.context=Xf(a,f));e.state=a.memoizedState;f=b.getDerivedStateFromProps;"function"===typeof f&&(Ig(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,\n"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mg.enqueueReplaceState(e,e.state,null),Eg(a,c,e,d),e.state=a.memoizedState);"function"===typeof e.componentDidMount&&(a.flags|=4194308)}var Rg=[],Sg=0,Tg=null,Ug=0,Vg=[],Wg=0,Xg=null,Yg=1,Zg="";function $g(a,b){Rg[Sg++]=Ug;Rg[Sg++]=Tg;Tg=a;Ug=b}\nfunction ah(a,b,c){Vg[Wg++]=Yg;Vg[Wg++]=Zg;Vg[Wg++]=Xg;Xg=a;var d=Yg;a=Zg;var e=32-nc(d)-1;d&=~(1<<e);c+=1;var f=32-nc(b)+e;if(30<f){var g=e-e%5;f=(d&(1<<g)-1).toString(32);d>>=g;e-=g;Yg=1<<32-nc(b)+e|c<<e|d;Zg=f+a}else Yg=1<<f|c<<e|d,Zg=a}function bh(a){null!==a.return&&($g(a,1),ah(a,1,0))}function ch(a){for(;a===Tg;)Tg=Rg[--Sg],Rg[Sg]=null,Ug=Rg[--Sg],Rg[Sg]=null;for(;a===Xg;)Xg=Vg[--Wg],Vg[Wg]=null,Zg=Vg[--Wg],Vg[Wg]=null,Yg=Vg[--Wg],Vg[Wg]=null}var dh=null,eh=null,I=!1,fh=null;\nfunction gh(a,b){var c=hh(5,null,null,0);c.elementType="DELETED";c.stateNode=b;c.return=a;b=a.deletions;null===b?(a.deletions=[c],a.flags|=16):b.push(c)}\nfunction ih(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,dh=a,eh=Kf(b.firstChild),!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,dh=a,eh=null,!0):!1;case 13:return b=8!==b.nodeType?null:b,null!==b?(c=null!==Xg?{id:Yg,overflow:Zg}:null,a.memoizedState={dehydrated:b,treeContext:c,retryLane:1073741824},c=hh(18,null,null,0),c.stateNode=b,c.return=a,a.child=c,dh=a,eh=\nnull,!0):!1;default:return!1}}function jh(a){return 0!==(a.mode&1)&&0===(a.flags&128)}function kh(a){if(I){var b=eh;if(b){var c=b;if(!ih(a,b)){if(jh(a))throw Error(p(418));b=Kf(c.nextSibling);var d=dh;b&&ih(a,b)?gh(d,c):(a.flags=a.flags&-4097|2,I=!1,dh=a)}}else{if(jh(a))throw Error(p(418));a.flags=a.flags&-4097|2;I=!1;dh=a}}}function lh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;dh=a}\nfunction mh(a){if(a!==dh)return!1;if(!I)return lh(a),I=!0,!1;var b;(b=3!==a.tag)&&!(b=5!==a.tag)&&(b=a.type,b="head"!==b&&"body"!==b&&!Df(a.type,a.memoizedProps));if(b&&(b=eh)){if(jh(a)){for(a=eh;a;)a=Kf(a.nextSibling);throw Error(p(418));}for(;b;)gh(a,b),b=Kf(b.nextSibling)}lh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(p(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if("/$"===c){if(0===b){eh=Kf(a.nextSibling);break a}b--}else"$"!==c&&\n"$!"!==c&&"$?"!==c||b++}a=a.nextSibling}eh=null}}else eh=dh?Kf(a.stateNode.nextSibling):null;return!0}function nh(){eh=dh=null;I=!1}function oh(a){null===fh?fh=[a]:fh.push(a)}\nfunction ph(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(p(309));var d=c.stateNode}if(!d)throw Error(p(147,a));var e=d,f=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===f)return b.ref;b=function(a){var b=e.refs;b===Hg&&(b=e.refs={});null===a?delete b[f]:b[f]=a};b._stringRef=f;return b}if("string"!==typeof a)throw Error(p(284));if(!c._owner)throw Error(p(290,a));}return a}\nfunction qh(a,b){a=Object.prototype.toString.call(b);throw Error(p(31,"[object Object]"===a?"object with keys {"+Object.keys(b).join(", ")+"}":a));}function rh(a){var b=a._init;return b(a._payload)}\nfunction sh(a){function b(b,c){if(a){var d=b.deletions;null===d?(b.deletions=[c],b.flags|=16):d.push(c)}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b){a=th(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return b.flags|=1048576,c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.flags|=2,c):d;b.flags|=2;return c}function g(b){a&&\nnull===b.alternate&&(b.flags|=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=uh(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function k(a,b,c,d){var f=c.type;if(f===wa)return n(a,b,c.props.children,d,c.key);if(null!==b&&(b.elementType===f||"object"===typeof f&&null!==f&&f.$$typeof===Ga&&rh(f)===b.type))return d=e(b,c.props),d.ref=ph(a,b,c),d.return=a,d;d=vh(c.type,c.key,c.props,null,a.mode,d);d.ref=ph(a,b,c);d.return=a;return d}function l(a,b,c,d){if(null===b||4!==b.tag||\nb.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=wh(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function n(a,b,c,d,f){if(null===b||7!==b.tag)return b=xh(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function u(a,b,c){if("string"===typeof b&&""!==b||"number"===typeof b)return b=uh(""+b,a.mode,c),b.return=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case ua:return c=vh(b.type,b.key,b.props,null,a.mode,c),\nc.ref=ph(a,null,b),c.return=a,c;case va:return b=wh(b,a.mode,c),b.return=a,b;case Ga:var d=b._init;return u(a,d(b._payload),c)}if(db(b)||Ja(b))return b=xh(b,a.mode,c,null),b.return=a,b;qh(a,b)}return null}function q(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c&&""!==c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case ua:return c.key===e?k(a,b,c,d):null;case va:return c.key===e?l(a,b,c,d):null;case Ga:return e=c._init,q(a,\nb,e(c._payload),d)}if(db(c)||Ja(c))return null!==e?null:n(a,b,c,d,null);qh(a,c)}return null}function y(a,b,c,d,e){if("string"===typeof d&&""!==d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case ua:return a=a.get(null===d.key?c:d.key)||null,k(b,a,d,e);case va:return a=a.get(null===d.key?c:d.key)||null,l(b,a,d,e);case Ga:var f=d._init;return y(a,b,c,f(d._payload),e)}if(db(d)||Ja(d))return a=a.get(c)||null,n(b,a,d,e,null);qh(b,d)}return null}\nfunction m(e,g,h,k){for(var l=null,n=null,r=g,m=g=0,x=null;null!==r&&m<h.length;m++){r.index>m?(x=r,r=null):x=r.sibling;var v=q(e,r,h[m],k);if(null===v){null===r&&(r=x);break}a&&r&&null===v.alternate&&b(e,r);g=f(v,g,m);null===n?l=v:n.sibling=v;n=v;r=x}if(m===h.length)return c(e,r),I&&$g(e,m),l;if(null===r){for(;m<h.length;m++)r=u(e,h[m],k),null!==r&&(g=f(r,g,m),null===n?l=r:n.sibling=r,n=r);I&&$g(e,m);return l}for(r=d(e,r);m<h.length;m++)x=y(r,e,m,h[m],k),null!==x&&(a&&null!==x.alternate&&r.delete(null===\nx.key?m:x.key),g=f(x,g,m),null===n?l=x:n.sibling=x,n=x);a&&r.forEach(function(a){return b(e,a)});I&&$g(e,m);return l}function w(e,g,h,k){var l=Ja(h);if("function"!==typeof l)throw Error(p(150));h=l.call(h);if(null==h)throw Error(p(151));for(var n=l=null,m=g,r=g=0,x=null,v=h.next();null!==m&&!v.done;r++,v=h.next()){m.index>r?(x=m,m=null):x=m.sibling;var w=q(e,m,v.value,k);if(null===w){null===m&&(m=x);break}a&&m&&null===w.alternate&&b(e,m);g=f(w,g,r);null===n?l=w:n.sibling=w;n=w;m=x}if(v.done)return c(e,\nm),I&&$g(e,r),l;if(null===m){for(;!v.done;r++,v=h.next())v=u(e,v.value,k),null!==v&&(g=f(v,g,r),null===n?l=v:n.sibling=v,n=v);I&&$g(e,r);return l}for(m=d(e,m);!v.done;r++,v=h.next())v=y(m,e,r,v.value,k),null!==v&&(a&&null!==v.alternate&&m.delete(null===v.key?r:v.key),g=f(v,g,r),null===n?l=v:n.sibling=v,n=v);a&&m.forEach(function(a){return b(e,a)});I&&$g(e,r);return l}function J(a,d,f,h){"object"===typeof f&&null!==f&&f.type===wa&&null===f.key&&(f=f.props.children);if("object"===typeof f&&null!==f){switch(f.$$typeof){case ua:a:{for(var k=\nf.key,l=d;null!==l;){if(l.key===k){k=f.type;if(k===wa){if(7===l.tag){c(a,l.sibling);d=e(l,f.props.children);d.return=a;a=d;break a}}else if(l.elementType===k||"object"===typeof k&&null!==k&&k.$$typeof===Ga&&rh(k)===l.type){c(a,l.sibling);d=e(l,f.props);d.ref=ph(a,l,f);d.return=a;a=d;break a}c(a,l);break}else b(a,l);l=l.sibling}f.type===wa?(d=xh(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=vh(f.type,f.key,f.props,null,a.mode,h),h.ref=ph(a,d,f),h.return=a,a=h)}return g(a);case va:a:{for(l=f.key;null!==\nd;){if(d.key===l)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=wh(f,a.mode,h);d.return=a;a=d}return g(a);case Ga:return l=f._init,J(a,d,l(f._payload),h)}if(db(f))return m(a,d,f,h);if(Ja(f))return w(a,d,f,h);qh(a,f)}return"string"===typeof f&&""!==f||"number"===typeof f?(f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):\n(c(a,d),d=uh(f,a.mode,h),d.return=a,a=d),g(a)):c(a,d)}return J}var yh=sh(!0),zh=sh(!1),Ah={},Bh=Tf(Ah),Ch=Tf(Ah),Dh=Tf(Ah);function Eh(a){if(a===Ah)throw Error(p(174));return a}function Fh(a,b){G(Dh,b);G(Ch,a);G(Bh,Ah);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:kb(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=kb(b,a)}E(Bh);G(Bh,b)}function Gh(){E(Bh);E(Ch);E(Dh)}\nfunction Hh(a){Eh(Dh.current);var b=Eh(Bh.current);var c=kb(b,a.type);b!==c&&(G(Ch,a),G(Bh,c))}function Ih(a){Ch.current===a&&(E(Bh),E(Ch))}var K=Tf(0);\nfunction Jh(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||"$?"===c.data||"$!"===c.data))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.flags&128))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}var Kh=[];\nfunction Lh(){for(var a=0;a<Kh.length;a++)Kh[a]._workInProgressVersionPrimary=null;Kh.length=0}var Mh=ta.ReactCurrentDispatcher,Nh=ta.ReactCurrentBatchConfig,Oh=0,L=null,M=null,N=null,Ph=!1,Qh=!1,Rh=0,Sh=0;function O(){throw Error(p(321));}function Th(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Ge(a[c],b[c]))return!1;return!0}\nfunction Uh(a,b,c,d,e,f){Oh=f;L=b;b.memoizedState=null;b.updateQueue=null;b.lanes=0;Mh.current=null===a||null===a.memoizedState?Vh:Wh;a=c(d,e);if(Qh){f=0;do{Qh=!1;Rh=0;if(25<=f)throw Error(p(301));f+=1;N=M=null;b.updateQueue=null;Mh.current=Xh;a=c(d,e)}while(Qh)}Mh.current=Yh;b=null!==M&&null!==M.next;Oh=0;N=M=L=null;Ph=!1;if(b)throw Error(p(300));return a}function Zh(){var a=0!==Rh;Rh=0;return a}\nfunction $h(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===N?L.memoizedState=N=a:N=N.next=a;return N}function ai(){if(null===M){var a=L.alternate;a=null!==a?a.memoizedState:null}else a=M.next;var b=null===N?L.memoizedState:N.next;if(null!==b)N=b,M=a;else{if(null===a)throw Error(p(310));M=a;a={memoizedState:M.memoizedState,baseState:M.baseState,baseQueue:M.baseQueue,queue:M.queue,next:null};null===N?L.memoizedState=N=a:N=N.next=a}return N}\nfunction bi(a,b){return"function"===typeof b?b(a):b}\nfunction ci(a){var b=ai(),c=b.queue;if(null===c)throw Error(p(311));c.lastRenderedReducer=a;var d=M,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){f=e.next;d=d.baseState;var h=g=null,k=null,l=f;do{var n=l.lane;if((Oh&n)===n)null!==k&&(k=k.next={lane:0,action:l.action,hasEagerState:l.hasEagerState,eagerState:l.eagerState,next:null}),d=l.hasEagerState?l.eagerState:a(d,l.action);else{var u={lane:n,action:l.action,hasEagerState:l.hasEagerState,\neagerState:l.eagerState,next:null};null===k?(h=k=u,g=d):k=k.next=u;L.lanes|=n;Fg|=n}l=l.next}while(null!==l&&l!==f);null===k?g=d:k.next=h;Ge(d,b.memoizedState)||(tg=!0);b.memoizedState=d;b.baseState=g;b.baseQueue=k;c.lastRenderedState=d}a=c.interleaved;if(null!==a){e=a;do f=e.lane,L.lanes|=f,Fg|=f,e=e.next;while(e!==a)}else null===e&&(c.lanes=0);return[b.memoizedState,c.dispatch]}\nfunction di(a){var b=ai(),c=b.queue;if(null===c)throw Error(p(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Ge(f,b.memoizedState)||(tg=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function ei(){}\nfunction fi(a,b){var c=L,d=ai(),e=b(),f=!Ge(d.memoizedState,e);f&&(d.memoizedState=e,tg=!0);d=d.queue;gi(hi.bind(null,c,d,a),[a]);if(d.getSnapshot!==b||f||null!==N&&N.memoizedState.tag&1){c.flags|=2048;ii(9,ji.bind(null,c,d,e,b),void 0,null);if(null===P)throw Error(p(349));0!==(Oh&30)||ki(c,b,e)}return e}function ki(a,b,c){a.flags|=16384;a={getSnapshot:b,value:c};b=L.updateQueue;null===b?(b={lastEffect:null,stores:null},L.updateQueue=b,b.stores=[a]):(c=b.stores,null===c?b.stores=[a]:c.push(a))}\nfunction ji(a,b,c,d){b.value=c;b.getSnapshot=d;li(b)&&Lg(a,1,-1)}function hi(a,b,c){return c(function(){li(b)&&Lg(a,1,-1)})}function li(a){var b=a.getSnapshot;a=a.value;try{var c=b();return!Ge(a,c)}catch(d){return!0}}function mi(a){var b=$h();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:bi,lastRenderedState:a};b.queue=a;a=a.dispatch=ni.bind(null,L,a);return[b.memoizedState,a]}\nfunction ii(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=L.updateQueue;null===b?(b={lastEffect:null,stores:null},L.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function oi(){return ai().memoizedState}function pi(a,b,c,d){var e=$h();L.flags|=a;e.memoizedState=ii(1|b,c,void 0,void 0===d?null:d)}\nfunction qi(a,b,c,d){var e=ai();d=void 0===d?null:d;var f=void 0;if(null!==M){var g=M.memoizedState;f=g.destroy;if(null!==d&&Th(d,g.deps)){e.memoizedState=ii(b,c,f,d);return}}L.flags|=a;e.memoizedState=ii(1|b,c,f,d)}function ri(a,b){return pi(8390656,8,a,b)}function gi(a,b){return qi(2048,8,a,b)}function si(a,b){return qi(4,2,a,b)}function ti(a,b){return qi(4,4,a,b)}\nfunction ui(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function vi(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return qi(4,4,ui.bind(null,b,a),c)}function wi(){}function xi(a,b){var c=ai();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Th(b,d[1]))return d[0];c.memoizedState=[a,b];return a}\nfunction yi(a,b){var c=ai();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Th(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function zi(a,b,c){if(0===(Oh&21))return a.baseState&&(a.baseState=!1,tg=!0),a.memoizedState=c;Ge(c,b)||(c=xc(),L.lanes|=c,Fg|=c,a.baseState=!0);return b}function Ai(a,b){var c=C;C=0!==c&&4>c?c:4;a(!0);var d=Nh.transition;Nh.transition={};try{a(!1),b()}finally{C=c,Nh.transition=d}}function Bi(){return ai().memoizedState}\nfunction Ci(a,b,c){var d=Kg(a);c={lane:d,action:c,hasEagerState:!1,eagerState:null,next:null};Di(a)?Ei(b,c):(Fi(a,b,c),c=Jg(),a=Lg(a,d,c),null!==a&&Gi(a,b,d))}\nfunction ni(a,b,c){var d=Kg(a),e={lane:d,action:c,hasEagerState:!1,eagerState:null,next:null};if(Di(a))Ei(b,e);else{Fi(a,b,e);var f=a.alternate;if(0===a.lanes&&(null===f||0===f.lanes)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,h=f(g,c);e.hasEagerState=!0;e.eagerState=h;if(Ge(h,g))return}catch(k){}finally{}c=Jg();a=Lg(a,d,c);null!==a&&Gi(a,b,d)}}function Di(a){var b=a.alternate;return a===L||null!==b&&b===L}\nfunction Ei(a,b){Qh=Ph=!0;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}function Fi(a,b,c){Bg(a)?(a=b.interleaved,null===a?(c.next=c,null===vg?vg=[b]:vg.push(b)):(c.next=a.next,a.next=c),b.interleaved=c):(a=b.pending,null===a?c.next=c:(c.next=a.next,a.next=c),b.pending=c)}function Gi(a,b,c){if(0!==(c&4194240)){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;Bc(a,c)}}\nvar Yh={readContext:ug,useCallback:O,useContext:O,useEffect:O,useImperativeHandle:O,useInsertionEffect:O,useLayoutEffect:O,useMemo:O,useReducer:O,useRef:O,useState:O,useDebugValue:O,useDeferredValue:O,useTransition:O,useMutableSource:O,useSyncExternalStore:O,useId:O,unstable_isNewReconciler:!1},Vh={readContext:ug,useCallback:function(a,b){$h().memoizedState=[a,void 0===b?null:b];return a},useContext:ug,useEffect:ri,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return pi(4194308,\n4,ui.bind(null,b,a),c)},useLayoutEffect:function(a,b){return pi(4194308,4,a,b)},useInsertionEffect:function(a,b){return pi(4,2,a,b)},useMemo:function(a,b){var c=$h();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=$h();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};d.queue=a;a=a.dispatch=Ci.bind(null,L,a);return[d.memoizedState,a]},useRef:function(a){var b=\n$h();a={current:a};return b.memoizedState=a},useState:mi,useDebugValue:wi,useDeferredValue:function(a){return $h().memoizedState=a},useTransition:function(){var a=mi(!1),b=a[0];a=Ai.bind(null,a[1]);$h().memoizedState=a;return[b,a]},useMutableSource:function(){},useSyncExternalStore:function(a,b,c){var d=L,e=$h();if(I){if(void 0===c)throw Error(p(407));c=c()}else{c=b();if(null===P)throw Error(p(349));0!==(Oh&30)||ki(d,b,c)}e.memoizedState=c;var f={value:c,getSnapshot:b};e.queue=f;ri(hi.bind(null,d,\nf,a),[a]);d.flags|=2048;ii(9,ji.bind(null,d,f,c,b),void 0,null);return c},useId:function(){var a=$h(),b=P.identifierPrefix;if(I){var c=Zg;var d=Yg;c=(d&~(1<<32-nc(d)-1)).toString(32)+c;b=":"+b+"R"+c;c=Rh++;0<c&&(b+="H"+c.toString(32));b+=":"}else c=Sh++,b=":"+b+"r"+c.toString(32)+":";return a.memoizedState=b},unstable_isNewReconciler:!1},Wh={readContext:ug,useCallback:xi,useContext:ug,useEffect:gi,useImperativeHandle:vi,useInsertionEffect:si,useLayoutEffect:ti,useMemo:yi,useReducer:ci,useRef:oi,useState:function(){return ci(bi)},\nuseDebugValue:wi,useDeferredValue:function(a){var b=ai();return zi(b,M.memoizedState,a)},useTransition:function(){var a=ci(bi)[0],b=ai().memoizedState;return[a,b]},useMutableSource:ei,useSyncExternalStore:fi,useId:Bi,unstable_isNewReconciler:!1},Xh={readContext:ug,useCallback:xi,useContext:ug,useEffect:gi,useImperativeHandle:vi,useInsertionEffect:si,useLayoutEffect:ti,useMemo:yi,useReducer:di,useRef:oi,useState:function(){return di(bi)},useDebugValue:wi,useDeferredValue:function(a){var b=ai();return null===\nM?b.memoizedState=a:zi(b,M.memoizedState,a)},useTransition:function(){var a=di(bi)[0],b=ai().memoizedState;return[a,b]},useMutableSource:ei,useSyncExternalStore:fi,useId:Bi,unstable_isNewReconciler:!1};function Hi(a,b){try{var c="",d=b;do c+=Oa(d),d=d.return;while(d);var e=c}catch(f){e="\\nError generating stack: "+f.message+"\\n"+f.stack}return{value:a,source:b,stack:e}}function Ii(a,b){try{console.error(b.value)}catch(c){setTimeout(function(){throw c;})}}\nvar Ji="function"===typeof WeakMap?WeakMap:Map;function Ki(a,b,c){c=zg(-1,c);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){Li||(Li=!0,Mi=d);Ii(a,b)};return c}\nfunction Ni(a,b,c){c=zg(-1,c);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){return d(e)};c.callback=function(){Ii(a,b)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){Ii(a,b);"function"!==typeof d&&(null===Oi?Oi=new Set([this]):Oi.add(this));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}\nfunction Pi(a,b,c){var d=a.pingCache;if(null===d){d=a.pingCache=new Ji;var e=new Set;d.set(b,e)}else e=d.get(b),void 0===e&&(e=new Set,d.set(b,e));e.has(c)||(e.add(c),a=Qi.bind(null,a,b,c),b.then(a,a))}function Ri(a){do{var b;if(b=13===a.tag)b=a.memoizedState,b=null!==b?null!==b.dehydrated?!0:!1:!0;if(b)return a;a=a.return}while(null!==a);return null}\nfunction Si(a,b,c,d,e){if(0===(a.mode&1))return a===b?a.flags|=65536:(a.flags|=128,c.flags|=131072,c.flags&=-52805,1===c.tag&&(null===c.alternate?c.tag=17:(b=zg(-1,1),b.tag=2,Ag(c,b))),c.lanes|=1),a;a.flags|=65536;a.lanes=e;return a}var Ti,Ui,Vi,Wi;\nTi=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};Ui=function(){};\nVi=function(a,b,c,d){var e=a.memoizedProps;if(e!==d){a=b.stateNode;Eh(Bh.current);var f=null;switch(c){case "input":e=Xa(a,e);d=Xa(a,d);f=[];break;case "select":e=A({},e,{value:void 0});d=A({},d,{value:void 0});f=[];break;case "textarea":e=fb(a,e);d=fb(a,d);f=[];break;default:"function"!==typeof e.onClick&&"function"===typeof d.onClick&&(a.onclick=Af)}tb(c,d);var g;c=null;for(l in e)if(!d.hasOwnProperty(l)&&e.hasOwnProperty(l)&&null!=e[l])if("style"===l){var h=e[l];for(g in h)h.hasOwnProperty(g)&&\n(c||(c={}),c[g]="")}else"dangerouslySetInnerHTML"!==l&&"children"!==l&&"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&"autoFocus"!==l&&(ea.hasOwnProperty(l)?f||(f=[]):(f=f||[]).push(l,null));for(l in d){var k=d[l];h=null!=e?e[l]:void 0;if(d.hasOwnProperty(l)&&k!==h&&(null!=k||null!=h))if("style"===l)if(h){for(g in h)!h.hasOwnProperty(g)||k&&k.hasOwnProperty(g)||(c||(c={}),c[g]="");for(g in k)k.hasOwnProperty(g)&&h[g]!==k[g]&&(c||(c={}),c[g]=k[g])}else c||(f||(f=[]),f.push(l,\nc)),c=k;else"dangerouslySetInnerHTML"===l?(k=k?k.__html:void 0,h=h?h.__html:void 0,null!=k&&h!==k&&(f=f||[]).push(l,k)):"children"===l?"string"!==typeof k&&"number"!==typeof k||(f=f||[]).push(l,""+k):"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&(ea.hasOwnProperty(l)?(null!=k&&"onScroll"===l&&D("scroll",a),f||h===k||(f=[])):(f=f||[]).push(l,k))}c&&(f=f||[]).push("style",c);var l=f;if(b.updateQueue=l)b.flags|=4}};Wi=function(a,b,c,d){c!==d&&(b.flags|=4)};\nfunction Xi(a,b){if(!I)switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}\nfunction Q(a){var b=null!==a.alternate&&a.alternate.child===a.child,c=0,d=0;if(b)for(var e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags&14680064,d|=e.flags&14680064,e.return=a,e=e.sibling;else for(e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags,d|=e.flags,e.return=a,e=e.sibling;a.subtreeFlags|=d;a.childLanes=c;return b}\nfunction Yi(a,b,c){var d=b.pendingProps;ch(b);switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Q(b),null;case 1:return Yf(b.type)&&Zf(),Q(b),null;case 3:d=b.stateNode;Gh();E(Vf);E(H);Lh();d.pendingContext&&(d.context=d.pendingContext,d.pendingContext=null);if(null===a||null===a.child)mh(b)?b.flags|=4:null===a||a.memoizedState.isDehydrated&&0===(b.flags&256)||(b.flags|=1024,null!==fh&&(Zi(fh),fh=null));Ui(a,b);Q(b);return null;case 5:Ih(b);var e=Eh(Dh.current);\nc=b.type;if(null!==a&&null!=b.stateNode)Vi(a,b,c,d,e),a.ref!==b.ref&&(b.flags|=512,b.flags|=2097152);else{if(!d){if(null===b.stateNode)throw Error(p(166));Q(b);return null}a=Eh(Bh.current);if(mh(b)){d=b.stateNode;c=b.type;var f=b.memoizedProps;d[Nf]=b;d[Of]=f;a=0!==(b.mode&1);switch(c){case "dialog":D("cancel",d);D("close",d);break;case "iframe":case "object":case "embed":D("load",d);break;case "video":case "audio":for(e=0;e<kf.length;e++)D(kf[e],d);break;case "source":D("error",d);break;case "img":case "image":case "link":D("error",\nd);D("load",d);break;case "details":D("toggle",d);break;case "input":Ya(d,f);D("invalid",d);break;case "select":d._wrapperState={wasMultiple:!!f.multiple};D("invalid",d);break;case "textarea":gb(d,f),D("invalid",d)}tb(c,f);e=null;for(var g in f)if(f.hasOwnProperty(g)){var h=f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(!0!==f.suppressHydrationWarning&&zf(d.textContent,h,a),e=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(!0!==f.suppressHydrationWarning&&zf(d.textContent,\nh,a),e=["children",""+h]):ea.hasOwnProperty(g)&&null!=h&&"onScroll"===g&&D("scroll",d)}switch(c){case "input":Ua(d);cb(d,f,!0);break;case "textarea":Ua(d);ib(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=Af)}d=e;b.updateQueue=d;null!==d&&(b.flags|=4)}else{g=9===e.nodeType?e:e.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=jb(c));"http://www.w3.org/1999/xhtml"===a?"script"===c?(a=g.createElement("div"),a.innerHTML="<script>\\x3c/script>",a=a.removeChild(a.firstChild)):\n"string"===typeof d.is?a=g.createElement(c,{is:d.is}):(a=g.createElement(c),"select"===c&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,c);a[Nf]=b;a[Of]=d;Ti(a,b,!1,!1);b.stateNode=a;a:{g=ub(c,d);switch(c){case "dialog":D("cancel",a);D("close",a);e=d;break;case "iframe":case "object":case "embed":D("load",a);e=d;break;case "video":case "audio":for(e=0;e<kf.length;e++)D(kf[e],a);e=d;break;case "source":D("error",a);e=d;break;case "img":case "image":case "link":D("error",\na);D("load",a);e=d;break;case "details":D("toggle",a);e=d;break;case "input":Ya(a,d);e=Xa(a,d);D("invalid",a);break;case "option":e=d;break;case "select":a._wrapperState={wasMultiple:!!d.multiple};e=A({},d,{value:void 0});D("invalid",a);break;case "textarea":gb(a,d);e=fb(a,d);D("invalid",a);break;default:e=d}tb(c,e);h=e;for(f in h)if(h.hasOwnProperty(f)){var k=h[f];"style"===f?rb(a,k):"dangerouslySetInnerHTML"===f?(k=k?k.__html:void 0,null!=k&&mb(a,k)):"children"===f?"string"===typeof k?("textarea"!==\nc||""!==k)&&nb(a,k):"number"===typeof k&&nb(a,""+k):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(ea.hasOwnProperty(f)?null!=k&&"onScroll"===f&&D("scroll",a):null!=k&&sa(a,f,k,g))}switch(c){case "input":Ua(a);cb(a,d,!1);break;case "textarea":Ua(a);ib(a);break;case "option":null!=d.value&&a.setAttribute("value",""+Ra(d.value));break;case "select":a.multiple=!!d.multiple;f=d.value;null!=f?eb(a,!!d.multiple,f,!1):null!=d.defaultValue&&eb(a,!!d.multiple,d.defaultValue,\n!0);break;default:"function"===typeof e.onClick&&(a.onclick=Af)}switch(c){case "button":case "input":case "select":case "textarea":d=!!d.autoFocus;break a;case "img":d=!0;break a;default:d=!1}}d&&(b.flags|=4)}null!==b.ref&&(b.flags|=512,b.flags|=2097152)}Q(b);return null;case 6:if(a&&null!=b.stateNode)Wi(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(p(166));c=Eh(Dh.current);Eh(Bh.current);if(mh(b)){d=b.stateNode;c=b.memoizedProps;d[Nf]=b;if(f=d.nodeValue!==c)if(a=\ndh,null!==a)switch(a.tag){case 3:zf(d.nodeValue,c,0!==(a.mode&1));break;case 5:!0!==a.memoizedProps.suppressHydrationWarning&&zf(d.nodeValue,c,0!==(a.mode&1))}f&&(b.flags|=4)}else d=(9===c.nodeType?c:c.ownerDocument).createTextNode(d),d[Nf]=b,b.stateNode=d}Q(b);return null;case 13:E(K);d=b.memoizedState;if(I&&null!==eh&&0!==(b.mode&1)&&0===(b.flags&128)){for(d=eh;d;)d=Kf(d.nextSibling);nh();b.flags|=98560;return b}if(null!==d&&null!==d.dehydrated){d=mh(b);if(null===a){if(!d)throw Error(p(318));d=\nb.memoizedState;d=null!==d?d.dehydrated:null;if(!d)throw Error(p(317));d[Nf]=b}else nh(),0===(b.flags&128)&&(b.memoizedState=null),b.flags|=4;Q(b);return null}null!==fh&&(Zi(fh),fh=null);if(0!==(b.flags&128))return b.lanes=c,b;d=null!==d;c=!1;null===a?mh(b):c=null!==a.memoizedState;d!==c&&d&&(b.child.flags|=8192,0!==(b.mode&1)&&(null===a||0!==(K.current&1)?0===R&&(R=3):$i()));null!==b.updateQueue&&(b.flags|=4);Q(b);return null;case 4:return Gh(),Ui(a,b),null===a&&rf(b.stateNode.containerInfo),Q(b),\nnull;case 10:return qg(b.type._context),Q(b),null;case 17:return Yf(b.type)&&Zf(),Q(b),null;case 19:E(K);f=b.memoizedState;if(null===f)return Q(b),null;d=0!==(b.flags&128);g=f.rendering;if(null===g)if(d)Xi(f,!1);else{if(0!==R||null!==a&&0!==(a.flags&128))for(a=b.child;null!==a;){g=Jh(a);if(null!==g){b.flags|=128;Xi(f,!1);d=g.updateQueue;null!==d&&(b.updateQueue=d,b.flags|=4);b.subtreeFlags=0;d=c;for(c=b.child;null!==c;)f=c,a=d,f.flags&=14680066,g=f.alternate,null===g?(f.childLanes=0,f.lanes=a,f.child=\nnull,f.subtreeFlags=0,f.memoizedProps=null,f.memoizedState=null,f.updateQueue=null,f.dependencies=null,f.stateNode=null):(f.childLanes=g.childLanes,f.lanes=g.lanes,f.child=g.child,f.subtreeFlags=0,f.deletions=null,f.memoizedProps=g.memoizedProps,f.memoizedState=g.memoizedState,f.updateQueue=g.updateQueue,f.type=g.type,a=g.dependencies,f.dependencies=null===a?null:{lanes:a.lanes,firstContext:a.firstContext}),c=c.sibling;G(K,K.current&1|2);return b.child}a=a.sibling}null!==f.tail&&B()>aj&&(b.flags|=\n128,d=!0,Xi(f,!1),b.lanes=4194304)}else{if(!d)if(a=Jh(g),null!==a){if(b.flags|=128,d=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.flags|=4),Xi(f,!0),null===f.tail&&"hidden"===f.tailMode&&!g.alternate&&!I)return Q(b),null}else 2*B()-f.renderingStartTime>aj&&1073741824!==c&&(b.flags|=128,d=!0,Xi(f,!1),b.lanes=4194304);f.isBackwards?(g.sibling=b.child,b.child=g):(c=f.last,null!==c?c.sibling=g:b.child=g,f.last=g)}if(null!==f.tail)return b=f.tail,f.rendering=b,f.tail=b.sibling,f.renderingStartTime=\nB(),b.sibling=null,c=K.current,G(K,d?c&1|2:c&1),b;Q(b);return null;case 22:case 23:return bj(),d=null!==b.memoizedState,null!==a&&null!==a.memoizedState!==d&&(b.flags|=8192),d&&0!==(b.mode&1)?0!==(cj&1073741824)&&(Q(b),b.subtreeFlags&6&&(b.flags|=8192)):Q(b),null;case 24:return null;case 25:return null}throw Error(p(156,b.tag));}var dj=ta.ReactCurrentOwner,tg=!1;function ej(a,b,c,d){b.child=null===a?zh(b,null,c,d):yh(b,a.child,c,d)}\nfunction fj(a,b,c,d,e){c=c.render;var f=b.ref;sg(b,e);d=Uh(a,b,c,d,f,e);c=Zh();if(null!==a&&!tg)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,gj(a,b,e);I&&c&&bh(b);b.flags|=1;ej(a,b,d,e);return b.child}\nfunction hj(a,b,c,d,e){if(null===a){var f=c.type;if("function"===typeof f&&!ij(f)&&void 0===f.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=f,jj(a,b,f,d,e);a=vh(c.type,null,d,b,b.mode,e);a.ref=b.ref;a.return=b;return b.child=a}f=a.child;if(0===(a.lanes&e)){var g=f.memoizedProps;c=c.compare;c=null!==c?c:He;if(c(g,d)&&a.ref===b.ref)return gj(a,b,e)}b.flags|=1;a=th(f,d);a.ref=b.ref;a.return=b;return b.child=a}\nfunction jj(a,b,c,d,e){if(null!==a){var f=a.memoizedProps;if(He(f,d)&&a.ref===b.ref)if(tg=!1,b.pendingProps=d=f,0!==(a.lanes&e))0!==(a.flags&131072)&&(tg=!0);else return b.lanes=a.lanes,gj(a,b,e)}return kj(a,b,c,d,e)}\nfunction lj(a,b,c){var d=b.pendingProps,e=d.children,f=null!==a?a.memoizedState:null;if("hidden"===d.mode)if(0===(b.mode&1))b.memoizedState={baseLanes:0,cachePool:null,transitions:null},G(mj,cj),cj|=c;else if(0!==(c&1073741824))b.memoizedState={baseLanes:0,cachePool:null,transitions:null},d=null!==f?f.baseLanes:c,G(mj,cj),cj|=d;else return a=null!==f?f.baseLanes|c:c,b.lanes=b.childLanes=1073741824,b.memoizedState={baseLanes:a,cachePool:null,transitions:null},b.updateQueue=null,G(mj,cj),cj|=a,null;\nelse null!==f?(d=f.baseLanes|c,b.memoizedState=null):d=c,G(mj,cj),cj|=d;ej(a,b,e,c);return b.child}function nj(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.flags|=512,b.flags|=2097152}function kj(a,b,c,d,e){var f=Yf(c)?Wf:H.current;f=Xf(b,f);sg(b,e);c=Uh(a,b,c,d,f,e);d=Zh();if(null!==a&&!tg)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,gj(a,b,e);I&&d&&bh(b);b.flags|=1;ej(a,b,c,e);return b.child}\nfunction oj(a,b,c,d,e){if(Yf(c)){var f=!0;bg(b)}else f=!1;sg(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2),Og(b,c,d),Qg(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var k=g.context,l=c.contextType;"object"===typeof l&&null!==l?l=ug(l):(l=Yf(c)?Wf:H.current,l=Xf(b,l));var n=c.getDerivedStateFromProps,u="function"===typeof n||"function"===typeof g.getSnapshotBeforeUpdate;u||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&\n"function"!==typeof g.componentWillReceiveProps||(h!==d||k!==l)&&Pg(b,g,d,l);wg=!1;var q=b.memoizedState;g.state=q;Eg(b,d,g,e);k=b.memoizedState;h!==d||q!==k||Vf.current||wg?("function"===typeof n&&(Ig(b,c,n,d),k=b.memoizedState),(h=wg||Ng(b,c,h,d,q,k,l))?(u||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===\ntypeof g.componentDidMount&&(b.flags|=4194308)):("function"===typeof g.componentDidMount&&(b.flags|=4194308),b.memoizedProps=d,b.memoizedState=k),g.props=d,g.state=k,g.context=l,d=h):("function"===typeof g.componentDidMount&&(b.flags|=4194308),d=!1)}else{g=b.stateNode;yg(a,b);h=b.memoizedProps;l=b.type===b.elementType?h:kg(b.type,h);g.props=l;u=b.pendingProps;q=g.context;k=c.contextType;"object"===typeof k&&null!==k?k=ug(k):(k=Yf(c)?Wf:H.current,k=Xf(b,k));var y=c.getDerivedStateFromProps;(n="function"===\ntypeof y||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==u||q!==k)&&Pg(b,g,d,k);wg=!1;q=b.memoizedState;g.state=q;Eg(b,d,g,e);var m=b.memoizedState;h!==u||q!==m||Vf.current||wg?("function"===typeof y&&(Ig(b,c,y,d),m=b.memoizedState),(l=wg||Ng(b,c,l,d,q,m,k)||!1)?(n||"function"!==typeof g.UNSAFE_componentWillUpdate&&"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&\ng.componentWillUpdate(d,m,k),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,m,k)),"function"===typeof g.componentDidUpdate&&(b.flags|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.flags|=1024)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&q===a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&q===a.memoizedState||(b.flags|=1024),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=\nk,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&q===a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&q===a.memoizedState||(b.flags|=1024),d=!1)}return pj(a,b,c,d,f,e)}\nfunction pj(a,b,c,d,e,f){nj(a,b);var g=0!==(b.flags&128);if(!d&&!g)return e&&cg(b,c,!1),gj(a,b,f);d=b.stateNode;dj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?null:d.render();b.flags|=1;null!==a&&g?(b.child=yh(b,a.child,null,f),b.child=yh(b,null,h,f)):ej(a,b,h,f);b.memoizedState=d.state;e&&cg(b,c,!0);return b.child}function qj(a){var b=a.stateNode;b.pendingContext?$f(a,b.pendingContext,b.pendingContext!==b.context):b.context&&$f(a,b.context,!1);Fh(a,b.containerInfo)}\nfunction rj(a,b,c,d,e){nh();oh(e);b.flags|=256;ej(a,b,c,d);return b.child}var sj={dehydrated:null,treeContext:null,retryLane:0};function tj(a){return{baseLanes:a,cachePool:null,transitions:null}}function uj(a,b){return{baseLanes:a.baseLanes|b,cachePool:null,transitions:a.transitions}}\nfunction vj(a,b,c){var d=b.pendingProps,e=K.current,f=!1,g=0!==(b.flags&128),h;(h=g)||(h=null!==a&&null===a.memoizedState?!1:0!==(e&2));if(h)f=!0,b.flags&=-129;else if(null===a||null!==a.memoizedState)e|=1;G(K,e&1);if(null===a){kh(b);a=b.memoizedState;if(null!==a&&(a=a.dehydrated,null!==a))return 0===(b.mode&1)?b.lanes=1:"$!"===a.data?b.lanes=8:b.lanes=1073741824,null;e=d.children;a=d.fallback;return f?(d=b.mode,f=b.child,e={mode:"hidden",children:e},0===(d&1)&&null!==f?(f.childLanes=0,f.pendingProps=\ne):f=wj(e,d,0,null),a=xh(a,d,c,null),f.return=b,a.return=b,f.sibling=a,b.child=f,b.child.memoizedState=tj(c),b.memoizedState=sj,a):xj(b,e)}e=a.memoizedState;if(null!==e){h=e.dehydrated;if(null!==h){if(g){if(b.flags&256)return b.flags&=-257,yj(a,b,c,Error(p(422)));if(null!==b.memoizedState)return b.child=a.child,b.flags|=128,null;f=d.fallback;e=b.mode;d=wj({mode:"visible",children:d.children},e,0,null);f=xh(f,e,c,null);f.flags|=2;d.return=b;f.return=b;d.sibling=f;b.child=d;0!==(b.mode&1)&&yh(b,a.child,\nnull,c);b.child.memoizedState=tj(c);b.memoizedState=sj;return f}if(0===(b.mode&1))b=yj(a,b,c,null);else if("$!"===h.data)b=yj(a,b,c,Error(p(419)));else if(d=0!==(c&a.childLanes),tg||d){d=P;if(null!==d){switch(c&-c){case 4:f=2;break;case 16:f=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:f=32;break;case 536870912:f=\n268435456;break;default:f=0}d=0!==(f&(d.suspendedLanes|c))?0:f;0!==d&&d!==e.retryLane&&(e.retryLane=d,Lg(a,d,-1))}$i();b=yj(a,b,c,Error(p(421)))}else"$?"===h.data?(b.flags|=128,b.child=a.child,b=zj.bind(null,a),h._reactRetry=b,b=null):(c=e.treeContext,eh=Kf(h.nextSibling),dh=b,I=!0,fh=null,null!==c&&(Vg[Wg++]=Yg,Vg[Wg++]=Zg,Vg[Wg++]=Xg,Yg=c.id,Zg=c.overflow,Xg=b),b=xj(b,b.pendingProps.children),b.flags|=4096);return b}if(f)return d=Aj(a,b,d.children,d.fallback,c),f=b.child,e=a.child.memoizedState,\nf.memoizedState=null===e?tj(c):uj(e,c),f.childLanes=a.childLanes&~c,b.memoizedState=sj,d;c=Bj(a,b,d.children,c);b.memoizedState=null;return c}if(f)return d=Aj(a,b,d.children,d.fallback,c),f=b.child,e=a.child.memoizedState,f.memoizedState=null===e?tj(c):uj(e,c),f.childLanes=a.childLanes&~c,b.memoizedState=sj,d;c=Bj(a,b,d.children,c);b.memoizedState=null;return c}function xj(a,b){b=wj({mode:"visible",children:b},a.mode,0,null);b.return=a;return a.child=b}\nfunction Bj(a,b,c,d){var e=a.child;a=e.sibling;c=th(e,{mode:"visible",children:c});0===(b.mode&1)&&(c.lanes=d);c.return=b;c.sibling=null;null!==a&&(d=b.deletions,null===d?(b.deletions=[a],b.flags|=16):d.push(a));return b.child=c}\nfunction Aj(a,b,c,d,e){var f=b.mode;a=a.child;var g=a.sibling,h={mode:"hidden",children:c};0===(f&1)&&b.child!==a?(c=b.child,c.childLanes=0,c.pendingProps=h,b.deletions=null):(c=th(a,h),c.subtreeFlags=a.subtreeFlags&14680064);null!==g?d=th(g,d):(d=xh(d,f,e,null),d.flags|=2);d.return=b;c.return=b;c.sibling=d;b.child=c;return d}function yj(a,b,c,d){null!==d&&oh(d);yh(b,a.child,null,c);a=xj(b,b.pendingProps.children);a.flags|=2;b.memoizedState=null;return a}\nfunction Cj(a,b,c){a.lanes|=b;var d=a.alternate;null!==d&&(d.lanes|=b);rg(a.return,b,c)}function Dj(a,b,c,d,e){var f=a.memoizedState;null===f?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailMode:e}:(f.isBackwards=b,f.rendering=null,f.renderingStartTime=0,f.last=d,f.tail=c,f.tailMode=e)}\nfunction Ej(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;ej(a,b,d.children,c);d=K.current;if(0!==(d&2))d=d&1|2,b.flags|=128;else{if(null!==a&&0!==(a.flags&128))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&Cj(a,c,b);else if(19===a.tag)Cj(a,c,b);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}G(K,d);if(0===(b.mode&1))b.memoizedState=\nnull;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Jh(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Dj(b,!1,e,c,f);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Jh(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Dj(b,!0,c,null,f);break;case "together":Dj(b,!1,null,null,void 0);break;default:b.memoizedState=null}return b.child}\nfunction gj(a,b,c){null!==a&&(b.dependencies=a.dependencies);Fg|=b.lanes;if(0===(c&b.childLanes))return null;if(null!==a&&b.child!==a.child)throw Error(p(153));if(null!==b.child){a=b.child;c=th(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=th(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}\nfunction Fj(a,b,c){switch(b.tag){case 3:qj(b);nh();break;case 5:Hh(b);break;case 1:Yf(b.type)&&bg(b);break;case 4:Fh(b,b.stateNode.containerInfo);break;case 10:var d=b.type._context,e=b.memoizedProps.value;G(lg,d._currentValue);d._currentValue=e;break;case 13:d=b.memoizedState;if(null!==d){if(null!==d.dehydrated)return G(K,K.current&1),b.flags|=128,null;if(0!==(c&b.child.childLanes))return vj(a,b,c);G(K,K.current&1);a=gj(a,b,c);return null!==a?a.sibling:null}G(K,K.current&1);break;case 19:d=0!==(c&\nb.childLanes);if(0!==(a.flags&128)){if(d)return Ej(a,b,c);b.flags|=128}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null,e.lastEffect=null);G(K,K.current);if(d)break;else return null;case 22:case 23:return b.lanes=0,lj(a,b,c)}return gj(a,b,c)}\nfunction Gj(a,b){ch(b);switch(b.tag){case 1:return Yf(b.type)&&Zf(),a=b.flags,a&65536?(b.flags=a&-65537|128,b):null;case 3:return Gh(),E(Vf),E(H),Lh(),a=b.flags,0!==(a&65536)&&0===(a&128)?(b.flags=a&-65537|128,b):null;case 5:return Ih(b),null;case 13:E(K);a=b.memoizedState;if(null!==a&&null!==a.dehydrated){if(null===b.alternate)throw Error(p(340));nh()}a=b.flags;return a&65536?(b.flags=a&-65537|128,b):null;case 19:return E(K),null;case 4:return Gh(),null;case 10:return qg(b.type._context),null;case 22:case 23:return bj(),\nnull;case 24:return null;default:return null}}var Hj=!1,S=!1,Ij="function"===typeof WeakSet?WeakSet:Set,T=null;function Jj(a,b){var c=a.ref;if(null!==c)if("function"===typeof c)try{c(null)}catch(d){U(a,b,d)}else c.current=null}function Kj(a,b,c){try{c()}catch(d){U(a,b,d)}}var Lj=!1;\nfunction Mj(a,b){Bf=cd;a=Le();if(Me(a)){if("selectionStart"in a)var c={start:a.selectionStart,end:a.selectionEnd};else a:{c=(c=a.ownerDocument)&&c.defaultView||window;var d=c.getSelection&&c.getSelection();if(d&&0!==d.rangeCount){c=d.anchorNode;var e=d.anchorOffset,f=d.focusNode;d=d.focusOffset;try{c.nodeType,f.nodeType}catch(Z){c=null;break a}var g=0,h=-1,k=-1,l=0,n=0,u=a,q=null;b:for(;;){for(var y;;){u!==c||0!==e&&3!==u.nodeType||(h=g+e);u!==f||0!==d&&3!==u.nodeType||(k=g+d);3===u.nodeType&&(g+=\nu.nodeValue.length);if(null===(y=u.firstChild))break;q=u;u=y}for(;;){if(u===a)break b;q===c&&++l===e&&(h=g);q===f&&++n===d&&(k=g);if(null!==(y=u.nextSibling))break;u=q;q=u.parentNode}u=y}c=-1===h||-1===k?null:{start:h,end:k}}else c=null}c=c||{start:0,end:0}}else c=null;Cf={focusedElem:a,selectionRange:c};cd=!1;for(T=b;null!==T;)if(b=T,a=b.child,0!==(b.subtreeFlags&1028)&&null!==a)a.return=b,T=a;else for(;null!==T;){b=T;try{var m=b.alternate;if(0!==(b.flags&1024))switch(b.tag){case 0:case 11:case 15:break;\ncase 1:if(null!==m){var w=m.memoizedProps,J=m.memoizedState,v=b.stateNode,x=v.getSnapshotBeforeUpdate(b.elementType===b.type?w:kg(b.type,w),J);v.__reactInternalSnapshotBeforeUpdate=x}break;case 3:var r=b.stateNode.containerInfo;if(1===r.nodeType)r.textContent="";else if(9===r.nodeType){var F=r.body;null!=F&&(F.textContent="")}break;case 5:case 6:case 4:case 17:break;default:throw Error(p(163));}}catch(Z){U(b,b.return,Z)}a=b.sibling;if(null!==a){a.return=b.return;T=a;break}T=b.return}m=Lj;Lj=!1;return m}\nfunction Nj(a,b,c){var d=b.updateQueue;d=null!==d?d.lastEffect:null;if(null!==d){var e=d=d.next;do{if((e.tag&a)===a){var f=e.destroy;e.destroy=void 0;void 0!==f&&Kj(b,c,f)}e=e.next}while(e!==d)}}function Oj(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function Pj(a){var b=a.ref;if(null!==b){var c=a.stateNode;switch(a.tag){case 5:a=c;break;default:a=c}"function"===typeof b?b(a):b.current=a}}\nfunction Qj(a){var b=a.alternate;null!==b&&(a.alternate=null,Qj(b));a.child=null;a.deletions=null;a.sibling=null;5===a.tag&&(b=a.stateNode,null!==b&&(delete b[Nf],delete b[Of],delete b[nf],delete b[Pf],delete b[Qf]));a.stateNode=null;a.return=null;a.dependencies=null;a.memoizedProps=null;a.memoizedState=null;a.pendingProps=null;a.stateNode=null;a.updateQueue=null}function Rj(a){return 5===a.tag||3===a.tag||4===a.tag}\nfunction Sj(a){a:for(;;){for(;null===a.sibling;){if(null===a.return||Rj(a.return))return null;a=a.return}a.sibling.return=a.return;for(a=a.sibling;5!==a.tag&&6!==a.tag&&18!==a.tag;){if(a.flags&2)continue a;if(null===a.child||4===a.tag)continue a;else a.child.return=a,a=a.child}if(!(a.flags&2))return a.stateNode}}\nfunction Tj(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=Af));else if(4!==d&&(a=a.child,null!==a))for(Tj(a,b,c),a=a.sibling;null!==a;)Tj(a,b,c),a=a.sibling}\nfunction Uj(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Uj(a,b,c),a=a.sibling;null!==a;)Uj(a,b,c),a=a.sibling}var V=null,Vj=!1;function Wj(a,b,c){for(c=c.child;null!==c;)Xj(a,b,c),c=c.sibling}\nfunction Xj(a,b,c){if(kc&&"function"===typeof kc.onCommitFiberUnmount)try{kc.onCommitFiberUnmount(jc,c)}catch(h){}switch(c.tag){case 5:S||Jj(c,b);case 6:var d=V,e=Vj;V=null;Wj(a,b,c);V=d;Vj=e;null!==V&&(Vj?(a=V,c=c.stateNode,8===a.nodeType?a.parentNode.removeChild(c):a.removeChild(c)):V.removeChild(c.stateNode));break;case 18:null!==V&&(Vj?(a=V,c=c.stateNode,8===a.nodeType?Jf(a.parentNode,c):1===a.nodeType&&Jf(a,c),ad(a)):Jf(V,c.stateNode));break;case 4:d=V;e=Vj;V=c.stateNode.containerInfo;Vj=!0;\nWj(a,b,c);V=d;Vj=e;break;case 0:case 11:case 14:case 15:if(!S&&(d=c.updateQueue,null!==d&&(d=d.lastEffect,null!==d))){e=d=d.next;do{var f=e,g=f.destroy;f=f.tag;void 0!==g&&(0!==(f&2)?Kj(c,b,g):0!==(f&4)&&Kj(c,b,g));e=e.next}while(e!==d)}Wj(a,b,c);break;case 1:if(!S&&(Jj(c,b),d=c.stateNode,"function"===typeof d.componentWillUnmount))try{d.props=c.memoizedProps,d.state=c.memoizedState,d.componentWillUnmount()}catch(h){U(c,b,h)}Wj(a,b,c);break;case 21:Wj(a,b,c);break;case 22:c.mode&1?(S=(d=S)||null!==\nc.memoizedState,Wj(a,b,c),S=d):Wj(a,b,c);break;default:Wj(a,b,c)}}function Yj(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Ij);b.forEach(function(b){var d=Zj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}\nfunction ak(a,b){var c=b.deletions;if(null!==c)for(var d=0;d<c.length;d++){var e=c[d];try{var f=a,g=b,h=g;a:for(;null!==h;){switch(h.tag){case 5:V=h.stateNode;Vj=!1;break a;case 3:V=h.stateNode.containerInfo;Vj=!0;break a;case 4:V=h.stateNode.containerInfo;Vj=!0;break a}h=h.return}if(null===V)throw Error(p(160));Xj(f,g,e);V=null;Vj=!1;var k=e.alternate;null!==k&&(k.return=null);e.return=null}catch(l){U(e,b,l)}}if(b.subtreeFlags&12854)for(b=b.child;null!==b;)bk(b,a),b=b.sibling}\nfunction bk(a,b){var c=a.alternate,d=a.flags;switch(a.tag){case 0:case 11:case 14:case 15:ak(b,a);ck(a);if(d&4){try{Nj(3,a,a.return),Oj(3,a)}catch(m){U(a,a.return,m)}try{Nj(5,a,a.return)}catch(m){U(a,a.return,m)}}break;case 1:ak(b,a);ck(a);d&512&&null!==c&&Jj(c,c.return);break;case 5:ak(b,a);ck(a);d&512&&null!==c&&Jj(c,c.return);if(a.flags&32){var e=a.stateNode;try{nb(e,"")}catch(m){U(a,a.return,m)}}if(d&4&&(e=a.stateNode,null!=e)){var f=a.memoizedProps,g=null!==c?c.memoizedProps:f,h=a.type,k=a.updateQueue;\na.updateQueue=null;if(null!==k)try{"input"===h&&"radio"===f.type&&null!=f.name&&Za(e,f);ub(h,g);var l=ub(h,f);for(g=0;g<k.length;g+=2){var n=k[g],u=k[g+1];"style"===n?rb(e,u):"dangerouslySetInnerHTML"===n?mb(e,u):"children"===n?nb(e,u):sa(e,n,u,l)}switch(h){case "input":$a(e,f);break;case "textarea":hb(e,f);break;case "select":var q=e._wrapperState.wasMultiple;e._wrapperState.wasMultiple=!!f.multiple;var y=f.value;null!=y?eb(e,!!f.multiple,y,!1):q!==!!f.multiple&&(null!=f.defaultValue?eb(e,!!f.multiple,\nf.defaultValue,!0):eb(e,!!f.multiple,f.multiple?[]:"",!1))}e[Of]=f}catch(m){U(a,a.return,m)}}break;case 6:ak(b,a);ck(a);if(d&4){if(null===a.stateNode)throw Error(p(162));l=a.stateNode;n=a.memoizedProps;try{l.nodeValue=n}catch(m){U(a,a.return,m)}}break;case 3:ak(b,a);ck(a);if(d&4&&null!==c&&c.memoizedState.isDehydrated)try{ad(b.containerInfo)}catch(m){U(a,a.return,m)}break;case 4:ak(b,a);ck(a);break;case 13:ak(b,a);ck(a);l=a.child;l.flags&8192&&null!==l.memoizedState&&(null===l.alternate||null===l.alternate.memoizedState)&&\n(dk=B());d&4&&Yj(a);break;case 22:l=null!==c&&null!==c.memoizedState;a.mode&1?(S=(n=S)||l,ak(b,a),S=n):ak(b,a);ck(a);if(d&8192){n=null!==a.memoizedState;a:for(u=null,q=a;;){if(5===q.tag){if(null===u){u=q;try{e=q.stateNode,n?(f=e.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(h=q.stateNode,k=q.memoizedProps.style,g=void 0!==k&&null!==k&&k.hasOwnProperty("display")?k.display:null,h.style.display=qb("display",g))}catch(m){U(a,a.return,m)}}}else if(6===\nq.tag){if(null===u)try{q.stateNode.nodeValue=n?"":q.memoizedProps}catch(m){U(a,a.return,m)}}else if((22!==q.tag&&23!==q.tag||null===q.memoizedState||q===a)&&null!==q.child){q.child.return=q;q=q.child;continue}if(q===a)break a;for(;null===q.sibling;){if(null===q.return||q.return===a)break a;u===q&&(u=null);q=q.return}u===q&&(u=null);q.sibling.return=q.return;q=q.sibling}if(n&&!l&&0!==(a.mode&1))for(T=a,a=a.child;null!==a;){for(l=T=a;null!==T;){n=T;u=n.child;switch(n.tag){case 0:case 11:case 14:case 15:Nj(4,\nn,n.return);break;case 1:Jj(n,n.return);f=n.stateNode;if("function"===typeof f.componentWillUnmount){q=n;y=n.return;try{e=q,f.props=e.memoizedProps,f.state=e.memoizedState,f.componentWillUnmount()}catch(m){U(q,y,m)}}break;case 5:Jj(n,n.return);break;case 22:if(null!==n.memoizedState){ek(l);continue}}null!==u?(u.return=n,T=u):ek(l)}a=a.sibling}}break;case 19:ak(b,a);ck(a);d&4&&Yj(a);break;case 21:break;default:ak(b,a),ck(a)}}\nfunction ck(a){var b=a.flags;if(b&2){try{a:{for(var c=a.return;null!==c;){if(Rj(c)){var d=c;break a}c=c.return}throw Error(p(160));}switch(d.tag){case 5:var e=d.stateNode;d.flags&32&&(nb(e,""),d.flags&=-33);var f=Sj(a);Uj(a,f,e);break;case 3:case 4:var g=d.stateNode.containerInfo,h=Sj(a);Tj(a,h,g);break;default:throw Error(p(161));}}catch(k){U(a,a.return,k)}a.flags&=-3}b&4096&&(a.flags&=-4097)}function fk(a,b,c){T=a;gk(a,b,c)}\nfunction gk(a,b,c){for(var d=0!==(a.mode&1);null!==T;){var e=T,f=e.child;if(22===e.tag&&d){var g=null!==e.memoizedState||Hj;if(!g){var h=e.alternate,k=null!==h&&null!==h.memoizedState||S;h=Hj;var l=S;Hj=g;if((S=k)&&!l)for(T=e;null!==T;)g=T,k=g.child,22===g.tag&&null!==g.memoizedState?hk(e):null!==k?(k.return=g,T=k):hk(e);for(;null!==f;)T=f,gk(f,b,c),f=f.sibling;T=e;Hj=h;S=l}ik(a,b,c)}else 0!==(e.subtreeFlags&8772)&&null!==f?(f.return=e,T=f):ik(a,b,c)}}\nfunction ik(a){for(;null!==T;){var b=T;if(0!==(b.flags&8772)){var c=b.alternate;try{if(0!==(b.flags&8772))switch(b.tag){case 0:case 11:case 15:S||Oj(5,b);break;case 1:var d=b.stateNode;if(b.flags&4&&!S)if(null===c)d.componentDidMount();else{var e=b.elementType===b.type?c.memoizedProps:kg(b.type,c.memoizedProps);d.componentDidUpdate(e,c.memoizedState,d.__reactInternalSnapshotBeforeUpdate)}var f=b.updateQueue;null!==f&&Gg(b,f,d);break;case 3:var g=b.updateQueue;if(null!==g){c=null;if(null!==b.child)switch(b.child.tag){case 5:c=\nb.child.stateNode;break;case 1:c=b.child.stateNode}Gg(b,g,c)}break;case 5:var h=b.stateNode;if(null===c&&b.flags&4){c=h;var k=b.memoizedProps;switch(b.type){case "button":case "input":case "select":case "textarea":k.autoFocus&&c.focus();break;case "img":k.src&&(c.src=k.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(null===b.memoizedState){var l=b.alternate;if(null!==l){var n=l.memoizedState;if(null!==n){var u=n.dehydrated;null!==u&&ad(u)}}}break;case 19:case 17:case 21:case 22:case 23:break;\ndefault:throw Error(p(163));}S||b.flags&512&&Pj(b)}catch(q){U(b,b.return,q)}}if(b===a){T=null;break}c=b.sibling;if(null!==c){c.return=b.return;T=c;break}T=b.return}}function ek(a){for(;null!==T;){var b=T;if(b===a){T=null;break}var c=b.sibling;if(null!==c){c.return=b.return;T=c;break}T=b.return}}\nfunction hk(a){for(;null!==T;){var b=T;try{switch(b.tag){case 0:case 11:case 15:var c=b.return;try{Oj(4,b)}catch(k){U(b,c,k)}break;case 1:var d=b.stateNode;if("function"===typeof d.componentDidMount){var e=b.return;try{d.componentDidMount()}catch(k){U(b,e,k)}}var f=b.return;try{Pj(b)}catch(k){U(b,f,k)}break;case 5:var g=b.return;try{Pj(b)}catch(k){U(b,g,k)}}}catch(k){U(b,b.return,k)}if(b===a){T=null;break}var h=b.sibling;if(null!==h){h.return=b.return;T=h;break}T=b.return}}\nvar jk=Math.ceil,kk=ta.ReactCurrentDispatcher,lk=ta.ReactCurrentOwner,mk=ta.ReactCurrentBatchConfig,W=0,P=null,X=null,Y=0,cj=0,mj=Tf(0),R=0,nk=null,Fg=0,ok=0,pk=0,qk=null,rk=null,dk=0,aj=Infinity,sk=null,Li=!1,Mi=null,Oi=null,tk=!1,uk=null,vk=0,wk=0,xk=null,yk=-1,zk=0;function Jg(){return 0!==(W&6)?B():-1!==yk?yk:yk=B()}\nfunction Kg(a){if(0===(a.mode&1))return 1;if(0!==(W&2)&&0!==Y)return Y&-Y;if(null!==jg.transition)return 0===zk&&(zk=xc()),zk;a=C;if(0!==a)return a;a=window.event;a=void 0===a?16:id(a.type);return a}function Lg(a,b,c){if(50<wk)throw wk=0,xk=null,Error(p(185));var d=Ak(a,b);if(null===d)return null;zc(d,b,c);if(0===(W&2)||d!==P)d===P&&(0===(W&2)&&(ok|=b),4===R&&Bk(d,Y)),Ck(d,c),1===b&&0===W&&0===(a.mode&1)&&(aj=B()+500,eg&&ig());return d}\nfunction Ak(a,b){a.lanes|=b;var c=a.alternate;null!==c&&(c.lanes|=b);c=a;for(a=a.return;null!==a;)a.childLanes|=b,c=a.alternate,null!==c&&(c.childLanes|=b),c=a,a=a.return;return 3===c.tag?c.stateNode:null}function Bg(a){return(null!==P||null!==vg)&&0!==(a.mode&1)&&0===(W&2)}\nfunction Ck(a,b){var c=a.callbackNode;vc(a,b);var d=tc(a,a===P?Y:0);if(0===d)null!==c&&ac(c),a.callbackNode=null,a.callbackPriority=0;else if(b=d&-d,a.callbackPriority!==b){null!=c&&ac(c);if(1===b)0===a.tag?hg(Dk.bind(null,a)):gg(Dk.bind(null,a)),If(function(){0===W&&ig()}),c=null;else{switch(Cc(d)){case 1:c=ec;break;case 4:c=fc;break;case 16:c=gc;break;case 536870912:c=ic;break;default:c=gc}c=Ek(c,Fk.bind(null,a))}a.callbackPriority=b;a.callbackNode=c}}\nfunction Fk(a,b){yk=-1;zk=0;if(0!==(W&6))throw Error(p(327));var c=a.callbackNode;if(Gk()&&a.callbackNode!==c)return null;var d=tc(a,a===P?Y:0);if(0===d)return null;if(0!==(d&30)||0!==(d&a.expiredLanes)||b)b=Hk(a,d);else{b=d;var e=W;W|=2;var f=Ik();if(P!==a||Y!==b)sk=null,aj=B()+500,Jk(a,b);do try{Kk();break}catch(h){Lk(a,h)}while(1);pg();kk.current=f;W=e;null!==X?b=0:(P=null,Y=0,b=R)}if(0!==b){2===b&&(e=wc(a),0!==e&&(d=e,b=Mk(a,e)));if(1===b)throw c=nk,Jk(a,0),Bk(a,d),Ck(a,B()),c;if(6===b)Bk(a,d);\nelse{e=a.current.alternate;if(0===(d&30)&&!Nk(e)&&(b=Hk(a,d),2===b&&(f=wc(a),0!==f&&(d=f,b=Mk(a,f))),1===b))throw c=nk,Jk(a,0),Bk(a,d),Ck(a,B()),c;a.finishedWork=e;a.finishedLanes=d;switch(b){case 0:case 1:throw Error(p(345));case 2:Ok(a,rk,sk);break;case 3:Bk(a,d);if((d&130023424)===d&&(b=dk+500-B(),10<b)){if(0!==tc(a,0))break;e=a.suspendedLanes;if((e&d)!==d){Jg();a.pingedLanes|=a.suspendedLanes&e;break}a.timeoutHandle=Ef(Ok.bind(null,a,rk,sk),b);break}Ok(a,rk,sk);break;case 4:Bk(a,d);if((d&4194240)===\nd)break;b=a.eventTimes;for(e=-1;0<d;){var g=31-nc(d);f=1<<g;g=b[g];g>e&&(e=g);d&=~f}d=e;d=B()-d;d=(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*jk(d/1960))-d;if(10<d){a.timeoutHandle=Ef(Ok.bind(null,a,rk,sk),d);break}Ok(a,rk,sk);break;case 5:Ok(a,rk,sk);break;default:throw Error(p(329));}}}Ck(a,B());return a.callbackNode===c?Fk.bind(null,a):null}\nfunction Mk(a,b){var c=qk;a.current.memoizedState.isDehydrated&&(Jk(a,b).flags|=256);a=Hk(a,b);2!==a&&(b=rk,rk=c,null!==b&&Zi(b));return a}function Zi(a){null===rk?rk=a:rk.push.apply(rk,a)}\nfunction Nk(a){for(var b=a;;){if(b.flags&16384){var c=b.updateQueue;if(null!==c&&(c=c.stores,null!==c))for(var d=0;d<c.length;d++){var e=c[d],f=e.getSnapshot;e=e.value;try{if(!Ge(f(),e))return!1}catch(g){return!1}}}c=b.child;if(b.subtreeFlags&16384&&null!==c)c.return=b,b=c;else{if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return!0;b=b.return}b.sibling.return=b.return;b=b.sibling}}return!0}\nfunction Bk(a,b){b&=~pk;b&=~ok;a.suspendedLanes|=b;a.pingedLanes&=~b;for(a=a.expirationTimes;0<b;){var c=31-nc(b),d=1<<c;a[c]=-1;b&=~d}}function Dk(a){if(0!==(W&6))throw Error(p(327));Gk();var b=tc(a,0);if(0===(b&1))return Ck(a,B()),null;var c=Hk(a,b);if(0!==a.tag&&2===c){var d=wc(a);0!==d&&(b=d,c=Mk(a,d))}if(1===c)throw c=nk,Jk(a,0),Bk(a,b),Ck(a,B()),c;if(6===c)throw Error(p(345));a.finishedWork=a.current.alternate;a.finishedLanes=b;Ok(a,rk,sk);Ck(a,B());return null}\nfunction Pk(a,b){var c=W;W|=1;try{return a(b)}finally{W=c,0===W&&(aj=B()+500,eg&&ig())}}function Qk(a){null!==uk&&0===uk.tag&&0===(W&6)&&Gk();var b=W;W|=1;var c=mk.transition,d=C;try{if(mk.transition=null,C=1,a)return a()}finally{C=d,mk.transition=c,W=b,0===(W&6)&&ig()}}function bj(){cj=mj.current;E(mj)}\nfunction Jk(a,b){a.finishedWork=null;a.finishedLanes=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,Ff(c));if(null!==X)for(c=X.return;null!==c;){var d=c;ch(d);switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&Zf();break;case 3:Gh();E(Vf);E(H);Lh();break;case 5:Ih(d);break;case 4:Gh();break;case 13:E(K);break;case 19:E(K);break;case 10:qg(d.type._context);break;case 22:case 23:bj()}c=c.return}P=a;X=a=th(a.current,null);Y=cj=b;R=0;nk=null;pk=ok=Fg=0;rk=qk=null;if(null!==vg){for(b=\n0;b<vg.length;b++)if(c=vg[b],d=c.interleaved,null!==d){c.interleaved=null;var e=d.next,f=c.pending;if(null!==f){var g=f.next;f.next=e;d.next=g}c.pending=d}vg=null}return a}\nfunction Lk(a,b){do{var c=X;try{pg();Mh.current=Yh;if(Ph){for(var d=L.memoizedState;null!==d;){var e=d.queue;null!==e&&(e.pending=null);d=d.next}Ph=!1}Oh=0;N=M=L=null;Qh=!1;Rh=0;lk.current=null;if(null===c||null===c.return){R=1;nk=b;X=null;break}a:{var f=a,g=c.return,h=c,k=b;b=Y;h.flags|=32768;if(null!==k&&"object"===typeof k&&"function"===typeof k.then){var l=k,n=h,u=n.tag;if(0===(n.mode&1)&&(0===u||11===u||15===u)){var q=n.alternate;q?(n.updateQueue=q.updateQueue,n.memoizedState=q.memoizedState,\nn.lanes=q.lanes):(n.updateQueue=null,n.memoizedState=null)}var y=Ri(g);if(null!==y){y.flags&=-257;Si(y,g,h,f,b);y.mode&1&&Pi(f,l,b);b=y;k=l;var m=b.updateQueue;if(null===m){var w=new Set;w.add(k);b.updateQueue=w}else m.add(k);break a}else{if(0===(b&1)){Pi(f,l,b);$i();break a}k=Error(p(426))}}else if(I&&h.mode&1){var J=Ri(g);if(null!==J){0===(J.flags&65536)&&(J.flags|=256);Si(J,g,h,f,b);oh(k);break a}}f=k;4!==R&&(R=2);null===qk?qk=[f]:qk.push(f);k=Hi(k,h);h=g;do{switch(h.tag){case 3:h.flags|=65536;\nb&=-b;h.lanes|=b;var v=Ki(h,k,b);Dg(h,v);break a;case 1:f=k;var x=h.type,r=h.stateNode;if(0===(h.flags&128)&&("function"===typeof x.getDerivedStateFromError||null!==r&&"function"===typeof r.componentDidCatch&&(null===Oi||!Oi.has(r)))){h.flags|=65536;b&=-b;h.lanes|=b;var F=Ni(h,f,b);Dg(h,F);break a}}h=h.return}while(null!==h)}Rk(c)}catch(Z){b=Z;X===c&&null!==c&&(X=c=c.return);continue}break}while(1)}function Ik(){var a=kk.current;kk.current=Yh;return null===a?Yh:a}\nfunction $i(){if(0===R||3===R||2===R)R=4;null===P||0===(Fg&268435455)&&0===(ok&268435455)||Bk(P,Y)}function Hk(a,b){var c=W;W|=2;var d=Ik();if(P!==a||Y!==b)sk=null,Jk(a,b);do try{Sk();break}catch(e){Lk(a,e)}while(1);pg();W=c;kk.current=d;if(null!==X)throw Error(p(261));P=null;Y=0;return R}function Sk(){for(;null!==X;)Tk(X)}function Kk(){for(;null!==X&&!bc();)Tk(X)}function Tk(a){var b=Uk(a.alternate,a,cj);a.memoizedProps=a.pendingProps;null===b?Rk(a):X=b;lk.current=null}\nfunction Rk(a){var b=a;do{var c=b.alternate;a=b.return;if(0===(b.flags&32768)){if(c=Yi(c,b,cj),null!==c){X=c;return}}else{c=Gj(c,b);if(null!==c){c.flags&=32767;X=c;return}if(null!==a)a.flags|=32768,a.subtreeFlags=0,a.deletions=null;else{R=6;X=null;return}}b=b.sibling;if(null!==b){X=b;return}X=b=a}while(null!==b);0===R&&(R=5)}function Ok(a,b,c){var d=C,e=mk.transition;try{mk.transition=null,C=1,Vk(a,b,c,d)}finally{mk.transition=e,C=d}return null}\nfunction Vk(a,b,c,d){do Gk();while(null!==uk);if(0!==(W&6))throw Error(p(327));c=a.finishedWork;var e=a.finishedLanes;if(null===c)return null;a.finishedWork=null;a.finishedLanes=0;if(c===a.current)throw Error(p(177));a.callbackNode=null;a.callbackPriority=0;var f=c.lanes|c.childLanes;Ac(a,f);a===P&&(X=P=null,Y=0);0===(c.subtreeFlags&2064)&&0===(c.flags&2064)||tk||(tk=!0,Ek(gc,function(){Gk();return null}));f=0!==(c.flags&15990);if(0!==(c.subtreeFlags&15990)||f){f=mk.transition;mk.transition=null;\nvar g=C;C=1;var h=W;W|=4;lk.current=null;Mj(a,c);bk(c,a);Ne(Cf);cd=!!Bf;Cf=Bf=null;a.current=c;fk(c,a,e);cc();W=h;C=g;mk.transition=f}else a.current=c;tk&&(tk=!1,uk=a,vk=e);f=a.pendingLanes;0===f&&(Oi=null);lc(c.stateNode,d);Ck(a,B());if(null!==b)for(d=a.onRecoverableError,c=0;c<b.length;c++)d(b[c]);if(Li)throw Li=!1,a=Mi,Mi=null,a;0!==(vk&1)&&0!==a.tag&&Gk();f=a.pendingLanes;0!==(f&1)?a===xk?wk++:(wk=0,xk=a):wk=0;ig();return null}\nfunction Gk(){if(null!==uk){var a=Cc(vk),b=mk.transition,c=C;try{mk.transition=null;C=16>a?16:a;if(null===uk)var d=!1;else{a=uk;uk=null;vk=0;if(0!==(W&6))throw Error(p(331));var e=W;W|=4;for(T=a.current;null!==T;){var f=T,g=f.child;if(0!==(T.flags&16)){var h=f.deletions;if(null!==h){for(var k=0;k<h.length;k++){var l=h[k];for(T=l;null!==T;){var n=T;switch(n.tag){case 0:case 11:case 15:Nj(8,n,f)}var u=n.child;if(null!==u)u.return=n,T=u;else for(;null!==T;){n=T;var q=n.sibling,y=n.return;Qj(n);if(n===\nl){T=null;break}if(null!==q){q.return=y;T=q;break}T=y}}}var m=f.alternate;if(null!==m){var w=m.child;if(null!==w){m.child=null;do{var J=w.sibling;w.sibling=null;w=J}while(null!==w)}}T=f}}if(0!==(f.subtreeFlags&2064)&&null!==g)g.return=f,T=g;else b:for(;null!==T;){f=T;if(0!==(f.flags&2048))switch(f.tag){case 0:case 11:case 15:Nj(9,f,f.return)}var v=f.sibling;if(null!==v){v.return=f.return;T=v;break b}T=f.return}}var x=a.current;for(T=x;null!==T;){g=T;var r=g.child;if(0!==(g.subtreeFlags&2064)&&null!==\nr)r.return=g,T=r;else b:for(g=x;null!==T;){h=T;if(0!==(h.flags&2048))try{switch(h.tag){case 0:case 11:case 15:Oj(9,h)}}catch(Z){U(h,h.return,Z)}if(h===g){T=null;break b}var F=h.sibling;if(null!==F){F.return=h.return;T=F;break b}T=h.return}}W=e;ig();if(kc&&"function"===typeof kc.onPostCommitFiberRoot)try{kc.onPostCommitFiberRoot(jc,a)}catch(Z){}d=!0}return d}finally{C=c,mk.transition=b}}return!1}function Wk(a,b,c){b=Hi(c,b);b=Ki(a,b,1);Ag(a,b);b=Jg();a=Ak(a,1);null!==a&&(zc(a,1,b),Ck(a,b))}\nfunction U(a,b,c){if(3===a.tag)Wk(a,a,c);else for(;null!==b;){if(3===b.tag){Wk(b,a,c);break}else if(1===b.tag){var d=b.stateNode;if("function"===typeof b.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===Oi||!Oi.has(d))){a=Hi(c,a);a=Ni(b,a,1);Ag(b,a);a=Jg();b=Ak(b,1);null!==b&&(zc(b,1,a),Ck(b,a));break}}b=b.return}}\nfunction Qi(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);b=Jg();a.pingedLanes|=a.suspendedLanes&c;P===a&&(Y&c)===c&&(4===R||3===R&&(Y&130023424)===Y&&500>B()-dk?Jk(a,0):pk|=c);Ck(a,b)}function Xk(a,b){0===b&&(0===(a.mode&1)?b=1:(b=rc,rc<<=1,0===(rc&130023424)&&(rc=4194304)));var c=Jg();a=Ak(a,b);null!==a&&(zc(a,b,c),Ck(a,c))}function zj(a){var b=a.memoizedState,c=0;null!==b&&(c=b.retryLane);Xk(a,c)}\nfunction Zj(a,b){var c=0;switch(a.tag){case 13:var d=a.stateNode;var e=a.memoizedState;null!==e&&(c=e.retryLane);break;case 19:d=a.stateNode;break;default:throw Error(p(314));}null!==d&&d.delete(b);Xk(a,c)}var Uk;\nUk=function(a,b,c){if(null!==a)if(a.memoizedProps!==b.pendingProps||Vf.current)tg=!0;else{if(0===(a.lanes&c)&&0===(b.flags&128))return tg=!1,Fj(a,b,c);tg=0!==(a.flags&131072)?!0:!1}else tg=!1,I&&0!==(b.flags&1048576)&&ah(b,Ug,b.index);b.lanes=0;switch(b.tag){case 2:var d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2);a=b.pendingProps;var e=Xf(b,H.current);sg(b,c);e=Uh(null,b,d,a,e,c);var f=Zh();b.flags|=1;"object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof?\n(b.tag=1,b.memoizedState=null,b.updateQueue=null,Yf(d)?(f=!0,bg(b)):f=!1,b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null,xg(b),e.updater=Mg,b.stateNode=e,e._reactInternals=b,Qg(b,d,a,c),b=pj(null,b,d,!0,f,c)):(b.tag=0,I&&f&&bh(b),ej(null,b,e,c),b=b.child);return b;case 16:d=b.elementType;a:{null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2);a=b.pendingProps;e=d._init;d=e(d._payload);b.type=d;e=b.tag=Yk(d);a=kg(d,a);switch(e){case 0:b=kj(null,b,d,a,c);break a;case 1:b=oj(null,b,\nd,a,c);break a;case 11:b=fj(null,b,d,a,c);break a;case 14:b=hj(null,b,d,kg(d.type,a),c);break a}throw Error(p(306,d,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:kg(d,e),kj(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:kg(d,e),oj(a,b,d,e,c);case 3:a:{qj(b);if(null===a)throw Error(p(387));d=b.pendingProps;f=b.memoizedState;e=f.element;yg(a,b);Eg(b,d,null,c);var g=b.memoizedState;d=g.element;if(f.isDehydrated)if(f={element:d,isDehydrated:!1,\ncache:g.cache,pendingSuspenseBoundaries:g.pendingSuspenseBoundaries,transitions:g.transitions},b.updateQueue.baseState=f,b.memoizedState=f,b.flags&256){e=Error(p(423));b=rj(a,b,d,c,e);break a}else if(d!==e){e=Error(p(424));b=rj(a,b,d,c,e);break a}else for(eh=Kf(b.stateNode.containerInfo.firstChild),dh=b,I=!0,fh=null,c=zh(b,null,d,c),b.child=c;c;)c.flags=c.flags&-3|4096,c=c.sibling;else{nh();if(d===e){b=gj(a,b,c);break a}ej(a,b,d,c)}b=b.child}return b;case 5:return Hh(b),null===a&&kh(b),d=b.type,e=\nb.pendingProps,f=null!==a?a.memoizedProps:null,g=e.children,Df(d,e)?g=null:null!==f&&Df(d,f)&&(b.flags|=32),nj(a,b),ej(a,b,g,c),b.child;case 6:return null===a&&kh(b),null;case 13:return vj(a,b,c);case 4:return Fh(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=yh(b,null,d,c):ej(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:kg(d,e),fj(a,b,d,e,c);case 7:return ej(a,b,b.pendingProps,c),b.child;case 8:return ej(a,b,b.pendingProps.children,c),b.child;case 12:return ej(a,\nb,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;f=b.memoizedProps;g=e.value;G(lg,d._currentValue);d._currentValue=g;if(null!==f)if(Ge(f.value,g)){if(f.children===e.children&&!Vf.current){b=gj(a,b,c);break a}}else for(f=b.child,null!==f&&(f.return=b);null!==f;){var h=f.dependencies;if(null!==h){g=f.child;for(var k=h.firstContext;null!==k;){if(k.context===d){if(1===f.tag){k=zg(-1,c&-c);k.tag=2;var l=f.updateQueue;if(null!==l){l=l.shared;var n=l.pending;null===n?k.next=\nk:(k.next=n.next,n.next=k);l.pending=k}}f.lanes|=c;k=f.alternate;null!==k&&(k.lanes|=c);rg(f.return,c,b);h.lanes|=c;break}k=k.next}}else if(10===f.tag)g=f.type===b.type?null:f.child;else if(18===f.tag){g=f.return;if(null===g)throw Error(p(341));g.lanes|=c;h=g.alternate;null!==h&&(h.lanes|=c);rg(g,c,b);g=f.sibling}else g=f.child;if(null!==g)g.return=f;else for(g=f;null!==g;){if(g===b){g=null;break}f=g.sibling;if(null!==f){f.return=g.return;g=f;break}g=g.return}f=g}ej(a,b,e.children,c);b=b.child}return b;\ncase 9:return e=b.type,d=b.pendingProps.children,sg(b,c),e=ug(e),d=d(e),b.flags|=1,ej(a,b,d,c),b.child;case 14:return d=b.type,e=kg(d,b.pendingProps),e=kg(d.type,e),hj(a,b,d,e,c);case 15:return jj(a,b,b.type,b.pendingProps,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:kg(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2),b.tag=1,Yf(d)?(a=!0,bg(b)):a=!1,sg(b,c),Og(b,d,e),Qg(b,d,e,c),pj(null,b,d,!0,a,c);case 19:return Ej(a,b,c);case 22:return lj(a,b,c)}throw Error(p(156,\nb.tag));};function Ek(a,b){return $b(a,b)}function Zk(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.subtreeFlags=this.flags=0;this.deletions=null;this.childLanes=this.lanes=0;this.alternate=null}function hh(a,b,c,d){return new Zk(a,b,c,d)}\nfunction ij(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Yk(a){if("function"===typeof a)return ij(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===Ca)return 11;if(a===Fa)return 14}return 2}\nfunction th(a,b){var c=a.alternate;null===c?(c=hh(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.type=a.type,c.flags=0,c.subtreeFlags=0,c.deletions=null);c.flags=a.flags&14680064;c.childLanes=a.childLanes;c.lanes=a.lanes;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{lanes:b.lanes,firstContext:b.firstContext};\nc.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}\nfunction vh(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)ij(a)&&(g=1);else if("string"===typeof a)g=5;else a:switch(a){case wa:return xh(c.children,e,f,b);case xa:g=8;e|=8;break;case za:return a=hh(12,c,b,e|2),a.elementType=za,a.lanes=f,a;case Da:return a=hh(13,c,b,e),a.elementType=Da,a.lanes=f,a;case Ea:return a=hh(19,c,b,e),a.elementType=Ea,a.lanes=f,a;case Ha:return wj(c,e,f,b);default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Aa:g=10;break a;case Ba:g=9;break a;case Ca:g=11;\nbreak a;case Fa:g=14;break a;case Ga:g=16;d=null;break a}throw Error(p(130,null==a?a:typeof a,""));}b=hh(g,c,b,e);b.elementType=a;b.type=d;b.lanes=f;return b}function xh(a,b,c,d){a=hh(7,a,d,b);a.lanes=c;return a}function wj(a,b,c,d){a=hh(22,a,d,b);a.elementType=Ha;a.lanes=c;a.stateNode={};return a}function uh(a,b,c){a=hh(6,a,null,b);a.lanes=c;return a}\nfunction wh(a,b,c){b=hh(4,null!==a.children?a.children:[],a.key,b);b.lanes=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}\nfunction $k(a,b,c,d,e){this.tag=b;this.containerInfo=a;this.finishedWork=this.pingCache=this.current=this.pendingChildren=null;this.timeoutHandle=-1;this.callbackNode=this.pendingContext=this.context=null;this.callbackPriority=0;this.eventTimes=yc(0);this.expirationTimes=yc(-1);this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0;this.entanglements=yc(0);this.identifierPrefix=d;this.onRecoverableError=e;this.mutableSourceEagerHydrationData=\nnull}function al(a,b,c,d,e,f,g,h,k){a=new $k(a,b,c,h,k);1===b?(b=1,!0===f&&(b|=8)):b=0;f=hh(3,null,null,b);a.current=f;f.stateNode=a;f.memoizedState={element:d,isDehydrated:c,cache:null,transitions:null,pendingSuspenseBoundaries:null};xg(f);return a}function bl(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:va,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}\nfunction cl(a){if(!a)return Uf;a=a._reactInternals;a:{if(Ub(a)!==a||1!==a.tag)throw Error(p(170));var b=a;do{switch(b.tag){case 3:b=b.stateNode.context;break a;case 1:if(Yf(b.type)){b=b.stateNode.__reactInternalMemoizedMergedChildContext;break a}}b=b.return}while(null!==b);throw Error(p(171));}if(1===a.tag){var c=a.type;if(Yf(c))return ag(a,c,b)}return b}\nfunction dl(a,b,c,d,e,f,g,h,k){a=al(c,d,!0,a,e,f,g,h,k);a.context=cl(null);c=a.current;d=Jg();e=Kg(c);f=zg(d,e);f.callback=void 0!==b&&null!==b?b:null;Ag(c,f);a.current.lanes=e;zc(a,e,d);Ck(a,d);return a}function el(a,b,c,d){var e=b.current,f=Jg(),g=Kg(e);c=cl(c);null===b.context?b.context=c:b.pendingContext=c;b=zg(f,g);b.payload={element:a};d=void 0===d?null:d;null!==d&&(b.callback=d);Ag(e,b);a=Lg(e,g,f);null!==a&&Cg(a,e,g);return g}\nfunction fl(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function gl(a,b){a=a.memoizedState;if(null!==a&&null!==a.dehydrated){var c=a.retryLane;a.retryLane=0!==c&&c<b?c:b}}function hl(a,b){gl(a,b);(a=a.alternate)&&gl(a,b)}function il(){return null}var jl="function"===typeof reportError?reportError:function(a){console.error(a)};function kl(a){this._internalRoot=a}\nll.prototype.render=kl.prototype.render=function(a){var b=this._internalRoot;if(null===b)throw Error(p(409));el(a,b,null,null)};ll.prototype.unmount=kl.prototype.unmount=function(){var a=this._internalRoot;if(null!==a){this._internalRoot=null;var b=a.containerInfo;Qk(function(){el(null,a,null,null)});b[tf]=null}};function ll(a){this._internalRoot=a}\nll.prototype.unstable_scheduleHydration=function(a){if(a){var b=Gc();a={blockedOn:null,target:a,priority:b};for(var c=0;c<Pc.length&&0!==b&&b<Pc[c].priority;c++);Pc.splice(c,0,a);0===c&&Uc(a)}};function ml(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType)}function nl(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function ol(){}\nfunction pl(a,b,c,d,e){if(e){if("function"===typeof d){var f=d;d=function(){var a=fl(g);f.call(a)}}var g=dl(b,d,a,0,null,!1,!1,"",ol);a._reactRootContainer=g;a[tf]=g.current;rf(8===a.nodeType?a.parentNode:a);Qk();return g}for(;e=a.lastChild;)a.removeChild(e);if("function"===typeof d){var h=d;d=function(){var a=fl(k);h.call(a)}}var k=al(a,0,!1,null,null,!1,!1,"",ol);a._reactRootContainer=k;a[tf]=k.current;rf(8===a.nodeType?a.parentNode:a);Qk(function(){el(b,k,c,d)});return k}\nfunction ql(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f;if("function"===typeof e){var h=e;e=function(){var a=fl(g);h.call(a)}}el(b,g,a,e)}else g=pl(c,b,a,e,d);return fl(g)}Dc=function(a){switch(a.tag){case 3:var b=a.stateNode;if(b.current.memoizedState.isDehydrated){var c=sc(b.pendingLanes);0!==c&&(Bc(b,c|1),Ck(b,B()),0===(W&6)&&(aj=B()+500,ig()))}break;case 13:var d=Jg();Qk(function(){return Lg(a,1,d)});hl(a,1)}};Ec=function(a){if(13===a.tag){var b=Jg();Lg(a,134217728,b);hl(a,134217728)}};\nFc=function(a){if(13===a.tag){var b=Jg(),c=Kg(a);Lg(a,c,b);hl(a,c)}};Gc=function(){return C};Hc=function(a,b){var c=C;try{return C=a,b()}finally{C=c}};\nxb=function(a,b,c){switch(b){case "input":$a(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+\'][type="radio"]\');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Cb(d);if(!e)throw Error(p(90));Va(d);$a(d,e)}}}break;case "textarea":hb(a,c);break;case "select":b=c.value,null!=b&&eb(a,!!c.multiple,b,!1)}};Fb=Pk;Gb=Qk;\nvar rl={usingClientEntryPoint:!1,Events:[Bb,te,Cb,Db,Eb,Pk]},sl={findFiberByHostInstance:Vc,bundleType:0,version:"18.1.0",rendererPackageName:"react-dom"};\nvar tl={bundleType:sl.bundleType,version:sl.version,rendererPackageName:sl.rendererPackageName,rendererConfig:sl.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ta.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Yb(a);return null===a?null:a.stateNode},findFiberByHostInstance:sl.findFiberByHostInstance||\nil,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.1.0-next-22edb9f77-20220426"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var ul=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!ul.isDisabled&&ul.supportsFiber)try{jc=ul.inject(tl),kc=ul}catch(a){}}exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=rl;\nexports.createPortal=function(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!ml(b))throw Error(p(200));return bl(a,b,null,c)};exports.createRoot=function(a,b){if(!ml(a))throw Error(p(299));var c=!1,d="",e=jl;null!==b&&void 0!==b&&(!0===b.unstable_strictMode&&(c=!0),void 0!==b.identifierPrefix&&(d=b.identifierPrefix),void 0!==b.onRecoverableError&&(e=b.onRecoverableError));b=al(a,1,!1,null,null,c,!1,d,e);a[tf]=b.current;rf(8===a.nodeType?a.parentNode:a);return new kl(b)};\nexports.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternals;if(void 0===b){if("function"===typeof a.render)throw Error(p(188));a=Object.keys(a).join(",");throw Error(p(268,a));}a=Yb(b);a=null===a?null:a.stateNode;return a};exports.flushSync=function(a){return Qk(a)};exports.hydrate=function(a,b,c){if(!nl(b))throw Error(p(200));return ql(null,a,b,!0,c)};\nexports.hydrateRoot=function(a,b,c){if(!ml(a))throw Error(p(405));var d=null!=c&&c.hydratedSources||null,e=!1,f="",g=jl;null!==c&&void 0!==c&&(!0===c.unstable_strictMode&&(e=!0),void 0!==c.identifierPrefix&&(f=c.identifierPrefix),void 0!==c.onRecoverableError&&(g=c.onRecoverableError));b=dl(b,null,a,1,null!=c?c:null,e,!1,f,g);a[tf]=b.current;rf(a);if(d)for(a=0;a<d.length;a++)c=d[a],e=c._getVersion,e=e(c._source),null==b.mutableSourceEagerHydrationData?b.mutableSourceEagerHydrationData=[c,e]:b.mutableSourceEagerHydrationData.push(c,\ne);return new ll(b)};exports.render=function(a,b,c){if(!nl(b))throw Error(p(200));return ql(null,a,b,!1,c)};exports.unmountComponentAtNode=function(a){if(!nl(a))throw Error(p(40));return a._reactRootContainer?(Qk(function(){ql(null,null,a,!1,function(){a._reactRootContainer=null;a[tf]=null})}),!0):!1};exports.unstable_batchedUpdates=Pk;\nexports.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!nl(c))throw Error(p(200));if(null==a||void 0===a._reactInternals)throw Error(p(38));return ql(a,b,c,!1,d)};exports.version="18.1.0-next-22edb9f77-20220426";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Oi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanM/Y2E1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuLypcbiBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiovXG4ndXNlIHN0cmljdCc7dmFyIGFhPXJlcXVpcmUoXCJyZWFjdFwiKSxiYT1yZXF1aXJlKFwic2NoZWR1bGVyXCIpO2Z1bmN0aW9uIHAoYSl7Zm9yKHZhciBiPVwiaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2Vycm9yLWRlY29kZXIuaHRtbD9pbnZhcmlhbnQ9XCIrYSxjPTE7Yzxhcmd1bWVudHMubGVuZ3RoO2MrKyliKz1cIiZhcmdzW109XCIrZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3VtZW50c1tjXSk7cmV0dXJuXCJNaW5pZmllZCBSZWFjdCBlcnJvciAjXCIrYStcIjsgdmlzaXQgXCIrYitcIiBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuXCJ9dmFyIGRhPW5ldyBTZXQsZWE9e307ZnVuY3Rpb24gZmEoYSxiKXtoYShhLGIpO2hhKGErXCJDYXB0dXJlXCIsYil9XG5mdW5jdGlvbiBoYShhLGIpe2VhW2FdPWI7Zm9yKGE9MDthPGIubGVuZ3RoO2ErKylkYS5hZGQoYlthXSl9XG52YXIgaWE9IShcInVuZGVmaW5lZFwiPT09dHlwZW9mIHdpbmRvd3x8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiB3aW5kb3cuZG9jdW1lbnR8fFwidW5kZWZpbmVkXCI9PT10eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpLGphPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksa2E9L15bOkEtWl9hLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRdWzpBLVpfYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXFwtLjAtOVxcdTAwQjdcXHUwMzAwLVxcdTAzNkZcXHUyMDNGLVxcdTIwNDBdKiQvLGxhPVxue30sbWE9e307ZnVuY3Rpb24gbmEoYSl7aWYoamEuY2FsbChtYSxhKSlyZXR1cm4hMDtpZihqYS5jYWxsKGxhLGEpKXJldHVybiExO2lmKGthLnRlc3QoYSkpcmV0dXJuIG1hW2FdPSEwO2xhW2FdPSEwO3JldHVybiExfWZ1bmN0aW9uIG9hKGEsYixjLGQpe2lmKG51bGwhPT1jJiYwPT09Yy50eXBlKXJldHVybiExO3N3aXRjaCh0eXBlb2YgYil7Y2FzZSBcImZ1bmN0aW9uXCI6Y2FzZSBcInN5bWJvbFwiOnJldHVybiEwO2Nhc2UgXCJib29sZWFuXCI6aWYoZClyZXR1cm4hMTtpZihudWxsIT09YylyZXR1cm4hYy5hY2NlcHRzQm9vbGVhbnM7YT1hLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCw1KTtyZXR1cm5cImRhdGEtXCIhPT1hJiZcImFyaWEtXCIhPT1hO2RlZmF1bHQ6cmV0dXJuITF9fVxuZnVuY3Rpb24gcGEoYSxiLGMsZCl7aWYobnVsbD09PWJ8fFwidW5kZWZpbmVkXCI9PT10eXBlb2YgYnx8b2EoYSxiLGMsZCkpcmV0dXJuITA7aWYoZClyZXR1cm4hMTtpZihudWxsIT09Yylzd2l0Y2goYy50eXBlKXtjYXNlIDM6cmV0dXJuIWI7Y2FzZSA0OnJldHVybiExPT09YjtjYXNlIDU6cmV0dXJuIGlzTmFOKGIpO2Nhc2UgNjpyZXR1cm4gaXNOYU4oYil8fDE+Yn1yZXR1cm4hMX1mdW5jdGlvbiB0KGEsYixjLGQsZSxmLGcpe3RoaXMuYWNjZXB0c0Jvb2xlYW5zPTI9PT1ifHwzPT09Ynx8ND09PWI7dGhpcy5hdHRyaWJ1dGVOYW1lPWQ7dGhpcy5hdHRyaWJ1dGVOYW1lc3BhY2U9ZTt0aGlzLm11c3RVc2VQcm9wZXJ0eT1jO3RoaXMucHJvcGVydHlOYW1lPWE7dGhpcy50eXBlPWI7dGhpcy5zYW5pdGl6ZVVSTD1mO3RoaXMucmVtb3ZlRW1wdHlTdHJpbmc9Z312YXIgej17fTtcblwiY2hpbGRyZW4gZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgZGVmYXVsdFZhbHVlIGRlZmF1bHRDaGVja2VkIGlubmVySFRNTCBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nIHN0eWxlXCIuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24oYSl7elthXT1uZXcgdChhLDAsITEsYSxudWxsLCExLCExKX0pO1tbXCJhY2NlcHRDaGFyc2V0XCIsXCJhY2NlcHQtY2hhcnNldFwiXSxbXCJjbGFzc05hbWVcIixcImNsYXNzXCJdLFtcImh0bWxGb3JcIixcImZvclwiXSxbXCJodHRwRXF1aXZcIixcImh0dHAtZXF1aXZcIl1dLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGI9YVswXTt6W2JdPW5ldyB0KGIsMSwhMSxhWzFdLG51bGwsITEsITEpfSk7W1wiY29udGVudEVkaXRhYmxlXCIsXCJkcmFnZ2FibGVcIixcInNwZWxsQ2hlY2tcIixcInZhbHVlXCJdLmZvckVhY2goZnVuY3Rpb24oYSl7elthXT1uZXcgdChhLDIsITEsYS50b0xvd2VyQ2FzZSgpLG51bGwsITEsITEpfSk7XG5bXCJhdXRvUmV2ZXJzZVwiLFwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFwiLFwiZm9jdXNhYmxlXCIsXCJwcmVzZXJ2ZUFscGhhXCJdLmZvckVhY2goZnVuY3Rpb24oYSl7elthXT1uZXcgdChhLDIsITEsYSxudWxsLCExLCExKX0pO1wiYWxsb3dGdWxsU2NyZWVuIGFzeW5jIGF1dG9Gb2N1cyBhdXRvUGxheSBjb250cm9scyBkZWZhdWx0IGRlZmVyIGRpc2FibGVkIGRpc2FibGVQaWN0dXJlSW5QaWN0dXJlIGRpc2FibGVSZW1vdGVQbGF5YmFjayBmb3JtTm9WYWxpZGF0ZSBoaWRkZW4gbG9vcCBub01vZHVsZSBub1ZhbGlkYXRlIG9wZW4gcGxheXNJbmxpbmUgcmVhZE9ubHkgcmVxdWlyZWQgcmV2ZXJzZWQgc2NvcGVkIHNlYW1sZXNzIGl0ZW1TY29wZVwiLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3pbYV09bmV3IHQoYSwzLCExLGEudG9Mb3dlckNhc2UoKSxudWxsLCExLCExKX0pO1xuW1wiY2hlY2tlZFwiLFwibXVsdGlwbGVcIixcIm11dGVkXCIsXCJzZWxlY3RlZFwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3pbYV09bmV3IHQoYSwzLCEwLGEsbnVsbCwhMSwhMSl9KTtbXCJjYXB0dXJlXCIsXCJkb3dubG9hZFwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3pbYV09bmV3IHQoYSw0LCExLGEsbnVsbCwhMSwhMSl9KTtbXCJjb2xzXCIsXCJyb3dzXCIsXCJzaXplXCIsXCJzcGFuXCJdLmZvckVhY2goZnVuY3Rpb24oYSl7elthXT1uZXcgdChhLDYsITEsYSxudWxsLCExLCExKX0pO1tcInJvd1NwYW5cIixcInN0YXJ0XCJdLmZvckVhY2goZnVuY3Rpb24oYSl7elthXT1uZXcgdChhLDUsITEsYS50b0xvd2VyQ2FzZSgpLG51bGwsITEsITEpfSk7dmFyIHFhPS9bXFwtOl0oW2Etel0pL2c7ZnVuY3Rpb24gcmEoYSl7cmV0dXJuIGFbMV0udG9VcHBlckNhc2UoKX1cblwiYWNjZW50LWhlaWdodCBhbGlnbm1lbnQtYmFzZWxpbmUgYXJhYmljLWZvcm0gYmFzZWxpbmUtc2hpZnQgY2FwLWhlaWdodCBjbGlwLXBhdGggY2xpcC1ydWxlIGNvbG9yLWludGVycG9sYXRpb24gY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzIGNvbG9yLXByb2ZpbGUgY29sb3ItcmVuZGVyaW5nIGRvbWluYW50LWJhc2VsaW5lIGVuYWJsZS1iYWNrZ3JvdW5kIGZpbGwtb3BhY2l0eSBmaWxsLXJ1bGUgZmxvb2QtY29sb3IgZmxvb2Qtb3BhY2l0eSBmb250LWZhbWlseSBmb250LXNpemUgZm9udC1zaXplLWFkanVzdCBmb250LXN0cmV0Y2ggZm9udC1zdHlsZSBmb250LXZhcmlhbnQgZm9udC13ZWlnaHQgZ2x5cGgtbmFtZSBnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsIGdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsIGhvcml6LWFkdi14IGhvcml6LW9yaWdpbi14IGltYWdlLXJlbmRlcmluZyBsZXR0ZXItc3BhY2luZyBsaWdodGluZy1jb2xvciBtYXJrZXItZW5kIG1hcmtlci1taWQgbWFya2VyLXN0YXJ0IG92ZXJsaW5lLXBvc2l0aW9uIG92ZXJsaW5lLXRoaWNrbmVzcyBwYWludC1vcmRlciBwYW5vc2UtMSBwb2ludGVyLWV2ZW50cyByZW5kZXJpbmctaW50ZW50IHNoYXBlLXJlbmRlcmluZyBzdG9wLWNvbG9yIHN0b3Atb3BhY2l0eSBzdHJpa2V0aHJvdWdoLXBvc2l0aW9uIHN0cmlrZXRocm91Z2gtdGhpY2tuZXNzIHN0cm9rZS1kYXNoYXJyYXkgc3Ryb2tlLWRhc2hvZmZzZXQgc3Ryb2tlLWxpbmVjYXAgc3Ryb2tlLWxpbmVqb2luIHN0cm9rZS1taXRlcmxpbWl0IHN0cm9rZS1vcGFjaXR5IHN0cm9rZS13aWR0aCB0ZXh0LWFuY2hvciB0ZXh0LWRlY29yYXRpb24gdGV4dC1yZW5kZXJpbmcgdW5kZXJsaW5lLXBvc2l0aW9uIHVuZGVybGluZS10aGlja25lc3MgdW5pY29kZS1iaWRpIHVuaWNvZGUtcmFuZ2UgdW5pdHMtcGVyLWVtIHYtYWxwaGFiZXRpYyB2LWhhbmdpbmcgdi1pZGVvZ3JhcGhpYyB2LW1hdGhlbWF0aWNhbCB2ZWN0b3ItZWZmZWN0IHZlcnQtYWR2LXkgdmVydC1vcmlnaW4teCB2ZXJ0LW9yaWdpbi15IHdvcmQtc3BhY2luZyB3cml0aW5nLW1vZGUgeG1sbnM6eGxpbmsgeC1oZWlnaHRcIi5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihhKXt2YXIgYj1hLnJlcGxhY2UocWEsXG5yYSk7eltiXT1uZXcgdChiLDEsITEsYSxudWxsLCExLCExKX0pO1wieGxpbms6YWN0dWF0ZSB4bGluazphcmNyb2xlIHhsaW5rOnJvbGUgeGxpbms6c2hvdyB4bGluazp0aXRsZSB4bGluazp0eXBlXCIuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGI9YS5yZXBsYWNlKHFhLHJhKTt6W2JdPW5ldyB0KGIsMSwhMSxhLFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLCExLCExKX0pO1tcInhtbDpiYXNlXCIsXCJ4bWw6bGFuZ1wiLFwieG1sOnNwYWNlXCJdLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGI9YS5yZXBsYWNlKHFhLHJhKTt6W2JdPW5ldyB0KGIsMSwhMSxhLFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsITEsITEpfSk7W1widGFiSW5kZXhcIixcImNyb3NzT3JpZ2luXCJdLmZvckVhY2goZnVuY3Rpb24oYSl7elthXT1uZXcgdChhLDEsITEsYS50b0xvd2VyQ2FzZSgpLG51bGwsITEsITEpfSk7XG56LnhsaW5rSHJlZj1uZXcgdChcInhsaW5rSHJlZlwiLDEsITEsXCJ4bGluazpocmVmXCIsXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsITAsITEpO1tcInNyY1wiLFwiaHJlZlwiLFwiYWN0aW9uXCIsXCJmb3JtQWN0aW9uXCJdLmZvckVhY2goZnVuY3Rpb24oYSl7elthXT1uZXcgdChhLDEsITEsYS50b0xvd2VyQ2FzZSgpLG51bGwsITAsITApfSk7XG5mdW5jdGlvbiBzYShhLGIsYyxkKXt2YXIgZT16Lmhhc093blByb3BlcnR5KGIpP3pbYl06bnVsbDtpZihudWxsIT09ZT8wIT09ZS50eXBlOmR8fCEoMjxiLmxlbmd0aCl8fFwib1wiIT09YlswXSYmXCJPXCIhPT1iWzBdfHxcIm5cIiE9PWJbMV0mJlwiTlwiIT09YlsxXSlwYShiLGMsZSxkKSYmKGM9bnVsbCksZHx8bnVsbD09PWU/bmEoYikmJihudWxsPT09Yz9hLnJlbW92ZUF0dHJpYnV0ZShiKTphLnNldEF0dHJpYnV0ZShiLFwiXCIrYykpOmUubXVzdFVzZVByb3BlcnR5P2FbZS5wcm9wZXJ0eU5hbWVdPW51bGw9PT1jPzM9PT1lLnR5cGU/ITE6XCJcIjpjOihiPWUuYXR0cmlidXRlTmFtZSxkPWUuYXR0cmlidXRlTmFtZXNwYWNlLG51bGw9PT1jP2EucmVtb3ZlQXR0cmlidXRlKGIpOihlPWUudHlwZSxjPTM9PT1lfHw0PT09ZSYmITA9PT1jP1wiXCI6XCJcIitjLGQ/YS5zZXRBdHRyaWJ1dGVOUyhkLGIsYyk6YS5zZXRBdHRyaWJ1dGUoYixjKSkpfVxudmFyIHRhPWFhLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELHVhPVN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpLHZhPVN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksd2E9U3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLHhhPVN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSx6YT1TeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksQWE9U3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpLEJhPVN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLENhPVN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxEYT1TeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksRWE9U3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksRmE9U3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksR2E9U3ltYm9sLmZvcihcInJlYWN0LmxhenlcIik7U3ltYm9sLmZvcihcInJlYWN0LnNjb3BlXCIpO1N5bWJvbC5mb3IoXCJyZWFjdC5kZWJ1Z190cmFjZV9tb2RlXCIpO1xudmFyIEhhPVN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIik7U3ltYm9sLmZvcihcInJlYWN0LmxlZ2FjeV9oaWRkZW5cIik7U3ltYm9sLmZvcihcInJlYWN0LmNhY2hlXCIpO1N5bWJvbC5mb3IoXCJyZWFjdC50cmFjaW5nX21hcmtlclwiKTt2YXIgSWE9U3ltYm9sLml0ZXJhdG9yO2Z1bmN0aW9uIEphKGEpe2lmKG51bGw9PT1hfHxcIm9iamVjdFwiIT09dHlwZW9mIGEpcmV0dXJuIG51bGw7YT1JYSYmYVtJYV18fGFbXCJAQGl0ZXJhdG9yXCJdO3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBhP2E6bnVsbH12YXIgQT1PYmplY3QuYXNzaWduLEthO2Z1bmN0aW9uIExhKGEpe2lmKHZvaWQgMD09PUthKXRyeXt0aHJvdyBFcnJvcigpO31jYXRjaChjKXt2YXIgYj1jLnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO0thPWImJmJbMV18fFwiXCJ9cmV0dXJuXCJcXG5cIitLYSthfXZhciBNYT0hMTtcbmZ1bmN0aW9uIE5hKGEsYil7aWYoIWF8fE1hKXJldHVyblwiXCI7TWE9ITA7dmFyIGM9RXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7RXJyb3IucHJlcGFyZVN0YWNrVHJhY2U9dm9pZCAwO3RyeXtpZihiKWlmKGI9ZnVuY3Rpb24oKXt0aHJvdyBFcnJvcigpO30sT2JqZWN0LmRlZmluZVByb3BlcnR5KGIucHJvdG90eXBlLFwicHJvcHNcIix7c2V0OmZ1bmN0aW9uKCl7dGhyb3cgRXJyb3IoKTt9fSksXCJvYmplY3RcIj09PXR5cGVvZiBSZWZsZWN0JiZSZWZsZWN0LmNvbnN0cnVjdCl7dHJ5e1JlZmxlY3QuY29uc3RydWN0KGIsW10pfWNhdGNoKGwpe3ZhciBkPWx9UmVmbGVjdC5jb25zdHJ1Y3QoYSxbXSxiKX1lbHNle3RyeXtiLmNhbGwoKX1jYXRjaChsKXtkPWx9YS5jYWxsKGIucHJvdG90eXBlKX1lbHNle3RyeXt0aHJvdyBFcnJvcigpO31jYXRjaChsKXtkPWx9YSgpfX1jYXRjaChsKXtpZihsJiZkJiZcInN0cmluZ1wiPT09dHlwZW9mIGwuc3RhY2spe2Zvcih2YXIgZT1sLnN0YWNrLnNwbGl0KFwiXFxuXCIpLFxuZj1kLnN0YWNrLnNwbGl0KFwiXFxuXCIpLGc9ZS5sZW5ndGgtMSxoPWYubGVuZ3RoLTE7MTw9ZyYmMDw9aCYmZVtnXSE9PWZbaF07KWgtLTtmb3IoOzE8PWcmJjA8PWg7Zy0tLGgtLSlpZihlW2ddIT09ZltoXSl7aWYoMSE9PWd8fDEhPT1oKXtkbyBpZihnLS0saC0tLDA+aHx8ZVtnXSE9PWZbaF0pe3ZhciBrPVwiXFxuXCIrZVtnXS5yZXBsYWNlKFwiIGF0IG5ldyBcIixcIiBhdCBcIik7YS5kaXNwbGF5TmFtZSYmay5pbmNsdWRlcyhcIjxhbm9ueW1vdXM+XCIpJiYoaz1rLnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLGEuZGlzcGxheU5hbWUpKTtyZXR1cm4ga313aGlsZSgxPD1nJiYwPD1oKX1icmVha319fWZpbmFsbHl7TWE9ITEsRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U9Y31yZXR1cm4oYT1hP2EuZGlzcGxheU5hbWV8fGEubmFtZTpcIlwiKT9MYShhKTpcIlwifVxuZnVuY3Rpb24gT2EoYSl7c3dpdGNoKGEudGFnKXtjYXNlIDU6cmV0dXJuIExhKGEudHlwZSk7Y2FzZSAxNjpyZXR1cm4gTGEoXCJMYXp5XCIpO2Nhc2UgMTM6cmV0dXJuIExhKFwiU3VzcGVuc2VcIik7Y2FzZSAxOTpyZXR1cm4gTGEoXCJTdXNwZW5zZUxpc3RcIik7Y2FzZSAwOmNhc2UgMjpjYXNlIDE1OnJldHVybiBhPU5hKGEudHlwZSwhMSksYTtjYXNlIDExOnJldHVybiBhPU5hKGEudHlwZS5yZW5kZXIsITEpLGE7Y2FzZSAxOnJldHVybiBhPU5hKGEudHlwZSwhMCksYTtkZWZhdWx0OnJldHVyblwiXCJ9fVxuZnVuY3Rpb24gUGEoYSl7aWYobnVsbD09YSlyZXR1cm4gbnVsbDtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYSlyZXR1cm4gYS5kaXNwbGF5TmFtZXx8YS5uYW1lfHxudWxsO2lmKFwic3RyaW5nXCI9PT10eXBlb2YgYSlyZXR1cm4gYTtzd2l0Y2goYSl7Y2FzZSB3YTpyZXR1cm5cIkZyYWdtZW50XCI7Y2FzZSB2YTpyZXR1cm5cIlBvcnRhbFwiO2Nhc2UgemE6cmV0dXJuXCJQcm9maWxlclwiO2Nhc2UgeGE6cmV0dXJuXCJTdHJpY3RNb2RlXCI7Y2FzZSBEYTpyZXR1cm5cIlN1c3BlbnNlXCI7Y2FzZSBFYTpyZXR1cm5cIlN1c3BlbnNlTGlzdFwifWlmKFwib2JqZWN0XCI9PT10eXBlb2YgYSlzd2l0Y2goYS4kJHR5cGVvZil7Y2FzZSBCYTpyZXR1cm4oYS5kaXNwbGF5TmFtZXx8XCJDb250ZXh0XCIpK1wiLkNvbnN1bWVyXCI7Y2FzZSBBYTpyZXR1cm4oYS5fY29udGV4dC5kaXNwbGF5TmFtZXx8XCJDb250ZXh0XCIpK1wiLlByb3ZpZGVyXCI7Y2FzZSBDYTp2YXIgYj1hLnJlbmRlcjthPWEuZGlzcGxheU5hbWU7YXx8KGE9Yi5kaXNwbGF5TmFtZXx8XG5iLm5hbWV8fFwiXCIsYT1cIlwiIT09YT9cIkZvcndhcmRSZWYoXCIrYStcIilcIjpcIkZvcndhcmRSZWZcIik7cmV0dXJuIGE7Y2FzZSBGYTpyZXR1cm4gYj1hLmRpc3BsYXlOYW1lfHxudWxsLG51bGwhPT1iP2I6UGEoYS50eXBlKXx8XCJNZW1vXCI7Y2FzZSBHYTpiPWEuX3BheWxvYWQ7YT1hLl9pbml0O3RyeXtyZXR1cm4gUGEoYShiKSl9Y2F0Y2goYyl7fX1yZXR1cm4gbnVsbH1cbmZ1bmN0aW9uIFFhKGEpe3ZhciBiPWEudHlwZTtzd2l0Y2goYS50YWcpe2Nhc2UgMjQ6cmV0dXJuXCJDYWNoZVwiO2Nhc2UgOTpyZXR1cm4oYi5kaXNwbGF5TmFtZXx8XCJDb250ZXh0XCIpK1wiLkNvbnN1bWVyXCI7Y2FzZSAxMDpyZXR1cm4oYi5fY29udGV4dC5kaXNwbGF5TmFtZXx8XCJDb250ZXh0XCIpK1wiLlByb3ZpZGVyXCI7Y2FzZSAxODpyZXR1cm5cIkRlaHlkcmF0ZWRGcmFnbWVudFwiO2Nhc2UgMTE6cmV0dXJuIGE9Yi5yZW5kZXIsYT1hLmRpc3BsYXlOYW1lfHxhLm5hbWV8fFwiXCIsYi5kaXNwbGF5TmFtZXx8KFwiXCIhPT1hP1wiRm9yd2FyZFJlZihcIithK1wiKVwiOlwiRm9yd2FyZFJlZlwiKTtjYXNlIDc6cmV0dXJuXCJGcmFnbWVudFwiO2Nhc2UgNTpyZXR1cm4gYjtjYXNlIDQ6cmV0dXJuXCJQb3J0YWxcIjtjYXNlIDM6cmV0dXJuXCJSb290XCI7Y2FzZSA2OnJldHVyblwiVGV4dFwiO2Nhc2UgMTY6cmV0dXJuIFBhKGIpO2Nhc2UgODpyZXR1cm4gYj09PXhhP1wiU3RyaWN0TW9kZVwiOlwiTW9kZVwiO2Nhc2UgMjI6cmV0dXJuXCJPZmZzY3JlZW5cIjtcbmNhc2UgMTI6cmV0dXJuXCJQcm9maWxlclwiO2Nhc2UgMjE6cmV0dXJuXCJTY29wZVwiO2Nhc2UgMTM6cmV0dXJuXCJTdXNwZW5zZVwiO2Nhc2UgMTk6cmV0dXJuXCJTdXNwZW5zZUxpc3RcIjtjYXNlIDI1OnJldHVyblwiVHJhY2luZ01hcmtlclwiO2Nhc2UgMTpjYXNlIDA6Y2FzZSAxNzpjYXNlIDI6Y2FzZSAxNDpjYXNlIDE1OmlmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBiKXJldHVybiBiLmRpc3BsYXlOYW1lfHxiLm5hbWV8fG51bGw7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBiKXJldHVybiBifXJldHVybiBudWxsfWZ1bmN0aW9uIFJhKGEpe3N3aXRjaCh0eXBlb2YgYSl7Y2FzZSBcImJvb2xlYW5cIjpjYXNlIFwibnVtYmVyXCI6Y2FzZSBcInN0cmluZ1wiOmNhc2UgXCJ1bmRlZmluZWRcIjpyZXR1cm4gYTtjYXNlIFwib2JqZWN0XCI6cmV0dXJuIGE7ZGVmYXVsdDpyZXR1cm5cIlwifX1cbmZ1bmN0aW9uIFNhKGEpe3ZhciBiPWEudHlwZTtyZXR1cm4oYT1hLm5vZGVOYW1lKSYmXCJpbnB1dFwiPT09YS50b0xvd2VyQ2FzZSgpJiYoXCJjaGVja2JveFwiPT09Ynx8XCJyYWRpb1wiPT09Yil9XG5mdW5jdGlvbiBUYShhKXt2YXIgYj1TYShhKT9cImNoZWNrZWRcIjpcInZhbHVlXCIsYz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGEuY29uc3RydWN0b3IucHJvdG90eXBlLGIpLGQ9XCJcIithW2JdO2lmKCFhLmhhc093blByb3BlcnR5KGIpJiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIGMmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBjLmdldCYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGMuc2V0KXt2YXIgZT1jLmdldCxmPWMuc2V0O09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGIse2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZS5jYWxsKHRoaXMpfSxzZXQ6ZnVuY3Rpb24oYSl7ZD1cIlwiK2E7Zi5jYWxsKHRoaXMsYSl9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsYix7ZW51bWVyYWJsZTpjLmVudW1lcmFibGV9KTtyZXR1cm57Z2V0VmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gZH0sc2V0VmFsdWU6ZnVuY3Rpb24oYSl7ZD1cIlwiK2F9LHN0b3BUcmFja2luZzpmdW5jdGlvbigpe2EuX3ZhbHVlVHJhY2tlcj1cbm51bGw7ZGVsZXRlIGFbYl19fX19ZnVuY3Rpb24gVWEoYSl7YS5fdmFsdWVUcmFja2VyfHwoYS5fdmFsdWVUcmFja2VyPVRhKGEpKX1mdW5jdGlvbiBWYShhKXtpZighYSlyZXR1cm4hMTt2YXIgYj1hLl92YWx1ZVRyYWNrZXI7aWYoIWIpcmV0dXJuITA7dmFyIGM9Yi5nZXRWYWx1ZSgpO3ZhciBkPVwiXCI7YSYmKGQ9U2EoYSk/YS5jaGVja2VkP1widHJ1ZVwiOlwiZmFsc2VcIjphLnZhbHVlKTthPWQ7cmV0dXJuIGEhPT1jPyhiLnNldFZhbHVlKGEpLCEwKTohMX1mdW5jdGlvbiBXYShhKXthPWF8fChcInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50P2RvY3VtZW50OnZvaWQgMCk7aWYoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhKXJldHVybiBudWxsO3RyeXtyZXR1cm4gYS5hY3RpdmVFbGVtZW50fHxhLmJvZHl9Y2F0Y2goYil7cmV0dXJuIGEuYm9keX19XG5mdW5jdGlvbiBYYShhLGIpe3ZhciBjPWIuY2hlY2tlZDtyZXR1cm4gQSh7fSxiLHtkZWZhdWx0Q2hlY2tlZDp2b2lkIDAsZGVmYXVsdFZhbHVlOnZvaWQgMCx2YWx1ZTp2b2lkIDAsY2hlY2tlZDpudWxsIT1jP2M6YS5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkfSl9ZnVuY3Rpb24gWWEoYSxiKXt2YXIgYz1udWxsPT1iLmRlZmF1bHRWYWx1ZT9cIlwiOmIuZGVmYXVsdFZhbHVlLGQ9bnVsbCE9Yi5jaGVja2VkP2IuY2hlY2tlZDpiLmRlZmF1bHRDaGVja2VkO2M9UmEobnVsbCE9Yi52YWx1ZT9iLnZhbHVlOmMpO2EuX3dyYXBwZXJTdGF0ZT17aW5pdGlhbENoZWNrZWQ6ZCxpbml0aWFsVmFsdWU6Yyxjb250cm9sbGVkOlwiY2hlY2tib3hcIj09PWIudHlwZXx8XCJyYWRpb1wiPT09Yi50eXBlP251bGwhPWIuY2hlY2tlZDpudWxsIT1iLnZhbHVlfX1mdW5jdGlvbiBaYShhLGIpe2I9Yi5jaGVja2VkO251bGwhPWImJnNhKGEsXCJjaGVja2VkXCIsYiwhMSl9XG5mdW5jdGlvbiAkYShhLGIpe1phKGEsYik7dmFyIGM9UmEoYi52YWx1ZSksZD1iLnR5cGU7aWYobnVsbCE9YylpZihcIm51bWJlclwiPT09ZCl7aWYoMD09PWMmJlwiXCI9PT1hLnZhbHVlfHxhLnZhbHVlIT1jKWEudmFsdWU9XCJcIitjfWVsc2UgYS52YWx1ZSE9PVwiXCIrYyYmKGEudmFsdWU9XCJcIitjKTtlbHNlIGlmKFwic3VibWl0XCI9PT1kfHxcInJlc2V0XCI9PT1kKXthLnJlbW92ZUF0dHJpYnV0ZShcInZhbHVlXCIpO3JldHVybn1iLmhhc093blByb3BlcnR5KFwidmFsdWVcIik/YmIoYSxiLnR5cGUsYyk6Yi5oYXNPd25Qcm9wZXJ0eShcImRlZmF1bHRWYWx1ZVwiKSYmYmIoYSxiLnR5cGUsUmEoYi5kZWZhdWx0VmFsdWUpKTtudWxsPT1iLmNoZWNrZWQmJm51bGwhPWIuZGVmYXVsdENoZWNrZWQmJihhLmRlZmF1bHRDaGVja2VkPSEhYi5kZWZhdWx0Q2hlY2tlZCl9XG5mdW5jdGlvbiBjYihhLGIsYyl7aWYoYi5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpfHxiLmhhc093blByb3BlcnR5KFwiZGVmYXVsdFZhbHVlXCIpKXt2YXIgZD1iLnR5cGU7aWYoIShcInN1Ym1pdFwiIT09ZCYmXCJyZXNldFwiIT09ZHx8dm9pZCAwIT09Yi52YWx1ZSYmbnVsbCE9PWIudmFsdWUpKXJldHVybjtiPVwiXCIrYS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZTtjfHxiPT09YS52YWx1ZXx8KGEudmFsdWU9Yik7YS5kZWZhdWx0VmFsdWU9Yn1jPWEubmFtZTtcIlwiIT09YyYmKGEubmFtZT1cIlwiKTthLmRlZmF1bHRDaGVja2VkPSEhYS5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkO1wiXCIhPT1jJiYoYS5uYW1lPWMpfVxuZnVuY3Rpb24gYmIoYSxiLGMpe2lmKFwibnVtYmVyXCIhPT1ifHxXYShhLm93bmVyRG9jdW1lbnQpIT09YSludWxsPT1jP2EuZGVmYXVsdFZhbHVlPVwiXCIrYS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZTphLmRlZmF1bHRWYWx1ZSE9PVwiXCIrYyYmKGEuZGVmYXVsdFZhbHVlPVwiXCIrYyl9dmFyIGRiPUFycmF5LmlzQXJyYXk7XG5mdW5jdGlvbiBlYihhLGIsYyxkKXthPWEub3B0aW9ucztpZihiKXtiPXt9O2Zvcih2YXIgZT0wO2U8Yy5sZW5ndGg7ZSsrKWJbXCIkXCIrY1tlXV09ITA7Zm9yKGM9MDtjPGEubGVuZ3RoO2MrKyllPWIuaGFzT3duUHJvcGVydHkoXCIkXCIrYVtjXS52YWx1ZSksYVtjXS5zZWxlY3RlZCE9PWUmJihhW2NdLnNlbGVjdGVkPWUpLGUmJmQmJihhW2NdLmRlZmF1bHRTZWxlY3RlZD0hMCl9ZWxzZXtjPVwiXCIrUmEoYyk7Yj1udWxsO2ZvcihlPTA7ZTxhLmxlbmd0aDtlKyspe2lmKGFbZV0udmFsdWU9PT1jKXthW2VdLnNlbGVjdGVkPSEwO2QmJihhW2VdLmRlZmF1bHRTZWxlY3RlZD0hMCk7cmV0dXJufW51bGwhPT1ifHxhW2VdLmRpc2FibGVkfHwoYj1hW2VdKX1udWxsIT09YiYmKGIuc2VsZWN0ZWQ9ITApfX1cbmZ1bmN0aW9uIGZiKGEsYil7aWYobnVsbCE9Yi5kYW5nZXJvdXNseVNldElubmVySFRNTCl0aHJvdyBFcnJvcihwKDkxKSk7cmV0dXJuIEEoe30sYix7dmFsdWU6dm9pZCAwLGRlZmF1bHRWYWx1ZTp2b2lkIDAsY2hpbGRyZW46XCJcIithLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlfSl9ZnVuY3Rpb24gZ2IoYSxiKXt2YXIgYz1iLnZhbHVlO2lmKG51bGw9PWMpe2M9Yi5jaGlsZHJlbjtiPWIuZGVmYXVsdFZhbHVlO2lmKG51bGwhPWMpe2lmKG51bGwhPWIpdGhyb3cgRXJyb3IocCg5MikpO2lmKGRiKGMpKXtpZigxPGMubGVuZ3RoKXRocm93IEVycm9yKHAoOTMpKTtjPWNbMF19Yj1jfW51bGw9PWImJihiPVwiXCIpO2M9Yn1hLl93cmFwcGVyU3RhdGU9e2luaXRpYWxWYWx1ZTpSYShjKX19XG5mdW5jdGlvbiBoYihhLGIpe3ZhciBjPVJhKGIudmFsdWUpLGQ9UmEoYi5kZWZhdWx0VmFsdWUpO251bGwhPWMmJihjPVwiXCIrYyxjIT09YS52YWx1ZSYmKGEudmFsdWU9YyksbnVsbD09Yi5kZWZhdWx0VmFsdWUmJmEuZGVmYXVsdFZhbHVlIT09YyYmKGEuZGVmYXVsdFZhbHVlPWMpKTtudWxsIT1kJiYoYS5kZWZhdWx0VmFsdWU9XCJcIitkKX1mdW5jdGlvbiBpYihhKXt2YXIgYj1hLnRleHRDb250ZW50O2I9PT1hLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlJiZcIlwiIT09YiYmbnVsbCE9PWImJihhLnZhbHVlPWIpfWZ1bmN0aW9uIGpiKGEpe3N3aXRjaChhKXtjYXNlIFwic3ZnXCI6cmV0dXJuXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO2Nhc2UgXCJtYXRoXCI6cmV0dXJuXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7ZGVmYXVsdDpyZXR1cm5cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIn19XG5mdW5jdGlvbiBrYihhLGIpe3JldHVybiBudWxsPT1hfHxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIj09PWE/amIoYik6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPT09YSYmXCJmb3JlaWduT2JqZWN0XCI9PT1iP1wiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiOmF9XG52YXIgbGIsbWI9ZnVuY3Rpb24oYSl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBNU0FwcCYmTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24/ZnVuY3Rpb24oYixjLGQsZSl7TVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24oKXtyZXR1cm4gYShiLGMsZCxlKX0pfTphfShmdW5jdGlvbihhLGIpe2lmKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiE9PWEubmFtZXNwYWNlVVJJfHxcImlubmVySFRNTFwiaW4gYSlhLmlubmVySFRNTD1iO2Vsc2V7bGI9bGJ8fGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7bGIuaW5uZXJIVE1MPVwiPHN2Zz5cIitiLnZhbHVlT2YoKS50b1N0cmluZygpK1wiPC9zdmc+XCI7Zm9yKGI9bGIuZmlyc3RDaGlsZDthLmZpcnN0Q2hpbGQ7KWEucmVtb3ZlQ2hpbGQoYS5maXJzdENoaWxkKTtmb3IoO2IuZmlyc3RDaGlsZDspYS5hcHBlbmRDaGlsZChiLmZpcnN0Q2hpbGQpfX0pO1xuZnVuY3Rpb24gbmIoYSxiKXtpZihiKXt2YXIgYz1hLmZpcnN0Q2hpbGQ7aWYoYyYmYz09PWEubGFzdENoaWxkJiYzPT09Yy5ub2RlVHlwZSl7Yy5ub2RlVmFsdWU9YjtyZXR1cm59fWEudGV4dENvbnRlbnQ9Yn1cbnZhciBvYj17YW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6ITAsYXNwZWN0UmF0aW86ITAsYm9yZGVySW1hZ2VPdXRzZXQ6ITAsYm9yZGVySW1hZ2VTbGljZTohMCxib3JkZXJJbWFnZVdpZHRoOiEwLGJveEZsZXg6ITAsYm94RmxleEdyb3VwOiEwLGJveE9yZGluYWxHcm91cDohMCxjb2x1bW5Db3VudDohMCxjb2x1bW5zOiEwLGZsZXg6ITAsZmxleEdyb3c6ITAsZmxleFBvc2l0aXZlOiEwLGZsZXhTaHJpbms6ITAsZmxleE5lZ2F0aXZlOiEwLGZsZXhPcmRlcjohMCxncmlkQXJlYTohMCxncmlkUm93OiEwLGdyaWRSb3dFbmQ6ITAsZ3JpZFJvd1NwYW46ITAsZ3JpZFJvd1N0YXJ0OiEwLGdyaWRDb2x1bW46ITAsZ3JpZENvbHVtbkVuZDohMCxncmlkQ29sdW1uU3BhbjohMCxncmlkQ29sdW1uU3RhcnQ6ITAsZm9udFdlaWdodDohMCxsaW5lQ2xhbXA6ITAsbGluZUhlaWdodDohMCxvcGFjaXR5OiEwLG9yZGVyOiEwLG9ycGhhbnM6ITAsdGFiU2l6ZTohMCx3aWRvd3M6ITAsekluZGV4OiEwLFxuem9vbTohMCxmaWxsT3BhY2l0eTohMCxmbG9vZE9wYWNpdHk6ITAsc3RvcE9wYWNpdHk6ITAsc3Ryb2tlRGFzaGFycmF5OiEwLHN0cm9rZURhc2hvZmZzZXQ6ITAsc3Ryb2tlTWl0ZXJsaW1pdDohMCxzdHJva2VPcGFjaXR5OiEwLHN0cm9rZVdpZHRoOiEwfSxwYj1bXCJXZWJraXRcIixcIm1zXCIsXCJNb3pcIixcIk9cIl07T2JqZWN0LmtleXMob2IpLmZvckVhY2goZnVuY3Rpb24oYSl7cGIuZm9yRWFjaChmdW5jdGlvbihiKXtiPWIrYS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSthLnN1YnN0cmluZygxKTtvYltiXT1vYlthXX0pfSk7ZnVuY3Rpb24gcWIoYSxiLGMpe3JldHVybiBudWxsPT1ifHxcImJvb2xlYW5cIj09PXR5cGVvZiBifHxcIlwiPT09Yj9cIlwiOmN8fFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MD09PWJ8fG9iLmhhc093blByb3BlcnR5KGEpJiZvYlthXT8oXCJcIitiKS50cmltKCk6YitcInB4XCJ9XG5mdW5jdGlvbiByYihhLGIpe2E9YS5zdHlsZTtmb3IodmFyIGMgaW4gYilpZihiLmhhc093blByb3BlcnR5KGMpKXt2YXIgZD0wPT09Yy5pbmRleE9mKFwiLS1cIiksZT1xYihjLGJbY10sZCk7XCJmbG9hdFwiPT09YyYmKGM9XCJjc3NGbG9hdFwiKTtkP2Euc2V0UHJvcGVydHkoYyxlKTphW2NdPWV9fXZhciBzYj1BKHttZW51aXRlbTohMH0se2FyZWE6ITAsYmFzZTohMCxicjohMCxjb2w6ITAsZW1iZWQ6ITAsaHI6ITAsaW1nOiEwLGlucHV0OiEwLGtleWdlbjohMCxsaW5rOiEwLG1ldGE6ITAscGFyYW06ITAsc291cmNlOiEwLHRyYWNrOiEwLHdicjohMH0pO1xuZnVuY3Rpb24gdGIoYSxiKXtpZihiKXtpZihzYlthXSYmKG51bGwhPWIuY2hpbGRyZW58fG51bGwhPWIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpKXRocm93IEVycm9yKHAoMTM3LGEpKTtpZihudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKXtpZihudWxsIT1iLmNoaWxkcmVuKXRocm93IEVycm9yKHAoNjApKTtpZihcIm9iamVjdFwiIT09dHlwZW9mIGIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUx8fCEoXCJfX2h0bWxcImluIGIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpKXRocm93IEVycm9yKHAoNjEpKTt9aWYobnVsbCE9Yi5zdHlsZSYmXCJvYmplY3RcIiE9PXR5cGVvZiBiLnN0eWxlKXRocm93IEVycm9yKHAoNjIpKTt9fVxuZnVuY3Rpb24gdWIoYSxiKXtpZigtMT09PWEuaW5kZXhPZihcIi1cIikpcmV0dXJuXCJzdHJpbmdcIj09PXR5cGVvZiBiLmlzO3N3aXRjaChhKXtjYXNlIFwiYW5ub3RhdGlvbi14bWxcIjpjYXNlIFwiY29sb3ItcHJvZmlsZVwiOmNhc2UgXCJmb250LWZhY2VcIjpjYXNlIFwiZm9udC1mYWNlLXNyY1wiOmNhc2UgXCJmb250LWZhY2UtdXJpXCI6Y2FzZSBcImZvbnQtZmFjZS1mb3JtYXRcIjpjYXNlIFwiZm9udC1mYWNlLW5hbWVcIjpjYXNlIFwibWlzc2luZy1nbHlwaFwiOnJldHVybiExO2RlZmF1bHQ6cmV0dXJuITB9fXZhciB2Yj1udWxsO2Z1bmN0aW9uIHdiKGEpe2E9YS50YXJnZXR8fGEuc3JjRWxlbWVudHx8d2luZG93O2EuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQmJihhPWEuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpO3JldHVybiAzPT09YS5ub2RlVHlwZT9hLnBhcmVudE5vZGU6YX12YXIgeGI9bnVsbCx5Yj1udWxsLHpiPW51bGw7XG5mdW5jdGlvbiBBYihhKXtpZihhPUJiKGEpKXtpZihcImZ1bmN0aW9uXCIhPT10eXBlb2YgeGIpdGhyb3cgRXJyb3IocCgyODApKTt2YXIgYj1hLnN0YXRlTm9kZTtiJiYoYj1DYihiKSx4YihhLnN0YXRlTm9kZSxhLnR5cGUsYikpfX1mdW5jdGlvbiBEYihhKXt5Yj96Yj96Yi5wdXNoKGEpOnpiPVthXTp5Yj1hfWZ1bmN0aW9uIEViKCl7aWYoeWIpe3ZhciBhPXliLGI9emI7emI9eWI9bnVsbDtBYihhKTtpZihiKWZvcihhPTA7YTxiLmxlbmd0aDthKyspQWIoYlthXSl9fWZ1bmN0aW9uIEZiKGEsYil7cmV0dXJuIGEoYil9ZnVuY3Rpb24gR2IoKXt9dmFyIEhiPSExO2Z1bmN0aW9uIEliKGEsYixjKXtpZihIYilyZXR1cm4gYShiLGMpO0hiPSEwO3RyeXtyZXR1cm4gRmIoYSxiLGMpfWZpbmFsbHl7aWYoSGI9ITEsbnVsbCE9PXlifHxudWxsIT09emIpR2IoKSxFYigpfX1cbmZ1bmN0aW9uIEpiKGEsYil7dmFyIGM9YS5zdGF0ZU5vZGU7aWYobnVsbD09PWMpcmV0dXJuIG51bGw7dmFyIGQ9Q2IoYyk7aWYobnVsbD09PWQpcmV0dXJuIG51bGw7Yz1kW2JdO2E6c3dpdGNoKGIpe2Nhc2UgXCJvbkNsaWNrXCI6Y2FzZSBcIm9uQ2xpY2tDYXB0dXJlXCI6Y2FzZSBcIm9uRG91YmxlQ2xpY2tcIjpjYXNlIFwib25Eb3VibGVDbGlja0NhcHR1cmVcIjpjYXNlIFwib25Nb3VzZURvd25cIjpjYXNlIFwib25Nb3VzZURvd25DYXB0dXJlXCI6Y2FzZSBcIm9uTW91c2VNb3ZlXCI6Y2FzZSBcIm9uTW91c2VNb3ZlQ2FwdHVyZVwiOmNhc2UgXCJvbk1vdXNlVXBcIjpjYXNlIFwib25Nb3VzZVVwQ2FwdHVyZVwiOmNhc2UgXCJvbk1vdXNlRW50ZXJcIjooZD0hZC5kaXNhYmxlZCl8fChhPWEudHlwZSxkPSEoXCJidXR0b25cIj09PWF8fFwiaW5wdXRcIj09PWF8fFwic2VsZWN0XCI9PT1hfHxcInRleHRhcmVhXCI9PT1hKSk7YT0hZDticmVhayBhO2RlZmF1bHQ6YT0hMX1pZihhKXJldHVybiBudWxsO2lmKGMmJlwiZnVuY3Rpb25cIiE9PVxudHlwZW9mIGMpdGhyb3cgRXJyb3IocCgyMzEsYix0eXBlb2YgYykpO3JldHVybiBjfXZhciBLYj0hMTtpZihpYSl0cnl7dmFyIExiPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShMYixcInBhc3NpdmVcIix7Z2V0OmZ1bmN0aW9uKCl7S2I9ITB9fSk7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsTGIsTGIpO3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidGVzdFwiLExiLExiKX1jYXRjaChhKXtLYj0hMX1mdW5jdGlvbiBNYihhLGIsYyxkLGUsZixnLGgsayl7dmFyIGw9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDMpO3RyeXtiLmFwcGx5KGMsbCl9Y2F0Y2gobil7dGhpcy5vbkVycm9yKG4pfX12YXIgTmI9ITEsT2I9bnVsbCxQYj0hMSxRYj1udWxsLFJiPXtvbkVycm9yOmZ1bmN0aW9uKGEpe05iPSEwO09iPWF9fTtmdW5jdGlvbiBTYihhLGIsYyxkLGUsZixnLGgsayl7TmI9ITE7T2I9bnVsbDtNYi5hcHBseShSYixhcmd1bWVudHMpfVxuZnVuY3Rpb24gVGIoYSxiLGMsZCxlLGYsZyxoLGspe1NiLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtpZihOYil7aWYoTmIpe3ZhciBsPU9iO05iPSExO09iPW51bGx9ZWxzZSB0aHJvdyBFcnJvcihwKDE5OCkpO1BifHwoUGI9ITAsUWI9bCl9fWZ1bmN0aW9uIFViKGEpe3ZhciBiPWEsYz1hO2lmKGEuYWx0ZXJuYXRlKWZvcig7Yi5yZXR1cm47KWI9Yi5yZXR1cm47ZWxzZXthPWI7ZG8gYj1hLDAhPT0oYi5mbGFncyY0MDk4KSYmKGM9Yi5yZXR1cm4pLGE9Yi5yZXR1cm47d2hpbGUoYSl9cmV0dXJuIDM9PT1iLnRhZz9jOm51bGx9ZnVuY3Rpb24gVmIoYSl7aWYoMTM9PT1hLnRhZyl7dmFyIGI9YS5tZW1vaXplZFN0YXRlO251bGw9PT1iJiYoYT1hLmFsdGVybmF0ZSxudWxsIT09YSYmKGI9YS5tZW1vaXplZFN0YXRlKSk7aWYobnVsbCE9PWIpcmV0dXJuIGIuZGVoeWRyYXRlZH1yZXR1cm4gbnVsbH1mdW5jdGlvbiBXYihhKXtpZihVYihhKSE9PWEpdGhyb3cgRXJyb3IocCgxODgpKTt9XG5mdW5jdGlvbiBYYihhKXt2YXIgYj1hLmFsdGVybmF0ZTtpZighYil7Yj1VYihhKTtpZihudWxsPT09Yil0aHJvdyBFcnJvcihwKDE4OCkpO3JldHVybiBiIT09YT9udWxsOmF9Zm9yKHZhciBjPWEsZD1iOzspe3ZhciBlPWMucmV0dXJuO2lmKG51bGw9PT1lKWJyZWFrO3ZhciBmPWUuYWx0ZXJuYXRlO2lmKG51bGw9PT1mKXtkPWUucmV0dXJuO2lmKG51bGwhPT1kKXtjPWQ7Y29udGludWV9YnJlYWt9aWYoZS5jaGlsZD09PWYuY2hpbGQpe2ZvcihmPWUuY2hpbGQ7Zjspe2lmKGY9PT1jKXJldHVybiBXYihlKSxhO2lmKGY9PT1kKXJldHVybiBXYihlKSxiO2Y9Zi5zaWJsaW5nfXRocm93IEVycm9yKHAoMTg4KSk7fWlmKGMucmV0dXJuIT09ZC5yZXR1cm4pYz1lLGQ9ZjtlbHNle2Zvcih2YXIgZz0hMSxoPWUuY2hpbGQ7aDspe2lmKGg9PT1jKXtnPSEwO2M9ZTtkPWY7YnJlYWt9aWYoaD09PWQpe2c9ITA7ZD1lO2M9ZjticmVha31oPWguc2libGluZ31pZighZyl7Zm9yKGg9Zi5jaGlsZDtoOyl7aWYoaD09PVxuYyl7Zz0hMDtjPWY7ZD1lO2JyZWFrfWlmKGg9PT1kKXtnPSEwO2Q9ZjtjPWU7YnJlYWt9aD1oLnNpYmxpbmd9aWYoIWcpdGhyb3cgRXJyb3IocCgxODkpKTt9fWlmKGMuYWx0ZXJuYXRlIT09ZCl0aHJvdyBFcnJvcihwKDE5MCkpO31pZigzIT09Yy50YWcpdGhyb3cgRXJyb3IocCgxODgpKTtyZXR1cm4gYy5zdGF0ZU5vZGUuY3VycmVudD09PWM/YTpifWZ1bmN0aW9uIFliKGEpe2E9WGIoYSk7cmV0dXJuIG51bGwhPT1hP1piKGEpOm51bGx9ZnVuY3Rpb24gWmIoYSl7aWYoNT09PWEudGFnfHw2PT09YS50YWcpcmV0dXJuIGE7Zm9yKGE9YS5jaGlsZDtudWxsIT09YTspe3ZhciBiPVpiKGEpO2lmKG51bGwhPT1iKXJldHVybiBiO2E9YS5zaWJsaW5nfXJldHVybiBudWxsfVxudmFyICRiPWJhLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2ssYWM9YmEudW5zdGFibGVfY2FuY2VsQ2FsbGJhY2ssYmM9YmEudW5zdGFibGVfc2hvdWxkWWllbGQsY2M9YmEudW5zdGFibGVfcmVxdWVzdFBhaW50LEI9YmEudW5zdGFibGVfbm93LGRjPWJhLnVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsLGVjPWJhLnVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5LGZjPWJhLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5LGdjPWJhLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LGhjPWJhLnVuc3RhYmxlX0xvd1ByaW9yaXR5LGljPWJhLnVuc3RhYmxlX0lkbGVQcmlvcml0eSxqYz1udWxsLGtjPW51bGw7ZnVuY3Rpb24gbGMoYSl7aWYoa2MmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBrYy5vbkNvbW1pdEZpYmVyUm9vdCl0cnl7a2Mub25Db21taXRGaWJlclJvb3QoamMsYSx2b2lkIDAsMTI4PT09KGEuY3VycmVudC5mbGFncyYxMjgpKX1jYXRjaChiKXt9fVxudmFyIG5jPU1hdGguY2x6MzI/TWF0aC5jbHozMjptYyxvYz1NYXRoLmxvZyxwYz1NYXRoLkxOMjtmdW5jdGlvbiBtYyhhKXthPj4+PTA7cmV0dXJuIDA9PT1hPzMyOjMxLShvYyhhKS9wY3wwKXwwfXZhciBxYz02NCxyYz00MTk0MzA0O1xuZnVuY3Rpb24gc2MoYSl7c3dpdGNoKGEmLWEpe2Nhc2UgMTpyZXR1cm4gMTtjYXNlIDI6cmV0dXJuIDI7Y2FzZSA0OnJldHVybiA0O2Nhc2UgODpyZXR1cm4gODtjYXNlIDE2OnJldHVybiAxNjtjYXNlIDMyOnJldHVybiAzMjtjYXNlIDY0OmNhc2UgMTI4OmNhc2UgMjU2OmNhc2UgNTEyOmNhc2UgMTAyNDpjYXNlIDIwNDg6Y2FzZSA0MDk2OmNhc2UgODE5MjpjYXNlIDE2Mzg0OmNhc2UgMzI3Njg6Y2FzZSA2NTUzNjpjYXNlIDEzMTA3MjpjYXNlIDI2MjE0NDpjYXNlIDUyNDI4ODpjYXNlIDEwNDg1NzY6Y2FzZSAyMDk3MTUyOnJldHVybiBhJjQxOTQyNDA7Y2FzZSA0MTk0MzA0OmNhc2UgODM4ODYwODpjYXNlIDE2Nzc3MjE2OmNhc2UgMzM1NTQ0MzI6Y2FzZSA2NzEwODg2NDpyZXR1cm4gYSYxMzAwMjM0MjQ7Y2FzZSAxMzQyMTc3Mjg6cmV0dXJuIDEzNDIxNzcyODtjYXNlIDI2ODQzNTQ1NjpyZXR1cm4gMjY4NDM1NDU2O2Nhc2UgNTM2ODcwOTEyOnJldHVybiA1MzY4NzA5MTI7Y2FzZSAxMDczNzQxODI0OnJldHVybiAxMDczNzQxODI0O1xuZGVmYXVsdDpyZXR1cm4gYX19ZnVuY3Rpb24gdGMoYSxiKXt2YXIgYz1hLnBlbmRpbmdMYW5lcztpZigwPT09YylyZXR1cm4gMDt2YXIgZD0wLGU9YS5zdXNwZW5kZWRMYW5lcyxmPWEucGluZ2VkTGFuZXMsZz1jJjI2ODQzNTQ1NTtpZigwIT09Zyl7dmFyIGg9ZyZ+ZTswIT09aD9kPXNjKGgpOihmJj1nLDAhPT1mJiYoZD1zYyhmKSkpfWVsc2UgZz1jJn5lLDAhPT1nP2Q9c2MoZyk6MCE9PWYmJihkPXNjKGYpKTtpZigwPT09ZClyZXR1cm4gMDtpZigwIT09YiYmYiE9PWQmJjA9PT0oYiZlKSYmKGU9ZCYtZCxmPWImLWIsZT49Znx8MTY9PT1lJiYwIT09KGYmNDE5NDI0MCkpKXJldHVybiBiOzAhPT0oZCY0KSYmKGR8PWMmMTYpO2I9YS5lbnRhbmdsZWRMYW5lcztpZigwIT09Yilmb3IoYT1hLmVudGFuZ2xlbWVudHMsYiY9ZDswPGI7KWM9MzEtbmMoYiksZT0xPDxjLGR8PWFbY10sYiY9fmU7cmV0dXJuIGR9XG5mdW5jdGlvbiB1YyhhLGIpe3N3aXRjaChhKXtjYXNlIDE6Y2FzZSAyOmNhc2UgNDpyZXR1cm4gYisyNTA7Y2FzZSA4OmNhc2UgMTY6Y2FzZSAzMjpjYXNlIDY0OmNhc2UgMTI4OmNhc2UgMjU2OmNhc2UgNTEyOmNhc2UgMTAyNDpjYXNlIDIwNDg6Y2FzZSA0MDk2OmNhc2UgODE5MjpjYXNlIDE2Mzg0OmNhc2UgMzI3Njg6Y2FzZSA2NTUzNjpjYXNlIDEzMTA3MjpjYXNlIDI2MjE0NDpjYXNlIDUyNDI4ODpjYXNlIDEwNDg1NzY6Y2FzZSAyMDk3MTUyOnJldHVybiBiKzVFMztjYXNlIDQxOTQzMDQ6Y2FzZSA4Mzg4NjA4OmNhc2UgMTY3NzcyMTY6Y2FzZSAzMzU1NDQzMjpjYXNlIDY3MTA4ODY0OnJldHVybi0xO2Nhc2UgMTM0MjE3NzI4OmNhc2UgMjY4NDM1NDU2OmNhc2UgNTM2ODcwOTEyOmNhc2UgMTA3Mzc0MTgyNDpyZXR1cm4tMTtkZWZhdWx0OnJldHVybi0xfX1cbmZ1bmN0aW9uIHZjKGEsYil7Zm9yKHZhciBjPWEuc3VzcGVuZGVkTGFuZXMsZD1hLnBpbmdlZExhbmVzLGU9YS5leHBpcmF0aW9uVGltZXMsZj1hLnBlbmRpbmdMYW5lczswPGY7KXt2YXIgZz0zMS1uYyhmKSxoPTE8PGcsaz1lW2ddO2lmKC0xPT09ayl7aWYoMD09PShoJmMpfHwwIT09KGgmZCkpZVtnXT11YyhoLGIpfWVsc2Ugazw9YiYmKGEuZXhwaXJlZExhbmVzfD1oKTtmJj1+aH19ZnVuY3Rpb24gd2MoYSl7YT1hLnBlbmRpbmdMYW5lcyYtMTA3Mzc0MTgyNTtyZXR1cm4gMCE9PWE/YTphJjEwNzM3NDE4MjQ/MTA3Mzc0MTgyNDowfWZ1bmN0aW9uIHhjKCl7dmFyIGE9cWM7cWM8PD0xOzA9PT0ocWMmNDE5NDI0MCkmJihxYz02NCk7cmV0dXJuIGF9ZnVuY3Rpb24geWMoYSl7Zm9yKHZhciBiPVtdLGM9MDszMT5jO2MrKyliLnB1c2goYSk7cmV0dXJuIGJ9XG5mdW5jdGlvbiB6YyhhLGIsYyl7YS5wZW5kaW5nTGFuZXN8PWI7NTM2ODcwOTEyIT09YiYmKGEuc3VzcGVuZGVkTGFuZXM9MCxhLnBpbmdlZExhbmVzPTApO2E9YS5ldmVudFRpbWVzO2I9MzEtbmMoYik7YVtiXT1jfWZ1bmN0aW9uIEFjKGEsYil7dmFyIGM9YS5wZW5kaW5nTGFuZXMmfmI7YS5wZW5kaW5nTGFuZXM9YjthLnN1c3BlbmRlZExhbmVzPTA7YS5waW5nZWRMYW5lcz0wO2EuZXhwaXJlZExhbmVzJj1iO2EubXV0YWJsZVJlYWRMYW5lcyY9YjthLmVudGFuZ2xlZExhbmVzJj1iO2I9YS5lbnRhbmdsZW1lbnRzO3ZhciBkPWEuZXZlbnRUaW1lcztmb3IoYT1hLmV4cGlyYXRpb25UaW1lczswPGM7KXt2YXIgZT0zMS1uYyhjKSxmPTE8PGU7YltlXT0wO2RbZV09LTE7YVtlXT0tMTtjJj1+Zn19XG5mdW5jdGlvbiBCYyhhLGIpe3ZhciBjPWEuZW50YW5nbGVkTGFuZXN8PWI7Zm9yKGE9YS5lbnRhbmdsZW1lbnRzO2M7KXt2YXIgZD0zMS1uYyhjKSxlPTE8PGQ7ZSZifGFbZF0mYiYmKGFbZF18PWIpO2MmPX5lfX12YXIgQz0wO2Z1bmN0aW9uIENjKGEpe2EmPS1hO3JldHVybiAxPGE/NDxhPzAhPT0oYSYyNjg0MzU0NTUpPzE2OjUzNjg3MDkxMjo0OjF9dmFyIERjLEVjLEZjLEdjLEhjLEljPSExLEpjPVtdLEtjPW51bGwsTGM9bnVsbCxNYz1udWxsLE5jPW5ldyBNYXAsT2M9bmV3IE1hcCxQYz1bXSxRYz1cIm1vdXNlZG93biBtb3VzZXVwIHRvdWNoY2FuY2VsIHRvdWNoZW5kIHRvdWNoc3RhcnQgYXV4Y2xpY2sgZGJsY2xpY2sgcG9pbnRlcmNhbmNlbCBwb2ludGVyZG93biBwb2ludGVydXAgZHJhZ2VuZCBkcmFnc3RhcnQgZHJvcCBjb21wb3NpdGlvbmVuZCBjb21wb3NpdGlvbnN0YXJ0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgaW5wdXQgdGV4dElucHV0IGNvcHkgY3V0IHBhc3RlIGNsaWNrIGNoYW5nZSBjb250ZXh0bWVudSByZXNldCBzdWJtaXRcIi5zcGxpdChcIiBcIik7XG5mdW5jdGlvbiBSYyhhLGIpe3N3aXRjaChhKXtjYXNlIFwiZm9jdXNpblwiOmNhc2UgXCJmb2N1c291dFwiOktjPW51bGw7YnJlYWs7Y2FzZSBcImRyYWdlbnRlclwiOmNhc2UgXCJkcmFnbGVhdmVcIjpMYz1udWxsO2JyZWFrO2Nhc2UgXCJtb3VzZW92ZXJcIjpjYXNlIFwibW91c2VvdXRcIjpNYz1udWxsO2JyZWFrO2Nhc2UgXCJwb2ludGVyb3ZlclwiOmNhc2UgXCJwb2ludGVyb3V0XCI6TmMuZGVsZXRlKGIucG9pbnRlcklkKTticmVhaztjYXNlIFwiZ290cG9pbnRlcmNhcHR1cmVcIjpjYXNlIFwibG9zdHBvaW50ZXJjYXB0dXJlXCI6T2MuZGVsZXRlKGIucG9pbnRlcklkKX19XG5mdW5jdGlvbiBTYyhhLGIsYyxkLGUsZil7aWYobnVsbD09PWF8fGEubmF0aXZlRXZlbnQhPT1mKXJldHVybiBhPXtibG9ja2VkT246Yixkb21FdmVudE5hbWU6YyxldmVudFN5c3RlbUZsYWdzOmQsbmF0aXZlRXZlbnQ6Zix0YXJnZXRDb250YWluZXJzOltlXX0sbnVsbCE9PWImJihiPUJiKGIpLG51bGwhPT1iJiZFYyhiKSksYTthLmV2ZW50U3lzdGVtRmxhZ3N8PWQ7Yj1hLnRhcmdldENvbnRhaW5lcnM7bnVsbCE9PWUmJi0xPT09Yi5pbmRleE9mKGUpJiZiLnB1c2goZSk7cmV0dXJuIGF9XG5mdW5jdGlvbiBUYyhhLGIsYyxkLGUpe3N3aXRjaChiKXtjYXNlIFwiZm9jdXNpblwiOnJldHVybiBLYz1TYyhLYyxhLGIsYyxkLGUpLCEwO2Nhc2UgXCJkcmFnZW50ZXJcIjpyZXR1cm4gTGM9U2MoTGMsYSxiLGMsZCxlKSwhMDtjYXNlIFwibW91c2VvdmVyXCI6cmV0dXJuIE1jPVNjKE1jLGEsYixjLGQsZSksITA7Y2FzZSBcInBvaW50ZXJvdmVyXCI6dmFyIGY9ZS5wb2ludGVySWQ7TmMuc2V0KGYsU2MoTmMuZ2V0KGYpfHxudWxsLGEsYixjLGQsZSkpO3JldHVybiEwO2Nhc2UgXCJnb3Rwb2ludGVyY2FwdHVyZVwiOnJldHVybiBmPWUucG9pbnRlcklkLE9jLnNldChmLFNjKE9jLmdldChmKXx8bnVsbCxhLGIsYyxkLGUpKSwhMH1yZXR1cm4hMX1cbmZ1bmN0aW9uIFVjKGEpe3ZhciBiPVZjKGEudGFyZ2V0KTtpZihudWxsIT09Yil7dmFyIGM9VWIoYik7aWYobnVsbCE9PWMpaWYoYj1jLnRhZywxMz09PWIpe2lmKGI9VmIoYyksbnVsbCE9PWIpe2EuYmxvY2tlZE9uPWI7SGMoYS5wcmlvcml0eSxmdW5jdGlvbigpe0ZjKGMpfSk7cmV0dXJufX1lbHNlIGlmKDM9PT1iJiZjLnN0YXRlTm9kZS5jdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkKXthLmJsb2NrZWRPbj0zPT09Yy50YWc/Yy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbzpudWxsO3JldHVybn19YS5ibG9ja2VkT249bnVsbH1cbmZ1bmN0aW9uIFdjKGEpe2lmKG51bGwhPT1hLmJsb2NrZWRPbilyZXR1cm4hMTtmb3IodmFyIGI9YS50YXJnZXRDb250YWluZXJzOzA8Yi5sZW5ndGg7KXt2YXIgYz1YYyhhLmRvbUV2ZW50TmFtZSxhLmV2ZW50U3lzdGVtRmxhZ3MsYlswXSxhLm5hdGl2ZUV2ZW50KTtpZihudWxsPT09Yyl7Yz1hLm5hdGl2ZUV2ZW50O3ZhciBkPW5ldyBjLmNvbnN0cnVjdG9yKGMudHlwZSxjKTt2Yj1kO2MudGFyZ2V0LmRpc3BhdGNoRXZlbnQoZCk7dmI9bnVsbH1lbHNlIHJldHVybiBiPUJiKGMpLG51bGwhPT1iJiZFYyhiKSxhLmJsb2NrZWRPbj1jLCExO2Iuc2hpZnQoKX1yZXR1cm4hMH1mdW5jdGlvbiBZYyhhLGIsYyl7V2MoYSkmJmMuZGVsZXRlKGIpfWZ1bmN0aW9uIFpjKCl7SWM9ITE7bnVsbCE9PUtjJiZXYyhLYykmJihLYz1udWxsKTtudWxsIT09TGMmJldjKExjKSYmKExjPW51bGwpO251bGwhPT1NYyYmV2MoTWMpJiYoTWM9bnVsbCk7TmMuZm9yRWFjaChZYyk7T2MuZm9yRWFjaChZYyl9XG5mdW5jdGlvbiAkYyhhLGIpe2EuYmxvY2tlZE9uPT09YiYmKGEuYmxvY2tlZE9uPW51bGwsSWN8fChJYz0hMCxiYS51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrKGJhLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LFpjKSkpfVxuZnVuY3Rpb24gYWQoYSl7ZnVuY3Rpb24gYihiKXtyZXR1cm4gJGMoYixhKX1pZigwPEpjLmxlbmd0aCl7JGMoSmNbMF0sYSk7Zm9yKHZhciBjPTE7YzxKYy5sZW5ndGg7YysrKXt2YXIgZD1KY1tjXTtkLmJsb2NrZWRPbj09PWEmJihkLmJsb2NrZWRPbj1udWxsKX19bnVsbCE9PUtjJiYkYyhLYyxhKTtudWxsIT09TGMmJiRjKExjLGEpO251bGwhPT1NYyYmJGMoTWMsYSk7TmMuZm9yRWFjaChiKTtPYy5mb3JFYWNoKGIpO2ZvcihjPTA7YzxQYy5sZW5ndGg7YysrKWQ9UGNbY10sZC5ibG9ja2VkT249PT1hJiYoZC5ibG9ja2VkT249bnVsbCk7Zm9yKDswPFBjLmxlbmd0aCYmKGM9UGNbMF0sbnVsbD09PWMuYmxvY2tlZE9uKTspVWMoYyksbnVsbD09PWMuYmxvY2tlZE9uJiZQYy5zaGlmdCgpfXZhciBiZD10YS5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxjZD0hMDtcbmZ1bmN0aW9uIGRkKGEsYixjLGQpe3ZhciBlPUMsZj1iZC50cmFuc2l0aW9uO2JkLnRyYW5zaXRpb249bnVsbDt0cnl7Qz0xLGVkKGEsYixjLGQpfWZpbmFsbHl7Qz1lLGJkLnRyYW5zaXRpb249Zn19ZnVuY3Rpb24gZmQoYSxiLGMsZCl7dmFyIGU9QyxmPWJkLnRyYW5zaXRpb247YmQudHJhbnNpdGlvbj1udWxsO3RyeXtDPTQsZWQoYSxiLGMsZCl9ZmluYWxseXtDPWUsYmQudHJhbnNpdGlvbj1mfX1cbmZ1bmN0aW9uIGVkKGEsYixjLGQpe2lmKGNkKXt2YXIgZT1YYyhhLGIsYyxkKTtpZihudWxsPT09ZSlnZChhLGIsZCxoZCxjKSxSYyhhLGQpO2Vsc2UgaWYoVGMoZSxhLGIsYyxkKSlkLnN0b3BQcm9wYWdhdGlvbigpO2Vsc2UgaWYoUmMoYSxkKSxiJjQmJi0xPFFjLmluZGV4T2YoYSkpe2Zvcig7bnVsbCE9PWU7KXt2YXIgZj1CYihlKTtudWxsIT09ZiYmRGMoZik7Zj1YYyhhLGIsYyxkKTtudWxsPT09ZiYmZ2QoYSxiLGQsaGQsYyk7aWYoZj09PWUpYnJlYWs7ZT1mfW51bGwhPT1lJiZkLnN0b3BQcm9wYWdhdGlvbigpfWVsc2UgZ2QoYSxiLGQsbnVsbCxjKX19dmFyIGhkPW51bGw7XG5mdW5jdGlvbiBYYyhhLGIsYyxkKXtoZD1udWxsO2E9d2IoZCk7YT1WYyhhKTtpZihudWxsIT09YSlpZihiPVViKGEpLG51bGw9PT1iKWE9bnVsbDtlbHNlIGlmKGM9Yi50YWcsMTM9PT1jKXthPVZiKGIpO2lmKG51bGwhPT1hKXJldHVybiBhO2E9bnVsbH1lbHNlIGlmKDM9PT1jKXtpZihiLnN0YXRlTm9kZS5jdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkKXJldHVybiAzPT09Yi50YWc/Yi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbzpudWxsO2E9bnVsbH1lbHNlIGIhPT1hJiYoYT1udWxsKTtoZD1hO3JldHVybiBudWxsfVxuZnVuY3Rpb24gaWQoYSl7c3dpdGNoKGEpe2Nhc2UgXCJjYW5jZWxcIjpjYXNlIFwiY2xpY2tcIjpjYXNlIFwiY2xvc2VcIjpjYXNlIFwiY29udGV4dG1lbnVcIjpjYXNlIFwiY29weVwiOmNhc2UgXCJjdXRcIjpjYXNlIFwiYXV4Y2xpY2tcIjpjYXNlIFwiZGJsY2xpY2tcIjpjYXNlIFwiZHJhZ2VuZFwiOmNhc2UgXCJkcmFnc3RhcnRcIjpjYXNlIFwiZHJvcFwiOmNhc2UgXCJmb2N1c2luXCI6Y2FzZSBcImZvY3Vzb3V0XCI6Y2FzZSBcImlucHV0XCI6Y2FzZSBcImludmFsaWRcIjpjYXNlIFwia2V5ZG93blwiOmNhc2UgXCJrZXlwcmVzc1wiOmNhc2UgXCJrZXl1cFwiOmNhc2UgXCJtb3VzZWRvd25cIjpjYXNlIFwibW91c2V1cFwiOmNhc2UgXCJwYXN0ZVwiOmNhc2UgXCJwYXVzZVwiOmNhc2UgXCJwbGF5XCI6Y2FzZSBcInBvaW50ZXJjYW5jZWxcIjpjYXNlIFwicG9pbnRlcmRvd25cIjpjYXNlIFwicG9pbnRlcnVwXCI6Y2FzZSBcInJhdGVjaGFuZ2VcIjpjYXNlIFwicmVzZXRcIjpjYXNlIFwicmVzaXplXCI6Y2FzZSBcInNlZWtlZFwiOmNhc2UgXCJzdWJtaXRcIjpjYXNlIFwidG91Y2hjYW5jZWxcIjpjYXNlIFwidG91Y2hlbmRcIjpjYXNlIFwidG91Y2hzdGFydFwiOmNhc2UgXCJ2b2x1bWVjaGFuZ2VcIjpjYXNlIFwiY2hhbmdlXCI6Y2FzZSBcInNlbGVjdGlvbmNoYW5nZVwiOmNhc2UgXCJ0ZXh0SW5wdXRcIjpjYXNlIFwiY29tcG9zaXRpb25zdGFydFwiOmNhc2UgXCJjb21wb3NpdGlvbmVuZFwiOmNhc2UgXCJjb21wb3NpdGlvbnVwZGF0ZVwiOmNhc2UgXCJiZWZvcmVibHVyXCI6Y2FzZSBcImFmdGVyYmx1clwiOmNhc2UgXCJiZWZvcmVpbnB1dFwiOmNhc2UgXCJibHVyXCI6Y2FzZSBcImZ1bGxzY3JlZW5jaGFuZ2VcIjpjYXNlIFwiZm9jdXNcIjpjYXNlIFwiaGFzaGNoYW5nZVwiOmNhc2UgXCJwb3BzdGF0ZVwiOmNhc2UgXCJzZWxlY3RcIjpjYXNlIFwic2VsZWN0c3RhcnRcIjpyZXR1cm4gMTtjYXNlIFwiZHJhZ1wiOmNhc2UgXCJkcmFnZW50ZXJcIjpjYXNlIFwiZHJhZ2V4aXRcIjpjYXNlIFwiZHJhZ2xlYXZlXCI6Y2FzZSBcImRyYWdvdmVyXCI6Y2FzZSBcIm1vdXNlbW92ZVwiOmNhc2UgXCJtb3VzZW91dFwiOmNhc2UgXCJtb3VzZW92ZXJcIjpjYXNlIFwicG9pbnRlcm1vdmVcIjpjYXNlIFwicG9pbnRlcm91dFwiOmNhc2UgXCJwb2ludGVyb3ZlclwiOmNhc2UgXCJzY3JvbGxcIjpjYXNlIFwidG9nZ2xlXCI6Y2FzZSBcInRvdWNobW92ZVwiOmNhc2UgXCJ3aGVlbFwiOmNhc2UgXCJtb3VzZWVudGVyXCI6Y2FzZSBcIm1vdXNlbGVhdmVcIjpjYXNlIFwicG9pbnRlcmVudGVyXCI6Y2FzZSBcInBvaW50ZXJsZWF2ZVwiOnJldHVybiA0O1xuY2FzZSBcIm1lc3NhZ2VcIjpzd2l0Y2goZGMoKSl7Y2FzZSBlYzpyZXR1cm4gMTtjYXNlIGZjOnJldHVybiA0O2Nhc2UgZ2M6Y2FzZSBoYzpyZXR1cm4gMTY7Y2FzZSBpYzpyZXR1cm4gNTM2ODcwOTEyO2RlZmF1bHQ6cmV0dXJuIDE2fWRlZmF1bHQ6cmV0dXJuIDE2fX12YXIgamQ9bnVsbCxrZD1udWxsLGxkPW51bGw7ZnVuY3Rpb24gbWQoKXtpZihsZClyZXR1cm4gbGQ7dmFyIGEsYj1rZCxjPWIubGVuZ3RoLGQsZT1cInZhbHVlXCJpbiBqZD9qZC52YWx1ZTpqZC50ZXh0Q29udGVudCxmPWUubGVuZ3RoO2ZvcihhPTA7YTxjJiZiW2FdPT09ZVthXTthKyspO3ZhciBnPWMtYTtmb3IoZD0xO2Q8PWcmJmJbYy1kXT09PWVbZi1kXTtkKyspO3JldHVybiBsZD1lLnNsaWNlKGEsMTxkPzEtZDp2b2lkIDApfVxuZnVuY3Rpb24gbmQoYSl7dmFyIGI9YS5rZXlDb2RlO1wiY2hhckNvZGVcImluIGE/KGE9YS5jaGFyQ29kZSwwPT09YSYmMTM9PT1iJiYoYT0xMykpOmE9YjsxMD09PWEmJihhPTEzKTtyZXR1cm4gMzI8PWF8fDEzPT09YT9hOjB9ZnVuY3Rpb24gb2QoKXtyZXR1cm4hMH1mdW5jdGlvbiBwZCgpe3JldHVybiExfVxuZnVuY3Rpb24gcWQoYSl7ZnVuY3Rpb24gYihiLGQsZSxmLGcpe3RoaXMuX3JlYWN0TmFtZT1iO3RoaXMuX3RhcmdldEluc3Q9ZTt0aGlzLnR5cGU9ZDt0aGlzLm5hdGl2ZUV2ZW50PWY7dGhpcy50YXJnZXQ9Zzt0aGlzLmN1cnJlbnRUYXJnZXQ9bnVsbDtmb3IodmFyIGMgaW4gYSlhLmhhc093blByb3BlcnR5KGMpJiYoYj1hW2NdLHRoaXNbY109Yj9iKGYpOmZbY10pO3RoaXMuaXNEZWZhdWx0UHJldmVudGVkPShudWxsIT1mLmRlZmF1bHRQcmV2ZW50ZWQ/Zi5kZWZhdWx0UHJldmVudGVkOiExPT09Zi5yZXR1cm5WYWx1ZSk/b2Q6cGQ7dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZD1wZDtyZXR1cm4gdGhpc31BKGIucHJvdG90eXBlLHtwcmV2ZW50RGVmYXVsdDpmdW5jdGlvbigpe3RoaXMuZGVmYXVsdFByZXZlbnRlZD0hMDt2YXIgYT10aGlzLm5hdGl2ZUV2ZW50O2EmJihhLnByZXZlbnREZWZhdWx0P2EucHJldmVudERlZmF1bHQoKTpcInVua25vd25cIiE9PXR5cGVvZiBhLnJldHVyblZhbHVlJiZcbihhLnJldHVyblZhbHVlPSExKSx0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD1vZCl9LHN0b3BQcm9wYWdhdGlvbjpmdW5jdGlvbigpe3ZhciBhPXRoaXMubmF0aXZlRXZlbnQ7YSYmKGEuc3RvcFByb3BhZ2F0aW9uP2Euc3RvcFByb3BhZ2F0aW9uKCk6XCJ1bmtub3duXCIhPT10eXBlb2YgYS5jYW5jZWxCdWJibGUmJihhLmNhbmNlbEJ1YmJsZT0hMCksdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZD1vZCl9LHBlcnNpc3Q6ZnVuY3Rpb24oKXt9LGlzUGVyc2lzdGVudDpvZH0pO3JldHVybiBifVxudmFyIHJkPXtldmVudFBoYXNlOjAsYnViYmxlczowLGNhbmNlbGFibGU6MCx0aW1lU3RhbXA6ZnVuY3Rpb24oYSl7cmV0dXJuIGEudGltZVN0YW1wfHxEYXRlLm5vdygpfSxkZWZhdWx0UHJldmVudGVkOjAsaXNUcnVzdGVkOjB9LHNkPXFkKHJkKSx0ZD1BKHt9LHJkLHt2aWV3OjAsZGV0YWlsOjB9KSx1ZD1xZCh0ZCksdmQsd2QseGQsemQ9QSh7fSx0ZCx7c2NyZWVuWDowLHNjcmVlblk6MCxjbGllbnRYOjAsY2xpZW50WTowLHBhZ2VYOjAscGFnZVk6MCxjdHJsS2V5OjAsc2hpZnRLZXk6MCxhbHRLZXk6MCxtZXRhS2V5OjAsZ2V0TW9kaWZpZXJTdGF0ZTp5ZCxidXR0b246MCxidXR0b25zOjAscmVsYXRlZFRhcmdldDpmdW5jdGlvbihhKXtyZXR1cm4gdm9pZCAwPT09YS5yZWxhdGVkVGFyZ2V0P2EuZnJvbUVsZW1lbnQ9PT1hLnNyY0VsZW1lbnQ/YS50b0VsZW1lbnQ6YS5mcm9tRWxlbWVudDphLnJlbGF0ZWRUYXJnZXR9LG1vdmVtZW50WDpmdW5jdGlvbihhKXtpZihcIm1vdmVtZW50WFwiaW5cbmEpcmV0dXJuIGEubW92ZW1lbnRYO2EhPT14ZCYmKHhkJiZcIm1vdXNlbW92ZVwiPT09YS50eXBlPyh2ZD1hLnNjcmVlblgteGQuc2NyZWVuWCx3ZD1hLnNjcmVlblkteGQuc2NyZWVuWSk6d2Q9dmQ9MCx4ZD1hKTtyZXR1cm4gdmR9LG1vdmVtZW50WTpmdW5jdGlvbihhKXtyZXR1cm5cIm1vdmVtZW50WVwiaW4gYT9hLm1vdmVtZW50WTp3ZH19KSxBZD1xZCh6ZCksQmQ9QSh7fSx6ZCx7ZGF0YVRyYW5zZmVyOjB9KSxDZD1xZChCZCksRGQ9QSh7fSx0ZCx7cmVsYXRlZFRhcmdldDowfSksRWQ9cWQoRGQpLEZkPUEoe30scmQse2FuaW1hdGlvbk5hbWU6MCxlbGFwc2VkVGltZTowLHBzZXVkb0VsZW1lbnQ6MH0pLEdkPXFkKEZkKSxIZD1BKHt9LHJkLHtjbGlwYm9hcmREYXRhOmZ1bmN0aW9uKGEpe3JldHVyblwiY2xpcGJvYXJkRGF0YVwiaW4gYT9hLmNsaXBib2FyZERhdGE6d2luZG93LmNsaXBib2FyZERhdGF9fSksSWQ9cWQoSGQpLEpkPUEoe30scmQse2RhdGE6MH0pLEtkPXFkKEpkKSxMZD17RXNjOlwiRXNjYXBlXCIsXG5TcGFjZWJhcjpcIiBcIixMZWZ0OlwiQXJyb3dMZWZ0XCIsVXA6XCJBcnJvd1VwXCIsUmlnaHQ6XCJBcnJvd1JpZ2h0XCIsRG93bjpcIkFycm93RG93blwiLERlbDpcIkRlbGV0ZVwiLFdpbjpcIk9TXCIsTWVudTpcIkNvbnRleHRNZW51XCIsQXBwczpcIkNvbnRleHRNZW51XCIsU2Nyb2xsOlwiU2Nyb2xsTG9ja1wiLE1velByaW50YWJsZUtleTpcIlVuaWRlbnRpZmllZFwifSxNZD17ODpcIkJhY2tzcGFjZVwiLDk6XCJUYWJcIiwxMjpcIkNsZWFyXCIsMTM6XCJFbnRlclwiLDE2OlwiU2hpZnRcIiwxNzpcIkNvbnRyb2xcIiwxODpcIkFsdFwiLDE5OlwiUGF1c2VcIiwyMDpcIkNhcHNMb2NrXCIsMjc6XCJFc2NhcGVcIiwzMjpcIiBcIiwzMzpcIlBhZ2VVcFwiLDM0OlwiUGFnZURvd25cIiwzNTpcIkVuZFwiLDM2OlwiSG9tZVwiLDM3OlwiQXJyb3dMZWZ0XCIsMzg6XCJBcnJvd1VwXCIsMzk6XCJBcnJvd1JpZ2h0XCIsNDA6XCJBcnJvd0Rvd25cIiw0NTpcIkluc2VydFwiLDQ2OlwiRGVsZXRlXCIsMTEyOlwiRjFcIiwxMTM6XCJGMlwiLDExNDpcIkYzXCIsMTE1OlwiRjRcIiwxMTY6XCJGNVwiLDExNzpcIkY2XCIsMTE4OlwiRjdcIixcbjExOTpcIkY4XCIsMTIwOlwiRjlcIiwxMjE6XCJGMTBcIiwxMjI6XCJGMTFcIiwxMjM6XCJGMTJcIiwxNDQ6XCJOdW1Mb2NrXCIsMTQ1OlwiU2Nyb2xsTG9ja1wiLDIyNDpcIk1ldGFcIn0sTmQ9e0FsdDpcImFsdEtleVwiLENvbnRyb2w6XCJjdHJsS2V5XCIsTWV0YTpcIm1ldGFLZXlcIixTaGlmdDpcInNoaWZ0S2V5XCJ9O2Z1bmN0aW9uIE9kKGEpe3ZhciBiPXRoaXMubmF0aXZlRXZlbnQ7cmV0dXJuIGIuZ2V0TW9kaWZpZXJTdGF0ZT9iLmdldE1vZGlmaWVyU3RhdGUoYSk6KGE9TmRbYV0pPyEhYlthXTohMX1mdW5jdGlvbiB5ZCgpe3JldHVybiBPZH1cbnZhciBQZD1BKHt9LHRkLHtrZXk6ZnVuY3Rpb24oYSl7aWYoYS5rZXkpe3ZhciBiPUxkW2Eua2V5XXx8YS5rZXk7aWYoXCJVbmlkZW50aWZpZWRcIiE9PWIpcmV0dXJuIGJ9cmV0dXJuXCJrZXlwcmVzc1wiPT09YS50eXBlPyhhPW5kKGEpLDEzPT09YT9cIkVudGVyXCI6U3RyaW5nLmZyb21DaGFyQ29kZShhKSk6XCJrZXlkb3duXCI9PT1hLnR5cGV8fFwia2V5dXBcIj09PWEudHlwZT9NZFthLmtleUNvZGVdfHxcIlVuaWRlbnRpZmllZFwiOlwiXCJ9LGNvZGU6MCxsb2NhdGlvbjowLGN0cmxLZXk6MCxzaGlmdEtleTowLGFsdEtleTowLG1ldGFLZXk6MCxyZXBlYXQ6MCxsb2NhbGU6MCxnZXRNb2RpZmllclN0YXRlOnlkLGNoYXJDb2RlOmZ1bmN0aW9uKGEpe3JldHVyblwia2V5cHJlc3NcIj09PWEudHlwZT9uZChhKTowfSxrZXlDb2RlOmZ1bmN0aW9uKGEpe3JldHVyblwia2V5ZG93blwiPT09YS50eXBlfHxcImtleXVwXCI9PT1hLnR5cGU/YS5rZXlDb2RlOjB9LHdoaWNoOmZ1bmN0aW9uKGEpe3JldHVyblwia2V5cHJlc3NcIj09PVxuYS50eXBlP25kKGEpOlwia2V5ZG93blwiPT09YS50eXBlfHxcImtleXVwXCI9PT1hLnR5cGU/YS5rZXlDb2RlOjB9fSksUWQ9cWQoUGQpLFJkPUEoe30semQse3BvaW50ZXJJZDowLHdpZHRoOjAsaGVpZ2h0OjAscHJlc3N1cmU6MCx0YW5nZW50aWFsUHJlc3N1cmU6MCx0aWx0WDowLHRpbHRZOjAsdHdpc3Q6MCxwb2ludGVyVHlwZTowLGlzUHJpbWFyeTowfSksU2Q9cWQoUmQpLFRkPUEoe30sdGQse3RvdWNoZXM6MCx0YXJnZXRUb3VjaGVzOjAsY2hhbmdlZFRvdWNoZXM6MCxhbHRLZXk6MCxtZXRhS2V5OjAsY3RybEtleTowLHNoaWZ0S2V5OjAsZ2V0TW9kaWZpZXJTdGF0ZTp5ZH0pLFVkPXFkKFRkKSxWZD1BKHt9LHJkLHtwcm9wZXJ0eU5hbWU6MCxlbGFwc2VkVGltZTowLHBzZXVkb0VsZW1lbnQ6MH0pLFdkPXFkKFZkKSxYZD1BKHt9LHpkLHtkZWx0YVg6ZnVuY3Rpb24oYSl7cmV0dXJuXCJkZWx0YVhcImluIGE/YS5kZWx0YVg6XCJ3aGVlbERlbHRhWFwiaW4gYT8tYS53aGVlbERlbHRhWDowfSxcbmRlbHRhWTpmdW5jdGlvbihhKXtyZXR1cm5cImRlbHRhWVwiaW4gYT9hLmRlbHRhWTpcIndoZWVsRGVsdGFZXCJpbiBhPy1hLndoZWVsRGVsdGFZOlwid2hlZWxEZWx0YVwiaW4gYT8tYS53aGVlbERlbHRhOjB9LGRlbHRhWjowLGRlbHRhTW9kZTowfSksWWQ9cWQoWGQpLFpkPVs5LDEzLDI3LDMyXSwkZD1pYSYmXCJDb21wb3NpdGlvbkV2ZW50XCJpbiB3aW5kb3csYWU9bnVsbDtpYSYmXCJkb2N1bWVudE1vZGVcImluIGRvY3VtZW50JiYoYWU9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKTt2YXIgYmU9aWEmJlwiVGV4dEV2ZW50XCJpbiB3aW5kb3cmJiFhZSxjZT1pYSYmKCEkZHx8YWUmJjg8YWUmJjExPj1hZSksZGU9U3RyaW5nLmZyb21DaGFyQ29kZSgzMiksZWU9ITE7XG5mdW5jdGlvbiBmZShhLGIpe3N3aXRjaChhKXtjYXNlIFwia2V5dXBcIjpyZXR1cm4tMSE9PVpkLmluZGV4T2YoYi5rZXlDb2RlKTtjYXNlIFwia2V5ZG93blwiOnJldHVybiAyMjkhPT1iLmtleUNvZGU7Y2FzZSBcImtleXByZXNzXCI6Y2FzZSBcIm1vdXNlZG93blwiOmNhc2UgXCJmb2N1c291dFwiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fWZ1bmN0aW9uIGdlKGEpe2E9YS5kZXRhaWw7cmV0dXJuXCJvYmplY3RcIj09PXR5cGVvZiBhJiZcImRhdGFcImluIGE/YS5kYXRhOm51bGx9dmFyIGhlPSExO2Z1bmN0aW9uIGllKGEsYil7c3dpdGNoKGEpe2Nhc2UgXCJjb21wb3NpdGlvbmVuZFwiOnJldHVybiBnZShiKTtjYXNlIFwia2V5cHJlc3NcIjppZigzMiE9PWIud2hpY2gpcmV0dXJuIG51bGw7ZWU9ITA7cmV0dXJuIGRlO2Nhc2UgXCJ0ZXh0SW5wdXRcIjpyZXR1cm4gYT1iLmRhdGEsYT09PWRlJiZlZT9udWxsOmE7ZGVmYXVsdDpyZXR1cm4gbnVsbH19XG5mdW5jdGlvbiBqZShhLGIpe2lmKGhlKXJldHVyblwiY29tcG9zaXRpb25lbmRcIj09PWF8fCEkZCYmZmUoYSxiKT8oYT1tZCgpLGxkPWtkPWpkPW51bGwsaGU9ITEsYSk6bnVsbDtzd2l0Y2goYSl7Y2FzZSBcInBhc3RlXCI6cmV0dXJuIG51bGw7Y2FzZSBcImtleXByZXNzXCI6aWYoIShiLmN0cmxLZXl8fGIuYWx0S2V5fHxiLm1ldGFLZXkpfHxiLmN0cmxLZXkmJmIuYWx0S2V5KXtpZihiLmNoYXImJjE8Yi5jaGFyLmxlbmd0aClyZXR1cm4gYi5jaGFyO2lmKGIud2hpY2gpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYi53aGljaCl9cmV0dXJuIG51bGw7Y2FzZSBcImNvbXBvc2l0aW9uZW5kXCI6cmV0dXJuIGNlJiZcImtvXCIhPT1iLmxvY2FsZT9udWxsOmIuZGF0YTtkZWZhdWx0OnJldHVybiBudWxsfX1cbnZhciBrZT17Y29sb3I6ITAsZGF0ZTohMCxkYXRldGltZTohMCxcImRhdGV0aW1lLWxvY2FsXCI6ITAsZW1haWw6ITAsbW9udGg6ITAsbnVtYmVyOiEwLHBhc3N3b3JkOiEwLHJhbmdlOiEwLHNlYXJjaDohMCx0ZWw6ITAsdGV4dDohMCx0aW1lOiEwLHVybDohMCx3ZWVrOiEwfTtmdW5jdGlvbiBsZShhKXt2YXIgYj1hJiZhLm5vZGVOYW1lJiZhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCJpbnB1dFwiPT09Yj8hIWtlW2EudHlwZV06XCJ0ZXh0YXJlYVwiPT09Yj8hMDohMX1mdW5jdGlvbiBtZShhLGIsYyxkKXtEYihkKTtiPW5lKGIsXCJvbkNoYW5nZVwiKTswPGIubGVuZ3RoJiYoYz1uZXcgc2QoXCJvbkNoYW5nZVwiLFwiY2hhbmdlXCIsbnVsbCxjLGQpLGEucHVzaCh7ZXZlbnQ6YyxsaXN0ZW5lcnM6Yn0pKX12YXIgb2U9bnVsbCxwZT1udWxsO2Z1bmN0aW9uIHFlKGEpe3JlKGEsMCl9ZnVuY3Rpb24gc2UoYSl7dmFyIGI9dGUoYSk7aWYoVmEoYikpcmV0dXJuIGF9XG5mdW5jdGlvbiB1ZShhLGIpe2lmKFwiY2hhbmdlXCI9PT1hKXJldHVybiBifXZhciB2ZT0hMTtpZihpYSl7dmFyIHdlO2lmKGlhKXt2YXIgeGU9XCJvbmlucHV0XCJpbiBkb2N1bWVudDtpZigheGUpe3ZhciB5ZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3llLnNldEF0dHJpYnV0ZShcIm9uaW5wdXRcIixcInJldHVybjtcIik7eGU9XCJmdW5jdGlvblwiPT09dHlwZW9mIHllLm9uaW5wdXR9d2U9eGV9ZWxzZSB3ZT0hMTt2ZT13ZSYmKCFkb2N1bWVudC5kb2N1bWVudE1vZGV8fDk8ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKX1mdW5jdGlvbiB6ZSgpe29lJiYob2UuZGV0YWNoRXZlbnQoXCJvbnByb3BlcnR5Y2hhbmdlXCIsQWUpLHBlPW9lPW51bGwpfWZ1bmN0aW9uIEFlKGEpe2lmKFwidmFsdWVcIj09PWEucHJvcGVydHlOYW1lJiZzZShwZSkpe3ZhciBiPVtdO21lKGIscGUsYSx3YihhKSk7SWIocWUsYil9fVxuZnVuY3Rpb24gQmUoYSxiLGMpe1wiZm9jdXNpblwiPT09YT8oemUoKSxvZT1iLHBlPWMsb2UuYXR0YWNoRXZlbnQoXCJvbnByb3BlcnR5Y2hhbmdlXCIsQWUpKTpcImZvY3Vzb3V0XCI9PT1hJiZ6ZSgpfWZ1bmN0aW9uIENlKGEpe2lmKFwic2VsZWN0aW9uY2hhbmdlXCI9PT1hfHxcImtleXVwXCI9PT1hfHxcImtleWRvd25cIj09PWEpcmV0dXJuIHNlKHBlKX1mdW5jdGlvbiBEZShhLGIpe2lmKFwiY2xpY2tcIj09PWEpcmV0dXJuIHNlKGIpfWZ1bmN0aW9uIEVlKGEsYil7aWYoXCJpbnB1dFwiPT09YXx8XCJjaGFuZ2VcIj09PWEpcmV0dXJuIHNlKGIpfWZ1bmN0aW9uIEZlKGEsYil7cmV0dXJuIGE9PT1iJiYoMCE9PWF8fDEvYT09PTEvYil8fGEhPT1hJiZiIT09Yn12YXIgR2U9XCJmdW5jdGlvblwiPT09dHlwZW9mIE9iamVjdC5pcz9PYmplY3QuaXM6RmU7XG5mdW5jdGlvbiBIZShhLGIpe2lmKEdlKGEsYikpcmV0dXJuITA7aWYoXCJvYmplY3RcIiE9PXR5cGVvZiBhfHxudWxsPT09YXx8XCJvYmplY3RcIiE9PXR5cGVvZiBifHxudWxsPT09YilyZXR1cm4hMTt2YXIgYz1PYmplY3Qua2V5cyhhKSxkPU9iamVjdC5rZXlzKGIpO2lmKGMubGVuZ3RoIT09ZC5sZW5ndGgpcmV0dXJuITE7Zm9yKGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGU9Y1tkXTtpZighamEuY2FsbChiLGUpfHwhR2UoYVtlXSxiW2VdKSlyZXR1cm4hMX1yZXR1cm4hMH1mdW5jdGlvbiBJZShhKXtmb3IoO2EmJmEuZmlyc3RDaGlsZDspYT1hLmZpcnN0Q2hpbGQ7cmV0dXJuIGF9XG5mdW5jdGlvbiBKZShhLGIpe3ZhciBjPUllKGEpO2E9MDtmb3IodmFyIGQ7Yzspe2lmKDM9PT1jLm5vZGVUeXBlKXtkPWErYy50ZXh0Q29udGVudC5sZW5ndGg7aWYoYTw9YiYmZD49YilyZXR1cm57bm9kZTpjLG9mZnNldDpiLWF9O2E9ZH1hOntmb3IoO2M7KXtpZihjLm5leHRTaWJsaW5nKXtjPWMubmV4dFNpYmxpbmc7YnJlYWsgYX1jPWMucGFyZW50Tm9kZX1jPXZvaWQgMH1jPUllKGMpfX1mdW5jdGlvbiBLZShhLGIpe3JldHVybiBhJiZiP2E9PT1iPyEwOmEmJjM9PT1hLm5vZGVUeXBlPyExOmImJjM9PT1iLm5vZGVUeXBlP0tlKGEsYi5wYXJlbnROb2RlKTpcImNvbnRhaW5zXCJpbiBhP2EuY29udGFpbnMoYik6YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbj8hIShhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpJjE2KTohMTohMX1cbmZ1bmN0aW9uIExlKCl7Zm9yKHZhciBhPXdpbmRvdyxiPVdhKCk7YiBpbnN0YW5jZW9mIGEuSFRNTElGcmFtZUVsZW1lbnQ7KXt0cnl7dmFyIGM9XCJzdHJpbmdcIj09PXR5cGVvZiBiLmNvbnRlbnRXaW5kb3cubG9jYXRpb24uaHJlZn1jYXRjaChkKXtjPSExfWlmKGMpYT1iLmNvbnRlbnRXaW5kb3c7ZWxzZSBicmVhaztiPVdhKGEuZG9jdW1lbnQpfXJldHVybiBifWZ1bmN0aW9uIE1lKGEpe3ZhciBiPWEmJmEubm9kZU5hbWUmJmEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gYiYmKFwiaW5wdXRcIj09PWImJihcInRleHRcIj09PWEudHlwZXx8XCJzZWFyY2hcIj09PWEudHlwZXx8XCJ0ZWxcIj09PWEudHlwZXx8XCJ1cmxcIj09PWEudHlwZXx8XCJwYXNzd29yZFwiPT09YS50eXBlKXx8XCJ0ZXh0YXJlYVwiPT09Ynx8XCJ0cnVlXCI9PT1hLmNvbnRlbnRFZGl0YWJsZSl9XG5mdW5jdGlvbiBOZShhKXt2YXIgYj1MZSgpLGM9YS5mb2N1c2VkRWxlbSxkPWEuc2VsZWN0aW9uUmFuZ2U7aWYoYiE9PWMmJmMmJmMub3duZXJEb2N1bWVudCYmS2UoYy5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxjKSl7aWYobnVsbCE9PWQmJk1lKGMpKWlmKGI9ZC5zdGFydCxhPWQuZW5kLHZvaWQgMD09PWEmJihhPWIpLFwic2VsZWN0aW9uU3RhcnRcImluIGMpYy5zZWxlY3Rpb25TdGFydD1iLGMuc2VsZWN0aW9uRW5kPU1hdGgubWluKGEsYy52YWx1ZS5sZW5ndGgpO2Vsc2UgaWYoYT0oYj1jLm93bmVyRG9jdW1lbnR8fGRvY3VtZW50KSYmYi5kZWZhdWx0Vmlld3x8d2luZG93LGEuZ2V0U2VsZWN0aW9uKXthPWEuZ2V0U2VsZWN0aW9uKCk7dmFyIGU9Yy50ZXh0Q29udGVudC5sZW5ndGgsZj1NYXRoLm1pbihkLnN0YXJ0LGUpO2Q9dm9pZCAwPT09ZC5lbmQ/ZjpNYXRoLm1pbihkLmVuZCxlKTshYS5leHRlbmQmJmY+ZCYmKGU9ZCxkPWYsZj1lKTtlPUplKGMsZik7dmFyIGc9SmUoYyxcbmQpO2UmJmcmJigxIT09YS5yYW5nZUNvdW50fHxhLmFuY2hvck5vZGUhPT1lLm5vZGV8fGEuYW5jaG9yT2Zmc2V0IT09ZS5vZmZzZXR8fGEuZm9jdXNOb2RlIT09Zy5ub2RlfHxhLmZvY3VzT2Zmc2V0IT09Zy5vZmZzZXQpJiYoYj1iLmNyZWF0ZVJhbmdlKCksYi5zZXRTdGFydChlLm5vZGUsZS5vZmZzZXQpLGEucmVtb3ZlQWxsUmFuZ2VzKCksZj5kPyhhLmFkZFJhbmdlKGIpLGEuZXh0ZW5kKGcubm9kZSxnLm9mZnNldCkpOihiLnNldEVuZChnLm5vZGUsZy5vZmZzZXQpLGEuYWRkUmFuZ2UoYikpKX1iPVtdO2ZvcihhPWM7YT1hLnBhcmVudE5vZGU7KTE9PT1hLm5vZGVUeXBlJiZiLnB1c2goe2VsZW1lbnQ6YSxsZWZ0OmEuc2Nyb2xsTGVmdCx0b3A6YS5zY3JvbGxUb3B9KTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgYy5mb2N1cyYmYy5mb2N1cygpO2ZvcihjPTA7YzxiLmxlbmd0aDtjKyspYT1iW2NdLGEuZWxlbWVudC5zY3JvbGxMZWZ0PWEubGVmdCxhLmVsZW1lbnQuc2Nyb2xsVG9wPWEudG9wfX1cbnZhciBPZT1pYSYmXCJkb2N1bWVudE1vZGVcImluIGRvY3VtZW50JiYxMT49ZG9jdW1lbnQuZG9jdW1lbnRNb2RlLFBlPW51bGwsUWU9bnVsbCxSZT1udWxsLFNlPSExO1xuZnVuY3Rpb24gVGUoYSxiLGMpe3ZhciBkPWMud2luZG93PT09Yz9jLmRvY3VtZW50Ojk9PT1jLm5vZGVUeXBlP2M6Yy5vd25lckRvY3VtZW50O1NlfHxudWxsPT1QZXx8UGUhPT1XYShkKXx8KGQ9UGUsXCJzZWxlY3Rpb25TdGFydFwiaW4gZCYmTWUoZCk/ZD17c3RhcnQ6ZC5zZWxlY3Rpb25TdGFydCxlbmQ6ZC5zZWxlY3Rpb25FbmR9OihkPShkLm93bmVyRG9jdW1lbnQmJmQub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlld3x8d2luZG93KS5nZXRTZWxlY3Rpb24oKSxkPXthbmNob3JOb2RlOmQuYW5jaG9yTm9kZSxhbmNob3JPZmZzZXQ6ZC5hbmNob3JPZmZzZXQsZm9jdXNOb2RlOmQuZm9jdXNOb2RlLGZvY3VzT2Zmc2V0OmQuZm9jdXNPZmZzZXR9KSxSZSYmSGUoUmUsZCl8fChSZT1kLGQ9bmUoUWUsXCJvblNlbGVjdFwiKSwwPGQubGVuZ3RoJiYoYj1uZXcgc2QoXCJvblNlbGVjdFwiLFwic2VsZWN0XCIsbnVsbCxiLGMpLGEucHVzaCh7ZXZlbnQ6YixsaXN0ZW5lcnM6ZH0pLGIudGFyZ2V0PVBlKSkpfVxuZnVuY3Rpb24gVWUoYSxiKXt2YXIgYz17fTtjW2EudG9Mb3dlckNhc2UoKV09Yi50b0xvd2VyQ2FzZSgpO2NbXCJXZWJraXRcIithXT1cIndlYmtpdFwiK2I7Y1tcIk1velwiK2FdPVwibW96XCIrYjtyZXR1cm4gY312YXIgVmU9e2FuaW1hdGlvbmVuZDpVZShcIkFuaW1hdGlvblwiLFwiQW5pbWF0aW9uRW5kXCIpLGFuaW1hdGlvbml0ZXJhdGlvbjpVZShcIkFuaW1hdGlvblwiLFwiQW5pbWF0aW9uSXRlcmF0aW9uXCIpLGFuaW1hdGlvbnN0YXJ0OlVlKFwiQW5pbWF0aW9uXCIsXCJBbmltYXRpb25TdGFydFwiKSx0cmFuc2l0aW9uZW5kOlVlKFwiVHJhbnNpdGlvblwiLFwiVHJhbnNpdGlvbkVuZFwiKX0sV2U9e30sWGU9e307XG5pYSYmKFhlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuc3R5bGUsXCJBbmltYXRpb25FdmVudFwiaW4gd2luZG93fHwoZGVsZXRlIFZlLmFuaW1hdGlvbmVuZC5hbmltYXRpb24sZGVsZXRlIFZlLmFuaW1hdGlvbml0ZXJhdGlvbi5hbmltYXRpb24sZGVsZXRlIFZlLmFuaW1hdGlvbnN0YXJ0LmFuaW1hdGlvbiksXCJUcmFuc2l0aW9uRXZlbnRcImluIHdpbmRvd3x8ZGVsZXRlIFZlLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbik7ZnVuY3Rpb24gWWUoYSl7aWYoV2VbYV0pcmV0dXJuIFdlW2FdO2lmKCFWZVthXSlyZXR1cm4gYTt2YXIgYj1WZVthXSxjO2ZvcihjIGluIGIpaWYoYi5oYXNPd25Qcm9wZXJ0eShjKSYmYyBpbiBYZSlyZXR1cm4gV2VbYV09YltjXTtyZXR1cm4gYX12YXIgWmU9WWUoXCJhbmltYXRpb25lbmRcIiksJGU9WWUoXCJhbmltYXRpb25pdGVyYXRpb25cIiksYWY9WWUoXCJhbmltYXRpb25zdGFydFwiKSxiZj1ZZShcInRyYW5zaXRpb25lbmRcIiksY2Y9bmV3IE1hcCxkZj1cImFib3J0IGF1eENsaWNrIGNhbmNlbCBjYW5QbGF5IGNhblBsYXlUaHJvdWdoIGNsaWNrIGNsb3NlIGNvbnRleHRNZW51IGNvcHkgY3V0IGRyYWcgZHJhZ0VuZCBkcmFnRW50ZXIgZHJhZ0V4aXQgZHJhZ0xlYXZlIGRyYWdPdmVyIGRyYWdTdGFydCBkcm9wIGR1cmF0aW9uQ2hhbmdlIGVtcHRpZWQgZW5jcnlwdGVkIGVuZGVkIGVycm9yIGdvdFBvaW50ZXJDYXB0dXJlIGlucHV0IGludmFsaWQga2V5RG93biBrZXlQcmVzcyBrZXlVcCBsb2FkIGxvYWRlZERhdGEgbG9hZGVkTWV0YWRhdGEgbG9hZFN0YXJ0IGxvc3RQb2ludGVyQ2FwdHVyZSBtb3VzZURvd24gbW91c2VNb3ZlIG1vdXNlT3V0IG1vdXNlT3ZlciBtb3VzZVVwIHBhc3RlIHBhdXNlIHBsYXkgcGxheWluZyBwb2ludGVyQ2FuY2VsIHBvaW50ZXJEb3duIHBvaW50ZXJNb3ZlIHBvaW50ZXJPdXQgcG9pbnRlck92ZXIgcG9pbnRlclVwIHByb2dyZXNzIHJhdGVDaGFuZ2UgcmVzZXQgcmVzaXplIHNlZWtlZCBzZWVraW5nIHN0YWxsZWQgc3VibWl0IHN1c3BlbmQgdGltZVVwZGF0ZSB0b3VjaENhbmNlbCB0b3VjaEVuZCB0b3VjaFN0YXJ0IHZvbHVtZUNoYW5nZSBzY3JvbGwgdG9nZ2xlIHRvdWNoTW92ZSB3YWl0aW5nIHdoZWVsXCIuc3BsaXQoXCIgXCIpO1xuZnVuY3Rpb24gZWYoYSxiKXtjZi5zZXQoYSxiKTtmYShiLFthXSl9Zm9yKHZhciBmZj0wO2ZmPGRmLmxlbmd0aDtmZisrKXt2YXIgZ2Y9ZGZbZmZdLGhmPWdmLnRvTG93ZXJDYXNlKCksamY9Z2ZbMF0udG9VcHBlckNhc2UoKStnZi5zbGljZSgxKTtlZihoZixcIm9uXCIramYpfWVmKFplLFwib25BbmltYXRpb25FbmRcIik7ZWYoJGUsXCJvbkFuaW1hdGlvbkl0ZXJhdGlvblwiKTtlZihhZixcIm9uQW5pbWF0aW9uU3RhcnRcIik7ZWYoXCJkYmxjbGlja1wiLFwib25Eb3VibGVDbGlja1wiKTtlZihcImZvY3VzaW5cIixcIm9uRm9jdXNcIik7ZWYoXCJmb2N1c291dFwiLFwib25CbHVyXCIpO2VmKGJmLFwib25UcmFuc2l0aW9uRW5kXCIpO2hhKFwib25Nb3VzZUVudGVyXCIsW1wibW91c2VvdXRcIixcIm1vdXNlb3ZlclwiXSk7aGEoXCJvbk1vdXNlTGVhdmVcIixbXCJtb3VzZW91dFwiLFwibW91c2VvdmVyXCJdKTtoYShcIm9uUG9pbnRlckVudGVyXCIsW1wicG9pbnRlcm91dFwiLFwicG9pbnRlcm92ZXJcIl0pO1xuaGEoXCJvblBvaW50ZXJMZWF2ZVwiLFtcInBvaW50ZXJvdXRcIixcInBvaW50ZXJvdmVyXCJdKTtmYShcIm9uQ2hhbmdlXCIsXCJjaGFuZ2UgY2xpY2sgZm9jdXNpbiBmb2N1c291dCBpbnB1dCBrZXlkb3duIGtleXVwIHNlbGVjdGlvbmNoYW5nZVwiLnNwbGl0KFwiIFwiKSk7ZmEoXCJvblNlbGVjdFwiLFwiZm9jdXNvdXQgY29udGV4dG1lbnUgZHJhZ2VuZCBmb2N1c2luIGtleWRvd24ga2V5dXAgbW91c2Vkb3duIG1vdXNldXAgc2VsZWN0aW9uY2hhbmdlXCIuc3BsaXQoXCIgXCIpKTtmYShcIm9uQmVmb3JlSW5wdXRcIixbXCJjb21wb3NpdGlvbmVuZFwiLFwia2V5cHJlc3NcIixcInRleHRJbnB1dFwiLFwicGFzdGVcIl0pO2ZhKFwib25Db21wb3NpdGlvbkVuZFwiLFwiY29tcG9zaXRpb25lbmQgZm9jdXNvdXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd25cIi5zcGxpdChcIiBcIikpO2ZhKFwib25Db21wb3NpdGlvblN0YXJ0XCIsXCJjb21wb3NpdGlvbnN0YXJ0IGZvY3Vzb3V0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgbW91c2Vkb3duXCIuc3BsaXQoXCIgXCIpKTtcbmZhKFwib25Db21wb3NpdGlvblVwZGF0ZVwiLFwiY29tcG9zaXRpb251cGRhdGUgZm9jdXNvdXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd25cIi5zcGxpdChcIiBcIikpO3ZhciBrZj1cImFib3J0IGNhbnBsYXkgY2FucGxheXRocm91Z2ggZHVyYXRpb25jaGFuZ2UgZW1wdGllZCBlbmNyeXB0ZWQgZW5kZWQgZXJyb3IgbG9hZGVkZGF0YSBsb2FkZWRtZXRhZGF0YSBsb2Fkc3RhcnQgcGF1c2UgcGxheSBwbGF5aW5nIHByb2dyZXNzIHJhdGVjaGFuZ2UgcmVzaXplIHNlZWtlZCBzZWVraW5nIHN0YWxsZWQgc3VzcGVuZCB0aW1ldXBkYXRlIHZvbHVtZWNoYW5nZSB3YWl0aW5nXCIuc3BsaXQoXCIgXCIpLGxmPW5ldyBTZXQoXCJjYW5jZWwgY2xvc2UgaW52YWxpZCBsb2FkIHNjcm9sbCB0b2dnbGVcIi5zcGxpdChcIiBcIikuY29uY2F0KGtmKSk7XG5mdW5jdGlvbiBtZihhLGIsYyl7dmFyIGQ9YS50eXBlfHxcInVua25vd24tZXZlbnRcIjthLmN1cnJlbnRUYXJnZXQ9YztUYihkLGIsdm9pZCAwLGEpO2EuY3VycmVudFRhcmdldD1udWxsfVxuZnVuY3Rpb24gcmUoYSxiKXtiPTAhPT0oYiY0KTtmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKyl7dmFyIGQ9YVtjXSxlPWQuZXZlbnQ7ZD1kLmxpc3RlbmVyczthOnt2YXIgZj12b2lkIDA7aWYoYilmb3IodmFyIGc9ZC5sZW5ndGgtMTswPD1nO2ctLSl7dmFyIGg9ZFtnXSxrPWguaW5zdGFuY2UsbD1oLmN1cnJlbnRUYXJnZXQ7aD1oLmxpc3RlbmVyO2lmKGshPT1mJiZlLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpYnJlYWsgYTttZihlLGgsbCk7Zj1rfWVsc2UgZm9yKGc9MDtnPGQubGVuZ3RoO2crKyl7aD1kW2ddO2s9aC5pbnN0YW5jZTtsPWguY3VycmVudFRhcmdldDtoPWgubGlzdGVuZXI7aWYoayE9PWYmJmUuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSlicmVhayBhO21mKGUsaCxsKTtmPWt9fX1pZihQYil0aHJvdyBhPVFiLFBiPSExLFFiPW51bGwsYTt9XG5mdW5jdGlvbiBEKGEsYil7dmFyIGM9YltuZl07dm9pZCAwPT09YyYmKGM9YltuZl09bmV3IFNldCk7dmFyIGQ9YStcIl9fYnViYmxlXCI7Yy5oYXMoZCl8fChvZihiLGEsMiwhMSksYy5hZGQoZCkpfWZ1bmN0aW9uIHBmKGEsYixjKXt2YXIgZD0wO2ImJihkfD00KTtvZihjLGEsZCxiKX12YXIgcWY9XCJfcmVhY3RMaXN0ZW5pbmdcIitNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtmdW5jdGlvbiByZihhKXtpZighYVtxZl0pe2FbcWZdPSEwO2RhLmZvckVhY2goZnVuY3Rpb24oYil7XCJzZWxlY3Rpb25jaGFuZ2VcIiE9PWImJihsZi5oYXMoYil8fHBmKGIsITEsYSkscGYoYiwhMCxhKSl9KTt2YXIgYj05PT09YS5ub2RlVHlwZT9hOmEub3duZXJEb2N1bWVudDtudWxsPT09Ynx8YltxZl18fChiW3FmXT0hMCxwZihcInNlbGVjdGlvbmNoYW5nZVwiLCExLGIpKX19XG5mdW5jdGlvbiBvZihhLGIsYyxkKXtzd2l0Y2goaWQoYikpe2Nhc2UgMTp2YXIgZT1kZDticmVhaztjYXNlIDQ6ZT1mZDticmVhaztkZWZhdWx0OmU9ZWR9Yz1lLmJpbmQobnVsbCxiLGMsYSk7ZT12b2lkIDA7IUtifHxcInRvdWNoc3RhcnRcIiE9PWImJlwidG91Y2htb3ZlXCIhPT1iJiZcIndoZWVsXCIhPT1ifHwoZT0hMCk7ZD92b2lkIDAhPT1lP2EuYWRkRXZlbnRMaXN0ZW5lcihiLGMse2NhcHR1cmU6ITAscGFzc2l2ZTplfSk6YS5hZGRFdmVudExpc3RlbmVyKGIsYywhMCk6dm9pZCAwIT09ZT9hLmFkZEV2ZW50TGlzdGVuZXIoYixjLHtwYXNzaXZlOmV9KTphLmFkZEV2ZW50TGlzdGVuZXIoYixjLCExKX1cbmZ1bmN0aW9uIGdkKGEsYixjLGQsZSl7dmFyIGY9ZDtpZigwPT09KGImMSkmJjA9PT0oYiYyKSYmbnVsbCE9PWQpYTpmb3IoOzspe2lmKG51bGw9PT1kKXJldHVybjt2YXIgZz1kLnRhZztpZigzPT09Z3x8ND09PWcpe3ZhciBoPWQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87aWYoaD09PWV8fDg9PT1oLm5vZGVUeXBlJiZoLnBhcmVudE5vZGU9PT1lKWJyZWFrO2lmKDQ9PT1nKWZvcihnPWQucmV0dXJuO251bGwhPT1nOyl7dmFyIGs9Zy50YWc7aWYoMz09PWt8fDQ9PT1rKWlmKGs9Zy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyxrPT09ZXx8OD09PWsubm9kZVR5cGUmJmsucGFyZW50Tm9kZT09PWUpcmV0dXJuO2c9Zy5yZXR1cm59Zm9yKDtudWxsIT09aDspe2c9VmMoaCk7aWYobnVsbD09PWcpcmV0dXJuO2s9Zy50YWc7aWYoNT09PWt8fDY9PT1rKXtkPWY9Zztjb250aW51ZSBhfWg9aC5wYXJlbnROb2RlfX1kPWQucmV0dXJufUliKGZ1bmN0aW9uKCl7dmFyIGQ9ZixlPXdiKGMpLGc9W107XG5hOnt2YXIgaD1jZi5nZXQoYSk7aWYodm9pZCAwIT09aCl7dmFyIGs9c2QsbT1hO3N3aXRjaChhKXtjYXNlIFwia2V5cHJlc3NcIjppZigwPT09bmQoYykpYnJlYWsgYTtjYXNlIFwia2V5ZG93blwiOmNhc2UgXCJrZXl1cFwiOms9UWQ7YnJlYWs7Y2FzZSBcImZvY3VzaW5cIjptPVwiZm9jdXNcIjtrPUVkO2JyZWFrO2Nhc2UgXCJmb2N1c291dFwiOm09XCJibHVyXCI7az1FZDticmVhaztjYXNlIFwiYmVmb3JlYmx1clwiOmNhc2UgXCJhZnRlcmJsdXJcIjprPUVkO2JyZWFrO2Nhc2UgXCJjbGlja1wiOmlmKDI9PT1jLmJ1dHRvbilicmVhayBhO2Nhc2UgXCJhdXhjbGlja1wiOmNhc2UgXCJkYmxjbGlja1wiOmNhc2UgXCJtb3VzZWRvd25cIjpjYXNlIFwibW91c2Vtb3ZlXCI6Y2FzZSBcIm1vdXNldXBcIjpjYXNlIFwibW91c2VvdXRcIjpjYXNlIFwibW91c2VvdmVyXCI6Y2FzZSBcImNvbnRleHRtZW51XCI6az1BZDticmVhaztjYXNlIFwiZHJhZ1wiOmNhc2UgXCJkcmFnZW5kXCI6Y2FzZSBcImRyYWdlbnRlclwiOmNhc2UgXCJkcmFnZXhpdFwiOmNhc2UgXCJkcmFnbGVhdmVcIjpjYXNlIFwiZHJhZ292ZXJcIjpjYXNlIFwiZHJhZ3N0YXJ0XCI6Y2FzZSBcImRyb3BcIjprPVxuQ2Q7YnJlYWs7Y2FzZSBcInRvdWNoY2FuY2VsXCI6Y2FzZSBcInRvdWNoZW5kXCI6Y2FzZSBcInRvdWNobW92ZVwiOmNhc2UgXCJ0b3VjaHN0YXJ0XCI6az1VZDticmVhaztjYXNlIFplOmNhc2UgJGU6Y2FzZSBhZjprPUdkO2JyZWFrO2Nhc2UgYmY6az1XZDticmVhaztjYXNlIFwic2Nyb2xsXCI6az11ZDticmVhaztjYXNlIFwid2hlZWxcIjprPVlkO2JyZWFrO2Nhc2UgXCJjb3B5XCI6Y2FzZSBcImN1dFwiOmNhc2UgXCJwYXN0ZVwiOms9SWQ7YnJlYWs7Y2FzZSBcImdvdHBvaW50ZXJjYXB0dXJlXCI6Y2FzZSBcImxvc3Rwb2ludGVyY2FwdHVyZVwiOmNhc2UgXCJwb2ludGVyY2FuY2VsXCI6Y2FzZSBcInBvaW50ZXJkb3duXCI6Y2FzZSBcInBvaW50ZXJtb3ZlXCI6Y2FzZSBcInBvaW50ZXJvdXRcIjpjYXNlIFwicG9pbnRlcm92ZXJcIjpjYXNlIFwicG9pbnRlcnVwXCI6az1TZH12YXIgdz0wIT09KGImNCksSj0hdyYmXCJzY3JvbGxcIj09PWEsdj13P251bGwhPT1oP2grXCJDYXB0dXJlXCI6bnVsbDpoO3c9W107Zm9yKHZhciB4PWQscjtudWxsIT09XG54Oyl7cj14O3ZhciBGPXIuc3RhdGVOb2RlOzU9PT1yLnRhZyYmbnVsbCE9PUYmJihyPUYsbnVsbCE9PXYmJihGPUpiKHgsdiksbnVsbCE9RiYmdy5wdXNoKHNmKHgsRixyKSkpKTtpZihKKWJyZWFrO3g9eC5yZXR1cm59MDx3Lmxlbmd0aCYmKGg9bmV3IGsoaCxtLG51bGwsYyxlKSxnLnB1c2goe2V2ZW50OmgsbGlzdGVuZXJzOnd9KSl9fWlmKDA9PT0oYiY3KSl7YTp7aD1cIm1vdXNlb3ZlclwiPT09YXx8XCJwb2ludGVyb3ZlclwiPT09YTtrPVwibW91c2VvdXRcIj09PWF8fFwicG9pbnRlcm91dFwiPT09YTtpZihoJiZjIT09dmImJihtPWMucmVsYXRlZFRhcmdldHx8Yy5mcm9tRWxlbWVudCkmJihWYyhtKXx8bVt0Zl0pKWJyZWFrIGE7aWYoa3x8aCl7aD1lLndpbmRvdz09PWU/ZTooaD1lLm93bmVyRG9jdW1lbnQpP2guZGVmYXVsdFZpZXd8fGgucGFyZW50V2luZG93OndpbmRvdztpZihrKXtpZihtPWMucmVsYXRlZFRhcmdldHx8Yy50b0VsZW1lbnQsaz1kLG09bT9WYyhtKTpudWxsLG51bGwhPT1cbm0mJihKPVViKG0pLG0hPT1KfHw1IT09bS50YWcmJjYhPT1tLnRhZykpbT1udWxsfWVsc2Ugaz1udWxsLG09ZDtpZihrIT09bSl7dz1BZDtGPVwib25Nb3VzZUxlYXZlXCI7dj1cIm9uTW91c2VFbnRlclwiO3g9XCJtb3VzZVwiO2lmKFwicG9pbnRlcm91dFwiPT09YXx8XCJwb2ludGVyb3ZlclwiPT09YSl3PVNkLEY9XCJvblBvaW50ZXJMZWF2ZVwiLHY9XCJvblBvaW50ZXJFbnRlclwiLHg9XCJwb2ludGVyXCI7Sj1udWxsPT1rP2g6dGUoayk7cj1udWxsPT1tP2g6dGUobSk7aD1uZXcgdyhGLHgrXCJsZWF2ZVwiLGssYyxlKTtoLnRhcmdldD1KO2gucmVsYXRlZFRhcmdldD1yO0Y9bnVsbDtWYyhlKT09PWQmJih3PW5ldyB3KHYseCtcImVudGVyXCIsbSxjLGUpLHcudGFyZ2V0PXIsdy5yZWxhdGVkVGFyZ2V0PUosRj13KTtKPUY7aWYoayYmbSliOnt3PWs7dj1tO3g9MDtmb3Iocj13O3I7cj11ZihyKSl4Kys7cj0wO2ZvcihGPXY7RjtGPXVmKEYpKXIrKztmb3IoOzA8eC1yOyl3PXVmKHcpLHgtLTtmb3IoOzA8ci14Oyl2PVxudWYodiksci0tO2Zvcig7eC0tOyl7aWYodz09PXZ8fG51bGwhPT12JiZ3PT09di5hbHRlcm5hdGUpYnJlYWsgYjt3PXVmKHcpO3Y9dWYodil9dz1udWxsfWVsc2Ugdz1udWxsO251bGwhPT1rJiZ2ZihnLGgsayx3LCExKTtudWxsIT09bSYmbnVsbCE9PUomJnZmKGcsSixtLHcsITApfX19YTp7aD1kP3RlKGQpOndpbmRvdztrPWgubm9kZU5hbWUmJmgubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtpZihcInNlbGVjdFwiPT09a3x8XCJpbnB1dFwiPT09ayYmXCJmaWxlXCI9PT1oLnR5cGUpdmFyIFo9dWU7ZWxzZSBpZihsZShoKSlpZih2ZSlaPUVlO2Vsc2V7Wj1DZTt2YXIgeWE9QmV9ZWxzZShrPWgubm9kZU5hbWUpJiZcImlucHV0XCI9PT1rLnRvTG93ZXJDYXNlKCkmJihcImNoZWNrYm94XCI9PT1oLnR5cGV8fFwicmFkaW9cIj09PWgudHlwZSkmJihaPURlKTtpZihaJiYoWj1aKGEsZCkpKXttZShnLFosYyxlKTticmVhayBhfXlhJiZ5YShhLGgsZCk7XCJmb2N1c291dFwiPT09YSYmKHlhPWguX3dyYXBwZXJTdGF0ZSkmJlxueWEuY29udHJvbGxlZCYmXCJudW1iZXJcIj09PWgudHlwZSYmYmIoaCxcIm51bWJlclwiLGgudmFsdWUpfXlhPWQ/dGUoZCk6d2luZG93O3N3aXRjaChhKXtjYXNlIFwiZm9jdXNpblwiOmlmKGxlKHlhKXx8XCJ0cnVlXCI9PT15YS5jb250ZW50RWRpdGFibGUpUGU9eWEsUWU9ZCxSZT1udWxsO2JyZWFrO2Nhc2UgXCJmb2N1c291dFwiOlJlPVFlPVBlPW51bGw7YnJlYWs7Y2FzZSBcIm1vdXNlZG93blwiOlNlPSEwO2JyZWFrO2Nhc2UgXCJjb250ZXh0bWVudVwiOmNhc2UgXCJtb3VzZXVwXCI6Y2FzZSBcImRyYWdlbmRcIjpTZT0hMTtUZShnLGMsZSk7YnJlYWs7Y2FzZSBcInNlbGVjdGlvbmNoYW5nZVwiOmlmKE9lKWJyZWFrO2Nhc2UgXCJrZXlkb3duXCI6Y2FzZSBcImtleXVwXCI6VGUoZyxjLGUpfXZhciBhYjtpZigkZCliOntzd2l0Y2goYSl7Y2FzZSBcImNvbXBvc2l0aW9uc3RhcnRcIjp2YXIgY2E9XCJvbkNvbXBvc2l0aW9uU3RhcnRcIjticmVhayBiO2Nhc2UgXCJjb21wb3NpdGlvbmVuZFwiOmNhPVwib25Db21wb3NpdGlvbkVuZFwiO1xuYnJlYWsgYjtjYXNlIFwiY29tcG9zaXRpb251cGRhdGVcIjpjYT1cIm9uQ29tcG9zaXRpb25VcGRhdGVcIjticmVhayBifWNhPXZvaWQgMH1lbHNlIGhlP2ZlKGEsYykmJihjYT1cIm9uQ29tcG9zaXRpb25FbmRcIik6XCJrZXlkb3duXCI9PT1hJiYyMjk9PT1jLmtleUNvZGUmJihjYT1cIm9uQ29tcG9zaXRpb25TdGFydFwiKTtjYSYmKGNlJiZcImtvXCIhPT1jLmxvY2FsZSYmKGhlfHxcIm9uQ29tcG9zaXRpb25TdGFydFwiIT09Y2E/XCJvbkNvbXBvc2l0aW9uRW5kXCI9PT1jYSYmaGUmJihhYj1tZCgpKTooamQ9ZSxrZD1cInZhbHVlXCJpbiBqZD9qZC52YWx1ZTpqZC50ZXh0Q29udGVudCxoZT0hMCkpLHlhPW5lKGQsY2EpLDA8eWEubGVuZ3RoJiYoY2E9bmV3IEtkKGNhLGEsbnVsbCxjLGUpLGcucHVzaCh7ZXZlbnQ6Y2EsbGlzdGVuZXJzOnlhfSksYWI/Y2EuZGF0YT1hYjooYWI9Z2UoYyksbnVsbCE9PWFiJiYoY2EuZGF0YT1hYikpKSk7aWYoYWI9YmU/aWUoYSxjKTpqZShhLGMpKWQ9bmUoZCxcIm9uQmVmb3JlSW5wdXRcIiksXG4wPGQubGVuZ3RoJiYoZT1uZXcgS2QoXCJvbkJlZm9yZUlucHV0XCIsXCJiZWZvcmVpbnB1dFwiLG51bGwsYyxlKSxnLnB1c2goe2V2ZW50OmUsbGlzdGVuZXJzOmR9KSxlLmRhdGE9YWIpfXJlKGcsYil9KX1mdW5jdGlvbiBzZihhLGIsYyl7cmV0dXJue2luc3RhbmNlOmEsbGlzdGVuZXI6YixjdXJyZW50VGFyZ2V0OmN9fWZ1bmN0aW9uIG5lKGEsYil7Zm9yKHZhciBjPWIrXCJDYXB0dXJlXCIsZD1bXTtudWxsIT09YTspe3ZhciBlPWEsZj1lLnN0YXRlTm9kZTs1PT09ZS50YWcmJm51bGwhPT1mJiYoZT1mLGY9SmIoYSxjKSxudWxsIT1mJiZkLnVuc2hpZnQoc2YoYSxmLGUpKSxmPUpiKGEsYiksbnVsbCE9ZiYmZC5wdXNoKHNmKGEsZixlKSkpO2E9YS5yZXR1cm59cmV0dXJuIGR9ZnVuY3Rpb24gdWYoYSl7aWYobnVsbD09PWEpcmV0dXJuIG51bGw7ZG8gYT1hLnJldHVybjt3aGlsZShhJiY1IT09YS50YWcpO3JldHVybiBhP2E6bnVsbH1cbmZ1bmN0aW9uIHZmKGEsYixjLGQsZSl7Zm9yKHZhciBmPWIuX3JlYWN0TmFtZSxnPVtdO251bGwhPT1jJiZjIT09ZDspe3ZhciBoPWMsaz1oLmFsdGVybmF0ZSxsPWguc3RhdGVOb2RlO2lmKG51bGwhPT1rJiZrPT09ZClicmVhazs1PT09aC50YWcmJm51bGwhPT1sJiYoaD1sLGU/KGs9SmIoYyxmKSxudWxsIT1rJiZnLnVuc2hpZnQoc2YoYyxrLGgpKSk6ZXx8KGs9SmIoYyxmKSxudWxsIT1rJiZnLnB1c2goc2YoYyxrLGgpKSkpO2M9Yy5yZXR1cm59MCE9PWcubGVuZ3RoJiZhLnB1c2goe2V2ZW50OmIsbGlzdGVuZXJzOmd9KX12YXIgd2Y9L1xcclxcbj8vZyx4Zj0vXFx1MDAwMHxcXHVGRkZEL2c7ZnVuY3Rpb24geWYoYSl7cmV0dXJuKFwic3RyaW5nXCI9PT10eXBlb2YgYT9hOlwiXCIrYSkucmVwbGFjZSh3ZixcIlxcblwiKS5yZXBsYWNlKHhmLFwiXCIpfWZ1bmN0aW9uIHpmKGEsYixjKXtiPXlmKGIpO2lmKHlmKGEpIT09YiYmYyl0aHJvdyBFcnJvcihwKDQyNSkpO31mdW5jdGlvbiBBZigpe31cbnZhciBCZj1udWxsLENmPW51bGw7ZnVuY3Rpb24gRGYoYSxiKXtyZXR1cm5cInRleHRhcmVhXCI9PT1hfHxcIm5vc2NyaXB0XCI9PT1hfHxcInN0cmluZ1wiPT09dHlwZW9mIGIuY2hpbGRyZW58fFwibnVtYmVyXCI9PT10eXBlb2YgYi5jaGlsZHJlbnx8XCJvYmplY3RcIj09PXR5cGVvZiBiLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MJiZudWxsIT09Yi5kYW5nZXJvdXNseVNldElubmVySFRNTCYmbnVsbCE9Yi5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWx9XG52YXIgRWY9XCJmdW5jdGlvblwiPT09dHlwZW9mIHNldFRpbWVvdXQ/c2V0VGltZW91dDp2b2lkIDAsRmY9XCJmdW5jdGlvblwiPT09dHlwZW9mIGNsZWFyVGltZW91dD9jbGVhclRpbWVvdXQ6dm9pZCAwLEdmPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBQcm9taXNlP1Byb21pc2U6dm9pZCAwLElmPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBxdWV1ZU1pY3JvdGFzaz9xdWV1ZU1pY3JvdGFzazpcInVuZGVmaW5lZFwiIT09dHlwZW9mIEdmP2Z1bmN0aW9uKGEpe3JldHVybiBHZi5yZXNvbHZlKG51bGwpLnRoZW4oYSkuY2F0Y2goSGYpfTpFZjtmdW5jdGlvbiBIZihhKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhyb3cgYTt9KX1cbmZ1bmN0aW9uIEpmKGEsYil7dmFyIGM9YixkPTA7ZG97dmFyIGU9Yy5uZXh0U2libGluZzthLnJlbW92ZUNoaWxkKGMpO2lmKGUmJjg9PT1lLm5vZGVUeXBlKWlmKGM9ZS5kYXRhLFwiLyRcIj09PWMpe2lmKDA9PT1kKXthLnJlbW92ZUNoaWxkKGUpO2FkKGIpO3JldHVybn1kLS19ZWxzZVwiJFwiIT09YyYmXCIkP1wiIT09YyYmXCIkIVwiIT09Y3x8ZCsrO2M9ZX13aGlsZShjKTthZChiKX1mdW5jdGlvbiBLZihhKXtmb3IoO251bGwhPWE7YT1hLm5leHRTaWJsaW5nKXt2YXIgYj1hLm5vZGVUeXBlO2lmKDE9PT1ifHwzPT09YilicmVhaztpZig4PT09Yil7Yj1hLmRhdGE7aWYoXCIkXCI9PT1ifHxcIiQhXCI9PT1ifHxcIiQ/XCI9PT1iKWJyZWFrO2lmKFwiLyRcIj09PWIpcmV0dXJuIG51bGx9fXJldHVybiBhfVxuZnVuY3Rpb24gTGYoYSl7YT1hLnByZXZpb3VzU2libGluZztmb3IodmFyIGI9MDthOyl7aWYoOD09PWEubm9kZVR5cGUpe3ZhciBjPWEuZGF0YTtpZihcIiRcIj09PWN8fFwiJCFcIj09PWN8fFwiJD9cIj09PWMpe2lmKDA9PT1iKXJldHVybiBhO2ItLX1lbHNlXCIvJFwiPT09YyYmYisrfWE9YS5wcmV2aW91c1NpYmxpbmd9cmV0dXJuIG51bGx9dmFyIE1mPU1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpLE5mPVwiX19yZWFjdEZpYmVyJFwiK01mLE9mPVwiX19yZWFjdFByb3BzJFwiK01mLHRmPVwiX19yZWFjdENvbnRhaW5lciRcIitNZixuZj1cIl9fcmVhY3RFdmVudHMkXCIrTWYsUGY9XCJfX3JlYWN0TGlzdGVuZXJzJFwiK01mLFFmPVwiX19yZWFjdEhhbmRsZXMkXCIrTWY7XG5mdW5jdGlvbiBWYyhhKXt2YXIgYj1hW05mXTtpZihiKXJldHVybiBiO2Zvcih2YXIgYz1hLnBhcmVudE5vZGU7Yzspe2lmKGI9Y1t0Zl18fGNbTmZdKXtjPWIuYWx0ZXJuYXRlO2lmKG51bGwhPT1iLmNoaWxkfHxudWxsIT09YyYmbnVsbCE9PWMuY2hpbGQpZm9yKGE9TGYoYSk7bnVsbCE9PWE7KXtpZihjPWFbTmZdKXJldHVybiBjO2E9TGYoYSl9cmV0dXJuIGJ9YT1jO2M9YS5wYXJlbnROb2RlfXJldHVybiBudWxsfWZ1bmN0aW9uIEJiKGEpe2E9YVtOZl18fGFbdGZdO3JldHVybiFhfHw1IT09YS50YWcmJjYhPT1hLnRhZyYmMTMhPT1hLnRhZyYmMyE9PWEudGFnP251bGw6YX1mdW5jdGlvbiB0ZShhKXtpZig1PT09YS50YWd8fDY9PT1hLnRhZylyZXR1cm4gYS5zdGF0ZU5vZGU7dGhyb3cgRXJyb3IocCgzMykpO31mdW5jdGlvbiBDYihhKXtyZXR1cm4gYVtPZl18fG51bGx9dmFyIFJmPVtdLFNmPS0xO2Z1bmN0aW9uIFRmKGEpe3JldHVybntjdXJyZW50OmF9fVxuZnVuY3Rpb24gRShhKXswPlNmfHwoYS5jdXJyZW50PVJmW1NmXSxSZltTZl09bnVsbCxTZi0tKX1mdW5jdGlvbiBHKGEsYil7U2YrKztSZltTZl09YS5jdXJyZW50O2EuY3VycmVudD1ifXZhciBVZj17fSxIPVRmKFVmKSxWZj1UZighMSksV2Y9VWY7ZnVuY3Rpb24gWGYoYSxiKXt2YXIgYz1hLnR5cGUuY29udGV4dFR5cGVzO2lmKCFjKXJldHVybiBVZjt2YXIgZD1hLnN0YXRlTm9kZTtpZihkJiZkLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9PT1iKXJldHVybiBkLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0O3ZhciBlPXt9LGY7Zm9yKGYgaW4gYyllW2ZdPWJbZl07ZCYmKGE9YS5zdGF0ZU5vZGUsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PWIsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dD1lKTtyZXR1cm4gZX1cbmZ1bmN0aW9uIFlmKGEpe2E9YS5jaGlsZENvbnRleHRUeXBlcztyZXR1cm4gbnVsbCE9PWEmJnZvaWQgMCE9PWF9ZnVuY3Rpb24gWmYoKXtFKFZmKTtFKEgpfWZ1bmN0aW9uICRmKGEsYixjKXtpZihILmN1cnJlbnQhPT1VZil0aHJvdyBFcnJvcihwKDE2OCkpO0coSCxiKTtHKFZmLGMpfWZ1bmN0aW9uIGFnKGEsYixjKXt2YXIgZD1hLnN0YXRlTm9kZTtiPWIuY2hpbGRDb250ZXh0VHlwZXM7aWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIGQuZ2V0Q2hpbGRDb250ZXh0KXJldHVybiBjO2Q9ZC5nZXRDaGlsZENvbnRleHQoKTtmb3IodmFyIGUgaW4gZClpZighKGUgaW4gYikpdGhyb3cgRXJyb3IocCgxMDgsUWEoYSl8fFwiVW5rbm93blwiLGUpKTtyZXR1cm4gQSh7fSxjLGQpfVxuZnVuY3Rpb24gYmcoYSl7YT0oYT1hLnN0YXRlTm9kZSkmJmEuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHR8fFVmO1dmPUguY3VycmVudDtHKEgsYSk7RyhWZixWZi5jdXJyZW50KTtyZXR1cm4hMH1mdW5jdGlvbiBjZyhhLGIsYyl7dmFyIGQ9YS5zdGF0ZU5vZGU7aWYoIWQpdGhyb3cgRXJyb3IocCgxNjkpKTtjPyhhPWFnKGEsYixXZiksZC5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dD1hLEUoVmYpLEUoSCksRyhILGEpKTpFKFZmKTtHKFZmLGMpfXZhciBkZz1udWxsLGVnPSExLGZnPSExO2Z1bmN0aW9uIGdnKGEpe251bGw9PT1kZz9kZz1bYV06ZGcucHVzaChhKX1mdW5jdGlvbiBoZyhhKXtlZz0hMDtnZyhhKX1cbmZ1bmN0aW9uIGlnKCl7aWYoIWZnJiZudWxsIT09ZGcpe2ZnPSEwO3ZhciBhPTAsYj1DO3RyeXt2YXIgYz1kZztmb3IoQz0xO2E8Yy5sZW5ndGg7YSsrKXt2YXIgZD1jW2FdO2RvIGQ9ZCghMCk7d2hpbGUobnVsbCE9PWQpfWRnPW51bGw7ZWc9ITF9Y2F0Y2goZSl7dGhyb3cgbnVsbCE9PWRnJiYoZGc9ZGcuc2xpY2UoYSsxKSksJGIoZWMsaWcpLGU7fWZpbmFsbHl7Qz1iLGZnPSExfX1yZXR1cm4gbnVsbH12YXIgamc9dGEuUmVhY3RDdXJyZW50QmF0Y2hDb25maWc7ZnVuY3Rpb24ga2coYSxiKXtpZihhJiZhLmRlZmF1bHRQcm9wcyl7Yj1BKHt9LGIpO2E9YS5kZWZhdWx0UHJvcHM7Zm9yKHZhciBjIGluIGEpdm9pZCAwPT09YltjXSYmKGJbY109YVtjXSk7cmV0dXJuIGJ9cmV0dXJuIGJ9dmFyIGxnPVRmKG51bGwpLG1nPW51bGwsbmc9bnVsbCxvZz1udWxsO2Z1bmN0aW9uIHBnKCl7b2c9bmc9bWc9bnVsbH1cbmZ1bmN0aW9uIHFnKGEpe3ZhciBiPWxnLmN1cnJlbnQ7RShsZyk7YS5fY3VycmVudFZhbHVlPWJ9ZnVuY3Rpb24gcmcoYSxiLGMpe2Zvcig7bnVsbCE9PWE7KXt2YXIgZD1hLmFsdGVybmF0ZTsoYS5jaGlsZExhbmVzJmIpIT09Yj8oYS5jaGlsZExhbmVzfD1iLG51bGwhPT1kJiYoZC5jaGlsZExhbmVzfD1iKSk6bnVsbCE9PWQmJihkLmNoaWxkTGFuZXMmYikhPT1iJiYoZC5jaGlsZExhbmVzfD1iKTtpZihhPT09YylicmVhazthPWEucmV0dXJufX1mdW5jdGlvbiBzZyhhLGIpe21nPWE7b2c9bmc9bnVsbDthPWEuZGVwZW5kZW5jaWVzO251bGwhPT1hJiZudWxsIT09YS5maXJzdENvbnRleHQmJigwIT09KGEubGFuZXMmYikmJih0Zz0hMCksYS5maXJzdENvbnRleHQ9bnVsbCl9XG5mdW5jdGlvbiB1ZyhhKXt2YXIgYj1hLl9jdXJyZW50VmFsdWU7aWYob2chPT1hKWlmKGE9e2NvbnRleHQ6YSxtZW1vaXplZFZhbHVlOmIsbmV4dDpudWxsfSxudWxsPT09bmcpe2lmKG51bGw9PT1tZyl0aHJvdyBFcnJvcihwKDMwOCkpO25nPWE7bWcuZGVwZW5kZW5jaWVzPXtsYW5lczowLGZpcnN0Q29udGV4dDphfX1lbHNlIG5nPW5nLm5leHQ9YTtyZXR1cm4gYn12YXIgdmc9bnVsbCx3Zz0hMTtmdW5jdGlvbiB4ZyhhKXthLnVwZGF0ZVF1ZXVlPXtiYXNlU3RhdGU6YS5tZW1vaXplZFN0YXRlLGZpcnN0QmFzZVVwZGF0ZTpudWxsLGxhc3RCYXNlVXBkYXRlOm51bGwsc2hhcmVkOntwZW5kaW5nOm51bGwsaW50ZXJsZWF2ZWQ6bnVsbCxsYW5lczowfSxlZmZlY3RzOm51bGx9fVxuZnVuY3Rpb24geWcoYSxiKXthPWEudXBkYXRlUXVldWU7Yi51cGRhdGVRdWV1ZT09PWEmJihiLnVwZGF0ZVF1ZXVlPXtiYXNlU3RhdGU6YS5iYXNlU3RhdGUsZmlyc3RCYXNlVXBkYXRlOmEuZmlyc3RCYXNlVXBkYXRlLGxhc3RCYXNlVXBkYXRlOmEubGFzdEJhc2VVcGRhdGUsc2hhcmVkOmEuc2hhcmVkLGVmZmVjdHM6YS5lZmZlY3RzfSl9ZnVuY3Rpb24gemcoYSxiKXtyZXR1cm57ZXZlbnRUaW1lOmEsbGFuZTpiLHRhZzowLHBheWxvYWQ6bnVsbCxjYWxsYmFjazpudWxsLG5leHQ6bnVsbH19XG5mdW5jdGlvbiBBZyhhLGIpe3ZhciBjPWEudXBkYXRlUXVldWU7bnVsbCE9PWMmJihjPWMuc2hhcmVkLEJnKGEpPyhhPWMuaW50ZXJsZWF2ZWQsbnVsbD09PWE/KGIubmV4dD1iLG51bGw9PT12Zz92Zz1bY106dmcucHVzaChjKSk6KGIubmV4dD1hLm5leHQsYS5uZXh0PWIpLGMuaW50ZXJsZWF2ZWQ9Yik6KGE9Yy5wZW5kaW5nLG51bGw9PT1hP2IubmV4dD1iOihiLm5leHQ9YS5uZXh0LGEubmV4dD1iKSxjLnBlbmRpbmc9YikpfWZ1bmN0aW9uIENnKGEsYixjKXtiPWIudXBkYXRlUXVldWU7aWYobnVsbCE9PWImJihiPWIuc2hhcmVkLDAhPT0oYyY0MTk0MjQwKSkpe3ZhciBkPWIubGFuZXM7ZCY9YS5wZW5kaW5nTGFuZXM7Y3w9ZDtiLmxhbmVzPWM7QmMoYSxjKX19XG5mdW5jdGlvbiBEZyhhLGIpe3ZhciBjPWEudXBkYXRlUXVldWUsZD1hLmFsdGVybmF0ZTtpZihudWxsIT09ZCYmKGQ9ZC51cGRhdGVRdWV1ZSxjPT09ZCkpe3ZhciBlPW51bGwsZj1udWxsO2M9Yy5maXJzdEJhc2VVcGRhdGU7aWYobnVsbCE9PWMpe2Rve3ZhciBnPXtldmVudFRpbWU6Yy5ldmVudFRpbWUsbGFuZTpjLmxhbmUsdGFnOmMudGFnLHBheWxvYWQ6Yy5wYXlsb2FkLGNhbGxiYWNrOmMuY2FsbGJhY2ssbmV4dDpudWxsfTtudWxsPT09Zj9lPWY9ZzpmPWYubmV4dD1nO2M9Yy5uZXh0fXdoaWxlKG51bGwhPT1jKTtudWxsPT09Zj9lPWY9YjpmPWYubmV4dD1ifWVsc2UgZT1mPWI7Yz17YmFzZVN0YXRlOmQuYmFzZVN0YXRlLGZpcnN0QmFzZVVwZGF0ZTplLGxhc3RCYXNlVXBkYXRlOmYsc2hhcmVkOmQuc2hhcmVkLGVmZmVjdHM6ZC5lZmZlY3RzfTthLnVwZGF0ZVF1ZXVlPWM7cmV0dXJufWE9Yy5sYXN0QmFzZVVwZGF0ZTtudWxsPT09YT9jLmZpcnN0QmFzZVVwZGF0ZT1iOmEubmV4dD1cbmI7Yy5sYXN0QmFzZVVwZGF0ZT1ifVxuZnVuY3Rpb24gRWcoYSxiLGMsZCl7dmFyIGU9YS51cGRhdGVRdWV1ZTt3Zz0hMTt2YXIgZj1lLmZpcnN0QmFzZVVwZGF0ZSxnPWUubGFzdEJhc2VVcGRhdGUsaD1lLnNoYXJlZC5wZW5kaW5nO2lmKG51bGwhPT1oKXtlLnNoYXJlZC5wZW5kaW5nPW51bGw7dmFyIGs9aCxsPWsubmV4dDtrLm5leHQ9bnVsbDtudWxsPT09Zz9mPWw6Zy5uZXh0PWw7Zz1rO3ZhciBuPWEuYWx0ZXJuYXRlO251bGwhPT1uJiYobj1uLnVwZGF0ZVF1ZXVlLGg9bi5sYXN0QmFzZVVwZGF0ZSxoIT09ZyYmKG51bGw9PT1oP24uZmlyc3RCYXNlVXBkYXRlPWw6aC5uZXh0PWwsbi5sYXN0QmFzZVVwZGF0ZT1rKSl9aWYobnVsbCE9PWYpe3ZhciB1PWUuYmFzZVN0YXRlO2c9MDtuPWw9az1udWxsO2g9Zjtkb3t2YXIgcT1oLmxhbmUseT1oLmV2ZW50VGltZTtpZigoZCZxKT09PXEpe251bGwhPT1uJiYobj1uLm5leHQ9e2V2ZW50VGltZTp5LGxhbmU6MCx0YWc6aC50YWcscGF5bG9hZDpoLnBheWxvYWQsY2FsbGJhY2s6aC5jYWxsYmFjayxcbm5leHQ6bnVsbH0pO2E6e3ZhciBtPWEsdz1oO3E9Yjt5PWM7c3dpdGNoKHcudGFnKXtjYXNlIDE6bT13LnBheWxvYWQ7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIG0pe3U9bS5jYWxsKHksdSxxKTticmVhayBhfXU9bTticmVhayBhO2Nhc2UgMzptLmZsYWdzPW0uZmxhZ3MmLTY1NTM3fDEyODtjYXNlIDA6bT13LnBheWxvYWQ7cT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgbT9tLmNhbGwoeSx1LHEpOm07aWYobnVsbD09PXF8fHZvaWQgMD09PXEpYnJlYWsgYTt1PUEoe30sdSxxKTticmVhayBhO2Nhc2UgMjp3Zz0hMH19bnVsbCE9PWguY2FsbGJhY2smJjAhPT1oLmxhbmUmJihhLmZsYWdzfD02NCxxPWUuZWZmZWN0cyxudWxsPT09cT9lLmVmZmVjdHM9W2hdOnEucHVzaChoKSl9ZWxzZSB5PXtldmVudFRpbWU6eSxsYW5lOnEsdGFnOmgudGFnLHBheWxvYWQ6aC5wYXlsb2FkLGNhbGxiYWNrOmguY2FsbGJhY2ssbmV4dDpudWxsfSxudWxsPT09bj8obD1uPXksaz11KTpuPW4ubmV4dD15LGd8PXE7XG5oPWgubmV4dDtpZihudWxsPT09aClpZihoPWUuc2hhcmVkLnBlbmRpbmcsbnVsbD09PWgpYnJlYWs7ZWxzZSBxPWgsaD1xLm5leHQscS5uZXh0PW51bGwsZS5sYXN0QmFzZVVwZGF0ZT1xLGUuc2hhcmVkLnBlbmRpbmc9bnVsbH13aGlsZSgxKTtudWxsPT09biYmKGs9dSk7ZS5iYXNlU3RhdGU9aztlLmZpcnN0QmFzZVVwZGF0ZT1sO2UubGFzdEJhc2VVcGRhdGU9bjtiPWUuc2hhcmVkLmludGVybGVhdmVkO2lmKG51bGwhPT1iKXtlPWI7ZG8gZ3w9ZS5sYW5lLGU9ZS5uZXh0O3doaWxlKGUhPT1iKX1lbHNlIG51bGw9PT1mJiYoZS5zaGFyZWQubGFuZXM9MCk7Rmd8PWc7YS5sYW5lcz1nO2EubWVtb2l6ZWRTdGF0ZT11fX1cbmZ1bmN0aW9uIEdnKGEsYixjKXthPWIuZWZmZWN0cztiLmVmZmVjdHM9bnVsbDtpZihudWxsIT09YSlmb3IoYj0wO2I8YS5sZW5ndGg7YisrKXt2YXIgZD1hW2JdLGU9ZC5jYWxsYmFjaztpZihudWxsIT09ZSl7ZC5jYWxsYmFjaz1udWxsO2Q9YztpZihcImZ1bmN0aW9uXCIhPT10eXBlb2YgZSl0aHJvdyBFcnJvcihwKDE5MSxlKSk7ZS5jYWxsKGQpfX19dmFyIEhnPShuZXcgYWEuQ29tcG9uZW50KS5yZWZzO2Z1bmN0aW9uIElnKGEsYixjLGQpe2I9YS5tZW1vaXplZFN0YXRlO2M9YyhkLGIpO2M9bnVsbD09PWN8fHZvaWQgMD09PWM/YjpBKHt9LGIsYyk7YS5tZW1vaXplZFN0YXRlPWM7MD09PWEubGFuZXMmJihhLnVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZT1jKX1cbnZhciBNZz17aXNNb3VudGVkOmZ1bmN0aW9uKGEpe3JldHVybihhPWEuX3JlYWN0SW50ZXJuYWxzKT9VYihhKT09PWE6ITF9LGVucXVldWVTZXRTdGF0ZTpmdW5jdGlvbihhLGIsYyl7YT1hLl9yZWFjdEludGVybmFsczt2YXIgZD1KZygpLGU9S2coYSksZj16ZyhkLGUpO2YucGF5bG9hZD1iO3ZvaWQgMCE9PWMmJm51bGwhPT1jJiYoZi5jYWxsYmFjaz1jKTtBZyhhLGYpO2I9TGcoYSxlLGQpO251bGwhPT1iJiZDZyhiLGEsZSl9LGVucXVldWVSZXBsYWNlU3RhdGU6ZnVuY3Rpb24oYSxiLGMpe2E9YS5fcmVhY3RJbnRlcm5hbHM7dmFyIGQ9SmcoKSxlPUtnKGEpLGY9emcoZCxlKTtmLnRhZz0xO2YucGF5bG9hZD1iO3ZvaWQgMCE9PWMmJm51bGwhPT1jJiYoZi5jYWxsYmFjaz1jKTtBZyhhLGYpO2I9TGcoYSxlLGQpO251bGwhPT1iJiZDZyhiLGEsZSl9LGVucXVldWVGb3JjZVVwZGF0ZTpmdW5jdGlvbihhLGIpe2E9YS5fcmVhY3RJbnRlcm5hbHM7dmFyIGM9SmcoKSxkPUtnKGEpLGU9emcoYyxcbmQpO2UudGFnPTI7dm9pZCAwIT09YiYmbnVsbCE9PWImJihlLmNhbGxiYWNrPWIpO0FnKGEsZSk7Yj1MZyhhLGQsYyk7bnVsbCE9PWImJkNnKGIsYSxkKX19O2Z1bmN0aW9uIE5nKGEsYixjLGQsZSxmLGcpe2E9YS5zdGF0ZU5vZGU7cmV0dXJuXCJmdW5jdGlvblwiPT09dHlwZW9mIGEuc2hvdWxkQ29tcG9uZW50VXBkYXRlP2Euc2hvdWxkQ29tcG9uZW50VXBkYXRlKGQsZixnKTpiLnByb3RvdHlwZSYmYi5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQ/IUhlKGMsZCl8fCFIZShlLGYpOiEwfVxuZnVuY3Rpb24gT2coYSxiLGMpe3ZhciBkPSExLGU9VWY7dmFyIGY9Yi5jb250ZXh0VHlwZTtcIm9iamVjdFwiPT09dHlwZW9mIGYmJm51bGwhPT1mP2Y9dWcoZik6KGU9WWYoYik/V2Y6SC5jdXJyZW50LGQ9Yi5jb250ZXh0VHlwZXMsZj0oZD1udWxsIT09ZCYmdm9pZCAwIT09ZCk/WGYoYSxlKTpVZik7Yj1uZXcgYihjLGYpO2EubWVtb2l6ZWRTdGF0ZT1udWxsIT09Yi5zdGF0ZSYmdm9pZCAwIT09Yi5zdGF0ZT9iLnN0YXRlOm51bGw7Yi51cGRhdGVyPU1nO2Euc3RhdGVOb2RlPWI7Yi5fcmVhY3RJbnRlcm5hbHM9YTtkJiYoYT1hLnN0YXRlTm9kZSxhLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9ZSxhLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0PWYpO3JldHVybiBifVxuZnVuY3Rpb24gUGcoYSxiLGMsZCl7YT1iLnN0YXRlO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBiLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMmJmIuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhjLGQpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBiLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJiZiLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKGMsZCk7Yi5zdGF0ZSE9PWEmJk1nLmVucXVldWVSZXBsYWNlU3RhdGUoYixiLnN0YXRlLG51bGwpfVxuZnVuY3Rpb24gUWcoYSxiLGMsZCl7dmFyIGU9YS5zdGF0ZU5vZGU7ZS5wcm9wcz1jO2Uuc3RhdGU9YS5tZW1vaXplZFN0YXRlO2UucmVmcz1IZzt4ZyhhKTt2YXIgZj1iLmNvbnRleHRUeXBlO1wib2JqZWN0XCI9PT10eXBlb2YgZiYmbnVsbCE9PWY/ZS5jb250ZXh0PXVnKGYpOihmPVlmKGIpP1dmOkguY3VycmVudCxlLmNvbnRleHQ9WGYoYSxmKSk7ZS5zdGF0ZT1hLm1lbW9pemVkU3RhdGU7Zj1iLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcImZ1bmN0aW9uXCI9PT10eXBlb2YgZiYmKElnKGEsYixmLGMpLGUuc3RhdGU9YS5tZW1vaXplZFN0YXRlKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgYi5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHN8fFwiZnVuY3Rpb25cIj09PXR5cGVvZiBlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlfHxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgZS5jb21wb25lbnRXaWxsTW91bnR8fChiPWUuc3RhdGUsXG5cImZ1bmN0aW9uXCI9PT10eXBlb2YgZS5jb21wb25lbnRXaWxsTW91bnQmJmUuY29tcG9uZW50V2lsbE1vdW50KCksXCJmdW5jdGlvblwiPT09dHlwZW9mIGUuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCYmZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCksYiE9PWUuc3RhdGUmJk1nLmVucXVldWVSZXBsYWNlU3RhdGUoZSxlLnN0YXRlLG51bGwpLEVnKGEsYyxlLGQpLGUuc3RhdGU9YS5tZW1vaXplZFN0YXRlKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgZS5jb21wb25lbnREaWRNb3VudCYmKGEuZmxhZ3N8PTQxOTQzMDgpfXZhciBSZz1bXSxTZz0wLFRnPW51bGwsVWc9MCxWZz1bXSxXZz0wLFhnPW51bGwsWWc9MSxaZz1cIlwiO2Z1bmN0aW9uICRnKGEsYil7UmdbU2crK109VWc7UmdbU2crK109VGc7VGc9YTtVZz1ifVxuZnVuY3Rpb24gYWgoYSxiLGMpe1ZnW1dnKytdPVlnO1ZnW1dnKytdPVpnO1ZnW1dnKytdPVhnO1hnPWE7dmFyIGQ9WWc7YT1aZzt2YXIgZT0zMi1uYyhkKS0xO2QmPX4oMTw8ZSk7Yys9MTt2YXIgZj0zMi1uYyhiKStlO2lmKDMwPGYpe3ZhciBnPWUtZSU1O2Y9KGQmKDE8PGcpLTEpLnRvU3RyaW5nKDMyKTtkPj49ZztlLT1nO1lnPTE8PDMyLW5jKGIpK2V8Yzw8ZXxkO1pnPWYrYX1lbHNlIFlnPTE8PGZ8Yzw8ZXxkLFpnPWF9ZnVuY3Rpb24gYmgoYSl7bnVsbCE9PWEucmV0dXJuJiYoJGcoYSwxKSxhaChhLDEsMCkpfWZ1bmN0aW9uIGNoKGEpe2Zvcig7YT09PVRnOylUZz1SZ1stLVNnXSxSZ1tTZ109bnVsbCxVZz1SZ1stLVNnXSxSZ1tTZ109bnVsbDtmb3IoO2E9PT1YZzspWGc9VmdbLS1XZ10sVmdbV2ddPW51bGwsWmc9VmdbLS1XZ10sVmdbV2ddPW51bGwsWWc9VmdbLS1XZ10sVmdbV2ddPW51bGx9dmFyIGRoPW51bGwsZWg9bnVsbCxJPSExLGZoPW51bGw7XG5mdW5jdGlvbiBnaChhLGIpe3ZhciBjPWhoKDUsbnVsbCxudWxsLDApO2MuZWxlbWVudFR5cGU9XCJERUxFVEVEXCI7Yy5zdGF0ZU5vZGU9YjtjLnJldHVybj1hO2I9YS5kZWxldGlvbnM7bnVsbD09PWI/KGEuZGVsZXRpb25zPVtjXSxhLmZsYWdzfD0xNik6Yi5wdXNoKGMpfVxuZnVuY3Rpb24gaWgoYSxiKXtzd2l0Y2goYS50YWcpe2Nhc2UgNTp2YXIgYz1hLnR5cGU7Yj0xIT09Yi5ub2RlVHlwZXx8Yy50b0xvd2VyQ2FzZSgpIT09Yi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpP251bGw6YjtyZXR1cm4gbnVsbCE9PWI/KGEuc3RhdGVOb2RlPWIsZGg9YSxlaD1LZihiLmZpcnN0Q2hpbGQpLCEwKTohMTtjYXNlIDY6cmV0dXJuIGI9XCJcIj09PWEucGVuZGluZ1Byb3BzfHwzIT09Yi5ub2RlVHlwZT9udWxsOmIsbnVsbCE9PWI/KGEuc3RhdGVOb2RlPWIsZGg9YSxlaD1udWxsLCEwKTohMTtjYXNlIDEzOnJldHVybiBiPTghPT1iLm5vZGVUeXBlP251bGw6YixudWxsIT09Yj8oYz1udWxsIT09WGc/e2lkOllnLG92ZXJmbG93OlpnfTpudWxsLGEubWVtb2l6ZWRTdGF0ZT17ZGVoeWRyYXRlZDpiLHRyZWVDb250ZXh0OmMscmV0cnlMYW5lOjEwNzM3NDE4MjR9LGM9aGgoMTgsbnVsbCxudWxsLDApLGMuc3RhdGVOb2RlPWIsYy5yZXR1cm49YSxhLmNoaWxkPWMsZGg9YSxlaD1cbm51bGwsITApOiExO2RlZmF1bHQ6cmV0dXJuITF9fWZ1bmN0aW9uIGpoKGEpe3JldHVybiAwIT09KGEubW9kZSYxKSYmMD09PShhLmZsYWdzJjEyOCl9ZnVuY3Rpb24ga2goYSl7aWYoSSl7dmFyIGI9ZWg7aWYoYil7dmFyIGM9YjtpZighaWgoYSxiKSl7aWYoamgoYSkpdGhyb3cgRXJyb3IocCg0MTgpKTtiPUtmKGMubmV4dFNpYmxpbmcpO3ZhciBkPWRoO2ImJmloKGEsYik/Z2goZCxjKTooYS5mbGFncz1hLmZsYWdzJi00MDk3fDIsST0hMSxkaD1hKX19ZWxzZXtpZihqaChhKSl0aHJvdyBFcnJvcihwKDQxOCkpO2EuZmxhZ3M9YS5mbGFncyYtNDA5N3wyO0k9ITE7ZGg9YX19fWZ1bmN0aW9uIGxoKGEpe2ZvcihhPWEucmV0dXJuO251bGwhPT1hJiY1IT09YS50YWcmJjMhPT1hLnRhZyYmMTMhPT1hLnRhZzspYT1hLnJldHVybjtkaD1hfVxuZnVuY3Rpb24gbWgoYSl7aWYoYSE9PWRoKXJldHVybiExO2lmKCFJKXJldHVybiBsaChhKSxJPSEwLCExO3ZhciBiOyhiPTMhPT1hLnRhZykmJiEoYj01IT09YS50YWcpJiYoYj1hLnR5cGUsYj1cImhlYWRcIiE9PWImJlwiYm9keVwiIT09YiYmIURmKGEudHlwZSxhLm1lbW9pemVkUHJvcHMpKTtpZihiJiYoYj1laCkpe2lmKGpoKGEpKXtmb3IoYT1laDthOylhPUtmKGEubmV4dFNpYmxpbmcpO3Rocm93IEVycm9yKHAoNDE4KSk7fWZvcig7YjspZ2goYSxiKSxiPUtmKGIubmV4dFNpYmxpbmcpfWxoKGEpO2lmKDEzPT09YS50YWcpe2E9YS5tZW1vaXplZFN0YXRlO2E9bnVsbCE9PWE/YS5kZWh5ZHJhdGVkOm51bGw7aWYoIWEpdGhyb3cgRXJyb3IocCgzMTcpKTthOnthPWEubmV4dFNpYmxpbmc7Zm9yKGI9MDthOyl7aWYoOD09PWEubm9kZVR5cGUpe3ZhciBjPWEuZGF0YTtpZihcIi8kXCI9PT1jKXtpZigwPT09Yil7ZWg9S2YoYS5uZXh0U2libGluZyk7YnJlYWsgYX1iLS19ZWxzZVwiJFwiIT09YyYmXG5cIiQhXCIhPT1jJiZcIiQ/XCIhPT1jfHxiKyt9YT1hLm5leHRTaWJsaW5nfWVoPW51bGx9fWVsc2UgZWg9ZGg/S2YoYS5zdGF0ZU5vZGUubmV4dFNpYmxpbmcpOm51bGw7cmV0dXJuITB9ZnVuY3Rpb24gbmgoKXtlaD1kaD1udWxsO0k9ITF9ZnVuY3Rpb24gb2goYSl7bnVsbD09PWZoP2ZoPVthXTpmaC5wdXNoKGEpfVxuZnVuY3Rpb24gcGgoYSxiLGMpe2E9Yy5yZWY7aWYobnVsbCE9PWEmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBhJiZcIm9iamVjdFwiIT09dHlwZW9mIGEpe2lmKGMuX293bmVyKXtjPWMuX293bmVyO2lmKGMpe2lmKDEhPT1jLnRhZyl0aHJvdyBFcnJvcihwKDMwOSkpO3ZhciBkPWMuc3RhdGVOb2RlfWlmKCFkKXRocm93IEVycm9yKHAoMTQ3LGEpKTt2YXIgZT1kLGY9XCJcIithO2lmKG51bGwhPT1iJiZudWxsIT09Yi5yZWYmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBiLnJlZiYmYi5yZWYuX3N0cmluZ1JlZj09PWYpcmV0dXJuIGIucmVmO2I9ZnVuY3Rpb24oYSl7dmFyIGI9ZS5yZWZzO2I9PT1IZyYmKGI9ZS5yZWZzPXt9KTtudWxsPT09YT9kZWxldGUgYltmXTpiW2ZdPWF9O2IuX3N0cmluZ1JlZj1mO3JldHVybiBifWlmKFwic3RyaW5nXCIhPT10eXBlb2YgYSl0aHJvdyBFcnJvcihwKDI4NCkpO2lmKCFjLl9vd25lcil0aHJvdyBFcnJvcihwKDI5MCxhKSk7fXJldHVybiBhfVxuZnVuY3Rpb24gcWgoYSxiKXthPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChiKTt0aHJvdyBFcnJvcihwKDMxLFwiW29iamVjdCBPYmplY3RdXCI9PT1hP1wib2JqZWN0IHdpdGgga2V5cyB7XCIrT2JqZWN0LmtleXMoYikuam9pbihcIiwgXCIpK1wifVwiOmEpKTt9ZnVuY3Rpb24gcmgoYSl7dmFyIGI9YS5faW5pdDtyZXR1cm4gYihhLl9wYXlsb2FkKX1cbmZ1bmN0aW9uIHNoKGEpe2Z1bmN0aW9uIGIoYixjKXtpZihhKXt2YXIgZD1iLmRlbGV0aW9ucztudWxsPT09ZD8oYi5kZWxldGlvbnM9W2NdLGIuZmxhZ3N8PTE2KTpkLnB1c2goYyl9fWZ1bmN0aW9uIGMoYyxkKXtpZighYSlyZXR1cm4gbnVsbDtmb3IoO251bGwhPT1kOyliKGMsZCksZD1kLnNpYmxpbmc7cmV0dXJuIG51bGx9ZnVuY3Rpb24gZChhLGIpe2ZvcihhPW5ldyBNYXA7bnVsbCE9PWI7KW51bGwhPT1iLmtleT9hLnNldChiLmtleSxiKTphLnNldChiLmluZGV4LGIpLGI9Yi5zaWJsaW5nO3JldHVybiBhfWZ1bmN0aW9uIGUoYSxiKXthPXRoKGEsYik7YS5pbmRleD0wO2Euc2libGluZz1udWxsO3JldHVybiBhfWZ1bmN0aW9uIGYoYixjLGQpe2IuaW5kZXg9ZDtpZighYSlyZXR1cm4gYi5mbGFnc3w9MTA0ODU3NixjO2Q9Yi5hbHRlcm5hdGU7aWYobnVsbCE9PWQpcmV0dXJuIGQ9ZC5pbmRleCxkPGM/KGIuZmxhZ3N8PTIsYyk6ZDtiLmZsYWdzfD0yO3JldHVybiBjfWZ1bmN0aW9uIGcoYil7YSYmXG5udWxsPT09Yi5hbHRlcm5hdGUmJihiLmZsYWdzfD0yKTtyZXR1cm4gYn1mdW5jdGlvbiBoKGEsYixjLGQpe2lmKG51bGw9PT1ifHw2IT09Yi50YWcpcmV0dXJuIGI9dWgoYyxhLm1vZGUsZCksYi5yZXR1cm49YSxiO2I9ZShiLGMpO2IucmV0dXJuPWE7cmV0dXJuIGJ9ZnVuY3Rpb24gayhhLGIsYyxkKXt2YXIgZj1jLnR5cGU7aWYoZj09PXdhKXJldHVybiBuKGEsYixjLnByb3BzLmNoaWxkcmVuLGQsYy5rZXkpO2lmKG51bGwhPT1iJiYoYi5lbGVtZW50VHlwZT09PWZ8fFwib2JqZWN0XCI9PT10eXBlb2YgZiYmbnVsbCE9PWYmJmYuJCR0eXBlb2Y9PT1HYSYmcmgoZik9PT1iLnR5cGUpKXJldHVybiBkPWUoYixjLnByb3BzKSxkLnJlZj1waChhLGIsYyksZC5yZXR1cm49YSxkO2Q9dmgoYy50eXBlLGMua2V5LGMucHJvcHMsbnVsbCxhLm1vZGUsZCk7ZC5yZWY9cGgoYSxiLGMpO2QucmV0dXJuPWE7cmV0dXJuIGR9ZnVuY3Rpb24gbChhLGIsYyxkKXtpZihudWxsPT09Ynx8NCE9PWIudGFnfHxcbmIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8hPT1jLmNvbnRhaW5lckluZm98fGIuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uIT09Yy5pbXBsZW1lbnRhdGlvbilyZXR1cm4gYj13aChjLGEubW9kZSxkKSxiLnJldHVybj1hLGI7Yj1lKGIsYy5jaGlsZHJlbnx8W10pO2IucmV0dXJuPWE7cmV0dXJuIGJ9ZnVuY3Rpb24gbihhLGIsYyxkLGYpe2lmKG51bGw9PT1ifHw3IT09Yi50YWcpcmV0dXJuIGI9eGgoYyxhLm1vZGUsZCxmKSxiLnJldHVybj1hLGI7Yj1lKGIsYyk7Yi5yZXR1cm49YTtyZXR1cm4gYn1mdW5jdGlvbiB1KGEsYixjKXtpZihcInN0cmluZ1wiPT09dHlwZW9mIGImJlwiXCIhPT1ifHxcIm51bWJlclwiPT09dHlwZW9mIGIpcmV0dXJuIGI9dWgoXCJcIitiLGEubW9kZSxjKSxiLnJldHVybj1hLGI7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBiJiZudWxsIT09Yil7c3dpdGNoKGIuJCR0eXBlb2Ype2Nhc2UgdWE6cmV0dXJuIGM9dmgoYi50eXBlLGIua2V5LGIucHJvcHMsbnVsbCxhLm1vZGUsYyksXG5jLnJlZj1waChhLG51bGwsYiksYy5yZXR1cm49YSxjO2Nhc2UgdmE6cmV0dXJuIGI9d2goYixhLm1vZGUsYyksYi5yZXR1cm49YSxiO2Nhc2UgR2E6dmFyIGQ9Yi5faW5pdDtyZXR1cm4gdShhLGQoYi5fcGF5bG9hZCksYyl9aWYoZGIoYil8fEphKGIpKXJldHVybiBiPXhoKGIsYS5tb2RlLGMsbnVsbCksYi5yZXR1cm49YSxiO3FoKGEsYil9cmV0dXJuIG51bGx9ZnVuY3Rpb24gcShhLGIsYyxkKXt2YXIgZT1udWxsIT09Yj9iLmtleTpudWxsO2lmKFwic3RyaW5nXCI9PT10eXBlb2YgYyYmXCJcIiE9PWN8fFwibnVtYmVyXCI9PT10eXBlb2YgYylyZXR1cm4gbnVsbCE9PWU/bnVsbDpoKGEsYixcIlwiK2MsZCk7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBjJiZudWxsIT09Yyl7c3dpdGNoKGMuJCR0eXBlb2Ype2Nhc2UgdWE6cmV0dXJuIGMua2V5PT09ZT9rKGEsYixjLGQpOm51bGw7Y2FzZSB2YTpyZXR1cm4gYy5rZXk9PT1lP2woYSxiLGMsZCk6bnVsbDtjYXNlIEdhOnJldHVybiBlPWMuX2luaXQscShhLFxuYixlKGMuX3BheWxvYWQpLGQpfWlmKGRiKGMpfHxKYShjKSlyZXR1cm4gbnVsbCE9PWU/bnVsbDpuKGEsYixjLGQsbnVsbCk7cWgoYSxjKX1yZXR1cm4gbnVsbH1mdW5jdGlvbiB5KGEsYixjLGQsZSl7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBkJiZcIlwiIT09ZHx8XCJudW1iZXJcIj09PXR5cGVvZiBkKXJldHVybiBhPWEuZ2V0KGMpfHxudWxsLGgoYixhLFwiXCIrZCxlKTtpZihcIm9iamVjdFwiPT09dHlwZW9mIGQmJm51bGwhPT1kKXtzd2l0Y2goZC4kJHR5cGVvZil7Y2FzZSB1YTpyZXR1cm4gYT1hLmdldChudWxsPT09ZC5rZXk/YzpkLmtleSl8fG51bGwsayhiLGEsZCxlKTtjYXNlIHZhOnJldHVybiBhPWEuZ2V0KG51bGw9PT1kLmtleT9jOmQua2V5KXx8bnVsbCxsKGIsYSxkLGUpO2Nhc2UgR2E6dmFyIGY9ZC5faW5pdDtyZXR1cm4geShhLGIsYyxmKGQuX3BheWxvYWQpLGUpfWlmKGRiKGQpfHxKYShkKSlyZXR1cm4gYT1hLmdldChjKXx8bnVsbCxuKGIsYSxkLGUsbnVsbCk7cWgoYixkKX1yZXR1cm4gbnVsbH1cbmZ1bmN0aW9uIG0oZSxnLGgsayl7Zm9yKHZhciBsPW51bGwsbj1udWxsLHI9ZyxtPWc9MCx4PW51bGw7bnVsbCE9PXImJm08aC5sZW5ndGg7bSsrKXtyLmluZGV4Pm0/KHg9cixyPW51bGwpOng9ci5zaWJsaW5nO3ZhciB2PXEoZSxyLGhbbV0sayk7aWYobnVsbD09PXYpe251bGw9PT1yJiYocj14KTticmVha31hJiZyJiZudWxsPT09di5hbHRlcm5hdGUmJmIoZSxyKTtnPWYodixnLG0pO251bGw9PT1uP2w9djpuLnNpYmxpbmc9djtuPXY7cj14fWlmKG09PT1oLmxlbmd0aClyZXR1cm4gYyhlLHIpLEkmJiRnKGUsbSksbDtpZihudWxsPT09cil7Zm9yKDttPGgubGVuZ3RoO20rKylyPXUoZSxoW21dLGspLG51bGwhPT1yJiYoZz1mKHIsZyxtKSxudWxsPT09bj9sPXI6bi5zaWJsaW5nPXIsbj1yKTtJJiYkZyhlLG0pO3JldHVybiBsfWZvcihyPWQoZSxyKTttPGgubGVuZ3RoO20rKyl4PXkocixlLG0saFttXSxrKSxudWxsIT09eCYmKGEmJm51bGwhPT14LmFsdGVybmF0ZSYmci5kZWxldGUobnVsbD09PVxueC5rZXk/bTp4LmtleSksZz1mKHgsZyxtKSxudWxsPT09bj9sPXg6bi5zaWJsaW5nPXgsbj14KTthJiZyLmZvckVhY2goZnVuY3Rpb24oYSl7cmV0dXJuIGIoZSxhKX0pO0kmJiRnKGUsbSk7cmV0dXJuIGx9ZnVuY3Rpb24gdyhlLGcsaCxrKXt2YXIgbD1KYShoKTtpZihcImZ1bmN0aW9uXCIhPT10eXBlb2YgbCl0aHJvdyBFcnJvcihwKDE1MCkpO2g9bC5jYWxsKGgpO2lmKG51bGw9PWgpdGhyb3cgRXJyb3IocCgxNTEpKTtmb3IodmFyIG49bD1udWxsLG09ZyxyPWc9MCx4PW51bGwsdj1oLm5leHQoKTtudWxsIT09bSYmIXYuZG9uZTtyKyssdj1oLm5leHQoKSl7bS5pbmRleD5yPyh4PW0sbT1udWxsKTp4PW0uc2libGluZzt2YXIgdz1xKGUsbSx2LnZhbHVlLGspO2lmKG51bGw9PT13KXtudWxsPT09bSYmKG09eCk7YnJlYWt9YSYmbSYmbnVsbD09PXcuYWx0ZXJuYXRlJiZiKGUsbSk7Zz1mKHcsZyxyKTtudWxsPT09bj9sPXc6bi5zaWJsaW5nPXc7bj13O209eH1pZih2LmRvbmUpcmV0dXJuIGMoZSxcbm0pLEkmJiRnKGUsciksbDtpZihudWxsPT09bSl7Zm9yKDshdi5kb25lO3IrKyx2PWgubmV4dCgpKXY9dShlLHYudmFsdWUsayksbnVsbCE9PXYmJihnPWYodixnLHIpLG51bGw9PT1uP2w9djpuLnNpYmxpbmc9dixuPXYpO0kmJiRnKGUscik7cmV0dXJuIGx9Zm9yKG09ZChlLG0pOyF2LmRvbmU7cisrLHY9aC5uZXh0KCkpdj15KG0sZSxyLHYudmFsdWUsayksbnVsbCE9PXYmJihhJiZudWxsIT09di5hbHRlcm5hdGUmJm0uZGVsZXRlKG51bGw9PT12LmtleT9yOnYua2V5KSxnPWYodixnLHIpLG51bGw9PT1uP2w9djpuLnNpYmxpbmc9dixuPXYpO2EmJm0uZm9yRWFjaChmdW5jdGlvbihhKXtyZXR1cm4gYihlLGEpfSk7SSYmJGcoZSxyKTtyZXR1cm4gbH1mdW5jdGlvbiBKKGEsZCxmLGgpe1wib2JqZWN0XCI9PT10eXBlb2YgZiYmbnVsbCE9PWYmJmYudHlwZT09PXdhJiZudWxsPT09Zi5rZXkmJihmPWYucHJvcHMuY2hpbGRyZW4pO2lmKFwib2JqZWN0XCI9PT10eXBlb2YgZiYmbnVsbCE9PWYpe3N3aXRjaChmLiQkdHlwZW9mKXtjYXNlIHVhOmE6e2Zvcih2YXIgaz1cbmYua2V5LGw9ZDtudWxsIT09bDspe2lmKGwua2V5PT09ayl7az1mLnR5cGU7aWYoaz09PXdhKXtpZig3PT09bC50YWcpe2MoYSxsLnNpYmxpbmcpO2Q9ZShsLGYucHJvcHMuY2hpbGRyZW4pO2QucmV0dXJuPWE7YT1kO2JyZWFrIGF9fWVsc2UgaWYobC5lbGVtZW50VHlwZT09PWt8fFwib2JqZWN0XCI9PT10eXBlb2YgayYmbnVsbCE9PWsmJmsuJCR0eXBlb2Y9PT1HYSYmcmgoayk9PT1sLnR5cGUpe2MoYSxsLnNpYmxpbmcpO2Q9ZShsLGYucHJvcHMpO2QucmVmPXBoKGEsbCxmKTtkLnJldHVybj1hO2E9ZDticmVhayBhfWMoYSxsKTticmVha31lbHNlIGIoYSxsKTtsPWwuc2libGluZ31mLnR5cGU9PT13YT8oZD14aChmLnByb3BzLmNoaWxkcmVuLGEubW9kZSxoLGYua2V5KSxkLnJldHVybj1hLGE9ZCk6KGg9dmgoZi50eXBlLGYua2V5LGYucHJvcHMsbnVsbCxhLm1vZGUsaCksaC5yZWY9cGgoYSxkLGYpLGgucmV0dXJuPWEsYT1oKX1yZXR1cm4gZyhhKTtjYXNlIHZhOmE6e2ZvcihsPWYua2V5O251bGwhPT1cbmQ7KXtpZihkLmtleT09PWwpaWYoND09PWQudGFnJiZkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvPT09Zi5jb250YWluZXJJbmZvJiZkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbj09PWYuaW1wbGVtZW50YXRpb24pe2MoYSxkLnNpYmxpbmcpO2Q9ZShkLGYuY2hpbGRyZW58fFtdKTtkLnJldHVybj1hO2E9ZDticmVhayBhfWVsc2V7YyhhLGQpO2JyZWFrfWVsc2UgYihhLGQpO2Q9ZC5zaWJsaW5nfWQ9d2goZixhLm1vZGUsaCk7ZC5yZXR1cm49YTthPWR9cmV0dXJuIGcoYSk7Y2FzZSBHYTpyZXR1cm4gbD1mLl9pbml0LEooYSxkLGwoZi5fcGF5bG9hZCksaCl9aWYoZGIoZikpcmV0dXJuIG0oYSxkLGYsaCk7aWYoSmEoZikpcmV0dXJuIHcoYSxkLGYsaCk7cWgoYSxmKX1yZXR1cm5cInN0cmluZ1wiPT09dHlwZW9mIGYmJlwiXCIhPT1mfHxcIm51bWJlclwiPT09dHlwZW9mIGY/KGY9XCJcIitmLG51bGwhPT1kJiY2PT09ZC50YWc/KGMoYSxkLnNpYmxpbmcpLGQ9ZShkLGYpLGQucmV0dXJuPWEsYT1kKTpcbihjKGEsZCksZD11aChmLGEubW9kZSxoKSxkLnJldHVybj1hLGE9ZCksZyhhKSk6YyhhLGQpfXJldHVybiBKfXZhciB5aD1zaCghMCksemg9c2goITEpLEFoPXt9LEJoPVRmKEFoKSxDaD1UZihBaCksRGg9VGYoQWgpO2Z1bmN0aW9uIEVoKGEpe2lmKGE9PT1BaCl0aHJvdyBFcnJvcihwKDE3NCkpO3JldHVybiBhfWZ1bmN0aW9uIEZoKGEsYil7RyhEaCxiKTtHKENoLGEpO0coQmgsQWgpO2E9Yi5ub2RlVHlwZTtzd2l0Y2goYSl7Y2FzZSA5OmNhc2UgMTE6Yj0oYj1iLmRvY3VtZW50RWxlbWVudCk/Yi5uYW1lc3BhY2VVUkk6a2IobnVsbCxcIlwiKTticmVhaztkZWZhdWx0OmE9OD09PWE/Yi5wYXJlbnROb2RlOmIsYj1hLm5hbWVzcGFjZVVSSXx8bnVsbCxhPWEudGFnTmFtZSxiPWtiKGIsYSl9RShCaCk7RyhCaCxiKX1mdW5jdGlvbiBHaCgpe0UoQmgpO0UoQ2gpO0UoRGgpfVxuZnVuY3Rpb24gSGgoYSl7RWgoRGguY3VycmVudCk7dmFyIGI9RWgoQmguY3VycmVudCk7dmFyIGM9a2IoYixhLnR5cGUpO2IhPT1jJiYoRyhDaCxhKSxHKEJoLGMpKX1mdW5jdGlvbiBJaChhKXtDaC5jdXJyZW50PT09YSYmKEUoQmgpLEUoQ2gpKX12YXIgSz1UZigwKTtcbmZ1bmN0aW9uIEpoKGEpe2Zvcih2YXIgYj1hO251bGwhPT1iOyl7aWYoMTM9PT1iLnRhZyl7dmFyIGM9Yi5tZW1vaXplZFN0YXRlO2lmKG51bGwhPT1jJiYoYz1jLmRlaHlkcmF0ZWQsbnVsbD09PWN8fFwiJD9cIj09PWMuZGF0YXx8XCIkIVwiPT09Yy5kYXRhKSlyZXR1cm4gYn1lbHNlIGlmKDE5PT09Yi50YWcmJnZvaWQgMCE9PWIubWVtb2l6ZWRQcm9wcy5yZXZlYWxPcmRlcil7aWYoMCE9PShiLmZsYWdzJjEyOCkpcmV0dXJuIGJ9ZWxzZSBpZihudWxsIT09Yi5jaGlsZCl7Yi5jaGlsZC5yZXR1cm49YjtiPWIuY2hpbGQ7Y29udGludWV9aWYoYj09PWEpYnJlYWs7Zm9yKDtudWxsPT09Yi5zaWJsaW5nOyl7aWYobnVsbD09PWIucmV0dXJufHxiLnJldHVybj09PWEpcmV0dXJuIG51bGw7Yj1iLnJldHVybn1iLnNpYmxpbmcucmV0dXJuPWIucmV0dXJuO2I9Yi5zaWJsaW5nfXJldHVybiBudWxsfXZhciBLaD1bXTtcbmZ1bmN0aW9uIExoKCl7Zm9yKHZhciBhPTA7YTxLaC5sZW5ndGg7YSsrKUtoW2FdLl93b3JrSW5Qcm9ncmVzc1ZlcnNpb25QcmltYXJ5PW51bGw7S2gubGVuZ3RoPTB9dmFyIE1oPXRhLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsTmg9dGEuUmVhY3RDdXJyZW50QmF0Y2hDb25maWcsT2g9MCxMPW51bGwsTT1udWxsLE49bnVsbCxQaD0hMSxRaD0hMSxSaD0wLFNoPTA7ZnVuY3Rpb24gTygpe3Rocm93IEVycm9yKHAoMzIxKSk7fWZ1bmN0aW9uIFRoKGEsYil7aWYobnVsbD09PWIpcmV0dXJuITE7Zm9yKHZhciBjPTA7YzxiLmxlbmd0aCYmYzxhLmxlbmd0aDtjKyspaWYoIUdlKGFbY10sYltjXSkpcmV0dXJuITE7cmV0dXJuITB9XG5mdW5jdGlvbiBVaChhLGIsYyxkLGUsZil7T2g9ZjtMPWI7Yi5tZW1vaXplZFN0YXRlPW51bGw7Yi51cGRhdGVRdWV1ZT1udWxsO2IubGFuZXM9MDtNaC5jdXJyZW50PW51bGw9PT1hfHxudWxsPT09YS5tZW1vaXplZFN0YXRlP1ZoOldoO2E9YyhkLGUpO2lmKFFoKXtmPTA7ZG97UWg9ITE7Umg9MDtpZigyNTw9Zil0aHJvdyBFcnJvcihwKDMwMSkpO2YrPTE7Tj1NPW51bGw7Yi51cGRhdGVRdWV1ZT1udWxsO01oLmN1cnJlbnQ9WGg7YT1jKGQsZSl9d2hpbGUoUWgpfU1oLmN1cnJlbnQ9WWg7Yj1udWxsIT09TSYmbnVsbCE9PU0ubmV4dDtPaD0wO049TT1MPW51bGw7UGg9ITE7aWYoYil0aHJvdyBFcnJvcihwKDMwMCkpO3JldHVybiBhfWZ1bmN0aW9uIFpoKCl7dmFyIGE9MCE9PVJoO1JoPTA7cmV0dXJuIGF9XG5mdW5jdGlvbiAkaCgpe3ZhciBhPXttZW1vaXplZFN0YXRlOm51bGwsYmFzZVN0YXRlOm51bGwsYmFzZVF1ZXVlOm51bGwscXVldWU6bnVsbCxuZXh0Om51bGx9O251bGw9PT1OP0wubWVtb2l6ZWRTdGF0ZT1OPWE6Tj1OLm5leHQ9YTtyZXR1cm4gTn1mdW5jdGlvbiBhaSgpe2lmKG51bGw9PT1NKXt2YXIgYT1MLmFsdGVybmF0ZTthPW51bGwhPT1hP2EubWVtb2l6ZWRTdGF0ZTpudWxsfWVsc2UgYT1NLm5leHQ7dmFyIGI9bnVsbD09PU4/TC5tZW1vaXplZFN0YXRlOk4ubmV4dDtpZihudWxsIT09YilOPWIsTT1hO2Vsc2V7aWYobnVsbD09PWEpdGhyb3cgRXJyb3IocCgzMTApKTtNPWE7YT17bWVtb2l6ZWRTdGF0ZTpNLm1lbW9pemVkU3RhdGUsYmFzZVN0YXRlOk0uYmFzZVN0YXRlLGJhc2VRdWV1ZTpNLmJhc2VRdWV1ZSxxdWV1ZTpNLnF1ZXVlLG5leHQ6bnVsbH07bnVsbD09PU4/TC5tZW1vaXplZFN0YXRlPU49YTpOPU4ubmV4dD1hfXJldHVybiBOfVxuZnVuY3Rpb24gYmkoYSxiKXtyZXR1cm5cImZ1bmN0aW9uXCI9PT10eXBlb2YgYj9iKGEpOmJ9XG5mdW5jdGlvbiBjaShhKXt2YXIgYj1haSgpLGM9Yi5xdWV1ZTtpZihudWxsPT09Yyl0aHJvdyBFcnJvcihwKDMxMSkpO2MubGFzdFJlbmRlcmVkUmVkdWNlcj1hO3ZhciBkPU0sZT1kLmJhc2VRdWV1ZSxmPWMucGVuZGluZztpZihudWxsIT09Zil7aWYobnVsbCE9PWUpe3ZhciBnPWUubmV4dDtlLm5leHQ9Zi5uZXh0O2YubmV4dD1nfWQuYmFzZVF1ZXVlPWU9ZjtjLnBlbmRpbmc9bnVsbH1pZihudWxsIT09ZSl7Zj1lLm5leHQ7ZD1kLmJhc2VTdGF0ZTt2YXIgaD1nPW51bGwsaz1udWxsLGw9Zjtkb3t2YXIgbj1sLmxhbmU7aWYoKE9oJm4pPT09biludWxsIT09ayYmKGs9ay5uZXh0PXtsYW5lOjAsYWN0aW9uOmwuYWN0aW9uLGhhc0VhZ2VyU3RhdGU6bC5oYXNFYWdlclN0YXRlLGVhZ2VyU3RhdGU6bC5lYWdlclN0YXRlLG5leHQ6bnVsbH0pLGQ9bC5oYXNFYWdlclN0YXRlP2wuZWFnZXJTdGF0ZTphKGQsbC5hY3Rpb24pO2Vsc2V7dmFyIHU9e2xhbmU6bixhY3Rpb246bC5hY3Rpb24saGFzRWFnZXJTdGF0ZTpsLmhhc0VhZ2VyU3RhdGUsXG5lYWdlclN0YXRlOmwuZWFnZXJTdGF0ZSxuZXh0Om51bGx9O251bGw9PT1rPyhoPWs9dSxnPWQpOms9ay5uZXh0PXU7TC5sYW5lc3w9bjtGZ3w9bn1sPWwubmV4dH13aGlsZShudWxsIT09bCYmbCE9PWYpO251bGw9PT1rP2c9ZDprLm5leHQ9aDtHZShkLGIubWVtb2l6ZWRTdGF0ZSl8fCh0Zz0hMCk7Yi5tZW1vaXplZFN0YXRlPWQ7Yi5iYXNlU3RhdGU9ZztiLmJhc2VRdWV1ZT1rO2MubGFzdFJlbmRlcmVkU3RhdGU9ZH1hPWMuaW50ZXJsZWF2ZWQ7aWYobnVsbCE9PWEpe2U9YTtkbyBmPWUubGFuZSxMLmxhbmVzfD1mLEZnfD1mLGU9ZS5uZXh0O3doaWxlKGUhPT1hKX1lbHNlIG51bGw9PT1lJiYoYy5sYW5lcz0wKTtyZXR1cm5bYi5tZW1vaXplZFN0YXRlLGMuZGlzcGF0Y2hdfVxuZnVuY3Rpb24gZGkoYSl7dmFyIGI9YWkoKSxjPWIucXVldWU7aWYobnVsbD09PWMpdGhyb3cgRXJyb3IocCgzMTEpKTtjLmxhc3RSZW5kZXJlZFJlZHVjZXI9YTt2YXIgZD1jLmRpc3BhdGNoLGU9Yy5wZW5kaW5nLGY9Yi5tZW1vaXplZFN0YXRlO2lmKG51bGwhPT1lKXtjLnBlbmRpbmc9bnVsbDt2YXIgZz1lPWUubmV4dDtkbyBmPWEoZixnLmFjdGlvbiksZz1nLm5leHQ7d2hpbGUoZyE9PWUpO0dlKGYsYi5tZW1vaXplZFN0YXRlKXx8KHRnPSEwKTtiLm1lbW9pemVkU3RhdGU9ZjtudWxsPT09Yi5iYXNlUXVldWUmJihiLmJhc2VTdGF0ZT1mKTtjLmxhc3RSZW5kZXJlZFN0YXRlPWZ9cmV0dXJuW2YsZF19ZnVuY3Rpb24gZWkoKXt9XG5mdW5jdGlvbiBmaShhLGIpe3ZhciBjPUwsZD1haSgpLGU9YigpLGY9IUdlKGQubWVtb2l6ZWRTdGF0ZSxlKTtmJiYoZC5tZW1vaXplZFN0YXRlPWUsdGc9ITApO2Q9ZC5xdWV1ZTtnaShoaS5iaW5kKG51bGwsYyxkLGEpLFthXSk7aWYoZC5nZXRTbmFwc2hvdCE9PWJ8fGZ8fG51bGwhPT1OJiZOLm1lbW9pemVkU3RhdGUudGFnJjEpe2MuZmxhZ3N8PTIwNDg7aWkoOSxqaS5iaW5kKG51bGwsYyxkLGUsYiksdm9pZCAwLG51bGwpO2lmKG51bGw9PT1QKXRocm93IEVycm9yKHAoMzQ5KSk7MCE9PShPaCYzMCl8fGtpKGMsYixlKX1yZXR1cm4gZX1mdW5jdGlvbiBraShhLGIsYyl7YS5mbGFnc3w9MTYzODQ7YT17Z2V0U25hcHNob3Q6Yix2YWx1ZTpjfTtiPUwudXBkYXRlUXVldWU7bnVsbD09PWI/KGI9e2xhc3RFZmZlY3Q6bnVsbCxzdG9yZXM6bnVsbH0sTC51cGRhdGVRdWV1ZT1iLGIuc3RvcmVzPVthXSk6KGM9Yi5zdG9yZXMsbnVsbD09PWM/Yi5zdG9yZXM9W2FdOmMucHVzaChhKSl9XG5mdW5jdGlvbiBqaShhLGIsYyxkKXtiLnZhbHVlPWM7Yi5nZXRTbmFwc2hvdD1kO2xpKGIpJiZMZyhhLDEsLTEpfWZ1bmN0aW9uIGhpKGEsYixjKXtyZXR1cm4gYyhmdW5jdGlvbigpe2xpKGIpJiZMZyhhLDEsLTEpfSl9ZnVuY3Rpb24gbGkoYSl7dmFyIGI9YS5nZXRTbmFwc2hvdDthPWEudmFsdWU7dHJ5e3ZhciBjPWIoKTtyZXR1cm4hR2UoYSxjKX1jYXRjaChkKXtyZXR1cm4hMH19ZnVuY3Rpb24gbWkoYSl7dmFyIGI9JGgoKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgYSYmKGE9YSgpKTtiLm1lbW9pemVkU3RhdGU9Yi5iYXNlU3RhdGU9YTthPXtwZW5kaW5nOm51bGwsaW50ZXJsZWF2ZWQ6bnVsbCxsYW5lczowLGRpc3BhdGNoOm51bGwsbGFzdFJlbmRlcmVkUmVkdWNlcjpiaSxsYXN0UmVuZGVyZWRTdGF0ZTphfTtiLnF1ZXVlPWE7YT1hLmRpc3BhdGNoPW5pLmJpbmQobnVsbCxMLGEpO3JldHVybltiLm1lbW9pemVkU3RhdGUsYV19XG5mdW5jdGlvbiBpaShhLGIsYyxkKXthPXt0YWc6YSxjcmVhdGU6YixkZXN0cm95OmMsZGVwczpkLG5leHQ6bnVsbH07Yj1MLnVwZGF0ZVF1ZXVlO251bGw9PT1iPyhiPXtsYXN0RWZmZWN0Om51bGwsc3RvcmVzOm51bGx9LEwudXBkYXRlUXVldWU9YixiLmxhc3RFZmZlY3Q9YS5uZXh0PWEpOihjPWIubGFzdEVmZmVjdCxudWxsPT09Yz9iLmxhc3RFZmZlY3Q9YS5uZXh0PWE6KGQ9Yy5uZXh0LGMubmV4dD1hLGEubmV4dD1kLGIubGFzdEVmZmVjdD1hKSk7cmV0dXJuIGF9ZnVuY3Rpb24gb2koKXtyZXR1cm4gYWkoKS5tZW1vaXplZFN0YXRlfWZ1bmN0aW9uIHBpKGEsYixjLGQpe3ZhciBlPSRoKCk7TC5mbGFnc3w9YTtlLm1lbW9pemVkU3RhdGU9aWkoMXxiLGMsdm9pZCAwLHZvaWQgMD09PWQ/bnVsbDpkKX1cbmZ1bmN0aW9uIHFpKGEsYixjLGQpe3ZhciBlPWFpKCk7ZD12b2lkIDA9PT1kP251bGw6ZDt2YXIgZj12b2lkIDA7aWYobnVsbCE9PU0pe3ZhciBnPU0ubWVtb2l6ZWRTdGF0ZTtmPWcuZGVzdHJveTtpZihudWxsIT09ZCYmVGgoZCxnLmRlcHMpKXtlLm1lbW9pemVkU3RhdGU9aWkoYixjLGYsZCk7cmV0dXJufX1MLmZsYWdzfD1hO2UubWVtb2l6ZWRTdGF0ZT1paSgxfGIsYyxmLGQpfWZ1bmN0aW9uIHJpKGEsYil7cmV0dXJuIHBpKDgzOTA2NTYsOCxhLGIpfWZ1bmN0aW9uIGdpKGEsYil7cmV0dXJuIHFpKDIwNDgsOCxhLGIpfWZ1bmN0aW9uIHNpKGEsYil7cmV0dXJuIHFpKDQsMixhLGIpfWZ1bmN0aW9uIHRpKGEsYil7cmV0dXJuIHFpKDQsNCxhLGIpfVxuZnVuY3Rpb24gdWkoYSxiKXtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYilyZXR1cm4gYT1hKCksYihhKSxmdW5jdGlvbigpe2IobnVsbCl9O2lmKG51bGwhPT1iJiZ2b2lkIDAhPT1iKXJldHVybiBhPWEoKSxiLmN1cnJlbnQ9YSxmdW5jdGlvbigpe2IuY3VycmVudD1udWxsfX1mdW5jdGlvbiB2aShhLGIsYyl7Yz1udWxsIT09YyYmdm9pZCAwIT09Yz9jLmNvbmNhdChbYV0pOm51bGw7cmV0dXJuIHFpKDQsNCx1aS5iaW5kKG51bGwsYixhKSxjKX1mdW5jdGlvbiB3aSgpe31mdW5jdGlvbiB4aShhLGIpe3ZhciBjPWFpKCk7Yj12b2lkIDA9PT1iP251bGw6Yjt2YXIgZD1jLm1lbW9pemVkU3RhdGU7aWYobnVsbCE9PWQmJm51bGwhPT1iJiZUaChiLGRbMV0pKXJldHVybiBkWzBdO2MubWVtb2l6ZWRTdGF0ZT1bYSxiXTtyZXR1cm4gYX1cbmZ1bmN0aW9uIHlpKGEsYil7dmFyIGM9YWkoKTtiPXZvaWQgMD09PWI/bnVsbDpiO3ZhciBkPWMubWVtb2l6ZWRTdGF0ZTtpZihudWxsIT09ZCYmbnVsbCE9PWImJlRoKGIsZFsxXSkpcmV0dXJuIGRbMF07YT1hKCk7Yy5tZW1vaXplZFN0YXRlPVthLGJdO3JldHVybiBhfWZ1bmN0aW9uIHppKGEsYixjKXtpZigwPT09KE9oJjIxKSlyZXR1cm4gYS5iYXNlU3RhdGUmJihhLmJhc2VTdGF0ZT0hMSx0Zz0hMCksYS5tZW1vaXplZFN0YXRlPWM7R2UoYyxiKXx8KGM9eGMoKSxMLmxhbmVzfD1jLEZnfD1jLGEuYmFzZVN0YXRlPSEwKTtyZXR1cm4gYn1mdW5jdGlvbiBBaShhLGIpe3ZhciBjPUM7Qz0wIT09YyYmND5jP2M6NDthKCEwKTt2YXIgZD1OaC50cmFuc2l0aW9uO05oLnRyYW5zaXRpb249e307dHJ5e2EoITEpLGIoKX1maW5hbGx5e0M9YyxOaC50cmFuc2l0aW9uPWR9fWZ1bmN0aW9uIEJpKCl7cmV0dXJuIGFpKCkubWVtb2l6ZWRTdGF0ZX1cbmZ1bmN0aW9uIENpKGEsYixjKXt2YXIgZD1LZyhhKTtjPXtsYW5lOmQsYWN0aW9uOmMsaGFzRWFnZXJTdGF0ZTohMSxlYWdlclN0YXRlOm51bGwsbmV4dDpudWxsfTtEaShhKT9FaShiLGMpOihGaShhLGIsYyksYz1KZygpLGE9TGcoYSxkLGMpLG51bGwhPT1hJiZHaShhLGIsZCkpfVxuZnVuY3Rpb24gbmkoYSxiLGMpe3ZhciBkPUtnKGEpLGU9e2xhbmU6ZCxhY3Rpb246YyxoYXNFYWdlclN0YXRlOiExLGVhZ2VyU3RhdGU6bnVsbCxuZXh0Om51bGx9O2lmKERpKGEpKUVpKGIsZSk7ZWxzZXtGaShhLGIsZSk7dmFyIGY9YS5hbHRlcm5hdGU7aWYoMD09PWEubGFuZXMmJihudWxsPT09Znx8MD09PWYubGFuZXMpJiYoZj1iLmxhc3RSZW5kZXJlZFJlZHVjZXIsbnVsbCE9PWYpKXRyeXt2YXIgZz1iLmxhc3RSZW5kZXJlZFN0YXRlLGg9ZihnLGMpO2UuaGFzRWFnZXJTdGF0ZT0hMDtlLmVhZ2VyU3RhdGU9aDtpZihHZShoLGcpKXJldHVybn1jYXRjaChrKXt9ZmluYWxseXt9Yz1KZygpO2E9TGcoYSxkLGMpO251bGwhPT1hJiZHaShhLGIsZCl9fWZ1bmN0aW9uIERpKGEpe3ZhciBiPWEuYWx0ZXJuYXRlO3JldHVybiBhPT09THx8bnVsbCE9PWImJmI9PT1MfVxuZnVuY3Rpb24gRWkoYSxiKXtRaD1QaD0hMDt2YXIgYz1hLnBlbmRpbmc7bnVsbD09PWM/Yi5uZXh0PWI6KGIubmV4dD1jLm5leHQsYy5uZXh0PWIpO2EucGVuZGluZz1ifWZ1bmN0aW9uIEZpKGEsYixjKXtCZyhhKT8oYT1iLmludGVybGVhdmVkLG51bGw9PT1hPyhjLm5leHQ9YyxudWxsPT09dmc/dmc9W2JdOnZnLnB1c2goYikpOihjLm5leHQ9YS5uZXh0LGEubmV4dD1jKSxiLmludGVybGVhdmVkPWMpOihhPWIucGVuZGluZyxudWxsPT09YT9jLm5leHQ9YzooYy5uZXh0PWEubmV4dCxhLm5leHQ9YyksYi5wZW5kaW5nPWMpfWZ1bmN0aW9uIEdpKGEsYixjKXtpZigwIT09KGMmNDE5NDI0MCkpe3ZhciBkPWIubGFuZXM7ZCY9YS5wZW5kaW5nTGFuZXM7Y3w9ZDtiLmxhbmVzPWM7QmMoYSxjKX19XG52YXIgWWg9e3JlYWRDb250ZXh0OnVnLHVzZUNhbGxiYWNrOk8sdXNlQ29udGV4dDpPLHVzZUVmZmVjdDpPLHVzZUltcGVyYXRpdmVIYW5kbGU6Tyx1c2VJbnNlcnRpb25FZmZlY3Q6Tyx1c2VMYXlvdXRFZmZlY3Q6Tyx1c2VNZW1vOk8sdXNlUmVkdWNlcjpPLHVzZVJlZjpPLHVzZVN0YXRlOk8sdXNlRGVidWdWYWx1ZTpPLHVzZURlZmVycmVkVmFsdWU6Tyx1c2VUcmFuc2l0aW9uOk8sdXNlTXV0YWJsZVNvdXJjZTpPLHVzZVN5bmNFeHRlcm5hbFN0b3JlOk8sdXNlSWQ6Tyx1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6ITF9LFZoPXtyZWFkQ29udGV4dDp1Zyx1c2VDYWxsYmFjazpmdW5jdGlvbihhLGIpeyRoKCkubWVtb2l6ZWRTdGF0ZT1bYSx2b2lkIDA9PT1iP251bGw6Yl07cmV0dXJuIGF9LHVzZUNvbnRleHQ6dWcsdXNlRWZmZWN0OnJpLHVzZUltcGVyYXRpdmVIYW5kbGU6ZnVuY3Rpb24oYSxiLGMpe2M9bnVsbCE9PWMmJnZvaWQgMCE9PWM/Yy5jb25jYXQoW2FdKTpudWxsO3JldHVybiBwaSg0MTk0MzA4LFxuNCx1aS5iaW5kKG51bGwsYixhKSxjKX0sdXNlTGF5b3V0RWZmZWN0OmZ1bmN0aW9uKGEsYil7cmV0dXJuIHBpKDQxOTQzMDgsNCxhLGIpfSx1c2VJbnNlcnRpb25FZmZlY3Q6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gcGkoNCwyLGEsYil9LHVzZU1lbW86ZnVuY3Rpb24oYSxiKXt2YXIgYz0kaCgpO2I9dm9pZCAwPT09Yj9udWxsOmI7YT1hKCk7Yy5tZW1vaXplZFN0YXRlPVthLGJdO3JldHVybiBhfSx1c2VSZWR1Y2VyOmZ1bmN0aW9uKGEsYixjKXt2YXIgZD0kaCgpO2I9dm9pZCAwIT09Yz9jKGIpOmI7ZC5tZW1vaXplZFN0YXRlPWQuYmFzZVN0YXRlPWI7YT17cGVuZGluZzpudWxsLGludGVybGVhdmVkOm51bGwsbGFuZXM6MCxkaXNwYXRjaDpudWxsLGxhc3RSZW5kZXJlZFJlZHVjZXI6YSxsYXN0UmVuZGVyZWRTdGF0ZTpifTtkLnF1ZXVlPWE7YT1hLmRpc3BhdGNoPUNpLmJpbmQobnVsbCxMLGEpO3JldHVybltkLm1lbW9pemVkU3RhdGUsYV19LHVzZVJlZjpmdW5jdGlvbihhKXt2YXIgYj1cbiRoKCk7YT17Y3VycmVudDphfTtyZXR1cm4gYi5tZW1vaXplZFN0YXRlPWF9LHVzZVN0YXRlOm1pLHVzZURlYnVnVmFsdWU6d2ksdXNlRGVmZXJyZWRWYWx1ZTpmdW5jdGlvbihhKXtyZXR1cm4gJGgoKS5tZW1vaXplZFN0YXRlPWF9LHVzZVRyYW5zaXRpb246ZnVuY3Rpb24oKXt2YXIgYT1taSghMSksYj1hWzBdO2E9QWkuYmluZChudWxsLGFbMV0pOyRoKCkubWVtb2l6ZWRTdGF0ZT1hO3JldHVybltiLGFdfSx1c2VNdXRhYmxlU291cmNlOmZ1bmN0aW9uKCl7fSx1c2VTeW5jRXh0ZXJuYWxTdG9yZTpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9TCxlPSRoKCk7aWYoSSl7aWYodm9pZCAwPT09Yyl0aHJvdyBFcnJvcihwKDQwNykpO2M9YygpfWVsc2V7Yz1iKCk7aWYobnVsbD09PVApdGhyb3cgRXJyb3IocCgzNDkpKTswIT09KE9oJjMwKXx8a2koZCxiLGMpfWUubWVtb2l6ZWRTdGF0ZT1jO3ZhciBmPXt2YWx1ZTpjLGdldFNuYXBzaG90OmJ9O2UucXVldWU9ZjtyaShoaS5iaW5kKG51bGwsZCxcbmYsYSksW2FdKTtkLmZsYWdzfD0yMDQ4O2lpKDksamkuYmluZChudWxsLGQsZixjLGIpLHZvaWQgMCxudWxsKTtyZXR1cm4gY30sdXNlSWQ6ZnVuY3Rpb24oKXt2YXIgYT0kaCgpLGI9UC5pZGVudGlmaWVyUHJlZml4O2lmKEkpe3ZhciBjPVpnO3ZhciBkPVlnO2M9KGQmfigxPDwzMi1uYyhkKS0xKSkudG9TdHJpbmcoMzIpK2M7Yj1cIjpcIitiK1wiUlwiK2M7Yz1SaCsrOzA8YyYmKGIrPVwiSFwiK2MudG9TdHJpbmcoMzIpKTtiKz1cIjpcIn1lbHNlIGM9U2grKyxiPVwiOlwiK2IrXCJyXCIrYy50b1N0cmluZygzMikrXCI6XCI7cmV0dXJuIGEubWVtb2l6ZWRTdGF0ZT1ifSx1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6ITF9LFdoPXtyZWFkQ29udGV4dDp1Zyx1c2VDYWxsYmFjazp4aSx1c2VDb250ZXh0OnVnLHVzZUVmZmVjdDpnaSx1c2VJbXBlcmF0aXZlSGFuZGxlOnZpLHVzZUluc2VydGlvbkVmZmVjdDpzaSx1c2VMYXlvdXRFZmZlY3Q6dGksdXNlTWVtbzp5aSx1c2VSZWR1Y2VyOmNpLHVzZVJlZjpvaSx1c2VTdGF0ZTpmdW5jdGlvbigpe3JldHVybiBjaShiaSl9LFxudXNlRGVidWdWYWx1ZTp3aSx1c2VEZWZlcnJlZFZhbHVlOmZ1bmN0aW9uKGEpe3ZhciBiPWFpKCk7cmV0dXJuIHppKGIsTS5tZW1vaXplZFN0YXRlLGEpfSx1c2VUcmFuc2l0aW9uOmZ1bmN0aW9uKCl7dmFyIGE9Y2koYmkpWzBdLGI9YWkoKS5tZW1vaXplZFN0YXRlO3JldHVyblthLGJdfSx1c2VNdXRhYmxlU291cmNlOmVpLHVzZVN5bmNFeHRlcm5hbFN0b3JlOmZpLHVzZUlkOkJpLHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjohMX0sWGg9e3JlYWRDb250ZXh0OnVnLHVzZUNhbGxiYWNrOnhpLHVzZUNvbnRleHQ6dWcsdXNlRWZmZWN0OmdpLHVzZUltcGVyYXRpdmVIYW5kbGU6dmksdXNlSW5zZXJ0aW9uRWZmZWN0OnNpLHVzZUxheW91dEVmZmVjdDp0aSx1c2VNZW1vOnlpLHVzZVJlZHVjZXI6ZGksdXNlUmVmOm9pLHVzZVN0YXRlOmZ1bmN0aW9uKCl7cmV0dXJuIGRpKGJpKX0sdXNlRGVidWdWYWx1ZTp3aSx1c2VEZWZlcnJlZFZhbHVlOmZ1bmN0aW9uKGEpe3ZhciBiPWFpKCk7cmV0dXJuIG51bGw9PT1cbk0/Yi5tZW1vaXplZFN0YXRlPWE6emkoYixNLm1lbW9pemVkU3RhdGUsYSl9LHVzZVRyYW5zaXRpb246ZnVuY3Rpb24oKXt2YXIgYT1kaShiaSlbMF0sYj1haSgpLm1lbW9pemVkU3RhdGU7cmV0dXJuW2EsYl19LHVzZU11dGFibGVTb3VyY2U6ZWksdXNlU3luY0V4dGVybmFsU3RvcmU6ZmksdXNlSWQ6QmksdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiExfTtmdW5jdGlvbiBIaShhLGIpe3RyeXt2YXIgYz1cIlwiLGQ9YjtkbyBjKz1PYShkKSxkPWQucmV0dXJuO3doaWxlKGQpO3ZhciBlPWN9Y2F0Y2goZil7ZT1cIlxcbkVycm9yIGdlbmVyYXRpbmcgc3RhY2s6IFwiK2YubWVzc2FnZStcIlxcblwiK2Yuc3RhY2t9cmV0dXJue3ZhbHVlOmEsc291cmNlOmIsc3RhY2s6ZX19ZnVuY3Rpb24gSWkoYSxiKXt0cnl7Y29uc29sZS5lcnJvcihiLnZhbHVlKX1jYXRjaChjKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhyb3cgYzt9KX19XG52YXIgSmk9XCJmdW5jdGlvblwiPT09dHlwZW9mIFdlYWtNYXA/V2Vha01hcDpNYXA7ZnVuY3Rpb24gS2koYSxiLGMpe2M9emcoLTEsYyk7Yy50YWc9MztjLnBheWxvYWQ9e2VsZW1lbnQ6bnVsbH07dmFyIGQ9Yi52YWx1ZTtjLmNhbGxiYWNrPWZ1bmN0aW9uKCl7TGl8fChMaT0hMCxNaT1kKTtJaShhLGIpfTtyZXR1cm4gY31cbmZ1bmN0aW9uIE5pKGEsYixjKXtjPXpnKC0xLGMpO2MudGFnPTM7dmFyIGQ9YS50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZCl7dmFyIGU9Yi52YWx1ZTtjLnBheWxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gZChlKX07Yy5jYWxsYmFjaz1mdW5jdGlvbigpe0lpKGEsYil9fXZhciBmPWEuc3RhdGVOb2RlO251bGwhPT1mJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgZi5jb21wb25lbnREaWRDYXRjaCYmKGMuY2FsbGJhY2s9ZnVuY3Rpb24oKXtJaShhLGIpO1wiZnVuY3Rpb25cIiE9PXR5cGVvZiBkJiYobnVsbD09PU9pP09pPW5ldyBTZXQoW3RoaXNdKTpPaS5hZGQodGhpcykpO3ZhciBjPWIuc3RhY2s7dGhpcy5jb21wb25lbnREaWRDYXRjaChiLnZhbHVlLHtjb21wb25lbnRTdGFjazpudWxsIT09Yz9jOlwiXCJ9KX0pO3JldHVybiBjfVxuZnVuY3Rpb24gUGkoYSxiLGMpe3ZhciBkPWEucGluZ0NhY2hlO2lmKG51bGw9PT1kKXtkPWEucGluZ0NhY2hlPW5ldyBKaTt2YXIgZT1uZXcgU2V0O2Quc2V0KGIsZSl9ZWxzZSBlPWQuZ2V0KGIpLHZvaWQgMD09PWUmJihlPW5ldyBTZXQsZC5zZXQoYixlKSk7ZS5oYXMoYyl8fChlLmFkZChjKSxhPVFpLmJpbmQobnVsbCxhLGIsYyksYi50aGVuKGEsYSkpfWZ1bmN0aW9uIFJpKGEpe2Rve3ZhciBiO2lmKGI9MTM9PT1hLnRhZyliPWEubWVtb2l6ZWRTdGF0ZSxiPW51bGwhPT1iP251bGwhPT1iLmRlaHlkcmF0ZWQ/ITA6ITE6ITA7aWYoYilyZXR1cm4gYTthPWEucmV0dXJufXdoaWxlKG51bGwhPT1hKTtyZXR1cm4gbnVsbH1cbmZ1bmN0aW9uIFNpKGEsYixjLGQsZSl7aWYoMD09PShhLm1vZGUmMSkpcmV0dXJuIGE9PT1iP2EuZmxhZ3N8PTY1NTM2OihhLmZsYWdzfD0xMjgsYy5mbGFnc3w9MTMxMDcyLGMuZmxhZ3MmPS01MjgwNSwxPT09Yy50YWcmJihudWxsPT09Yy5hbHRlcm5hdGU/Yy50YWc9MTc6KGI9emcoLTEsMSksYi50YWc9MixBZyhjLGIpKSksYy5sYW5lc3w9MSksYTthLmZsYWdzfD02NTUzNjthLmxhbmVzPWU7cmV0dXJuIGF9dmFyIFRpLFVpLFZpLFdpO1xuVGk9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9Yi5jaGlsZDtudWxsIT09Yzspe2lmKDU9PT1jLnRhZ3x8Nj09PWMudGFnKWEuYXBwZW5kQ2hpbGQoYy5zdGF0ZU5vZGUpO2Vsc2UgaWYoNCE9PWMudGFnJiZudWxsIT09Yy5jaGlsZCl7Yy5jaGlsZC5yZXR1cm49YztjPWMuY2hpbGQ7Y29udGludWV9aWYoYz09PWIpYnJlYWs7Zm9yKDtudWxsPT09Yy5zaWJsaW5nOyl7aWYobnVsbD09PWMucmV0dXJufHxjLnJldHVybj09PWIpcmV0dXJuO2M9Yy5yZXR1cm59Yy5zaWJsaW5nLnJldHVybj1jLnJldHVybjtjPWMuc2libGluZ319O1VpPWZ1bmN0aW9uKCl7fTtcblZpPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWEubWVtb2l6ZWRQcm9wcztpZihlIT09ZCl7YT1iLnN0YXRlTm9kZTtFaChCaC5jdXJyZW50KTt2YXIgZj1udWxsO3N3aXRjaChjKXtjYXNlIFwiaW5wdXRcIjplPVhhKGEsZSk7ZD1YYShhLGQpO2Y9W107YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmU9QSh7fSxlLHt2YWx1ZTp2b2lkIDB9KTtkPUEoe30sZCx7dmFsdWU6dm9pZCAwfSk7Zj1bXTticmVhaztjYXNlIFwidGV4dGFyZWFcIjplPWZiKGEsZSk7ZD1mYihhLGQpO2Y9W107YnJlYWs7ZGVmYXVsdDpcImZ1bmN0aW9uXCIhPT10eXBlb2YgZS5vbkNsaWNrJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5vbkNsaWNrJiYoYS5vbmNsaWNrPUFmKX10YihjLGQpO3ZhciBnO2M9bnVsbDtmb3IobCBpbiBlKWlmKCFkLmhhc093blByb3BlcnR5KGwpJiZlLmhhc093blByb3BlcnR5KGwpJiZudWxsIT1lW2xdKWlmKFwic3R5bGVcIj09PWwpe3ZhciBoPWVbbF07Zm9yKGcgaW4gaCloLmhhc093blByb3BlcnR5KGcpJiZcbihjfHwoYz17fSksY1tnXT1cIlwiKX1lbHNlXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiIT09bCYmXCJjaGlsZHJlblwiIT09bCYmXCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIiE9PWwmJlwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCIhPT1sJiZcImF1dG9Gb2N1c1wiIT09bCYmKGVhLmhhc093blByb3BlcnR5KGwpP2Z8fChmPVtdKTooZj1mfHxbXSkucHVzaChsLG51bGwpKTtmb3IobCBpbiBkKXt2YXIgaz1kW2xdO2g9bnVsbCE9ZT9lW2xdOnZvaWQgMDtpZihkLmhhc093blByb3BlcnR5KGwpJiZrIT09aCYmKG51bGwhPWt8fG51bGwhPWgpKWlmKFwic3R5bGVcIj09PWwpaWYoaCl7Zm9yKGcgaW4gaCkhaC5oYXNPd25Qcm9wZXJ0eShnKXx8ayYmay5oYXNPd25Qcm9wZXJ0eShnKXx8KGN8fChjPXt9KSxjW2ddPVwiXCIpO2ZvcihnIGluIGspay5oYXNPd25Qcm9wZXJ0eShnKSYmaFtnXSE9PWtbZ10mJihjfHwoYz17fSksY1tnXT1rW2ddKX1lbHNlIGN8fChmfHwoZj1bXSksZi5wdXNoKGwsXG5jKSksYz1rO2Vsc2VcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI9PT1sPyhrPWs/ay5fX2h0bWw6dm9pZCAwLGg9aD9oLl9faHRtbDp2b2lkIDAsbnVsbCE9ayYmaCE9PWsmJihmPWZ8fFtdKS5wdXNoKGwsaykpOlwiY2hpbGRyZW5cIj09PWw/XCJzdHJpbmdcIiE9PXR5cGVvZiBrJiZcIm51bWJlclwiIT09dHlwZW9mIGt8fChmPWZ8fFtdKS5wdXNoKGwsXCJcIitrKTpcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiIT09bCYmXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIiE9PWwmJihlYS5oYXNPd25Qcm9wZXJ0eShsKT8obnVsbCE9ayYmXCJvblNjcm9sbFwiPT09bCYmRChcInNjcm9sbFwiLGEpLGZ8fGg9PT1rfHwoZj1bXSkpOihmPWZ8fFtdKS5wdXNoKGwsaykpfWMmJihmPWZ8fFtdKS5wdXNoKFwic3R5bGVcIixjKTt2YXIgbD1mO2lmKGIudXBkYXRlUXVldWU9bCliLmZsYWdzfD00fX07V2k9ZnVuY3Rpb24oYSxiLGMsZCl7YyE9PWQmJihiLmZsYWdzfD00KX07XG5mdW5jdGlvbiBYaShhLGIpe2lmKCFJKXN3aXRjaChhLnRhaWxNb2RlKXtjYXNlIFwiaGlkZGVuXCI6Yj1hLnRhaWw7Zm9yKHZhciBjPW51bGw7bnVsbCE9PWI7KW51bGwhPT1iLmFsdGVybmF0ZSYmKGM9YiksYj1iLnNpYmxpbmc7bnVsbD09PWM/YS50YWlsPW51bGw6Yy5zaWJsaW5nPW51bGw7YnJlYWs7Y2FzZSBcImNvbGxhcHNlZFwiOmM9YS50YWlsO2Zvcih2YXIgZD1udWxsO251bGwhPT1jOyludWxsIT09Yy5hbHRlcm5hdGUmJihkPWMpLGM9Yy5zaWJsaW5nO251bGw9PT1kP2J8fG51bGw9PT1hLnRhaWw/YS50YWlsPW51bGw6YS50YWlsLnNpYmxpbmc9bnVsbDpkLnNpYmxpbmc9bnVsbH19XG5mdW5jdGlvbiBRKGEpe3ZhciBiPW51bGwhPT1hLmFsdGVybmF0ZSYmYS5hbHRlcm5hdGUuY2hpbGQ9PT1hLmNoaWxkLGM9MCxkPTA7aWYoYilmb3IodmFyIGU9YS5jaGlsZDtudWxsIT09ZTspY3w9ZS5sYW5lc3xlLmNoaWxkTGFuZXMsZHw9ZS5zdWJ0cmVlRmxhZ3MmMTQ2ODAwNjQsZHw9ZS5mbGFncyYxNDY4MDA2NCxlLnJldHVybj1hLGU9ZS5zaWJsaW5nO2Vsc2UgZm9yKGU9YS5jaGlsZDtudWxsIT09ZTspY3w9ZS5sYW5lc3xlLmNoaWxkTGFuZXMsZHw9ZS5zdWJ0cmVlRmxhZ3MsZHw9ZS5mbGFncyxlLnJldHVybj1hLGU9ZS5zaWJsaW5nO2Euc3VidHJlZUZsYWdzfD1kO2EuY2hpbGRMYW5lcz1jO3JldHVybiBifVxuZnVuY3Rpb24gWWkoYSxiLGMpe3ZhciBkPWIucGVuZGluZ1Byb3BzO2NoKGIpO3N3aXRjaChiLnRhZyl7Y2FzZSAyOmNhc2UgMTY6Y2FzZSAxNTpjYXNlIDA6Y2FzZSAxMTpjYXNlIDc6Y2FzZSA4OmNhc2UgMTI6Y2FzZSA5OmNhc2UgMTQ6cmV0dXJuIFEoYiksbnVsbDtjYXNlIDE6cmV0dXJuIFlmKGIudHlwZSkmJlpmKCksUShiKSxudWxsO2Nhc2UgMzpkPWIuc3RhdGVOb2RlO0doKCk7RShWZik7RShIKTtMaCgpO2QucGVuZGluZ0NvbnRleHQmJihkLmNvbnRleHQ9ZC5wZW5kaW5nQ29udGV4dCxkLnBlbmRpbmdDb250ZXh0PW51bGwpO2lmKG51bGw9PT1hfHxudWxsPT09YS5jaGlsZCltaChiKT9iLmZsYWdzfD00Om51bGw9PT1hfHxhLm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkJiYwPT09KGIuZmxhZ3MmMjU2KXx8KGIuZmxhZ3N8PTEwMjQsbnVsbCE9PWZoJiYoWmkoZmgpLGZoPW51bGwpKTtVaShhLGIpO1EoYik7cmV0dXJuIG51bGw7Y2FzZSA1OkloKGIpO3ZhciBlPUVoKERoLmN1cnJlbnQpO1xuYz1iLnR5cGU7aWYobnVsbCE9PWEmJm51bGwhPWIuc3RhdGVOb2RlKVZpKGEsYixjLGQsZSksYS5yZWYhPT1iLnJlZiYmKGIuZmxhZ3N8PTUxMixiLmZsYWdzfD0yMDk3MTUyKTtlbHNle2lmKCFkKXtpZihudWxsPT09Yi5zdGF0ZU5vZGUpdGhyb3cgRXJyb3IocCgxNjYpKTtRKGIpO3JldHVybiBudWxsfWE9RWgoQmguY3VycmVudCk7aWYobWgoYikpe2Q9Yi5zdGF0ZU5vZGU7Yz1iLnR5cGU7dmFyIGY9Yi5tZW1vaXplZFByb3BzO2RbTmZdPWI7ZFtPZl09ZjthPTAhPT0oYi5tb2RlJjEpO3N3aXRjaChjKXtjYXNlIFwiZGlhbG9nXCI6RChcImNhbmNlbFwiLGQpO0QoXCJjbG9zZVwiLGQpO2JyZWFrO2Nhc2UgXCJpZnJhbWVcIjpjYXNlIFwib2JqZWN0XCI6Y2FzZSBcImVtYmVkXCI6RChcImxvYWRcIixkKTticmVhaztjYXNlIFwidmlkZW9cIjpjYXNlIFwiYXVkaW9cIjpmb3IoZT0wO2U8a2YubGVuZ3RoO2UrKylEKGtmW2VdLGQpO2JyZWFrO2Nhc2UgXCJzb3VyY2VcIjpEKFwiZXJyb3JcIixkKTticmVhaztjYXNlIFwiaW1nXCI6Y2FzZSBcImltYWdlXCI6Y2FzZSBcImxpbmtcIjpEKFwiZXJyb3JcIixcbmQpO0QoXCJsb2FkXCIsZCk7YnJlYWs7Y2FzZSBcImRldGFpbHNcIjpEKFwidG9nZ2xlXCIsZCk7YnJlYWs7Y2FzZSBcImlucHV0XCI6WWEoZCxmKTtEKFwiaW52YWxpZFwiLGQpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpkLl93cmFwcGVyU3RhdGU9e3dhc011bHRpcGxlOiEhZi5tdWx0aXBsZX07RChcImludmFsaWRcIixkKTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpnYihkLGYpLEQoXCJpbnZhbGlkXCIsZCl9dGIoYyxmKTtlPW51bGw7Zm9yKHZhciBnIGluIGYpaWYoZi5oYXNPd25Qcm9wZXJ0eShnKSl7dmFyIGg9ZltnXTtcImNoaWxkcmVuXCI9PT1nP1wic3RyaW5nXCI9PT10eXBlb2YgaD9kLnRleHRDb250ZW50IT09aCYmKCEwIT09Zi5zdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcmJnpmKGQudGV4dENvbnRlbnQsaCxhKSxlPVtcImNoaWxkcmVuXCIsaF0pOlwibnVtYmVyXCI9PT10eXBlb2YgaCYmZC50ZXh0Q29udGVudCE9PVwiXCIraCYmKCEwIT09Zi5zdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcmJnpmKGQudGV4dENvbnRlbnQsXG5oLGEpLGU9W1wiY2hpbGRyZW5cIixcIlwiK2hdKTplYS5oYXNPd25Qcm9wZXJ0eShnKSYmbnVsbCE9aCYmXCJvblNjcm9sbFwiPT09ZyYmRChcInNjcm9sbFwiLGQpfXN3aXRjaChjKXtjYXNlIFwiaW5wdXRcIjpVYShkKTtjYihkLGYsITApO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOlVhKGQpO2liKGQpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpjYXNlIFwib3B0aW9uXCI6YnJlYWs7ZGVmYXVsdDpcImZ1bmN0aW9uXCI9PT10eXBlb2YgZi5vbkNsaWNrJiYoZC5vbmNsaWNrPUFmKX1kPWU7Yi51cGRhdGVRdWV1ZT1kO251bGwhPT1kJiYoYi5mbGFnc3w9NCl9ZWxzZXtnPTk9PT1lLm5vZGVUeXBlP2U6ZS5vd25lckRvY3VtZW50O1wiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiPT09YSYmKGE9amIoYykpO1wiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiPT09YT9cInNjcmlwdFwiPT09Yz8oYT1nLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksYS5pbm5lckhUTUw9XCI8c2NyaXB0PlxceDNjL3NjcmlwdD5cIixhPWEucmVtb3ZlQ2hpbGQoYS5maXJzdENoaWxkKSk6XG5cInN0cmluZ1wiPT09dHlwZW9mIGQuaXM/YT1nLmNyZWF0ZUVsZW1lbnQoYyx7aXM6ZC5pc30pOihhPWcuY3JlYXRlRWxlbWVudChjKSxcInNlbGVjdFwiPT09YyYmKGc9YSxkLm11bHRpcGxlP2cubXVsdGlwbGU9ITA6ZC5zaXplJiYoZy5zaXplPWQuc2l6ZSkpKTphPWcuY3JlYXRlRWxlbWVudE5TKGEsYyk7YVtOZl09YjthW09mXT1kO1RpKGEsYiwhMSwhMSk7Yi5zdGF0ZU5vZGU9YTthOntnPXViKGMsZCk7c3dpdGNoKGMpe2Nhc2UgXCJkaWFsb2dcIjpEKFwiY2FuY2VsXCIsYSk7RChcImNsb3NlXCIsYSk7ZT1kO2JyZWFrO2Nhc2UgXCJpZnJhbWVcIjpjYXNlIFwib2JqZWN0XCI6Y2FzZSBcImVtYmVkXCI6RChcImxvYWRcIixhKTtlPWQ7YnJlYWs7Y2FzZSBcInZpZGVvXCI6Y2FzZSBcImF1ZGlvXCI6Zm9yKGU9MDtlPGtmLmxlbmd0aDtlKyspRChrZltlXSxhKTtlPWQ7YnJlYWs7Y2FzZSBcInNvdXJjZVwiOkQoXCJlcnJvclwiLGEpO2U9ZDticmVhaztjYXNlIFwiaW1nXCI6Y2FzZSBcImltYWdlXCI6Y2FzZSBcImxpbmtcIjpEKFwiZXJyb3JcIixcbmEpO0QoXCJsb2FkXCIsYSk7ZT1kO2JyZWFrO2Nhc2UgXCJkZXRhaWxzXCI6RChcInRvZ2dsZVwiLGEpO2U9ZDticmVhaztjYXNlIFwiaW5wdXRcIjpZYShhLGQpO2U9WGEoYSxkKTtEKFwiaW52YWxpZFwiLGEpO2JyZWFrO2Nhc2UgXCJvcHRpb25cIjplPWQ7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmEuX3dyYXBwZXJTdGF0ZT17d2FzTXVsdGlwbGU6ISFkLm11bHRpcGxlfTtlPUEoe30sZCx7dmFsdWU6dm9pZCAwfSk7RChcImludmFsaWRcIixhKTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpnYihhLGQpO2U9ZmIoYSxkKTtEKFwiaW52YWxpZFwiLGEpO2JyZWFrO2RlZmF1bHQ6ZT1kfXRiKGMsZSk7aD1lO2ZvcihmIGluIGgpaWYoaC5oYXNPd25Qcm9wZXJ0eShmKSl7dmFyIGs9aFtmXTtcInN0eWxlXCI9PT1mP3JiKGEsayk6XCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiPT09Zj8oaz1rP2suX19odG1sOnZvaWQgMCxudWxsIT1rJiZtYihhLGspKTpcImNoaWxkcmVuXCI9PT1mP1wic3RyaW5nXCI9PT10eXBlb2Ygaz8oXCJ0ZXh0YXJlYVwiIT09XG5jfHxcIlwiIT09aykmJm5iKGEsayk6XCJudW1iZXJcIj09PXR5cGVvZiBrJiZuYihhLFwiXCIrayk6XCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIiE9PWYmJlwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCIhPT1mJiZcImF1dG9Gb2N1c1wiIT09ZiYmKGVhLmhhc093blByb3BlcnR5KGYpP251bGwhPWsmJlwib25TY3JvbGxcIj09PWYmJkQoXCJzY3JvbGxcIixhKTpudWxsIT1rJiZzYShhLGYsayxnKSl9c3dpdGNoKGMpe2Nhc2UgXCJpbnB1dFwiOlVhKGEpO2NiKGEsZCwhMSk7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6VWEoYSk7aWIoYSk7YnJlYWs7Y2FzZSBcIm9wdGlvblwiOm51bGwhPWQudmFsdWUmJmEuc2V0QXR0cmlidXRlKFwidmFsdWVcIixcIlwiK1JhKGQudmFsdWUpKTticmVhaztjYXNlIFwic2VsZWN0XCI6YS5tdWx0aXBsZT0hIWQubXVsdGlwbGU7Zj1kLnZhbHVlO251bGwhPWY/ZWIoYSwhIWQubXVsdGlwbGUsZiwhMSk6bnVsbCE9ZC5kZWZhdWx0VmFsdWUmJmViKGEsISFkLm11bHRpcGxlLGQuZGVmYXVsdFZhbHVlLFxuITApO2JyZWFrO2RlZmF1bHQ6XCJmdW5jdGlvblwiPT09dHlwZW9mIGUub25DbGljayYmKGEub25jbGljaz1BZil9c3dpdGNoKGMpe2Nhc2UgXCJidXR0b25cIjpjYXNlIFwiaW5wdXRcIjpjYXNlIFwic2VsZWN0XCI6Y2FzZSBcInRleHRhcmVhXCI6ZD0hIWQuYXV0b0ZvY3VzO2JyZWFrIGE7Y2FzZSBcImltZ1wiOmQ9ITA7YnJlYWsgYTtkZWZhdWx0OmQ9ITF9fWQmJihiLmZsYWdzfD00KX1udWxsIT09Yi5yZWYmJihiLmZsYWdzfD01MTIsYi5mbGFnc3w9MjA5NzE1Mil9UShiKTtyZXR1cm4gbnVsbDtjYXNlIDY6aWYoYSYmbnVsbCE9Yi5zdGF0ZU5vZGUpV2koYSxiLGEubWVtb2l6ZWRQcm9wcyxkKTtlbHNle2lmKFwic3RyaW5nXCIhPT10eXBlb2YgZCYmbnVsbD09PWIuc3RhdGVOb2RlKXRocm93IEVycm9yKHAoMTY2KSk7Yz1FaChEaC5jdXJyZW50KTtFaChCaC5jdXJyZW50KTtpZihtaChiKSl7ZD1iLnN0YXRlTm9kZTtjPWIubWVtb2l6ZWRQcm9wcztkW05mXT1iO2lmKGY9ZC5ub2RlVmFsdWUhPT1jKWlmKGE9XG5kaCxudWxsIT09YSlzd2l0Y2goYS50YWcpe2Nhc2UgMzp6ZihkLm5vZGVWYWx1ZSxjLDAhPT0oYS5tb2RlJjEpKTticmVhaztjYXNlIDU6ITAhPT1hLm1lbW9pemVkUHJvcHMuc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJiZ6ZihkLm5vZGVWYWx1ZSxjLDAhPT0oYS5tb2RlJjEpKX1mJiYoYi5mbGFnc3w9NCl9ZWxzZSBkPSg5PT09Yy5ub2RlVHlwZT9jOmMub3duZXJEb2N1bWVudCkuY3JlYXRlVGV4dE5vZGUoZCksZFtOZl09YixiLnN0YXRlTm9kZT1kfVEoYik7cmV0dXJuIG51bGw7Y2FzZSAxMzpFKEspO2Q9Yi5tZW1vaXplZFN0YXRlO2lmKEkmJm51bGwhPT1laCYmMCE9PShiLm1vZGUmMSkmJjA9PT0oYi5mbGFncyYxMjgpKXtmb3IoZD1laDtkOylkPUtmKGQubmV4dFNpYmxpbmcpO25oKCk7Yi5mbGFnc3w9OTg1NjA7cmV0dXJuIGJ9aWYobnVsbCE9PWQmJm51bGwhPT1kLmRlaHlkcmF0ZWQpe2Q9bWgoYik7aWYobnVsbD09PWEpe2lmKCFkKXRocm93IEVycm9yKHAoMzE4KSk7ZD1cbmIubWVtb2l6ZWRTdGF0ZTtkPW51bGwhPT1kP2QuZGVoeWRyYXRlZDpudWxsO2lmKCFkKXRocm93IEVycm9yKHAoMzE3KSk7ZFtOZl09Yn1lbHNlIG5oKCksMD09PShiLmZsYWdzJjEyOCkmJihiLm1lbW9pemVkU3RhdGU9bnVsbCksYi5mbGFnc3w9NDtRKGIpO3JldHVybiBudWxsfW51bGwhPT1maCYmKFppKGZoKSxmaD1udWxsKTtpZigwIT09KGIuZmxhZ3MmMTI4KSlyZXR1cm4gYi5sYW5lcz1jLGI7ZD1udWxsIT09ZDtjPSExO251bGw9PT1hP21oKGIpOmM9bnVsbCE9PWEubWVtb2l6ZWRTdGF0ZTtkIT09YyYmZCYmKGIuY2hpbGQuZmxhZ3N8PTgxOTIsMCE9PShiLm1vZGUmMSkmJihudWxsPT09YXx8MCE9PShLLmN1cnJlbnQmMSk/MD09PVImJihSPTMpOiRpKCkpKTtudWxsIT09Yi51cGRhdGVRdWV1ZSYmKGIuZmxhZ3N8PTQpO1EoYik7cmV0dXJuIG51bGw7Y2FzZSA0OnJldHVybiBHaCgpLFVpKGEsYiksbnVsbD09PWEmJnJmKGIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pLFEoYiksXG5udWxsO2Nhc2UgMTA6cmV0dXJuIHFnKGIudHlwZS5fY29udGV4dCksUShiKSxudWxsO2Nhc2UgMTc6cmV0dXJuIFlmKGIudHlwZSkmJlpmKCksUShiKSxudWxsO2Nhc2UgMTk6RShLKTtmPWIubWVtb2l6ZWRTdGF0ZTtpZihudWxsPT09ZilyZXR1cm4gUShiKSxudWxsO2Q9MCE9PShiLmZsYWdzJjEyOCk7Zz1mLnJlbmRlcmluZztpZihudWxsPT09ZylpZihkKVhpKGYsITEpO2Vsc2V7aWYoMCE9PVJ8fG51bGwhPT1hJiYwIT09KGEuZmxhZ3MmMTI4KSlmb3IoYT1iLmNoaWxkO251bGwhPT1hOyl7Zz1KaChhKTtpZihudWxsIT09Zyl7Yi5mbGFnc3w9MTI4O1hpKGYsITEpO2Q9Zy51cGRhdGVRdWV1ZTtudWxsIT09ZCYmKGIudXBkYXRlUXVldWU9ZCxiLmZsYWdzfD00KTtiLnN1YnRyZWVGbGFncz0wO2Q9Yztmb3IoYz1iLmNoaWxkO251bGwhPT1jOylmPWMsYT1kLGYuZmxhZ3MmPTE0NjgwMDY2LGc9Zi5hbHRlcm5hdGUsbnVsbD09PWc/KGYuY2hpbGRMYW5lcz0wLGYubGFuZXM9YSxmLmNoaWxkPVxubnVsbCxmLnN1YnRyZWVGbGFncz0wLGYubWVtb2l6ZWRQcm9wcz1udWxsLGYubWVtb2l6ZWRTdGF0ZT1udWxsLGYudXBkYXRlUXVldWU9bnVsbCxmLmRlcGVuZGVuY2llcz1udWxsLGYuc3RhdGVOb2RlPW51bGwpOihmLmNoaWxkTGFuZXM9Zy5jaGlsZExhbmVzLGYubGFuZXM9Zy5sYW5lcyxmLmNoaWxkPWcuY2hpbGQsZi5zdWJ0cmVlRmxhZ3M9MCxmLmRlbGV0aW9ucz1udWxsLGYubWVtb2l6ZWRQcm9wcz1nLm1lbW9pemVkUHJvcHMsZi5tZW1vaXplZFN0YXRlPWcubWVtb2l6ZWRTdGF0ZSxmLnVwZGF0ZVF1ZXVlPWcudXBkYXRlUXVldWUsZi50eXBlPWcudHlwZSxhPWcuZGVwZW5kZW5jaWVzLGYuZGVwZW5kZW5jaWVzPW51bGw9PT1hP251bGw6e2xhbmVzOmEubGFuZXMsZmlyc3RDb250ZXh0OmEuZmlyc3RDb250ZXh0fSksYz1jLnNpYmxpbmc7RyhLLEsuY3VycmVudCYxfDIpO3JldHVybiBiLmNoaWxkfWE9YS5zaWJsaW5nfW51bGwhPT1mLnRhaWwmJkIoKT5haiYmKGIuZmxhZ3N8PVxuMTI4LGQ9ITAsWGkoZiwhMSksYi5sYW5lcz00MTk0MzA0KX1lbHNle2lmKCFkKWlmKGE9SmgoZyksbnVsbCE9PWEpe2lmKGIuZmxhZ3N8PTEyOCxkPSEwLGM9YS51cGRhdGVRdWV1ZSxudWxsIT09YyYmKGIudXBkYXRlUXVldWU9YyxiLmZsYWdzfD00KSxYaShmLCEwKSxudWxsPT09Zi50YWlsJiZcImhpZGRlblwiPT09Zi50YWlsTW9kZSYmIWcuYWx0ZXJuYXRlJiYhSSlyZXR1cm4gUShiKSxudWxsfWVsc2UgMipCKCktZi5yZW5kZXJpbmdTdGFydFRpbWU+YWomJjEwNzM3NDE4MjQhPT1jJiYoYi5mbGFnc3w9MTI4LGQ9ITAsWGkoZiwhMSksYi5sYW5lcz00MTk0MzA0KTtmLmlzQmFja3dhcmRzPyhnLnNpYmxpbmc9Yi5jaGlsZCxiLmNoaWxkPWcpOihjPWYubGFzdCxudWxsIT09Yz9jLnNpYmxpbmc9ZzpiLmNoaWxkPWcsZi5sYXN0PWcpfWlmKG51bGwhPT1mLnRhaWwpcmV0dXJuIGI9Zi50YWlsLGYucmVuZGVyaW5nPWIsZi50YWlsPWIuc2libGluZyxmLnJlbmRlcmluZ1N0YXJ0VGltZT1cbkIoKSxiLnNpYmxpbmc9bnVsbCxjPUsuY3VycmVudCxHKEssZD9jJjF8MjpjJjEpLGI7UShiKTtyZXR1cm4gbnVsbDtjYXNlIDIyOmNhc2UgMjM6cmV0dXJuIGJqKCksZD1udWxsIT09Yi5tZW1vaXplZFN0YXRlLG51bGwhPT1hJiZudWxsIT09YS5tZW1vaXplZFN0YXRlIT09ZCYmKGIuZmxhZ3N8PTgxOTIpLGQmJjAhPT0oYi5tb2RlJjEpPzAhPT0oY2omMTA3Mzc0MTgyNCkmJihRKGIpLGIuc3VidHJlZUZsYWdzJjYmJihiLmZsYWdzfD04MTkyKSk6UShiKSxudWxsO2Nhc2UgMjQ6cmV0dXJuIG51bGw7Y2FzZSAyNTpyZXR1cm4gbnVsbH10aHJvdyBFcnJvcihwKDE1NixiLnRhZykpO312YXIgZGo9dGEuUmVhY3RDdXJyZW50T3duZXIsdGc9ITE7ZnVuY3Rpb24gZWooYSxiLGMsZCl7Yi5jaGlsZD1udWxsPT09YT96aChiLG51bGwsYyxkKTp5aChiLGEuY2hpbGQsYyxkKX1cbmZ1bmN0aW9uIGZqKGEsYixjLGQsZSl7Yz1jLnJlbmRlcjt2YXIgZj1iLnJlZjtzZyhiLGUpO2Q9VWgoYSxiLGMsZCxmLGUpO2M9WmgoKTtpZihudWxsIT09YSYmIXRnKXJldHVybiBiLnVwZGF0ZVF1ZXVlPWEudXBkYXRlUXVldWUsYi5mbGFncyY9LTIwNTMsYS5sYW5lcyY9fmUsZ2ooYSxiLGUpO0kmJmMmJmJoKGIpO2IuZmxhZ3N8PTE7ZWooYSxiLGQsZSk7cmV0dXJuIGIuY2hpbGR9XG5mdW5jdGlvbiBoaihhLGIsYyxkLGUpe2lmKG51bGw9PT1hKXt2YXIgZj1jLnR5cGU7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGYmJiFpaihmKSYmdm9pZCAwPT09Zi5kZWZhdWx0UHJvcHMmJm51bGw9PT1jLmNvbXBhcmUmJnZvaWQgMD09PWMuZGVmYXVsdFByb3BzKXJldHVybiBiLnRhZz0xNSxiLnR5cGU9ZixqaihhLGIsZixkLGUpO2E9dmgoYy50eXBlLG51bGwsZCxiLGIubW9kZSxlKTthLnJlZj1iLnJlZjthLnJldHVybj1iO3JldHVybiBiLmNoaWxkPWF9Zj1hLmNoaWxkO2lmKDA9PT0oYS5sYW5lcyZlKSl7dmFyIGc9Zi5tZW1vaXplZFByb3BzO2M9Yy5jb21wYXJlO2M9bnVsbCE9PWM/YzpIZTtpZihjKGcsZCkmJmEucmVmPT09Yi5yZWYpcmV0dXJuIGdqKGEsYixlKX1iLmZsYWdzfD0xO2E9dGgoZixkKTthLnJlZj1iLnJlZjthLnJldHVybj1iO3JldHVybiBiLmNoaWxkPWF9XG5mdW5jdGlvbiBqaihhLGIsYyxkLGUpe2lmKG51bGwhPT1hKXt2YXIgZj1hLm1lbW9pemVkUHJvcHM7aWYoSGUoZixkKSYmYS5yZWY9PT1iLnJlZilpZih0Zz0hMSxiLnBlbmRpbmdQcm9wcz1kPWYsMCE9PShhLmxhbmVzJmUpKTAhPT0oYS5mbGFncyYxMzEwNzIpJiYodGc9ITApO2Vsc2UgcmV0dXJuIGIubGFuZXM9YS5sYW5lcyxnaihhLGIsZSl9cmV0dXJuIGtqKGEsYixjLGQsZSl9XG5mdW5jdGlvbiBsaihhLGIsYyl7dmFyIGQ9Yi5wZW5kaW5nUHJvcHMsZT1kLmNoaWxkcmVuLGY9bnVsbCE9PWE/YS5tZW1vaXplZFN0YXRlOm51bGw7aWYoXCJoaWRkZW5cIj09PWQubW9kZSlpZigwPT09KGIubW9kZSYxKSliLm1lbW9pemVkU3RhdGU9e2Jhc2VMYW5lczowLGNhY2hlUG9vbDpudWxsLHRyYW5zaXRpb25zOm51bGx9LEcobWosY2opLGNqfD1jO2Vsc2UgaWYoMCE9PShjJjEwNzM3NDE4MjQpKWIubWVtb2l6ZWRTdGF0ZT17YmFzZUxhbmVzOjAsY2FjaGVQb29sOm51bGwsdHJhbnNpdGlvbnM6bnVsbH0sZD1udWxsIT09Zj9mLmJhc2VMYW5lczpjLEcobWosY2opLGNqfD1kO2Vsc2UgcmV0dXJuIGE9bnVsbCE9PWY/Zi5iYXNlTGFuZXN8YzpjLGIubGFuZXM9Yi5jaGlsZExhbmVzPTEwNzM3NDE4MjQsYi5tZW1vaXplZFN0YXRlPXtiYXNlTGFuZXM6YSxjYWNoZVBvb2w6bnVsbCx0cmFuc2l0aW9uczpudWxsfSxiLnVwZGF0ZVF1ZXVlPW51bGwsRyhtaixjaiksY2p8PWEsbnVsbDtcbmVsc2UgbnVsbCE9PWY/KGQ9Zi5iYXNlTGFuZXN8YyxiLm1lbW9pemVkU3RhdGU9bnVsbCk6ZD1jLEcobWosY2opLGNqfD1kO2VqKGEsYixlLGMpO3JldHVybiBiLmNoaWxkfWZ1bmN0aW9uIG5qKGEsYil7dmFyIGM9Yi5yZWY7aWYobnVsbD09PWEmJm51bGwhPT1jfHxudWxsIT09YSYmYS5yZWYhPT1jKWIuZmxhZ3N8PTUxMixiLmZsYWdzfD0yMDk3MTUyfWZ1bmN0aW9uIGtqKGEsYixjLGQsZSl7dmFyIGY9WWYoYyk/V2Y6SC5jdXJyZW50O2Y9WGYoYixmKTtzZyhiLGUpO2M9VWgoYSxiLGMsZCxmLGUpO2Q9WmgoKTtpZihudWxsIT09YSYmIXRnKXJldHVybiBiLnVwZGF0ZVF1ZXVlPWEudXBkYXRlUXVldWUsYi5mbGFncyY9LTIwNTMsYS5sYW5lcyY9fmUsZ2ooYSxiLGUpO0kmJmQmJmJoKGIpO2IuZmxhZ3N8PTE7ZWooYSxiLGMsZSk7cmV0dXJuIGIuY2hpbGR9XG5mdW5jdGlvbiBvaihhLGIsYyxkLGUpe2lmKFlmKGMpKXt2YXIgZj0hMDtiZyhiKX1lbHNlIGY9ITE7c2coYixlKTtpZihudWxsPT09Yi5zdGF0ZU5vZGUpbnVsbCE9PWEmJihhLmFsdGVybmF0ZT1udWxsLGIuYWx0ZXJuYXRlPW51bGwsYi5mbGFnc3w9MiksT2coYixjLGQpLFFnKGIsYyxkLGUpLGQ9ITA7ZWxzZSBpZihudWxsPT09YSl7dmFyIGc9Yi5zdGF0ZU5vZGUsaD1iLm1lbW9pemVkUHJvcHM7Zy5wcm9wcz1oO3ZhciBrPWcuY29udGV4dCxsPWMuY29udGV4dFR5cGU7XCJvYmplY3RcIj09PXR5cGVvZiBsJiZudWxsIT09bD9sPXVnKGwpOihsPVlmKGMpP1dmOkguY3VycmVudCxsPVhmKGIsbCkpO3ZhciBuPWMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLHU9XCJmdW5jdGlvblwiPT09dHlwZW9mIG58fFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlO3V8fFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJiZcblwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHN8fChoIT09ZHx8ayE9PWwpJiZQZyhiLGcsZCxsKTt3Zz0hMTt2YXIgcT1iLm1lbW9pemVkU3RhdGU7Zy5zdGF0ZT1xO0VnKGIsZCxnLGUpO2s9Yi5tZW1vaXplZFN0YXRlO2ghPT1kfHxxIT09a3x8VmYuY3VycmVudHx8d2c/KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBuJiYoSWcoYixjLG4sZCksaz1iLm1lbW9pemVkU3RhdGUpLChoPXdnfHxOZyhiLGMsaCxkLHEsayxsKSk/KHV8fFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxNb3VudHx8KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxNb3VudCYmZy5jb21wb25lbnRXaWxsTW91bnQoKSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JiZnLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKSksXCJmdW5jdGlvblwiPT09XG50eXBlb2YgZy5jb21wb25lbnREaWRNb3VudCYmKGIuZmxhZ3N8PTQxOTQzMDgpKTooXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuY29tcG9uZW50RGlkTW91bnQmJihiLmZsYWdzfD00MTk0MzA4KSxiLm1lbW9pemVkUHJvcHM9ZCxiLm1lbW9pemVkU3RhdGU9ayksZy5wcm9wcz1kLGcuc3RhdGU9ayxnLmNvbnRleHQ9bCxkPWgpOihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnREaWRNb3VudCYmKGIuZmxhZ3N8PTQxOTQzMDgpLGQ9ITEpfWVsc2V7Zz1iLnN0YXRlTm9kZTt5ZyhhLGIpO2g9Yi5tZW1vaXplZFByb3BzO2w9Yi50eXBlPT09Yi5lbGVtZW50VHlwZT9oOmtnKGIudHlwZSxoKTtnLnByb3BzPWw7dT1iLnBlbmRpbmdQcm9wcztxPWcuY29udGV4dDtrPWMuY29udGV4dFR5cGU7XCJvYmplY3RcIj09PXR5cGVvZiBrJiZudWxsIT09az9rPXVnKGspOihrPVlmKGMpP1dmOkguY3VycmVudCxrPVhmKGIsaykpO3ZhciB5PWMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOyhuPVwiZnVuY3Rpb25cIj09PVxudHlwZW9mIHl8fFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKXx8XCJmdW5jdGlvblwiIT09dHlwZW9mIGcuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHN8fChoIT09dXx8cSE9PWspJiZQZyhiLGcsZCxrKTt3Zz0hMTtxPWIubWVtb2l6ZWRTdGF0ZTtnLnN0YXRlPXE7RWcoYixkLGcsZSk7dmFyIG09Yi5tZW1vaXplZFN0YXRlO2ghPT11fHxxIT09bXx8VmYuY3VycmVudHx8d2c/KFwiZnVuY3Rpb25cIj09PXR5cGVvZiB5JiYoSWcoYixjLHksZCksbT1iLm1lbW9pemVkU3RhdGUpLChsPXdnfHxOZyhiLGMsbCxkLHEsbSxrKXx8ITEpPyhufHxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGcuY29tcG9uZW50V2lsbFVwZGF0ZXx8KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxVcGRhdGUmJlxuZy5jb21wb25lbnRXaWxsVXBkYXRlKGQsbSxrKSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSYmZy5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZShkLG0saykpLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmNvbXBvbmVudERpZFVwZGF0ZSYmKGIuZmxhZ3N8PTQpLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlJiYoYi5mbGFnc3w9MTAyNCkpOihcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGV8fGg9PT1hLm1lbW9pemVkUHJvcHMmJnE9PT1hLm1lbW9pemVkU3RhdGV8fChiLmZsYWdzfD00KSxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXx8aD09PWEubWVtb2l6ZWRQcm9wcyYmcT09PWEubWVtb2l6ZWRTdGF0ZXx8KGIuZmxhZ3N8PTEwMjQpLGIubWVtb2l6ZWRQcm9wcz1kLGIubWVtb2l6ZWRTdGF0ZT1tKSxnLnByb3BzPWQsZy5zdGF0ZT1tLGcuY29udGV4dD1cbmssZD1sKTooXCJmdW5jdGlvblwiIT09dHlwZW9mIGcuY29tcG9uZW50RGlkVXBkYXRlfHxoPT09YS5tZW1vaXplZFByb3BzJiZxPT09YS5tZW1vaXplZFN0YXRlfHwoYi5mbGFnc3w9NCksXCJmdW5jdGlvblwiIT09dHlwZW9mIGcuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGV8fGg9PT1hLm1lbW9pemVkUHJvcHMmJnE9PT1hLm1lbW9pemVkU3RhdGV8fChiLmZsYWdzfD0xMDI0KSxkPSExKX1yZXR1cm4gcGooYSxiLGMsZCxmLGUpfVxuZnVuY3Rpb24gcGooYSxiLGMsZCxlLGYpe25qKGEsYik7dmFyIGc9MCE9PShiLmZsYWdzJjEyOCk7aWYoIWQmJiFnKXJldHVybiBlJiZjZyhiLGMsITEpLGdqKGEsYixmKTtkPWIuc3RhdGVOb2RlO2RqLmN1cnJlbnQ9Yjt2YXIgaD1nJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgYy5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I/bnVsbDpkLnJlbmRlcigpO2IuZmxhZ3N8PTE7bnVsbCE9PWEmJmc/KGIuY2hpbGQ9eWgoYixhLmNoaWxkLG51bGwsZiksYi5jaGlsZD15aChiLG51bGwsaCxmKSk6ZWooYSxiLGgsZik7Yi5tZW1vaXplZFN0YXRlPWQuc3RhdGU7ZSYmY2coYixjLCEwKTtyZXR1cm4gYi5jaGlsZH1mdW5jdGlvbiBxaihhKXt2YXIgYj1hLnN0YXRlTm9kZTtiLnBlbmRpbmdDb250ZXh0PyRmKGEsYi5wZW5kaW5nQ29udGV4dCxiLnBlbmRpbmdDb250ZXh0IT09Yi5jb250ZXh0KTpiLmNvbnRleHQmJiRmKGEsYi5jb250ZXh0LCExKTtGaChhLGIuY29udGFpbmVySW5mbyl9XG5mdW5jdGlvbiByaihhLGIsYyxkLGUpe25oKCk7b2goZSk7Yi5mbGFnc3w9MjU2O2VqKGEsYixjLGQpO3JldHVybiBiLmNoaWxkfXZhciBzaj17ZGVoeWRyYXRlZDpudWxsLHRyZWVDb250ZXh0Om51bGwscmV0cnlMYW5lOjB9O2Z1bmN0aW9uIHRqKGEpe3JldHVybntiYXNlTGFuZXM6YSxjYWNoZVBvb2w6bnVsbCx0cmFuc2l0aW9uczpudWxsfX1mdW5jdGlvbiB1aihhLGIpe3JldHVybntiYXNlTGFuZXM6YS5iYXNlTGFuZXN8YixjYWNoZVBvb2w6bnVsbCx0cmFuc2l0aW9uczphLnRyYW5zaXRpb25zfX1cbmZ1bmN0aW9uIHZqKGEsYixjKXt2YXIgZD1iLnBlbmRpbmdQcm9wcyxlPUsuY3VycmVudCxmPSExLGc9MCE9PShiLmZsYWdzJjEyOCksaDsoaD1nKXx8KGg9bnVsbCE9PWEmJm51bGw9PT1hLm1lbW9pemVkU3RhdGU/ITE6MCE9PShlJjIpKTtpZihoKWY9ITAsYi5mbGFncyY9LTEyOTtlbHNlIGlmKG51bGw9PT1hfHxudWxsIT09YS5tZW1vaXplZFN0YXRlKWV8PTE7RyhLLGUmMSk7aWYobnVsbD09PWEpe2toKGIpO2E9Yi5tZW1vaXplZFN0YXRlO2lmKG51bGwhPT1hJiYoYT1hLmRlaHlkcmF0ZWQsbnVsbCE9PWEpKXJldHVybiAwPT09KGIubW9kZSYxKT9iLmxhbmVzPTE6XCIkIVwiPT09YS5kYXRhP2IubGFuZXM9ODpiLmxhbmVzPTEwNzM3NDE4MjQsbnVsbDtlPWQuY2hpbGRyZW47YT1kLmZhbGxiYWNrO3JldHVybiBmPyhkPWIubW9kZSxmPWIuY2hpbGQsZT17bW9kZTpcImhpZGRlblwiLGNoaWxkcmVuOmV9LDA9PT0oZCYxKSYmbnVsbCE9PWY/KGYuY2hpbGRMYW5lcz0wLGYucGVuZGluZ1Byb3BzPVxuZSk6Zj13aihlLGQsMCxudWxsKSxhPXhoKGEsZCxjLG51bGwpLGYucmV0dXJuPWIsYS5yZXR1cm49YixmLnNpYmxpbmc9YSxiLmNoaWxkPWYsYi5jaGlsZC5tZW1vaXplZFN0YXRlPXRqKGMpLGIubWVtb2l6ZWRTdGF0ZT1zaixhKTp4aihiLGUpfWU9YS5tZW1vaXplZFN0YXRlO2lmKG51bGwhPT1lKXtoPWUuZGVoeWRyYXRlZDtpZihudWxsIT09aCl7aWYoZyl7aWYoYi5mbGFncyYyNTYpcmV0dXJuIGIuZmxhZ3MmPS0yNTcseWooYSxiLGMsRXJyb3IocCg0MjIpKSk7aWYobnVsbCE9PWIubWVtb2l6ZWRTdGF0ZSlyZXR1cm4gYi5jaGlsZD1hLmNoaWxkLGIuZmxhZ3N8PTEyOCxudWxsO2Y9ZC5mYWxsYmFjaztlPWIubW9kZTtkPXdqKHttb2RlOlwidmlzaWJsZVwiLGNoaWxkcmVuOmQuY2hpbGRyZW59LGUsMCxudWxsKTtmPXhoKGYsZSxjLG51bGwpO2YuZmxhZ3N8PTI7ZC5yZXR1cm49YjtmLnJldHVybj1iO2Quc2libGluZz1mO2IuY2hpbGQ9ZDswIT09KGIubW9kZSYxKSYmeWgoYixhLmNoaWxkLFxubnVsbCxjKTtiLmNoaWxkLm1lbW9pemVkU3RhdGU9dGooYyk7Yi5tZW1vaXplZFN0YXRlPXNqO3JldHVybiBmfWlmKDA9PT0oYi5tb2RlJjEpKWI9eWooYSxiLGMsbnVsbCk7ZWxzZSBpZihcIiQhXCI9PT1oLmRhdGEpYj15aihhLGIsYyxFcnJvcihwKDQxOSkpKTtlbHNlIGlmKGQ9MCE9PShjJmEuY2hpbGRMYW5lcyksdGd8fGQpe2Q9UDtpZihudWxsIT09ZCl7c3dpdGNoKGMmLWMpe2Nhc2UgNDpmPTI7YnJlYWs7Y2FzZSAxNjpmPTg7YnJlYWs7Y2FzZSA2NDpjYXNlIDEyODpjYXNlIDI1NjpjYXNlIDUxMjpjYXNlIDEwMjQ6Y2FzZSAyMDQ4OmNhc2UgNDA5NjpjYXNlIDgxOTI6Y2FzZSAxNjM4NDpjYXNlIDMyNzY4OmNhc2UgNjU1MzY6Y2FzZSAxMzEwNzI6Y2FzZSAyNjIxNDQ6Y2FzZSA1MjQyODg6Y2FzZSAxMDQ4NTc2OmNhc2UgMjA5NzE1MjpjYXNlIDQxOTQzMDQ6Y2FzZSA4Mzg4NjA4OmNhc2UgMTY3NzcyMTY6Y2FzZSAzMzU1NDQzMjpjYXNlIDY3MTA4ODY0OmY9MzI7YnJlYWs7Y2FzZSA1MzY4NzA5MTI6Zj1cbjI2ODQzNTQ1NjticmVhaztkZWZhdWx0OmY9MH1kPTAhPT0oZiYoZC5zdXNwZW5kZWRMYW5lc3xjKSk/MDpmOzAhPT1kJiZkIT09ZS5yZXRyeUxhbmUmJihlLnJldHJ5TGFuZT1kLExnKGEsZCwtMSkpfSRpKCk7Yj15aihhLGIsYyxFcnJvcihwKDQyMSkpKX1lbHNlXCIkP1wiPT09aC5kYXRhPyhiLmZsYWdzfD0xMjgsYi5jaGlsZD1hLmNoaWxkLGI9emouYmluZChudWxsLGEpLGguX3JlYWN0UmV0cnk9YixiPW51bGwpOihjPWUudHJlZUNvbnRleHQsZWg9S2YoaC5uZXh0U2libGluZyksZGg9YixJPSEwLGZoPW51bGwsbnVsbCE9PWMmJihWZ1tXZysrXT1ZZyxWZ1tXZysrXT1aZyxWZ1tXZysrXT1YZyxZZz1jLmlkLFpnPWMub3ZlcmZsb3csWGc9YiksYj14aihiLGIucGVuZGluZ1Byb3BzLmNoaWxkcmVuKSxiLmZsYWdzfD00MDk2KTtyZXR1cm4gYn1pZihmKXJldHVybiBkPUFqKGEsYixkLmNoaWxkcmVuLGQuZmFsbGJhY2ssYyksZj1iLmNoaWxkLGU9YS5jaGlsZC5tZW1vaXplZFN0YXRlLFxuZi5tZW1vaXplZFN0YXRlPW51bGw9PT1lP3RqKGMpOnVqKGUsYyksZi5jaGlsZExhbmVzPWEuY2hpbGRMYW5lcyZ+YyxiLm1lbW9pemVkU3RhdGU9c2osZDtjPUJqKGEsYixkLmNoaWxkcmVuLGMpO2IubWVtb2l6ZWRTdGF0ZT1udWxsO3JldHVybiBjfWlmKGYpcmV0dXJuIGQ9QWooYSxiLGQuY2hpbGRyZW4sZC5mYWxsYmFjayxjKSxmPWIuY2hpbGQsZT1hLmNoaWxkLm1lbW9pemVkU3RhdGUsZi5tZW1vaXplZFN0YXRlPW51bGw9PT1lP3RqKGMpOnVqKGUsYyksZi5jaGlsZExhbmVzPWEuY2hpbGRMYW5lcyZ+YyxiLm1lbW9pemVkU3RhdGU9c2osZDtjPUJqKGEsYixkLmNoaWxkcmVuLGMpO2IubWVtb2l6ZWRTdGF0ZT1udWxsO3JldHVybiBjfWZ1bmN0aW9uIHhqKGEsYil7Yj13aih7bW9kZTpcInZpc2libGVcIixjaGlsZHJlbjpifSxhLm1vZGUsMCxudWxsKTtiLnJldHVybj1hO3JldHVybiBhLmNoaWxkPWJ9XG5mdW5jdGlvbiBCaihhLGIsYyxkKXt2YXIgZT1hLmNoaWxkO2E9ZS5zaWJsaW5nO2M9dGgoZSx7bW9kZTpcInZpc2libGVcIixjaGlsZHJlbjpjfSk7MD09PShiLm1vZGUmMSkmJihjLmxhbmVzPWQpO2MucmV0dXJuPWI7Yy5zaWJsaW5nPW51bGw7bnVsbCE9PWEmJihkPWIuZGVsZXRpb25zLG51bGw9PT1kPyhiLmRlbGV0aW9ucz1bYV0sYi5mbGFnc3w9MTYpOmQucHVzaChhKSk7cmV0dXJuIGIuY2hpbGQ9Y31cbmZ1bmN0aW9uIEFqKGEsYixjLGQsZSl7dmFyIGY9Yi5tb2RlO2E9YS5jaGlsZDt2YXIgZz1hLnNpYmxpbmcsaD17bW9kZTpcImhpZGRlblwiLGNoaWxkcmVuOmN9OzA9PT0oZiYxKSYmYi5jaGlsZCE9PWE/KGM9Yi5jaGlsZCxjLmNoaWxkTGFuZXM9MCxjLnBlbmRpbmdQcm9wcz1oLGIuZGVsZXRpb25zPW51bGwpOihjPXRoKGEsaCksYy5zdWJ0cmVlRmxhZ3M9YS5zdWJ0cmVlRmxhZ3MmMTQ2ODAwNjQpO251bGwhPT1nP2Q9dGgoZyxkKTooZD14aChkLGYsZSxudWxsKSxkLmZsYWdzfD0yKTtkLnJldHVybj1iO2MucmV0dXJuPWI7Yy5zaWJsaW5nPWQ7Yi5jaGlsZD1jO3JldHVybiBkfWZ1bmN0aW9uIHlqKGEsYixjLGQpe251bGwhPT1kJiZvaChkKTt5aChiLGEuY2hpbGQsbnVsbCxjKTthPXhqKGIsYi5wZW5kaW5nUHJvcHMuY2hpbGRyZW4pO2EuZmxhZ3N8PTI7Yi5tZW1vaXplZFN0YXRlPW51bGw7cmV0dXJuIGF9XG5mdW5jdGlvbiBDaihhLGIsYyl7YS5sYW5lc3w9Yjt2YXIgZD1hLmFsdGVybmF0ZTtudWxsIT09ZCYmKGQubGFuZXN8PWIpO3JnKGEucmV0dXJuLGIsYyl9ZnVuY3Rpb24gRGooYSxiLGMsZCxlKXt2YXIgZj1hLm1lbW9pemVkU3RhdGU7bnVsbD09PWY/YS5tZW1vaXplZFN0YXRlPXtpc0JhY2t3YXJkczpiLHJlbmRlcmluZzpudWxsLHJlbmRlcmluZ1N0YXJ0VGltZTowLGxhc3Q6ZCx0YWlsOmMsdGFpbE1vZGU6ZX06KGYuaXNCYWNrd2FyZHM9YixmLnJlbmRlcmluZz1udWxsLGYucmVuZGVyaW5nU3RhcnRUaW1lPTAsZi5sYXN0PWQsZi50YWlsPWMsZi50YWlsTW9kZT1lKX1cbmZ1bmN0aW9uIEVqKGEsYixjKXt2YXIgZD1iLnBlbmRpbmdQcm9wcyxlPWQucmV2ZWFsT3JkZXIsZj1kLnRhaWw7ZWooYSxiLGQuY2hpbGRyZW4sYyk7ZD1LLmN1cnJlbnQ7aWYoMCE9PShkJjIpKWQ9ZCYxfDIsYi5mbGFnc3w9MTI4O2Vsc2V7aWYobnVsbCE9PWEmJjAhPT0oYS5mbGFncyYxMjgpKWE6Zm9yKGE9Yi5jaGlsZDtudWxsIT09YTspe2lmKDEzPT09YS50YWcpbnVsbCE9PWEubWVtb2l6ZWRTdGF0ZSYmQ2ooYSxjLGIpO2Vsc2UgaWYoMTk9PT1hLnRhZylDaihhLGMsYik7ZWxzZSBpZihudWxsIT09YS5jaGlsZCl7YS5jaGlsZC5yZXR1cm49YTthPWEuY2hpbGQ7Y29udGludWV9aWYoYT09PWIpYnJlYWsgYTtmb3IoO251bGw9PT1hLnNpYmxpbmc7KXtpZihudWxsPT09YS5yZXR1cm58fGEucmV0dXJuPT09YilicmVhayBhO2E9YS5yZXR1cm59YS5zaWJsaW5nLnJldHVybj1hLnJldHVybjthPWEuc2libGluZ31kJj0xfUcoSyxkKTtpZigwPT09KGIubW9kZSYxKSliLm1lbW9pemVkU3RhdGU9XG5udWxsO2Vsc2Ugc3dpdGNoKGUpe2Nhc2UgXCJmb3J3YXJkc1wiOmM9Yi5jaGlsZDtmb3IoZT1udWxsO251bGwhPT1jOylhPWMuYWx0ZXJuYXRlLG51bGwhPT1hJiZudWxsPT09SmgoYSkmJihlPWMpLGM9Yy5zaWJsaW5nO2M9ZTtudWxsPT09Yz8oZT1iLmNoaWxkLGIuY2hpbGQ9bnVsbCk6KGU9Yy5zaWJsaW5nLGMuc2libGluZz1udWxsKTtEaihiLCExLGUsYyxmKTticmVhaztjYXNlIFwiYmFja3dhcmRzXCI6Yz1udWxsO2U9Yi5jaGlsZDtmb3IoYi5jaGlsZD1udWxsO251bGwhPT1lOyl7YT1lLmFsdGVybmF0ZTtpZihudWxsIT09YSYmbnVsbD09PUpoKGEpKXtiLmNoaWxkPWU7YnJlYWt9YT1lLnNpYmxpbmc7ZS5zaWJsaW5nPWM7Yz1lO2U9YX1EaihiLCEwLGMsbnVsbCxmKTticmVhaztjYXNlIFwidG9nZXRoZXJcIjpEaihiLCExLG51bGwsbnVsbCx2b2lkIDApO2JyZWFrO2RlZmF1bHQ6Yi5tZW1vaXplZFN0YXRlPW51bGx9cmV0dXJuIGIuY2hpbGR9XG5mdW5jdGlvbiBnaihhLGIsYyl7bnVsbCE9PWEmJihiLmRlcGVuZGVuY2llcz1hLmRlcGVuZGVuY2llcyk7Rmd8PWIubGFuZXM7aWYoMD09PShjJmIuY2hpbGRMYW5lcykpcmV0dXJuIG51bGw7aWYobnVsbCE9PWEmJmIuY2hpbGQhPT1hLmNoaWxkKXRocm93IEVycm9yKHAoMTUzKSk7aWYobnVsbCE9PWIuY2hpbGQpe2E9Yi5jaGlsZDtjPXRoKGEsYS5wZW5kaW5nUHJvcHMpO2IuY2hpbGQ9Yztmb3IoYy5yZXR1cm49YjtudWxsIT09YS5zaWJsaW5nOylhPWEuc2libGluZyxjPWMuc2libGluZz10aChhLGEucGVuZGluZ1Byb3BzKSxjLnJldHVybj1iO2Muc2libGluZz1udWxsfXJldHVybiBiLmNoaWxkfVxuZnVuY3Rpb24gRmooYSxiLGMpe3N3aXRjaChiLnRhZyl7Y2FzZSAzOnFqKGIpO25oKCk7YnJlYWs7Y2FzZSA1OkhoKGIpO2JyZWFrO2Nhc2UgMTpZZihiLnR5cGUpJiZiZyhiKTticmVhaztjYXNlIDQ6RmgoYixiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTticmVhaztjYXNlIDEwOnZhciBkPWIudHlwZS5fY29udGV4dCxlPWIubWVtb2l6ZWRQcm9wcy52YWx1ZTtHKGxnLGQuX2N1cnJlbnRWYWx1ZSk7ZC5fY3VycmVudFZhbHVlPWU7YnJlYWs7Y2FzZSAxMzpkPWIubWVtb2l6ZWRTdGF0ZTtpZihudWxsIT09ZCl7aWYobnVsbCE9PWQuZGVoeWRyYXRlZClyZXR1cm4gRyhLLEsuY3VycmVudCYxKSxiLmZsYWdzfD0xMjgsbnVsbDtpZigwIT09KGMmYi5jaGlsZC5jaGlsZExhbmVzKSlyZXR1cm4gdmooYSxiLGMpO0coSyxLLmN1cnJlbnQmMSk7YT1naihhLGIsYyk7cmV0dXJuIG51bGwhPT1hP2Euc2libGluZzpudWxsfUcoSyxLLmN1cnJlbnQmMSk7YnJlYWs7Y2FzZSAxOTpkPTAhPT0oYyZcbmIuY2hpbGRMYW5lcyk7aWYoMCE9PShhLmZsYWdzJjEyOCkpe2lmKGQpcmV0dXJuIEVqKGEsYixjKTtiLmZsYWdzfD0xMjh9ZT1iLm1lbW9pemVkU3RhdGU7bnVsbCE9PWUmJihlLnJlbmRlcmluZz1udWxsLGUudGFpbD1udWxsLGUubGFzdEVmZmVjdD1udWxsKTtHKEssSy5jdXJyZW50KTtpZihkKWJyZWFrO2Vsc2UgcmV0dXJuIG51bGw7Y2FzZSAyMjpjYXNlIDIzOnJldHVybiBiLmxhbmVzPTAsbGooYSxiLGMpfXJldHVybiBnaihhLGIsYyl9XG5mdW5jdGlvbiBHaihhLGIpe2NoKGIpO3N3aXRjaChiLnRhZyl7Y2FzZSAxOnJldHVybiBZZihiLnR5cGUpJiZaZigpLGE9Yi5mbGFncyxhJjY1NTM2PyhiLmZsYWdzPWEmLTY1NTM3fDEyOCxiKTpudWxsO2Nhc2UgMzpyZXR1cm4gR2goKSxFKFZmKSxFKEgpLExoKCksYT1iLmZsYWdzLDAhPT0oYSY2NTUzNikmJjA9PT0oYSYxMjgpPyhiLmZsYWdzPWEmLTY1NTM3fDEyOCxiKTpudWxsO2Nhc2UgNTpyZXR1cm4gSWgoYiksbnVsbDtjYXNlIDEzOkUoSyk7YT1iLm1lbW9pemVkU3RhdGU7aWYobnVsbCE9PWEmJm51bGwhPT1hLmRlaHlkcmF0ZWQpe2lmKG51bGw9PT1iLmFsdGVybmF0ZSl0aHJvdyBFcnJvcihwKDM0MCkpO25oKCl9YT1iLmZsYWdzO3JldHVybiBhJjY1NTM2PyhiLmZsYWdzPWEmLTY1NTM3fDEyOCxiKTpudWxsO2Nhc2UgMTk6cmV0dXJuIEUoSyksbnVsbDtjYXNlIDQ6cmV0dXJuIEdoKCksbnVsbDtjYXNlIDEwOnJldHVybiBxZyhiLnR5cGUuX2NvbnRleHQpLG51bGw7Y2FzZSAyMjpjYXNlIDIzOnJldHVybiBiaigpLFxubnVsbDtjYXNlIDI0OnJldHVybiBudWxsO2RlZmF1bHQ6cmV0dXJuIG51bGx9fXZhciBIaj0hMSxTPSExLElqPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBXZWFrU2V0P1dlYWtTZXQ6U2V0LFQ9bnVsbDtmdW5jdGlvbiBKaihhLGIpe3ZhciBjPWEucmVmO2lmKG51bGwhPT1jKWlmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBjKXRyeXtjKG51bGwpfWNhdGNoKGQpe1UoYSxiLGQpfWVsc2UgYy5jdXJyZW50PW51bGx9ZnVuY3Rpb24gS2ooYSxiLGMpe3RyeXtjKCl9Y2F0Y2goZCl7VShhLGIsZCl9fXZhciBMaj0hMTtcbmZ1bmN0aW9uIE1qKGEsYil7QmY9Y2Q7YT1MZSgpO2lmKE1lKGEpKXtpZihcInNlbGVjdGlvblN0YXJ0XCJpbiBhKXZhciBjPXtzdGFydDphLnNlbGVjdGlvblN0YXJ0LGVuZDphLnNlbGVjdGlvbkVuZH07ZWxzZSBhOntjPShjPWEub3duZXJEb2N1bWVudCkmJmMuZGVmYXVsdFZpZXd8fHdpbmRvdzt2YXIgZD1jLmdldFNlbGVjdGlvbiYmYy5nZXRTZWxlY3Rpb24oKTtpZihkJiYwIT09ZC5yYW5nZUNvdW50KXtjPWQuYW5jaG9yTm9kZTt2YXIgZT1kLmFuY2hvck9mZnNldCxmPWQuZm9jdXNOb2RlO2Q9ZC5mb2N1c09mZnNldDt0cnl7Yy5ub2RlVHlwZSxmLm5vZGVUeXBlfWNhdGNoKFope2M9bnVsbDticmVhayBhfXZhciBnPTAsaD0tMSxrPS0xLGw9MCxuPTAsdT1hLHE9bnVsbDtiOmZvcig7Oyl7Zm9yKHZhciB5Ozspe3UhPT1jfHwwIT09ZSYmMyE9PXUubm9kZVR5cGV8fChoPWcrZSk7dSE9PWZ8fDAhPT1kJiYzIT09dS5ub2RlVHlwZXx8KGs9ZytkKTszPT09dS5ub2RlVHlwZSYmKGcrPVxudS5ub2RlVmFsdWUubGVuZ3RoKTtpZihudWxsPT09KHk9dS5maXJzdENoaWxkKSlicmVhaztxPXU7dT15fWZvcig7Oyl7aWYodT09PWEpYnJlYWsgYjtxPT09YyYmKytsPT09ZSYmKGg9Zyk7cT09PWYmJisrbj09PWQmJihrPWcpO2lmKG51bGwhPT0oeT11Lm5leHRTaWJsaW5nKSlicmVhazt1PXE7cT11LnBhcmVudE5vZGV9dT15fWM9LTE9PT1ofHwtMT09PWs/bnVsbDp7c3RhcnQ6aCxlbmQ6a319ZWxzZSBjPW51bGx9Yz1jfHx7c3RhcnQ6MCxlbmQ6MH19ZWxzZSBjPW51bGw7Q2Y9e2ZvY3VzZWRFbGVtOmEsc2VsZWN0aW9uUmFuZ2U6Y307Y2Q9ITE7Zm9yKFQ9YjtudWxsIT09VDspaWYoYj1ULGE9Yi5jaGlsZCwwIT09KGIuc3VidHJlZUZsYWdzJjEwMjgpJiZudWxsIT09YSlhLnJldHVybj1iLFQ9YTtlbHNlIGZvcig7bnVsbCE9PVQ7KXtiPVQ7dHJ5e3ZhciBtPWIuYWx0ZXJuYXRlO2lmKDAhPT0oYi5mbGFncyYxMDI0KSlzd2l0Y2goYi50YWcpe2Nhc2UgMDpjYXNlIDExOmNhc2UgMTU6YnJlYWs7XG5jYXNlIDE6aWYobnVsbCE9PW0pe3ZhciB3PW0ubWVtb2l6ZWRQcm9wcyxKPW0ubWVtb2l6ZWRTdGF0ZSx2PWIuc3RhdGVOb2RlLHg9di5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShiLmVsZW1lbnRUeXBlPT09Yi50eXBlP3c6a2coYi50eXBlLHcpLEopO3YuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGU9eH1icmVhaztjYXNlIDM6dmFyIHI9Yi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztpZigxPT09ci5ub2RlVHlwZSlyLnRleHRDb250ZW50PVwiXCI7ZWxzZSBpZig5PT09ci5ub2RlVHlwZSl7dmFyIEY9ci5ib2R5O251bGwhPUYmJihGLnRleHRDb250ZW50PVwiXCIpfWJyZWFrO2Nhc2UgNTpjYXNlIDY6Y2FzZSA0OmNhc2UgMTc6YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihwKDE2MykpO319Y2F0Y2goWil7VShiLGIucmV0dXJuLFopfWE9Yi5zaWJsaW5nO2lmKG51bGwhPT1hKXthLnJldHVybj1iLnJldHVybjtUPWE7YnJlYWt9VD1iLnJldHVybn1tPUxqO0xqPSExO3JldHVybiBtfVxuZnVuY3Rpb24gTmooYSxiLGMpe3ZhciBkPWIudXBkYXRlUXVldWU7ZD1udWxsIT09ZD9kLmxhc3RFZmZlY3Q6bnVsbDtpZihudWxsIT09ZCl7dmFyIGU9ZD1kLm5leHQ7ZG97aWYoKGUudGFnJmEpPT09YSl7dmFyIGY9ZS5kZXN0cm95O2UuZGVzdHJveT12b2lkIDA7dm9pZCAwIT09ZiYmS2ooYixjLGYpfWU9ZS5uZXh0fXdoaWxlKGUhPT1kKX19ZnVuY3Rpb24gT2ooYSxiKXtiPWIudXBkYXRlUXVldWU7Yj1udWxsIT09Yj9iLmxhc3RFZmZlY3Q6bnVsbDtpZihudWxsIT09Yil7dmFyIGM9Yj1iLm5leHQ7ZG97aWYoKGMudGFnJmEpPT09YSl7dmFyIGQ9Yy5jcmVhdGU7Yy5kZXN0cm95PWQoKX1jPWMubmV4dH13aGlsZShjIT09Yil9fWZ1bmN0aW9uIFBqKGEpe3ZhciBiPWEucmVmO2lmKG51bGwhPT1iKXt2YXIgYz1hLnN0YXRlTm9kZTtzd2l0Y2goYS50YWcpe2Nhc2UgNTphPWM7YnJlYWs7ZGVmYXVsdDphPWN9XCJmdW5jdGlvblwiPT09dHlwZW9mIGI/YihhKTpiLmN1cnJlbnQ9YX19XG5mdW5jdGlvbiBRaihhKXt2YXIgYj1hLmFsdGVybmF0ZTtudWxsIT09YiYmKGEuYWx0ZXJuYXRlPW51bGwsUWooYikpO2EuY2hpbGQ9bnVsbDthLmRlbGV0aW9ucz1udWxsO2Euc2libGluZz1udWxsOzU9PT1hLnRhZyYmKGI9YS5zdGF0ZU5vZGUsbnVsbCE9PWImJihkZWxldGUgYltOZl0sZGVsZXRlIGJbT2ZdLGRlbGV0ZSBiW25mXSxkZWxldGUgYltQZl0sZGVsZXRlIGJbUWZdKSk7YS5zdGF0ZU5vZGU9bnVsbDthLnJldHVybj1udWxsO2EuZGVwZW5kZW5jaWVzPW51bGw7YS5tZW1vaXplZFByb3BzPW51bGw7YS5tZW1vaXplZFN0YXRlPW51bGw7YS5wZW5kaW5nUHJvcHM9bnVsbDthLnN0YXRlTm9kZT1udWxsO2EudXBkYXRlUXVldWU9bnVsbH1mdW5jdGlvbiBSaihhKXtyZXR1cm4gNT09PWEudGFnfHwzPT09YS50YWd8fDQ9PT1hLnRhZ31cbmZ1bmN0aW9uIFNqKGEpe2E6Zm9yKDs7KXtmb3IoO251bGw9PT1hLnNpYmxpbmc7KXtpZihudWxsPT09YS5yZXR1cm58fFJqKGEucmV0dXJuKSlyZXR1cm4gbnVsbDthPWEucmV0dXJufWEuc2libGluZy5yZXR1cm49YS5yZXR1cm47Zm9yKGE9YS5zaWJsaW5nOzUhPT1hLnRhZyYmNiE9PWEudGFnJiYxOCE9PWEudGFnOyl7aWYoYS5mbGFncyYyKWNvbnRpbnVlIGE7aWYobnVsbD09PWEuY2hpbGR8fDQ9PT1hLnRhZyljb250aW51ZSBhO2Vsc2UgYS5jaGlsZC5yZXR1cm49YSxhPWEuY2hpbGR9aWYoIShhLmZsYWdzJjIpKXJldHVybiBhLnN0YXRlTm9kZX19XG5mdW5jdGlvbiBUaihhLGIsYyl7dmFyIGQ9YS50YWc7aWYoNT09PWR8fDY9PT1kKWE9YS5zdGF0ZU5vZGUsYj84PT09Yy5ub2RlVHlwZT9jLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEsYik6Yy5pbnNlcnRCZWZvcmUoYSxiKTooOD09PWMubm9kZVR5cGU/KGI9Yy5wYXJlbnROb2RlLGIuaW5zZXJ0QmVmb3JlKGEsYykpOihiPWMsYi5hcHBlbmRDaGlsZChhKSksYz1jLl9yZWFjdFJvb3RDb250YWluZXIsbnVsbCE9PWMmJnZvaWQgMCE9PWN8fG51bGwhPT1iLm9uY2xpY2t8fChiLm9uY2xpY2s9QWYpKTtlbHNlIGlmKDQhPT1kJiYoYT1hLmNoaWxkLG51bGwhPT1hKSlmb3IoVGooYSxiLGMpLGE9YS5zaWJsaW5nO251bGwhPT1hOylUaihhLGIsYyksYT1hLnNpYmxpbmd9XG5mdW5jdGlvbiBVaihhLGIsYyl7dmFyIGQ9YS50YWc7aWYoNT09PWR8fDY9PT1kKWE9YS5zdGF0ZU5vZGUsYj9jLmluc2VydEJlZm9yZShhLGIpOmMuYXBwZW5kQ2hpbGQoYSk7ZWxzZSBpZig0IT09ZCYmKGE9YS5jaGlsZCxudWxsIT09YSkpZm9yKFVqKGEsYixjKSxhPWEuc2libGluZztudWxsIT09YTspVWooYSxiLGMpLGE9YS5zaWJsaW5nfXZhciBWPW51bGwsVmo9ITE7ZnVuY3Rpb24gV2ooYSxiLGMpe2ZvcihjPWMuY2hpbGQ7bnVsbCE9PWM7KVhqKGEsYixjKSxjPWMuc2libGluZ31cbmZ1bmN0aW9uIFhqKGEsYixjKXtpZihrYyYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGtjLm9uQ29tbWl0RmliZXJVbm1vdW50KXRyeXtrYy5vbkNvbW1pdEZpYmVyVW5tb3VudChqYyxjKX1jYXRjaChoKXt9c3dpdGNoKGMudGFnKXtjYXNlIDU6U3x8SmooYyxiKTtjYXNlIDY6dmFyIGQ9VixlPVZqO1Y9bnVsbDtXaihhLGIsYyk7Vj1kO1ZqPWU7bnVsbCE9PVYmJihWaj8oYT1WLGM9Yy5zdGF0ZU5vZGUsOD09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMpOmEucmVtb3ZlQ2hpbGQoYykpOlYucmVtb3ZlQ2hpbGQoYy5zdGF0ZU5vZGUpKTticmVhaztjYXNlIDE4Om51bGwhPT1WJiYoVmo/KGE9VixjPWMuc3RhdGVOb2RlLDg9PT1hLm5vZGVUeXBlP0pmKGEucGFyZW50Tm9kZSxjKToxPT09YS5ub2RlVHlwZSYmSmYoYSxjKSxhZChhKSk6SmYoVixjLnN0YXRlTm9kZSkpO2JyZWFrO2Nhc2UgNDpkPVY7ZT1WajtWPWMuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87Vmo9ITA7XG5XaihhLGIsYyk7Vj1kO1ZqPWU7YnJlYWs7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNDpjYXNlIDE1OmlmKCFTJiYoZD1jLnVwZGF0ZVF1ZXVlLG51bGwhPT1kJiYoZD1kLmxhc3RFZmZlY3QsbnVsbCE9PWQpKSl7ZT1kPWQubmV4dDtkb3t2YXIgZj1lLGc9Zi5kZXN0cm95O2Y9Zi50YWc7dm9pZCAwIT09ZyYmKDAhPT0oZiYyKT9LaihjLGIsZyk6MCE9PShmJjQpJiZLaihjLGIsZykpO2U9ZS5uZXh0fXdoaWxlKGUhPT1kKX1XaihhLGIsYyk7YnJlYWs7Y2FzZSAxOmlmKCFTJiYoSmooYyxiKSxkPWMuc3RhdGVOb2RlLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLmNvbXBvbmVudFdpbGxVbm1vdW50KSl0cnl7ZC5wcm9wcz1jLm1lbW9pemVkUHJvcHMsZC5zdGF0ZT1jLm1lbW9pemVkU3RhdGUsZC5jb21wb25lbnRXaWxsVW5tb3VudCgpfWNhdGNoKGgpe1UoYyxiLGgpfVdqKGEsYixjKTticmVhaztjYXNlIDIxOldqKGEsYixjKTticmVhaztjYXNlIDIyOmMubW9kZSYxPyhTPShkPVMpfHxudWxsIT09XG5jLm1lbW9pemVkU3RhdGUsV2ooYSxiLGMpLFM9ZCk6V2ooYSxiLGMpO2JyZWFrO2RlZmF1bHQ6V2ooYSxiLGMpfX1mdW5jdGlvbiBZaihhKXt2YXIgYj1hLnVwZGF0ZVF1ZXVlO2lmKG51bGwhPT1iKXthLnVwZGF0ZVF1ZXVlPW51bGw7dmFyIGM9YS5zdGF0ZU5vZGU7bnVsbD09PWMmJihjPWEuc3RhdGVOb2RlPW5ldyBJaik7Yi5mb3JFYWNoKGZ1bmN0aW9uKGIpe3ZhciBkPVpqLmJpbmQobnVsbCxhLGIpO2MuaGFzKGIpfHwoYy5hZGQoYiksYi50aGVuKGQsZCkpfSl9fVxuZnVuY3Rpb24gYWsoYSxiKXt2YXIgYz1iLmRlbGV0aW9ucztpZihudWxsIT09Yylmb3IodmFyIGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGU9Y1tkXTt0cnl7dmFyIGY9YSxnPWIsaD1nO2E6Zm9yKDtudWxsIT09aDspe3N3aXRjaChoLnRhZyl7Y2FzZSA1OlY9aC5zdGF0ZU5vZGU7Vmo9ITE7YnJlYWsgYTtjYXNlIDM6Vj1oLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1ZqPSEwO2JyZWFrIGE7Y2FzZSA0OlY9aC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztWaj0hMDticmVhayBhfWg9aC5yZXR1cm59aWYobnVsbD09PVYpdGhyb3cgRXJyb3IocCgxNjApKTtYaihmLGcsZSk7Vj1udWxsO1ZqPSExO3ZhciBrPWUuYWx0ZXJuYXRlO251bGwhPT1rJiYoay5yZXR1cm49bnVsbCk7ZS5yZXR1cm49bnVsbH1jYXRjaChsKXtVKGUsYixsKX19aWYoYi5zdWJ0cmVlRmxhZ3MmMTI4NTQpZm9yKGI9Yi5jaGlsZDtudWxsIT09YjspYmsoYixhKSxiPWIuc2libGluZ31cbmZ1bmN0aW9uIGJrKGEsYil7dmFyIGM9YS5hbHRlcm5hdGUsZD1hLmZsYWdzO3N3aXRjaChhLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNDpjYXNlIDE1OmFrKGIsYSk7Y2soYSk7aWYoZCY0KXt0cnl7TmooMyxhLGEucmV0dXJuKSxPaigzLGEpfWNhdGNoKG0pe1UoYSxhLnJldHVybixtKX10cnl7TmooNSxhLGEucmV0dXJuKX1jYXRjaChtKXtVKGEsYS5yZXR1cm4sbSl9fWJyZWFrO2Nhc2UgMTphayhiLGEpO2NrKGEpO2QmNTEyJiZudWxsIT09YyYmSmooYyxjLnJldHVybik7YnJlYWs7Y2FzZSA1OmFrKGIsYSk7Y2soYSk7ZCY1MTImJm51bGwhPT1jJiZKaihjLGMucmV0dXJuKTtpZihhLmZsYWdzJjMyKXt2YXIgZT1hLnN0YXRlTm9kZTt0cnl7bmIoZSxcIlwiKX1jYXRjaChtKXtVKGEsYS5yZXR1cm4sbSl9fWlmKGQmNCYmKGU9YS5zdGF0ZU5vZGUsbnVsbCE9ZSkpe3ZhciBmPWEubWVtb2l6ZWRQcm9wcyxnPW51bGwhPT1jP2MubWVtb2l6ZWRQcm9wczpmLGg9YS50eXBlLGs9YS51cGRhdGVRdWV1ZTtcbmEudXBkYXRlUXVldWU9bnVsbDtpZihudWxsIT09ayl0cnl7XCJpbnB1dFwiPT09aCYmXCJyYWRpb1wiPT09Zi50eXBlJiZudWxsIT1mLm5hbWUmJlphKGUsZik7dWIoaCxnKTt2YXIgbD11YihoLGYpO2ZvcihnPTA7ZzxrLmxlbmd0aDtnKz0yKXt2YXIgbj1rW2ddLHU9a1tnKzFdO1wic3R5bGVcIj09PW4/cmIoZSx1KTpcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI9PT1uP21iKGUsdSk6XCJjaGlsZHJlblwiPT09bj9uYihlLHUpOnNhKGUsbix1LGwpfXN3aXRjaChoKXtjYXNlIFwiaW5wdXRcIjokYShlLGYpO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOmhiKGUsZik7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOnZhciBxPWUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZTtlLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU9ISFmLm11bHRpcGxlO3ZhciB5PWYudmFsdWU7bnVsbCE9eT9lYihlLCEhZi5tdWx0aXBsZSx5LCExKTpxIT09ISFmLm11bHRpcGxlJiYobnVsbCE9Zi5kZWZhdWx0VmFsdWU/ZWIoZSwhIWYubXVsdGlwbGUsXG5mLmRlZmF1bHRWYWx1ZSwhMCk6ZWIoZSwhIWYubXVsdGlwbGUsZi5tdWx0aXBsZT9bXTpcIlwiLCExKSl9ZVtPZl09Zn1jYXRjaChtKXtVKGEsYS5yZXR1cm4sbSl9fWJyZWFrO2Nhc2UgNjphayhiLGEpO2NrKGEpO2lmKGQmNCl7aWYobnVsbD09PWEuc3RhdGVOb2RlKXRocm93IEVycm9yKHAoMTYyKSk7bD1hLnN0YXRlTm9kZTtuPWEubWVtb2l6ZWRQcm9wczt0cnl7bC5ub2RlVmFsdWU9bn1jYXRjaChtKXtVKGEsYS5yZXR1cm4sbSl9fWJyZWFrO2Nhc2UgMzphayhiLGEpO2NrKGEpO2lmKGQmNCYmbnVsbCE9PWMmJmMubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQpdHJ5e2FkKGIuY29udGFpbmVySW5mbyl9Y2F0Y2gobSl7VShhLGEucmV0dXJuLG0pfWJyZWFrO2Nhc2UgNDphayhiLGEpO2NrKGEpO2JyZWFrO2Nhc2UgMTM6YWsoYixhKTtjayhhKTtsPWEuY2hpbGQ7bC5mbGFncyY4MTkyJiZudWxsIT09bC5tZW1vaXplZFN0YXRlJiYobnVsbD09PWwuYWx0ZXJuYXRlfHxudWxsPT09bC5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZSkmJlxuKGRrPUIoKSk7ZCY0JiZZaihhKTticmVhaztjYXNlIDIyOmw9bnVsbCE9PWMmJm51bGwhPT1jLm1lbW9pemVkU3RhdGU7YS5tb2RlJjE/KFM9KG49Uyl8fGwsYWsoYixhKSxTPW4pOmFrKGIsYSk7Y2soYSk7aWYoZCY4MTkyKXtuPW51bGwhPT1hLm1lbW9pemVkU3RhdGU7YTpmb3IodT1udWxsLHE9YTs7KXtpZig1PT09cS50YWcpe2lmKG51bGw9PT11KXt1PXE7dHJ5e2U9cS5zdGF0ZU5vZGUsbj8oZj1lLnN0eWxlLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBmLnNldFByb3BlcnR5P2Yuc2V0UHJvcGVydHkoXCJkaXNwbGF5XCIsXCJub25lXCIsXCJpbXBvcnRhbnRcIik6Zi5kaXNwbGF5PVwibm9uZVwiKTooaD1xLnN0YXRlTm9kZSxrPXEubWVtb2l6ZWRQcm9wcy5zdHlsZSxnPXZvaWQgMCE9PWsmJm51bGwhPT1rJiZrLmhhc093blByb3BlcnR5KFwiZGlzcGxheVwiKT9rLmRpc3BsYXk6bnVsbCxoLnN0eWxlLmRpc3BsYXk9cWIoXCJkaXNwbGF5XCIsZykpfWNhdGNoKG0pe1UoYSxhLnJldHVybixtKX19fWVsc2UgaWYoNj09PVxucS50YWcpe2lmKG51bGw9PT11KXRyeXtxLnN0YXRlTm9kZS5ub2RlVmFsdWU9bj9cIlwiOnEubWVtb2l6ZWRQcm9wc31jYXRjaChtKXtVKGEsYS5yZXR1cm4sbSl9fWVsc2UgaWYoKDIyIT09cS50YWcmJjIzIT09cS50YWd8fG51bGw9PT1xLm1lbW9pemVkU3RhdGV8fHE9PT1hKSYmbnVsbCE9PXEuY2hpbGQpe3EuY2hpbGQucmV0dXJuPXE7cT1xLmNoaWxkO2NvbnRpbnVlfWlmKHE9PT1hKWJyZWFrIGE7Zm9yKDtudWxsPT09cS5zaWJsaW5nOyl7aWYobnVsbD09PXEucmV0dXJufHxxLnJldHVybj09PWEpYnJlYWsgYTt1PT09cSYmKHU9bnVsbCk7cT1xLnJldHVybn11PT09cSYmKHU9bnVsbCk7cS5zaWJsaW5nLnJldHVybj1xLnJldHVybjtxPXEuc2libGluZ31pZihuJiYhbCYmMCE9PShhLm1vZGUmMSkpZm9yKFQ9YSxhPWEuY2hpbGQ7bnVsbCE9PWE7KXtmb3IobD1UPWE7bnVsbCE9PVQ7KXtuPVQ7dT1uLmNoaWxkO3N3aXRjaChuLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNDpjYXNlIDE1Ok5qKDQsXG5uLG4ucmV0dXJuKTticmVhaztjYXNlIDE6SmoobixuLnJldHVybik7Zj1uLnN0YXRlTm9kZTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZi5jb21wb25lbnRXaWxsVW5tb3VudCl7cT1uO3k9bi5yZXR1cm47dHJ5e2U9cSxmLnByb3BzPWUubWVtb2l6ZWRQcm9wcyxmLnN0YXRlPWUubWVtb2l6ZWRTdGF0ZSxmLmNvbXBvbmVudFdpbGxVbm1vdW50KCl9Y2F0Y2gobSl7VShxLHksbSl9fWJyZWFrO2Nhc2UgNTpKaihuLG4ucmV0dXJuKTticmVhaztjYXNlIDIyOmlmKG51bGwhPT1uLm1lbW9pemVkU3RhdGUpe2VrKGwpO2NvbnRpbnVlfX1udWxsIT09dT8odS5yZXR1cm49bixUPXUpOmVrKGwpfWE9YS5zaWJsaW5nfX1icmVhaztjYXNlIDE5OmFrKGIsYSk7Y2soYSk7ZCY0JiZZaihhKTticmVhaztjYXNlIDIxOmJyZWFrO2RlZmF1bHQ6YWsoYixhKSxjayhhKX19XG5mdW5jdGlvbiBjayhhKXt2YXIgYj1hLmZsYWdzO2lmKGImMil7dHJ5e2E6e2Zvcih2YXIgYz1hLnJldHVybjtudWxsIT09Yzspe2lmKFJqKGMpKXt2YXIgZD1jO2JyZWFrIGF9Yz1jLnJldHVybn10aHJvdyBFcnJvcihwKDE2MCkpO31zd2l0Y2goZC50YWcpe2Nhc2UgNTp2YXIgZT1kLnN0YXRlTm9kZTtkLmZsYWdzJjMyJiYobmIoZSxcIlwiKSxkLmZsYWdzJj0tMzMpO3ZhciBmPVNqKGEpO1VqKGEsZixlKTticmVhaztjYXNlIDM6Y2FzZSA0OnZhciBnPWQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8saD1TaihhKTtUaihhLGgsZyk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihwKDE2MSkpO319Y2F0Y2goayl7VShhLGEucmV0dXJuLGspfWEuZmxhZ3MmPS0zfWImNDA5NiYmKGEuZmxhZ3MmPS00MDk3KX1mdW5jdGlvbiBmayhhLGIsYyl7VD1hO2drKGEsYixjKX1cbmZ1bmN0aW9uIGdrKGEsYixjKXtmb3IodmFyIGQ9MCE9PShhLm1vZGUmMSk7bnVsbCE9PVQ7KXt2YXIgZT1ULGY9ZS5jaGlsZDtpZigyMj09PWUudGFnJiZkKXt2YXIgZz1udWxsIT09ZS5tZW1vaXplZFN0YXRlfHxIajtpZighZyl7dmFyIGg9ZS5hbHRlcm5hdGUsaz1udWxsIT09aCYmbnVsbCE9PWgubWVtb2l6ZWRTdGF0ZXx8UztoPUhqO3ZhciBsPVM7SGo9ZztpZigoUz1rKSYmIWwpZm9yKFQ9ZTtudWxsIT09VDspZz1ULGs9Zy5jaGlsZCwyMj09PWcudGFnJiZudWxsIT09Zy5tZW1vaXplZFN0YXRlP2hrKGUpOm51bGwhPT1rPyhrLnJldHVybj1nLFQ9ayk6aGsoZSk7Zm9yKDtudWxsIT09ZjspVD1mLGdrKGYsYixjKSxmPWYuc2libGluZztUPWU7SGo9aDtTPWx9aWsoYSxiLGMpfWVsc2UgMCE9PShlLnN1YnRyZWVGbGFncyY4NzcyKSYmbnVsbCE9PWY/KGYucmV0dXJuPWUsVD1mKTppayhhLGIsYyl9fVxuZnVuY3Rpb24gaWsoYSl7Zm9yKDtudWxsIT09VDspe3ZhciBiPVQ7aWYoMCE9PShiLmZsYWdzJjg3NzIpKXt2YXIgYz1iLmFsdGVybmF0ZTt0cnl7aWYoMCE9PShiLmZsYWdzJjg3NzIpKXN3aXRjaChiLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNTpTfHxPaig1LGIpO2JyZWFrO2Nhc2UgMTp2YXIgZD1iLnN0YXRlTm9kZTtpZihiLmZsYWdzJjQmJiFTKWlmKG51bGw9PT1jKWQuY29tcG9uZW50RGlkTW91bnQoKTtlbHNle3ZhciBlPWIuZWxlbWVudFR5cGU9PT1iLnR5cGU/Yy5tZW1vaXplZFByb3BzOmtnKGIudHlwZSxjLm1lbW9pemVkUHJvcHMpO2QuY29tcG9uZW50RGlkVXBkYXRlKGUsYy5tZW1vaXplZFN0YXRlLGQuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUpfXZhciBmPWIudXBkYXRlUXVldWU7bnVsbCE9PWYmJkdnKGIsZixkKTticmVhaztjYXNlIDM6dmFyIGc9Yi51cGRhdGVRdWV1ZTtpZihudWxsIT09Zyl7Yz1udWxsO2lmKG51bGwhPT1iLmNoaWxkKXN3aXRjaChiLmNoaWxkLnRhZyl7Y2FzZSA1OmM9XG5iLmNoaWxkLnN0YXRlTm9kZTticmVhaztjYXNlIDE6Yz1iLmNoaWxkLnN0YXRlTm9kZX1HZyhiLGcsYyl9YnJlYWs7Y2FzZSA1OnZhciBoPWIuc3RhdGVOb2RlO2lmKG51bGw9PT1jJiZiLmZsYWdzJjQpe2M9aDt2YXIgaz1iLm1lbW9pemVkUHJvcHM7c3dpdGNoKGIudHlwZSl7Y2FzZSBcImJ1dHRvblwiOmNhc2UgXCJpbnB1dFwiOmNhc2UgXCJzZWxlY3RcIjpjYXNlIFwidGV4dGFyZWFcIjprLmF1dG9Gb2N1cyYmYy5mb2N1cygpO2JyZWFrO2Nhc2UgXCJpbWdcIjprLnNyYyYmKGMuc3JjPWsuc3JjKX19YnJlYWs7Y2FzZSA2OmJyZWFrO2Nhc2UgNDpicmVhaztjYXNlIDEyOmJyZWFrO2Nhc2UgMTM6aWYobnVsbD09PWIubWVtb2l6ZWRTdGF0ZSl7dmFyIGw9Yi5hbHRlcm5hdGU7aWYobnVsbCE9PWwpe3ZhciBuPWwubWVtb2l6ZWRTdGF0ZTtpZihudWxsIT09bil7dmFyIHU9bi5kZWh5ZHJhdGVkO251bGwhPT11JiZhZCh1KX19fWJyZWFrO2Nhc2UgMTk6Y2FzZSAxNzpjYXNlIDIxOmNhc2UgMjI6Y2FzZSAyMzpicmVhaztcbmRlZmF1bHQ6dGhyb3cgRXJyb3IocCgxNjMpKTt9U3x8Yi5mbGFncyY1MTImJlBqKGIpfWNhdGNoKHEpe1UoYixiLnJldHVybixxKX19aWYoYj09PWEpe1Q9bnVsbDticmVha31jPWIuc2libGluZztpZihudWxsIT09Yyl7Yy5yZXR1cm49Yi5yZXR1cm47VD1jO2JyZWFrfVQ9Yi5yZXR1cm59fWZ1bmN0aW9uIGVrKGEpe2Zvcig7bnVsbCE9PVQ7KXt2YXIgYj1UO2lmKGI9PT1hKXtUPW51bGw7YnJlYWt9dmFyIGM9Yi5zaWJsaW5nO2lmKG51bGwhPT1jKXtjLnJldHVybj1iLnJldHVybjtUPWM7YnJlYWt9VD1iLnJldHVybn19XG5mdW5jdGlvbiBoayhhKXtmb3IoO251bGwhPT1UOyl7dmFyIGI9VDt0cnl7c3dpdGNoKGIudGFnKXtjYXNlIDA6Y2FzZSAxMTpjYXNlIDE1OnZhciBjPWIucmV0dXJuO3RyeXtPaig0LGIpfWNhdGNoKGspe1UoYixjLGspfWJyZWFrO2Nhc2UgMTp2YXIgZD1iLnN0YXRlTm9kZTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5jb21wb25lbnREaWRNb3VudCl7dmFyIGU9Yi5yZXR1cm47dHJ5e2QuY29tcG9uZW50RGlkTW91bnQoKX1jYXRjaChrKXtVKGIsZSxrKX19dmFyIGY9Yi5yZXR1cm47dHJ5e1BqKGIpfWNhdGNoKGspe1UoYixmLGspfWJyZWFrO2Nhc2UgNTp2YXIgZz1iLnJldHVybjt0cnl7UGooYil9Y2F0Y2goayl7VShiLGcsayl9fX1jYXRjaChrKXtVKGIsYi5yZXR1cm4sayl9aWYoYj09PWEpe1Q9bnVsbDticmVha312YXIgaD1iLnNpYmxpbmc7aWYobnVsbCE9PWgpe2gucmV0dXJuPWIucmV0dXJuO1Q9aDticmVha31UPWIucmV0dXJufX1cbnZhciBqaz1NYXRoLmNlaWwsa2s9dGEuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixsaz10YS5SZWFjdEN1cnJlbnRPd25lcixtaz10YS5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxXPTAsUD1udWxsLFg9bnVsbCxZPTAsY2o9MCxtaj1UZigwKSxSPTAsbms9bnVsbCxGZz0wLG9rPTAscGs9MCxxaz1udWxsLHJrPW51bGwsZGs9MCxhaj1JbmZpbml0eSxzaz1udWxsLExpPSExLE1pPW51bGwsT2k9bnVsbCx0az0hMSx1az1udWxsLHZrPTAsd2s9MCx4az1udWxsLHlrPS0xLHprPTA7ZnVuY3Rpb24gSmcoKXtyZXR1cm4gMCE9PShXJjYpP0IoKTotMSE9PXlrP3lrOnlrPUIoKX1cbmZ1bmN0aW9uIEtnKGEpe2lmKDA9PT0oYS5tb2RlJjEpKXJldHVybiAxO2lmKDAhPT0oVyYyKSYmMCE9PVkpcmV0dXJuIFkmLVk7aWYobnVsbCE9PWpnLnRyYW5zaXRpb24pcmV0dXJuIDA9PT16ayYmKHprPXhjKCkpLHprO2E9QztpZigwIT09YSlyZXR1cm4gYTthPXdpbmRvdy5ldmVudDthPXZvaWQgMD09PWE/MTY6aWQoYS50eXBlKTtyZXR1cm4gYX1mdW5jdGlvbiBMZyhhLGIsYyl7aWYoNTA8d2spdGhyb3cgd2s9MCx4az1udWxsLEVycm9yKHAoMTg1KSk7dmFyIGQ9QWsoYSxiKTtpZihudWxsPT09ZClyZXR1cm4gbnVsbDt6YyhkLGIsYyk7aWYoMD09PShXJjIpfHxkIT09UClkPT09UCYmKDA9PT0oVyYyKSYmKG9rfD1iKSw0PT09UiYmQmsoZCxZKSksQ2soZCxjKSwxPT09YiYmMD09PVcmJjA9PT0oYS5tb2RlJjEpJiYoYWo9QigpKzUwMCxlZyYmaWcoKSk7cmV0dXJuIGR9XG5mdW5jdGlvbiBBayhhLGIpe2EubGFuZXN8PWI7dmFyIGM9YS5hbHRlcm5hdGU7bnVsbCE9PWMmJihjLmxhbmVzfD1iKTtjPWE7Zm9yKGE9YS5yZXR1cm47bnVsbCE9PWE7KWEuY2hpbGRMYW5lc3w9YixjPWEuYWx0ZXJuYXRlLG51bGwhPT1jJiYoYy5jaGlsZExhbmVzfD1iKSxjPWEsYT1hLnJldHVybjtyZXR1cm4gMz09PWMudGFnP2Muc3RhdGVOb2RlOm51bGx9ZnVuY3Rpb24gQmcoYSl7cmV0dXJuKG51bGwhPT1QfHxudWxsIT09dmcpJiYwIT09KGEubW9kZSYxKSYmMD09PShXJjIpfVxuZnVuY3Rpb24gQ2soYSxiKXt2YXIgYz1hLmNhbGxiYWNrTm9kZTt2YyhhLGIpO3ZhciBkPXRjKGEsYT09PVA/WTowKTtpZigwPT09ZCludWxsIT09YyYmYWMoYyksYS5jYWxsYmFja05vZGU9bnVsbCxhLmNhbGxiYWNrUHJpb3JpdHk9MDtlbHNlIGlmKGI9ZCYtZCxhLmNhbGxiYWNrUHJpb3JpdHkhPT1iKXtudWxsIT1jJiZhYyhjKTtpZigxPT09YikwPT09YS50YWc/aGcoRGsuYmluZChudWxsLGEpKTpnZyhEay5iaW5kKG51bGwsYSkpLElmKGZ1bmN0aW9uKCl7MD09PVcmJmlnKCl9KSxjPW51bGw7ZWxzZXtzd2l0Y2goQ2MoZCkpe2Nhc2UgMTpjPWVjO2JyZWFrO2Nhc2UgNDpjPWZjO2JyZWFrO2Nhc2UgMTY6Yz1nYzticmVhaztjYXNlIDUzNjg3MDkxMjpjPWljO2JyZWFrO2RlZmF1bHQ6Yz1nY31jPUVrKGMsRmsuYmluZChudWxsLGEpKX1hLmNhbGxiYWNrUHJpb3JpdHk9YjthLmNhbGxiYWNrTm9kZT1jfX1cbmZ1bmN0aW9uIEZrKGEsYil7eWs9LTE7ems9MDtpZigwIT09KFcmNikpdGhyb3cgRXJyb3IocCgzMjcpKTt2YXIgYz1hLmNhbGxiYWNrTm9kZTtpZihHaygpJiZhLmNhbGxiYWNrTm9kZSE9PWMpcmV0dXJuIG51bGw7dmFyIGQ9dGMoYSxhPT09UD9ZOjApO2lmKDA9PT1kKXJldHVybiBudWxsO2lmKDAhPT0oZCYzMCl8fDAhPT0oZCZhLmV4cGlyZWRMYW5lcyl8fGIpYj1IayhhLGQpO2Vsc2V7Yj1kO3ZhciBlPVc7V3w9Mjt2YXIgZj1JaygpO2lmKFAhPT1hfHxZIT09Yilzaz1udWxsLGFqPUIoKSs1MDAsSmsoYSxiKTtkbyB0cnl7S2soKTticmVha31jYXRjaChoKXtMayhhLGgpfXdoaWxlKDEpO3BnKCk7a2suY3VycmVudD1mO1c9ZTtudWxsIT09WD9iPTA6KFA9bnVsbCxZPTAsYj1SKX1pZigwIT09Yil7Mj09PWImJihlPXdjKGEpLDAhPT1lJiYoZD1lLGI9TWsoYSxlKSkpO2lmKDE9PT1iKXRocm93IGM9bmssSmsoYSwwKSxCayhhLGQpLENrKGEsQigpKSxjO2lmKDY9PT1iKUJrKGEsZCk7XG5lbHNle2U9YS5jdXJyZW50LmFsdGVybmF0ZTtpZigwPT09KGQmMzApJiYhTmsoZSkmJihiPUhrKGEsZCksMj09PWImJihmPXdjKGEpLDAhPT1mJiYoZD1mLGI9TWsoYSxmKSkpLDE9PT1iKSl0aHJvdyBjPW5rLEprKGEsMCksQmsoYSxkKSxDayhhLEIoKSksYzthLmZpbmlzaGVkV29yaz1lO2EuZmluaXNoZWRMYW5lcz1kO3N3aXRjaChiKXtjYXNlIDA6Y2FzZSAxOnRocm93IEVycm9yKHAoMzQ1KSk7Y2FzZSAyOk9rKGEscmssc2spO2JyZWFrO2Nhc2UgMzpCayhhLGQpO2lmKChkJjEzMDAyMzQyNCk9PT1kJiYoYj1kays1MDAtQigpLDEwPGIpKXtpZigwIT09dGMoYSwwKSlicmVhaztlPWEuc3VzcGVuZGVkTGFuZXM7aWYoKGUmZCkhPT1kKXtKZygpO2EucGluZ2VkTGFuZXN8PWEuc3VzcGVuZGVkTGFuZXMmZTticmVha31hLnRpbWVvdXRIYW5kbGU9RWYoT2suYmluZChudWxsLGEscmssc2spLGIpO2JyZWFrfU9rKGEscmssc2spO2JyZWFrO2Nhc2UgNDpCayhhLGQpO2lmKChkJjQxOTQyNDApPT09XG5kKWJyZWFrO2I9YS5ldmVudFRpbWVzO2ZvcihlPS0xOzA8ZDspe3ZhciBnPTMxLW5jKGQpO2Y9MTw8ZztnPWJbZ107Zz5lJiYoZT1nKTtkJj1+Zn1kPWU7ZD1CKCktZDtkPSgxMjA+ZD8xMjA6NDgwPmQ/NDgwOjEwODA+ZD8xMDgwOjE5MjA+ZD8xOTIwOjNFMz5kPzNFMzo0MzIwPmQ/NDMyMDoxOTYwKmprKGQvMTk2MCkpLWQ7aWYoMTA8ZCl7YS50aW1lb3V0SGFuZGxlPUVmKE9rLmJpbmQobnVsbCxhLHJrLHNrKSxkKTticmVha31PayhhLHJrLHNrKTticmVhaztjYXNlIDU6T2soYSxyayxzayk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihwKDMyOSkpO319fUNrKGEsQigpKTtyZXR1cm4gYS5jYWxsYmFja05vZGU9PT1jP0ZrLmJpbmQobnVsbCxhKTpudWxsfVxuZnVuY3Rpb24gTWsoYSxiKXt2YXIgYz1xazthLmN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQmJihKayhhLGIpLmZsYWdzfD0yNTYpO2E9SGsoYSxiKTsyIT09YSYmKGI9cmsscms9YyxudWxsIT09YiYmWmkoYikpO3JldHVybiBhfWZ1bmN0aW9uIFppKGEpe251bGw9PT1yaz9yaz1hOnJrLnB1c2guYXBwbHkocmssYSl9XG5mdW5jdGlvbiBOayhhKXtmb3IodmFyIGI9YTs7KXtpZihiLmZsYWdzJjE2Mzg0KXt2YXIgYz1iLnVwZGF0ZVF1ZXVlO2lmKG51bGwhPT1jJiYoYz1jLnN0b3JlcyxudWxsIT09YykpZm9yKHZhciBkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBlPWNbZF0sZj1lLmdldFNuYXBzaG90O2U9ZS52YWx1ZTt0cnl7aWYoIUdlKGYoKSxlKSlyZXR1cm4hMX1jYXRjaChnKXtyZXR1cm4hMX19fWM9Yi5jaGlsZDtpZihiLnN1YnRyZWVGbGFncyYxNjM4NCYmbnVsbCE9PWMpYy5yZXR1cm49YixiPWM7ZWxzZXtpZihiPT09YSlicmVhaztmb3IoO251bGw9PT1iLnNpYmxpbmc7KXtpZihudWxsPT09Yi5yZXR1cm58fGIucmV0dXJuPT09YSlyZXR1cm4hMDtiPWIucmV0dXJufWIuc2libGluZy5yZXR1cm49Yi5yZXR1cm47Yj1iLnNpYmxpbmd9fXJldHVybiEwfVxuZnVuY3Rpb24gQmsoYSxiKXtiJj1+cGs7YiY9fm9rO2Euc3VzcGVuZGVkTGFuZXN8PWI7YS5waW5nZWRMYW5lcyY9fmI7Zm9yKGE9YS5leHBpcmF0aW9uVGltZXM7MDxiOyl7dmFyIGM9MzEtbmMoYiksZD0xPDxjO2FbY109LTE7YiY9fmR9fWZ1bmN0aW9uIERrKGEpe2lmKDAhPT0oVyY2KSl0aHJvdyBFcnJvcihwKDMyNykpO0drKCk7dmFyIGI9dGMoYSwwKTtpZigwPT09KGImMSkpcmV0dXJuIENrKGEsQigpKSxudWxsO3ZhciBjPUhrKGEsYik7aWYoMCE9PWEudGFnJiYyPT09Yyl7dmFyIGQ9d2MoYSk7MCE9PWQmJihiPWQsYz1NayhhLGQpKX1pZigxPT09Yyl0aHJvdyBjPW5rLEprKGEsMCksQmsoYSxiKSxDayhhLEIoKSksYztpZig2PT09Yyl0aHJvdyBFcnJvcihwKDM0NSkpO2EuZmluaXNoZWRXb3JrPWEuY3VycmVudC5hbHRlcm5hdGU7YS5maW5pc2hlZExhbmVzPWI7T2soYSxyayxzayk7Q2soYSxCKCkpO3JldHVybiBudWxsfVxuZnVuY3Rpb24gUGsoYSxiKXt2YXIgYz1XO1d8PTE7dHJ5e3JldHVybiBhKGIpfWZpbmFsbHl7Vz1jLDA9PT1XJiYoYWo9QigpKzUwMCxlZyYmaWcoKSl9fWZ1bmN0aW9uIFFrKGEpe251bGwhPT11ayYmMD09PXVrLnRhZyYmMD09PShXJjYpJiZHaygpO3ZhciBiPVc7V3w9MTt2YXIgYz1tay50cmFuc2l0aW9uLGQ9Qzt0cnl7aWYobWsudHJhbnNpdGlvbj1udWxsLEM9MSxhKXJldHVybiBhKCl9ZmluYWxseXtDPWQsbWsudHJhbnNpdGlvbj1jLFc9YiwwPT09KFcmNikmJmlnKCl9fWZ1bmN0aW9uIGJqKCl7Y2o9bWouY3VycmVudDtFKG1qKX1cbmZ1bmN0aW9uIEprKGEsYil7YS5maW5pc2hlZFdvcms9bnVsbDthLmZpbmlzaGVkTGFuZXM9MDt2YXIgYz1hLnRpbWVvdXRIYW5kbGU7LTEhPT1jJiYoYS50aW1lb3V0SGFuZGxlPS0xLEZmKGMpKTtpZihudWxsIT09WClmb3IoYz1YLnJldHVybjtudWxsIT09Yzspe3ZhciBkPWM7Y2goZCk7c3dpdGNoKGQudGFnKXtjYXNlIDE6ZD1kLnR5cGUuY2hpbGRDb250ZXh0VHlwZXM7bnVsbCE9PWQmJnZvaWQgMCE9PWQmJlpmKCk7YnJlYWs7Y2FzZSAzOkdoKCk7RShWZik7RShIKTtMaCgpO2JyZWFrO2Nhc2UgNTpJaChkKTticmVhaztjYXNlIDQ6R2goKTticmVhaztjYXNlIDEzOkUoSyk7YnJlYWs7Y2FzZSAxOTpFKEspO2JyZWFrO2Nhc2UgMTA6cWcoZC50eXBlLl9jb250ZXh0KTticmVhaztjYXNlIDIyOmNhc2UgMjM6YmooKX1jPWMucmV0dXJufVA9YTtYPWE9dGgoYS5jdXJyZW50LG51bGwpO1k9Y2o9YjtSPTA7bms9bnVsbDtwaz1vaz1GZz0wO3JrPXFrPW51bGw7aWYobnVsbCE9PXZnKXtmb3IoYj1cbjA7Yjx2Zy5sZW5ndGg7YisrKWlmKGM9dmdbYl0sZD1jLmludGVybGVhdmVkLG51bGwhPT1kKXtjLmludGVybGVhdmVkPW51bGw7dmFyIGU9ZC5uZXh0LGY9Yy5wZW5kaW5nO2lmKG51bGwhPT1mKXt2YXIgZz1mLm5leHQ7Zi5uZXh0PWU7ZC5uZXh0PWd9Yy5wZW5kaW5nPWR9dmc9bnVsbH1yZXR1cm4gYX1cbmZ1bmN0aW9uIExrKGEsYil7ZG97dmFyIGM9WDt0cnl7cGcoKTtNaC5jdXJyZW50PVloO2lmKFBoKXtmb3IodmFyIGQ9TC5tZW1vaXplZFN0YXRlO251bGwhPT1kOyl7dmFyIGU9ZC5xdWV1ZTtudWxsIT09ZSYmKGUucGVuZGluZz1udWxsKTtkPWQubmV4dH1QaD0hMX1PaD0wO049TT1MPW51bGw7UWg9ITE7Umg9MDtsay5jdXJyZW50PW51bGw7aWYobnVsbD09PWN8fG51bGw9PT1jLnJldHVybil7Uj0xO25rPWI7WD1udWxsO2JyZWFrfWE6e3ZhciBmPWEsZz1jLnJldHVybixoPWMsaz1iO2I9WTtoLmZsYWdzfD0zMjc2ODtpZihudWxsIT09ayYmXCJvYmplY3RcIj09PXR5cGVvZiBrJiZcImZ1bmN0aW9uXCI9PT10eXBlb2Ygay50aGVuKXt2YXIgbD1rLG49aCx1PW4udGFnO2lmKDA9PT0obi5tb2RlJjEpJiYoMD09PXV8fDExPT09dXx8MTU9PT11KSl7dmFyIHE9bi5hbHRlcm5hdGU7cT8obi51cGRhdGVRdWV1ZT1xLnVwZGF0ZVF1ZXVlLG4ubWVtb2l6ZWRTdGF0ZT1xLm1lbW9pemVkU3RhdGUsXG5uLmxhbmVzPXEubGFuZXMpOihuLnVwZGF0ZVF1ZXVlPW51bGwsbi5tZW1vaXplZFN0YXRlPW51bGwpfXZhciB5PVJpKGcpO2lmKG51bGwhPT15KXt5LmZsYWdzJj0tMjU3O1NpKHksZyxoLGYsYik7eS5tb2RlJjEmJlBpKGYsbCxiKTtiPXk7az1sO3ZhciBtPWIudXBkYXRlUXVldWU7aWYobnVsbD09PW0pe3ZhciB3PW5ldyBTZXQ7dy5hZGQoayk7Yi51cGRhdGVRdWV1ZT13fWVsc2UgbS5hZGQoayk7YnJlYWsgYX1lbHNle2lmKDA9PT0oYiYxKSl7UGkoZixsLGIpOyRpKCk7YnJlYWsgYX1rPUVycm9yKHAoNDI2KSl9fWVsc2UgaWYoSSYmaC5tb2RlJjEpe3ZhciBKPVJpKGcpO2lmKG51bGwhPT1KKXswPT09KEouZmxhZ3MmNjU1MzYpJiYoSi5mbGFnc3w9MjU2KTtTaShKLGcsaCxmLGIpO29oKGspO2JyZWFrIGF9fWY9azs0IT09UiYmKFI9Mik7bnVsbD09PXFrP3FrPVtmXTpxay5wdXNoKGYpO2s9SGkoayxoKTtoPWc7ZG97c3dpdGNoKGgudGFnKXtjYXNlIDM6aC5mbGFnc3w9NjU1MzY7XG5iJj0tYjtoLmxhbmVzfD1iO3ZhciB2PUtpKGgsayxiKTtEZyhoLHYpO2JyZWFrIGE7Y2FzZSAxOmY9azt2YXIgeD1oLnR5cGUscj1oLnN0YXRlTm9kZTtpZigwPT09KGguZmxhZ3MmMTI4KSYmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiB4LmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcnx8bnVsbCE9PXImJlwiZnVuY3Rpb25cIj09PXR5cGVvZiByLmNvbXBvbmVudERpZENhdGNoJiYobnVsbD09PU9pfHwhT2kuaGFzKHIpKSkpe2guZmxhZ3N8PTY1NTM2O2ImPS1iO2gubGFuZXN8PWI7dmFyIEY9TmkoaCxmLGIpO0RnKGgsRik7YnJlYWsgYX19aD1oLnJldHVybn13aGlsZShudWxsIT09aCl9UmsoYyl9Y2F0Y2goWil7Yj1aO1g9PT1jJiZudWxsIT09YyYmKFg9Yz1jLnJldHVybik7Y29udGludWV9YnJlYWt9d2hpbGUoMSl9ZnVuY3Rpb24gSWsoKXt2YXIgYT1ray5jdXJyZW50O2trLmN1cnJlbnQ9WWg7cmV0dXJuIG51bGw9PT1hP1loOmF9XG5mdW5jdGlvbiAkaSgpe2lmKDA9PT1SfHwzPT09Unx8Mj09PVIpUj00O251bGw9PT1QfHwwPT09KEZnJjI2ODQzNTQ1NSkmJjA9PT0ob2smMjY4NDM1NDU1KXx8QmsoUCxZKX1mdW5jdGlvbiBIayhhLGIpe3ZhciBjPVc7V3w9Mjt2YXIgZD1JaygpO2lmKFAhPT1hfHxZIT09Yilzaz1udWxsLEprKGEsYik7ZG8gdHJ5e1NrKCk7YnJlYWt9Y2F0Y2goZSl7TGsoYSxlKX13aGlsZSgxKTtwZygpO1c9Yztray5jdXJyZW50PWQ7aWYobnVsbCE9PVgpdGhyb3cgRXJyb3IocCgyNjEpKTtQPW51bGw7WT0wO3JldHVybiBSfWZ1bmN0aW9uIFNrKCl7Zm9yKDtudWxsIT09WDspVGsoWCl9ZnVuY3Rpb24gS2soKXtmb3IoO251bGwhPT1YJiYhYmMoKTspVGsoWCl9ZnVuY3Rpb24gVGsoYSl7dmFyIGI9VWsoYS5hbHRlcm5hdGUsYSxjaik7YS5tZW1vaXplZFByb3BzPWEucGVuZGluZ1Byb3BzO251bGw9PT1iP1JrKGEpOlg9Yjtsay5jdXJyZW50PW51bGx9XG5mdW5jdGlvbiBSayhhKXt2YXIgYj1hO2Rve3ZhciBjPWIuYWx0ZXJuYXRlO2E9Yi5yZXR1cm47aWYoMD09PShiLmZsYWdzJjMyNzY4KSl7aWYoYz1ZaShjLGIsY2opLG51bGwhPT1jKXtYPWM7cmV0dXJufX1lbHNle2M9R2ooYyxiKTtpZihudWxsIT09Yyl7Yy5mbGFncyY9MzI3Njc7WD1jO3JldHVybn1pZihudWxsIT09YSlhLmZsYWdzfD0zMjc2OCxhLnN1YnRyZWVGbGFncz0wLGEuZGVsZXRpb25zPW51bGw7ZWxzZXtSPTY7WD1udWxsO3JldHVybn19Yj1iLnNpYmxpbmc7aWYobnVsbCE9PWIpe1g9YjtyZXR1cm59WD1iPWF9d2hpbGUobnVsbCE9PWIpOzA9PT1SJiYoUj01KX1mdW5jdGlvbiBPayhhLGIsYyl7dmFyIGQ9QyxlPW1rLnRyYW5zaXRpb247dHJ5e21rLnRyYW5zaXRpb249bnVsbCxDPTEsVmsoYSxiLGMsZCl9ZmluYWxseXttay50cmFuc2l0aW9uPWUsQz1kfXJldHVybiBudWxsfVxuZnVuY3Rpb24gVmsoYSxiLGMsZCl7ZG8gR2soKTt3aGlsZShudWxsIT09dWspO2lmKDAhPT0oVyY2KSl0aHJvdyBFcnJvcihwKDMyNykpO2M9YS5maW5pc2hlZFdvcms7dmFyIGU9YS5maW5pc2hlZExhbmVzO2lmKG51bGw9PT1jKXJldHVybiBudWxsO2EuZmluaXNoZWRXb3JrPW51bGw7YS5maW5pc2hlZExhbmVzPTA7aWYoYz09PWEuY3VycmVudCl0aHJvdyBFcnJvcihwKDE3NykpO2EuY2FsbGJhY2tOb2RlPW51bGw7YS5jYWxsYmFja1ByaW9yaXR5PTA7dmFyIGY9Yy5sYW5lc3xjLmNoaWxkTGFuZXM7QWMoYSxmKTthPT09UCYmKFg9UD1udWxsLFk9MCk7MD09PShjLnN1YnRyZWVGbGFncyYyMDY0KSYmMD09PShjLmZsYWdzJjIwNjQpfHx0a3x8KHRrPSEwLEVrKGdjLGZ1bmN0aW9uKCl7R2soKTtyZXR1cm4gbnVsbH0pKTtmPTAhPT0oYy5mbGFncyYxNTk5MCk7aWYoMCE9PShjLnN1YnRyZWVGbGFncyYxNTk5MCl8fGYpe2Y9bWsudHJhbnNpdGlvbjttay50cmFuc2l0aW9uPW51bGw7XG52YXIgZz1DO0M9MTt2YXIgaD1XO1d8PTQ7bGsuY3VycmVudD1udWxsO01qKGEsYyk7YmsoYyxhKTtOZShDZik7Y2Q9ISFCZjtDZj1CZj1udWxsO2EuY3VycmVudD1jO2ZrKGMsYSxlKTtjYygpO1c9aDtDPWc7bWsudHJhbnNpdGlvbj1mfWVsc2UgYS5jdXJyZW50PWM7dGsmJih0az0hMSx1az1hLHZrPWUpO2Y9YS5wZW5kaW5nTGFuZXM7MD09PWYmJihPaT1udWxsKTtsYyhjLnN0YXRlTm9kZSxkKTtDayhhLEIoKSk7aWYobnVsbCE9PWIpZm9yKGQ9YS5vblJlY292ZXJhYmxlRXJyb3IsYz0wO2M8Yi5sZW5ndGg7YysrKWQoYltjXSk7aWYoTGkpdGhyb3cgTGk9ITEsYT1NaSxNaT1udWxsLGE7MCE9PSh2ayYxKSYmMCE9PWEudGFnJiZHaygpO2Y9YS5wZW5kaW5nTGFuZXM7MCE9PShmJjEpP2E9PT14az93aysrOih3az0wLHhrPWEpOndrPTA7aWcoKTtyZXR1cm4gbnVsbH1cbmZ1bmN0aW9uIEdrKCl7aWYobnVsbCE9PXVrKXt2YXIgYT1DYyh2ayksYj1tay50cmFuc2l0aW9uLGM9Qzt0cnl7bWsudHJhbnNpdGlvbj1udWxsO0M9MTY+YT8xNjphO2lmKG51bGw9PT11ayl2YXIgZD0hMTtlbHNle2E9dWs7dWs9bnVsbDt2az0wO2lmKDAhPT0oVyY2KSl0aHJvdyBFcnJvcihwKDMzMSkpO3ZhciBlPVc7V3w9NDtmb3IoVD1hLmN1cnJlbnQ7bnVsbCE9PVQ7KXt2YXIgZj1ULGc9Zi5jaGlsZDtpZigwIT09KFQuZmxhZ3MmMTYpKXt2YXIgaD1mLmRlbGV0aW9ucztpZihudWxsIT09aCl7Zm9yKHZhciBrPTA7azxoLmxlbmd0aDtrKyspe3ZhciBsPWhba107Zm9yKFQ9bDtudWxsIT09VDspe3ZhciBuPVQ7c3dpdGNoKG4udGFnKXtjYXNlIDA6Y2FzZSAxMTpjYXNlIDE1Ok5qKDgsbixmKX12YXIgdT1uLmNoaWxkO2lmKG51bGwhPT11KXUucmV0dXJuPW4sVD11O2Vsc2UgZm9yKDtudWxsIT09VDspe249VDt2YXIgcT1uLnNpYmxpbmcseT1uLnJldHVybjtRaihuKTtpZihuPT09XG5sKXtUPW51bGw7YnJlYWt9aWYobnVsbCE9PXEpe3EucmV0dXJuPXk7VD1xO2JyZWFrfVQ9eX19fXZhciBtPWYuYWx0ZXJuYXRlO2lmKG51bGwhPT1tKXt2YXIgdz1tLmNoaWxkO2lmKG51bGwhPT13KXttLmNoaWxkPW51bGw7ZG97dmFyIEo9dy5zaWJsaW5nO3cuc2libGluZz1udWxsO3c9Sn13aGlsZShudWxsIT09dyl9fVQ9Zn19aWYoMCE9PShmLnN1YnRyZWVGbGFncyYyMDY0KSYmbnVsbCE9PWcpZy5yZXR1cm49ZixUPWc7ZWxzZSBiOmZvcig7bnVsbCE9PVQ7KXtmPVQ7aWYoMCE9PShmLmZsYWdzJjIwNDgpKXN3aXRjaChmLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNTpOaig5LGYsZi5yZXR1cm4pfXZhciB2PWYuc2libGluZztpZihudWxsIT09dil7di5yZXR1cm49Zi5yZXR1cm47VD12O2JyZWFrIGJ9VD1mLnJldHVybn19dmFyIHg9YS5jdXJyZW50O2ZvcihUPXg7bnVsbCE9PVQ7KXtnPVQ7dmFyIHI9Zy5jaGlsZDtpZigwIT09KGcuc3VidHJlZUZsYWdzJjIwNjQpJiZudWxsIT09XG5yKXIucmV0dXJuPWcsVD1yO2Vsc2UgYjpmb3IoZz14O251bGwhPT1UOyl7aD1UO2lmKDAhPT0oaC5mbGFncyYyMDQ4KSl0cnl7c3dpdGNoKGgudGFnKXtjYXNlIDA6Y2FzZSAxMTpjYXNlIDE1Ok9qKDksaCl9fWNhdGNoKFope1UoaCxoLnJldHVybixaKX1pZihoPT09Zyl7VD1udWxsO2JyZWFrIGJ9dmFyIEY9aC5zaWJsaW5nO2lmKG51bGwhPT1GKXtGLnJldHVybj1oLnJldHVybjtUPUY7YnJlYWsgYn1UPWgucmV0dXJufX1XPWU7aWcoKTtpZihrYyYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGtjLm9uUG9zdENvbW1pdEZpYmVyUm9vdCl0cnl7a2Mub25Qb3N0Q29tbWl0RmliZXJSb290KGpjLGEpfWNhdGNoKFope31kPSEwfXJldHVybiBkfWZpbmFsbHl7Qz1jLG1rLnRyYW5zaXRpb249Yn19cmV0dXJuITF9ZnVuY3Rpb24gV2soYSxiLGMpe2I9SGkoYyxiKTtiPUtpKGEsYiwxKTtBZyhhLGIpO2I9SmcoKTthPUFrKGEsMSk7bnVsbCE9PWEmJih6YyhhLDEsYiksQ2soYSxiKSl9XG5mdW5jdGlvbiBVKGEsYixjKXtpZigzPT09YS50YWcpV2soYSxhLGMpO2Vsc2UgZm9yKDtudWxsIT09Yjspe2lmKDM9PT1iLnRhZyl7V2soYixhLGMpO2JyZWFrfWVsc2UgaWYoMT09PWIudGFnKXt2YXIgZD1iLnN0YXRlTm9kZTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYi50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcnx8XCJmdW5jdGlvblwiPT09dHlwZW9mIGQuY29tcG9uZW50RGlkQ2F0Y2gmJihudWxsPT09T2l8fCFPaS5oYXMoZCkpKXthPUhpKGMsYSk7YT1OaShiLGEsMSk7QWcoYixhKTthPUpnKCk7Yj1BayhiLDEpO251bGwhPT1iJiYoemMoYiwxLGEpLENrKGIsYSkpO2JyZWFrfX1iPWIucmV0dXJufX1cbmZ1bmN0aW9uIFFpKGEsYixjKXt2YXIgZD1hLnBpbmdDYWNoZTtudWxsIT09ZCYmZC5kZWxldGUoYik7Yj1KZygpO2EucGluZ2VkTGFuZXN8PWEuc3VzcGVuZGVkTGFuZXMmYztQPT09YSYmKFkmYyk9PT1jJiYoND09PVJ8fDM9PT1SJiYoWSYxMzAwMjM0MjQpPT09WSYmNTAwPkIoKS1kaz9KayhhLDApOnBrfD1jKTtDayhhLGIpfWZ1bmN0aW9uIFhrKGEsYil7MD09PWImJigwPT09KGEubW9kZSYxKT9iPTE6KGI9cmMscmM8PD0xLDA9PT0ocmMmMTMwMDIzNDI0KSYmKHJjPTQxOTQzMDQpKSk7dmFyIGM9SmcoKTthPUFrKGEsYik7bnVsbCE9PWEmJih6YyhhLGIsYyksQ2soYSxjKSl9ZnVuY3Rpb24gemooYSl7dmFyIGI9YS5tZW1vaXplZFN0YXRlLGM9MDtudWxsIT09YiYmKGM9Yi5yZXRyeUxhbmUpO1hrKGEsYyl9XG5mdW5jdGlvbiBaaihhLGIpe3ZhciBjPTA7c3dpdGNoKGEudGFnKXtjYXNlIDEzOnZhciBkPWEuc3RhdGVOb2RlO3ZhciBlPWEubWVtb2l6ZWRTdGF0ZTtudWxsIT09ZSYmKGM9ZS5yZXRyeUxhbmUpO2JyZWFrO2Nhc2UgMTk6ZD1hLnN0YXRlTm9kZTticmVhaztkZWZhdWx0OnRocm93IEVycm9yKHAoMzE0KSk7fW51bGwhPT1kJiZkLmRlbGV0ZShiKTtYayhhLGMpfXZhciBVaztcblVrPWZ1bmN0aW9uKGEsYixjKXtpZihudWxsIT09YSlpZihhLm1lbW9pemVkUHJvcHMhPT1iLnBlbmRpbmdQcm9wc3x8VmYuY3VycmVudCl0Zz0hMDtlbHNle2lmKDA9PT0oYS5sYW5lcyZjKSYmMD09PShiLmZsYWdzJjEyOCkpcmV0dXJuIHRnPSExLEZqKGEsYixjKTt0Zz0wIT09KGEuZmxhZ3MmMTMxMDcyKT8hMDohMX1lbHNlIHRnPSExLEkmJjAhPT0oYi5mbGFncyYxMDQ4NTc2KSYmYWgoYixVZyxiLmluZGV4KTtiLmxhbmVzPTA7c3dpdGNoKGIudGFnKXtjYXNlIDI6dmFyIGQ9Yi50eXBlO251bGwhPT1hJiYoYS5hbHRlcm5hdGU9bnVsbCxiLmFsdGVybmF0ZT1udWxsLGIuZmxhZ3N8PTIpO2E9Yi5wZW5kaW5nUHJvcHM7dmFyIGU9WGYoYixILmN1cnJlbnQpO3NnKGIsYyk7ZT1VaChudWxsLGIsZCxhLGUsYyk7dmFyIGY9WmgoKTtiLmZsYWdzfD0xO1wib2JqZWN0XCI9PT10eXBlb2YgZSYmbnVsbCE9PWUmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBlLnJlbmRlciYmdm9pZCAwPT09ZS4kJHR5cGVvZj9cbihiLnRhZz0xLGIubWVtb2l6ZWRTdGF0ZT1udWxsLGIudXBkYXRlUXVldWU9bnVsbCxZZihkKT8oZj0hMCxiZyhiKSk6Zj0hMSxiLm1lbW9pemVkU3RhdGU9bnVsbCE9PWUuc3RhdGUmJnZvaWQgMCE9PWUuc3RhdGU/ZS5zdGF0ZTpudWxsLHhnKGIpLGUudXBkYXRlcj1NZyxiLnN0YXRlTm9kZT1lLGUuX3JlYWN0SW50ZXJuYWxzPWIsUWcoYixkLGEsYyksYj1waihudWxsLGIsZCwhMCxmLGMpKTooYi50YWc9MCxJJiZmJiZiaChiKSxlaihudWxsLGIsZSxjKSxiPWIuY2hpbGQpO3JldHVybiBiO2Nhc2UgMTY6ZD1iLmVsZW1lbnRUeXBlO2E6e251bGwhPT1hJiYoYS5hbHRlcm5hdGU9bnVsbCxiLmFsdGVybmF0ZT1udWxsLGIuZmxhZ3N8PTIpO2E9Yi5wZW5kaW5nUHJvcHM7ZT1kLl9pbml0O2Q9ZShkLl9wYXlsb2FkKTtiLnR5cGU9ZDtlPWIudGFnPVlrKGQpO2E9a2coZCxhKTtzd2l0Y2goZSl7Y2FzZSAwOmI9a2oobnVsbCxiLGQsYSxjKTticmVhayBhO2Nhc2UgMTpiPW9qKG51bGwsYixcbmQsYSxjKTticmVhayBhO2Nhc2UgMTE6Yj1maihudWxsLGIsZCxhLGMpO2JyZWFrIGE7Y2FzZSAxNDpiPWhqKG51bGwsYixkLGtnKGQudHlwZSxhKSxjKTticmVhayBhfXRocm93IEVycm9yKHAoMzA2LGQsXCJcIikpO31yZXR1cm4gYjtjYXNlIDA6cmV0dXJuIGQ9Yi50eXBlLGU9Yi5wZW5kaW5nUHJvcHMsZT1iLmVsZW1lbnRUeXBlPT09ZD9lOmtnKGQsZSksa2ooYSxiLGQsZSxjKTtjYXNlIDE6cmV0dXJuIGQ9Yi50eXBlLGU9Yi5wZW5kaW5nUHJvcHMsZT1iLmVsZW1lbnRUeXBlPT09ZD9lOmtnKGQsZSksb2ooYSxiLGQsZSxjKTtjYXNlIDM6YTp7cWooYik7aWYobnVsbD09PWEpdGhyb3cgRXJyb3IocCgzODcpKTtkPWIucGVuZGluZ1Byb3BzO2Y9Yi5tZW1vaXplZFN0YXRlO2U9Zi5lbGVtZW50O3lnKGEsYik7RWcoYixkLG51bGwsYyk7dmFyIGc9Yi5tZW1vaXplZFN0YXRlO2Q9Zy5lbGVtZW50O2lmKGYuaXNEZWh5ZHJhdGVkKWlmKGY9e2VsZW1lbnQ6ZCxpc0RlaHlkcmF0ZWQ6ITEsXG5jYWNoZTpnLmNhY2hlLHBlbmRpbmdTdXNwZW5zZUJvdW5kYXJpZXM6Zy5wZW5kaW5nU3VzcGVuc2VCb3VuZGFyaWVzLHRyYW5zaXRpb25zOmcudHJhbnNpdGlvbnN9LGIudXBkYXRlUXVldWUuYmFzZVN0YXRlPWYsYi5tZW1vaXplZFN0YXRlPWYsYi5mbGFncyYyNTYpe2U9RXJyb3IocCg0MjMpKTtiPXJqKGEsYixkLGMsZSk7YnJlYWsgYX1lbHNlIGlmKGQhPT1lKXtlPUVycm9yKHAoNDI0KSk7Yj1yaihhLGIsZCxjLGUpO2JyZWFrIGF9ZWxzZSBmb3IoZWg9S2YoYi5zdGF0ZU5vZGUuY29udGFpbmVySW5mby5maXJzdENoaWxkKSxkaD1iLEk9ITAsZmg9bnVsbCxjPXpoKGIsbnVsbCxkLGMpLGIuY2hpbGQ9YztjOyljLmZsYWdzPWMuZmxhZ3MmLTN8NDA5NixjPWMuc2libGluZztlbHNle25oKCk7aWYoZD09PWUpe2I9Z2ooYSxiLGMpO2JyZWFrIGF9ZWooYSxiLGQsYyl9Yj1iLmNoaWxkfXJldHVybiBiO2Nhc2UgNTpyZXR1cm4gSGgoYiksbnVsbD09PWEmJmtoKGIpLGQ9Yi50eXBlLGU9XG5iLnBlbmRpbmdQcm9wcyxmPW51bGwhPT1hP2EubWVtb2l6ZWRQcm9wczpudWxsLGc9ZS5jaGlsZHJlbixEZihkLGUpP2c9bnVsbDpudWxsIT09ZiYmRGYoZCxmKSYmKGIuZmxhZ3N8PTMyKSxuaihhLGIpLGVqKGEsYixnLGMpLGIuY2hpbGQ7Y2FzZSA2OnJldHVybiBudWxsPT09YSYma2goYiksbnVsbDtjYXNlIDEzOnJldHVybiB2aihhLGIsYyk7Y2FzZSA0OnJldHVybiBGaChiLGIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pLGQ9Yi5wZW5kaW5nUHJvcHMsbnVsbD09PWE/Yi5jaGlsZD15aChiLG51bGwsZCxjKTplaihhLGIsZCxjKSxiLmNoaWxkO2Nhc2UgMTE6cmV0dXJuIGQ9Yi50eXBlLGU9Yi5wZW5kaW5nUHJvcHMsZT1iLmVsZW1lbnRUeXBlPT09ZD9lOmtnKGQsZSksZmooYSxiLGQsZSxjKTtjYXNlIDc6cmV0dXJuIGVqKGEsYixiLnBlbmRpbmdQcm9wcyxjKSxiLmNoaWxkO2Nhc2UgODpyZXR1cm4gZWooYSxiLGIucGVuZGluZ1Byb3BzLmNoaWxkcmVuLGMpLGIuY2hpbGQ7Y2FzZSAxMjpyZXR1cm4gZWooYSxcbmIsYi5wZW5kaW5nUHJvcHMuY2hpbGRyZW4sYyksYi5jaGlsZDtjYXNlIDEwOmE6e2Q9Yi50eXBlLl9jb250ZXh0O2U9Yi5wZW5kaW5nUHJvcHM7Zj1iLm1lbW9pemVkUHJvcHM7Zz1lLnZhbHVlO0cobGcsZC5fY3VycmVudFZhbHVlKTtkLl9jdXJyZW50VmFsdWU9ZztpZihudWxsIT09ZilpZihHZShmLnZhbHVlLGcpKXtpZihmLmNoaWxkcmVuPT09ZS5jaGlsZHJlbiYmIVZmLmN1cnJlbnQpe2I9Z2ooYSxiLGMpO2JyZWFrIGF9fWVsc2UgZm9yKGY9Yi5jaGlsZCxudWxsIT09ZiYmKGYucmV0dXJuPWIpO251bGwhPT1mOyl7dmFyIGg9Zi5kZXBlbmRlbmNpZXM7aWYobnVsbCE9PWgpe2c9Zi5jaGlsZDtmb3IodmFyIGs9aC5maXJzdENvbnRleHQ7bnVsbCE9PWs7KXtpZihrLmNvbnRleHQ9PT1kKXtpZigxPT09Zi50YWcpe2s9emcoLTEsYyYtYyk7ay50YWc9Mjt2YXIgbD1mLnVwZGF0ZVF1ZXVlO2lmKG51bGwhPT1sKXtsPWwuc2hhcmVkO3ZhciBuPWwucGVuZGluZztudWxsPT09bj9rLm5leHQ9XG5rOihrLm5leHQ9bi5uZXh0LG4ubmV4dD1rKTtsLnBlbmRpbmc9a319Zi5sYW5lc3w9YztrPWYuYWx0ZXJuYXRlO251bGwhPT1rJiYoay5sYW5lc3w9Yyk7cmcoZi5yZXR1cm4sYyxiKTtoLmxhbmVzfD1jO2JyZWFrfWs9ay5uZXh0fX1lbHNlIGlmKDEwPT09Zi50YWcpZz1mLnR5cGU9PT1iLnR5cGU/bnVsbDpmLmNoaWxkO2Vsc2UgaWYoMTg9PT1mLnRhZyl7Zz1mLnJldHVybjtpZihudWxsPT09Zyl0aHJvdyBFcnJvcihwKDM0MSkpO2cubGFuZXN8PWM7aD1nLmFsdGVybmF0ZTtudWxsIT09aCYmKGgubGFuZXN8PWMpO3JnKGcsYyxiKTtnPWYuc2libGluZ31lbHNlIGc9Zi5jaGlsZDtpZihudWxsIT09ZylnLnJldHVybj1mO2Vsc2UgZm9yKGc9ZjtudWxsIT09Zzspe2lmKGc9PT1iKXtnPW51bGw7YnJlYWt9Zj1nLnNpYmxpbmc7aWYobnVsbCE9PWYpe2YucmV0dXJuPWcucmV0dXJuO2c9ZjticmVha31nPWcucmV0dXJufWY9Z31laihhLGIsZS5jaGlsZHJlbixjKTtiPWIuY2hpbGR9cmV0dXJuIGI7XG5jYXNlIDk6cmV0dXJuIGU9Yi50eXBlLGQ9Yi5wZW5kaW5nUHJvcHMuY2hpbGRyZW4sc2coYixjKSxlPXVnKGUpLGQ9ZChlKSxiLmZsYWdzfD0xLGVqKGEsYixkLGMpLGIuY2hpbGQ7Y2FzZSAxNDpyZXR1cm4gZD1iLnR5cGUsZT1rZyhkLGIucGVuZGluZ1Byb3BzKSxlPWtnKGQudHlwZSxlKSxoaihhLGIsZCxlLGMpO2Nhc2UgMTU6cmV0dXJuIGpqKGEsYixiLnR5cGUsYi5wZW5kaW5nUHJvcHMsYyk7Y2FzZSAxNzpyZXR1cm4gZD1iLnR5cGUsZT1iLnBlbmRpbmdQcm9wcyxlPWIuZWxlbWVudFR5cGU9PT1kP2U6a2coZCxlKSxudWxsIT09YSYmKGEuYWx0ZXJuYXRlPW51bGwsYi5hbHRlcm5hdGU9bnVsbCxiLmZsYWdzfD0yKSxiLnRhZz0xLFlmKGQpPyhhPSEwLGJnKGIpKTphPSExLHNnKGIsYyksT2coYixkLGUpLFFnKGIsZCxlLGMpLHBqKG51bGwsYixkLCEwLGEsYyk7Y2FzZSAxOTpyZXR1cm4gRWooYSxiLGMpO2Nhc2UgMjI6cmV0dXJuIGxqKGEsYixjKX10aHJvdyBFcnJvcihwKDE1NixcbmIudGFnKSk7fTtmdW5jdGlvbiBFayhhLGIpe3JldHVybiAkYihhLGIpfWZ1bmN0aW9uIFprKGEsYixjLGQpe3RoaXMudGFnPWE7dGhpcy5rZXk9Yzt0aGlzLnNpYmxpbmc9dGhpcy5jaGlsZD10aGlzLnJldHVybj10aGlzLnN0YXRlTm9kZT10aGlzLnR5cGU9dGhpcy5lbGVtZW50VHlwZT1udWxsO3RoaXMuaW5kZXg9MDt0aGlzLnJlZj1udWxsO3RoaXMucGVuZGluZ1Byb3BzPWI7dGhpcy5kZXBlbmRlbmNpZXM9dGhpcy5tZW1vaXplZFN0YXRlPXRoaXMudXBkYXRlUXVldWU9dGhpcy5tZW1vaXplZFByb3BzPW51bGw7dGhpcy5tb2RlPWQ7dGhpcy5zdWJ0cmVlRmxhZ3M9dGhpcy5mbGFncz0wO3RoaXMuZGVsZXRpb25zPW51bGw7dGhpcy5jaGlsZExhbmVzPXRoaXMubGFuZXM9MDt0aGlzLmFsdGVybmF0ZT1udWxsfWZ1bmN0aW9uIGhoKGEsYixjLGQpe3JldHVybiBuZXcgWmsoYSxiLGMsZCl9XG5mdW5jdGlvbiBpaihhKXthPWEucHJvdG90eXBlO3JldHVybiEoIWF8fCFhLmlzUmVhY3RDb21wb25lbnQpfWZ1bmN0aW9uIFlrKGEpe2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBhKXJldHVybiBpaihhKT8xOjA7aWYodm9pZCAwIT09YSYmbnVsbCE9PWEpe2E9YS4kJHR5cGVvZjtpZihhPT09Q2EpcmV0dXJuIDExO2lmKGE9PT1GYSlyZXR1cm4gMTR9cmV0dXJuIDJ9XG5mdW5jdGlvbiB0aChhLGIpe3ZhciBjPWEuYWx0ZXJuYXRlO251bGw9PT1jPyhjPWhoKGEudGFnLGIsYS5rZXksYS5tb2RlKSxjLmVsZW1lbnRUeXBlPWEuZWxlbWVudFR5cGUsYy50eXBlPWEudHlwZSxjLnN0YXRlTm9kZT1hLnN0YXRlTm9kZSxjLmFsdGVybmF0ZT1hLGEuYWx0ZXJuYXRlPWMpOihjLnBlbmRpbmdQcm9wcz1iLGMudHlwZT1hLnR5cGUsYy5mbGFncz0wLGMuc3VidHJlZUZsYWdzPTAsYy5kZWxldGlvbnM9bnVsbCk7Yy5mbGFncz1hLmZsYWdzJjE0NjgwMDY0O2MuY2hpbGRMYW5lcz1hLmNoaWxkTGFuZXM7Yy5sYW5lcz1hLmxhbmVzO2MuY2hpbGQ9YS5jaGlsZDtjLm1lbW9pemVkUHJvcHM9YS5tZW1vaXplZFByb3BzO2MubWVtb2l6ZWRTdGF0ZT1hLm1lbW9pemVkU3RhdGU7Yy51cGRhdGVRdWV1ZT1hLnVwZGF0ZVF1ZXVlO2I9YS5kZXBlbmRlbmNpZXM7Yy5kZXBlbmRlbmNpZXM9bnVsbD09PWI/bnVsbDp7bGFuZXM6Yi5sYW5lcyxmaXJzdENvbnRleHQ6Yi5maXJzdENvbnRleHR9O1xuYy5zaWJsaW5nPWEuc2libGluZztjLmluZGV4PWEuaW5kZXg7Yy5yZWY9YS5yZWY7cmV0dXJuIGN9XG5mdW5jdGlvbiB2aChhLGIsYyxkLGUsZil7dmFyIGc9MjtkPWE7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGEpaWooYSkmJihnPTEpO2Vsc2UgaWYoXCJzdHJpbmdcIj09PXR5cGVvZiBhKWc9NTtlbHNlIGE6c3dpdGNoKGEpe2Nhc2Ugd2E6cmV0dXJuIHhoKGMuY2hpbGRyZW4sZSxmLGIpO2Nhc2UgeGE6Zz04O2V8PTg7YnJlYWs7Y2FzZSB6YTpyZXR1cm4gYT1oaCgxMixjLGIsZXwyKSxhLmVsZW1lbnRUeXBlPXphLGEubGFuZXM9ZixhO2Nhc2UgRGE6cmV0dXJuIGE9aGgoMTMsYyxiLGUpLGEuZWxlbWVudFR5cGU9RGEsYS5sYW5lcz1mLGE7Y2FzZSBFYTpyZXR1cm4gYT1oaCgxOSxjLGIsZSksYS5lbGVtZW50VHlwZT1FYSxhLmxhbmVzPWYsYTtjYXNlIEhhOnJldHVybiB3aihjLGUsZixiKTtkZWZhdWx0OmlmKFwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEpc3dpdGNoKGEuJCR0eXBlb2Ype2Nhc2UgQWE6Zz0xMDticmVhayBhO2Nhc2UgQmE6Zz05O2JyZWFrIGE7Y2FzZSBDYTpnPTExO1xuYnJlYWsgYTtjYXNlIEZhOmc9MTQ7YnJlYWsgYTtjYXNlIEdhOmc9MTY7ZD1udWxsO2JyZWFrIGF9dGhyb3cgRXJyb3IocCgxMzAsbnVsbD09YT9hOnR5cGVvZiBhLFwiXCIpKTt9Yj1oaChnLGMsYixlKTtiLmVsZW1lbnRUeXBlPWE7Yi50eXBlPWQ7Yi5sYW5lcz1mO3JldHVybiBifWZ1bmN0aW9uIHhoKGEsYixjLGQpe2E9aGgoNyxhLGQsYik7YS5sYW5lcz1jO3JldHVybiBhfWZ1bmN0aW9uIHdqKGEsYixjLGQpe2E9aGgoMjIsYSxkLGIpO2EuZWxlbWVudFR5cGU9SGE7YS5sYW5lcz1jO2Euc3RhdGVOb2RlPXt9O3JldHVybiBhfWZ1bmN0aW9uIHVoKGEsYixjKXthPWhoKDYsYSxudWxsLGIpO2EubGFuZXM9YztyZXR1cm4gYX1cbmZ1bmN0aW9uIHdoKGEsYixjKXtiPWhoKDQsbnVsbCE9PWEuY2hpbGRyZW4/YS5jaGlsZHJlbjpbXSxhLmtleSxiKTtiLmxhbmVzPWM7Yi5zdGF0ZU5vZGU9e2NvbnRhaW5lckluZm86YS5jb250YWluZXJJbmZvLHBlbmRpbmdDaGlsZHJlbjpudWxsLGltcGxlbWVudGF0aW9uOmEuaW1wbGVtZW50YXRpb259O3JldHVybiBifVxuZnVuY3Rpb24gJGsoYSxiLGMsZCxlKXt0aGlzLnRhZz1iO3RoaXMuY29udGFpbmVySW5mbz1hO3RoaXMuZmluaXNoZWRXb3JrPXRoaXMucGluZ0NhY2hlPXRoaXMuY3VycmVudD10aGlzLnBlbmRpbmdDaGlsZHJlbj1udWxsO3RoaXMudGltZW91dEhhbmRsZT0tMTt0aGlzLmNhbGxiYWNrTm9kZT10aGlzLnBlbmRpbmdDb250ZXh0PXRoaXMuY29udGV4dD1udWxsO3RoaXMuY2FsbGJhY2tQcmlvcml0eT0wO3RoaXMuZXZlbnRUaW1lcz15YygwKTt0aGlzLmV4cGlyYXRpb25UaW1lcz15YygtMSk7dGhpcy5lbnRhbmdsZWRMYW5lcz10aGlzLmZpbmlzaGVkTGFuZXM9dGhpcy5tdXRhYmxlUmVhZExhbmVzPXRoaXMuZXhwaXJlZExhbmVzPXRoaXMucGluZ2VkTGFuZXM9dGhpcy5zdXNwZW5kZWRMYW5lcz10aGlzLnBlbmRpbmdMYW5lcz0wO3RoaXMuZW50YW5nbGVtZW50cz15YygwKTt0aGlzLmlkZW50aWZpZXJQcmVmaXg9ZDt0aGlzLm9uUmVjb3ZlcmFibGVFcnJvcj1lO3RoaXMubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YT1cbm51bGx9ZnVuY3Rpb24gYWwoYSxiLGMsZCxlLGYsZyxoLGspe2E9bmV3ICRrKGEsYixjLGgsayk7MT09PWI/KGI9MSwhMD09PWYmJihifD04KSk6Yj0wO2Y9aGgoMyxudWxsLG51bGwsYik7YS5jdXJyZW50PWY7Zi5zdGF0ZU5vZGU9YTtmLm1lbW9pemVkU3RhdGU9e2VsZW1lbnQ6ZCxpc0RlaHlkcmF0ZWQ6YyxjYWNoZTpudWxsLHRyYW5zaXRpb25zOm51bGwscGVuZGluZ1N1c3BlbnNlQm91bmRhcmllczpudWxsfTt4ZyhmKTtyZXR1cm4gYX1mdW5jdGlvbiBibChhLGIsYyl7dmFyIGQ9Mzxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOm51bGw7cmV0dXJueyQkdHlwZW9mOnZhLGtleTpudWxsPT1kP251bGw6XCJcIitkLGNoaWxkcmVuOmEsY29udGFpbmVySW5mbzpiLGltcGxlbWVudGF0aW9uOmN9fVxuZnVuY3Rpb24gY2woYSl7aWYoIWEpcmV0dXJuIFVmO2E9YS5fcmVhY3RJbnRlcm5hbHM7YTp7aWYoVWIoYSkhPT1hfHwxIT09YS50YWcpdGhyb3cgRXJyb3IocCgxNzApKTt2YXIgYj1hO2Rve3N3aXRjaChiLnRhZyl7Y2FzZSAzOmI9Yi5zdGF0ZU5vZGUuY29udGV4dDticmVhayBhO2Nhc2UgMTppZihZZihiLnR5cGUpKXtiPWIuc3RhdGVOb2RlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0O2JyZWFrIGF9fWI9Yi5yZXR1cm59d2hpbGUobnVsbCE9PWIpO3Rocm93IEVycm9yKHAoMTcxKSk7fWlmKDE9PT1hLnRhZyl7dmFyIGM9YS50eXBlO2lmKFlmKGMpKXJldHVybiBhZyhhLGMsYil9cmV0dXJuIGJ9XG5mdW5jdGlvbiBkbChhLGIsYyxkLGUsZixnLGgsayl7YT1hbChjLGQsITAsYSxlLGYsZyxoLGspO2EuY29udGV4dD1jbChudWxsKTtjPWEuY3VycmVudDtkPUpnKCk7ZT1LZyhjKTtmPXpnKGQsZSk7Zi5jYWxsYmFjaz12b2lkIDAhPT1iJiZudWxsIT09Yj9iOm51bGw7QWcoYyxmKTthLmN1cnJlbnQubGFuZXM9ZTt6YyhhLGUsZCk7Q2soYSxkKTtyZXR1cm4gYX1mdW5jdGlvbiBlbChhLGIsYyxkKXt2YXIgZT1iLmN1cnJlbnQsZj1KZygpLGc9S2coZSk7Yz1jbChjKTtudWxsPT09Yi5jb250ZXh0P2IuY29udGV4dD1jOmIucGVuZGluZ0NvbnRleHQ9YztiPXpnKGYsZyk7Yi5wYXlsb2FkPXtlbGVtZW50OmF9O2Q9dm9pZCAwPT09ZD9udWxsOmQ7bnVsbCE9PWQmJihiLmNhbGxiYWNrPWQpO0FnKGUsYik7YT1MZyhlLGcsZik7bnVsbCE9PWEmJkNnKGEsZSxnKTtyZXR1cm4gZ31cbmZ1bmN0aW9uIGZsKGEpe2E9YS5jdXJyZW50O2lmKCFhLmNoaWxkKXJldHVybiBudWxsO3N3aXRjaChhLmNoaWxkLnRhZyl7Y2FzZSA1OnJldHVybiBhLmNoaWxkLnN0YXRlTm9kZTtkZWZhdWx0OnJldHVybiBhLmNoaWxkLnN0YXRlTm9kZX19ZnVuY3Rpb24gZ2woYSxiKXthPWEubWVtb2l6ZWRTdGF0ZTtpZihudWxsIT09YSYmbnVsbCE9PWEuZGVoeWRyYXRlZCl7dmFyIGM9YS5yZXRyeUxhbmU7YS5yZXRyeUxhbmU9MCE9PWMmJmM8Yj9jOmJ9fWZ1bmN0aW9uIGhsKGEsYil7Z2woYSxiKTsoYT1hLmFsdGVybmF0ZSkmJmdsKGEsYil9ZnVuY3Rpb24gaWwoKXtyZXR1cm4gbnVsbH12YXIgamw9XCJmdW5jdGlvblwiPT09dHlwZW9mIHJlcG9ydEVycm9yP3JlcG9ydEVycm9yOmZ1bmN0aW9uKGEpe2NvbnNvbGUuZXJyb3IoYSl9O2Z1bmN0aW9uIGtsKGEpe3RoaXMuX2ludGVybmFsUm9vdD1hfVxubGwucHJvdG90eXBlLnJlbmRlcj1rbC5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuX2ludGVybmFsUm9vdDtpZihudWxsPT09Yil0aHJvdyBFcnJvcihwKDQwOSkpO2VsKGEsYixudWxsLG51bGwpfTtsbC5wcm90b3R5cGUudW5tb3VudD1rbC5wcm90b3R5cGUudW5tb3VudD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuX2ludGVybmFsUm9vdDtpZihudWxsIT09YSl7dGhpcy5faW50ZXJuYWxSb290PW51bGw7dmFyIGI9YS5jb250YWluZXJJbmZvO1FrKGZ1bmN0aW9uKCl7ZWwobnVsbCxhLG51bGwsbnVsbCl9KTtiW3RmXT1udWxsfX07ZnVuY3Rpb24gbGwoYSl7dGhpcy5faW50ZXJuYWxSb290PWF9XG5sbC5wcm90b3R5cGUudW5zdGFibGVfc2NoZWR1bGVIeWRyYXRpb249ZnVuY3Rpb24oYSl7aWYoYSl7dmFyIGI9R2MoKTthPXtibG9ja2VkT246bnVsbCx0YXJnZXQ6YSxwcmlvcml0eTpifTtmb3IodmFyIGM9MDtjPFBjLmxlbmd0aCYmMCE9PWImJmI8UGNbY10ucHJpb3JpdHk7YysrKTtQYy5zcGxpY2UoYywwLGEpOzA9PT1jJiZVYyhhKX19O2Z1bmN0aW9uIG1sKGEpe3JldHVybiEoIWF8fDEhPT1hLm5vZGVUeXBlJiY5IT09YS5ub2RlVHlwZSYmMTEhPT1hLm5vZGVUeXBlKX1mdW5jdGlvbiBubChhKXtyZXR1cm4hKCFhfHwxIT09YS5ub2RlVHlwZSYmOSE9PWEubm9kZVR5cGUmJjExIT09YS5ub2RlVHlwZSYmKDghPT1hLm5vZGVUeXBlfHxcIiByZWFjdC1tb3VudC1wb2ludC11bnN0YWJsZSBcIiE9PWEubm9kZVZhbHVlKSl9ZnVuY3Rpb24gb2woKXt9XG5mdW5jdGlvbiBwbChhLGIsYyxkLGUpe2lmKGUpe2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBkKXt2YXIgZj1kO2Q9ZnVuY3Rpb24oKXt2YXIgYT1mbChnKTtmLmNhbGwoYSl9fXZhciBnPWRsKGIsZCxhLDAsbnVsbCwhMSwhMSxcIlwiLG9sKTthLl9yZWFjdFJvb3RDb250YWluZXI9ZzthW3RmXT1nLmN1cnJlbnQ7cmYoOD09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlOmEpO1FrKCk7cmV0dXJuIGd9Zm9yKDtlPWEubGFzdENoaWxkOylhLnJlbW92ZUNoaWxkKGUpO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBkKXt2YXIgaD1kO2Q9ZnVuY3Rpb24oKXt2YXIgYT1mbChrKTtoLmNhbGwoYSl9fXZhciBrPWFsKGEsMCwhMSxudWxsLG51bGwsITEsITEsXCJcIixvbCk7YS5fcmVhY3RSb290Q29udGFpbmVyPWs7YVt0Zl09ay5jdXJyZW50O3JmKDg9PT1hLm5vZGVUeXBlP2EucGFyZW50Tm9kZTphKTtRayhmdW5jdGlvbigpe2VsKGIsayxjLGQpfSk7cmV0dXJuIGt9XG5mdW5jdGlvbiBxbChhLGIsYyxkLGUpe3ZhciBmPWMuX3JlYWN0Um9vdENvbnRhaW5lcjtpZihmKXt2YXIgZz1mO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBlKXt2YXIgaD1lO2U9ZnVuY3Rpb24oKXt2YXIgYT1mbChnKTtoLmNhbGwoYSl9fWVsKGIsZyxhLGUpfWVsc2UgZz1wbChjLGIsYSxlLGQpO3JldHVybiBmbChnKX1EYz1mdW5jdGlvbihhKXtzd2l0Y2goYS50YWcpe2Nhc2UgMzp2YXIgYj1hLnN0YXRlTm9kZTtpZihiLmN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQpe3ZhciBjPXNjKGIucGVuZGluZ0xhbmVzKTswIT09YyYmKEJjKGIsY3wxKSxDayhiLEIoKSksMD09PShXJjYpJiYoYWo9QigpKzUwMCxpZygpKSl9YnJlYWs7Y2FzZSAxMzp2YXIgZD1KZygpO1FrKGZ1bmN0aW9uKCl7cmV0dXJuIExnKGEsMSxkKX0pO2hsKGEsMSl9fTtFYz1mdW5jdGlvbihhKXtpZigxMz09PWEudGFnKXt2YXIgYj1KZygpO0xnKGEsMTM0MjE3NzI4LGIpO2hsKGEsMTM0MjE3NzI4KX19O1xuRmM9ZnVuY3Rpb24oYSl7aWYoMTM9PT1hLnRhZyl7dmFyIGI9SmcoKSxjPUtnKGEpO0xnKGEsYyxiKTtobChhLGMpfX07R2M9ZnVuY3Rpb24oKXtyZXR1cm4gQ307SGM9ZnVuY3Rpb24oYSxiKXt2YXIgYz1DO3RyeXtyZXR1cm4gQz1hLGIoKX1maW5hbGx5e0M9Y319O1xueGI9ZnVuY3Rpb24oYSxiLGMpe3N3aXRjaChiKXtjYXNlIFwiaW5wdXRcIjokYShhLGMpO2I9Yy5uYW1lO2lmKFwicmFkaW9cIj09PWMudHlwZSYmbnVsbCE9Yil7Zm9yKGM9YTtjLnBhcmVudE5vZGU7KWM9Yy5wYXJlbnROb2RlO2M9Yy5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXRbbmFtZT1cIitKU09OLnN0cmluZ2lmeShcIlwiK2IpKyddW3R5cGU9XCJyYWRpb1wiXScpO2ZvcihiPTA7YjxjLmxlbmd0aDtiKyspe3ZhciBkPWNbYl07aWYoZCE9PWEmJmQuZm9ybT09PWEuZm9ybSl7dmFyIGU9Q2IoZCk7aWYoIWUpdGhyb3cgRXJyb3IocCg5MCkpO1ZhKGQpOyRhKGQsZSl9fX1icmVhaztjYXNlIFwidGV4dGFyZWFcIjpoYihhLGMpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpiPWMudmFsdWUsbnVsbCE9YiYmZWIoYSwhIWMubXVsdGlwbGUsYiwhMSl9fTtGYj1QaztHYj1RaztcbnZhciBybD17dXNpbmdDbGllbnRFbnRyeVBvaW50OiExLEV2ZW50czpbQmIsdGUsQ2IsRGIsRWIsUGtdfSxzbD17ZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6VmMsYnVuZGxlVHlwZTowLHZlcnNpb246XCIxOC4xLjBcIixyZW5kZXJlclBhY2thZ2VOYW1lOlwicmVhY3QtZG9tXCJ9O1xudmFyIHRsPXtidW5kbGVUeXBlOnNsLmJ1bmRsZVR5cGUsdmVyc2lvbjpzbC52ZXJzaW9uLHJlbmRlcmVyUGFja2FnZU5hbWU6c2wucmVuZGVyZXJQYWNrYWdlTmFtZSxyZW5kZXJlckNvbmZpZzpzbC5yZW5kZXJlckNvbmZpZyxvdmVycmlkZUhvb2tTdGF0ZTpudWxsLG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aDpudWxsLG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aDpudWxsLG92ZXJyaWRlUHJvcHM6bnVsbCxvdmVycmlkZVByb3BzRGVsZXRlUGF0aDpudWxsLG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoOm51bGwsc2V0RXJyb3JIYW5kbGVyOm51bGwsc2V0U3VzcGVuc2VIYW5kbGVyOm51bGwsc2NoZWR1bGVVcGRhdGU6bnVsbCxjdXJyZW50RGlzcGF0Y2hlclJlZjp0YS5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyOmZ1bmN0aW9uKGEpe2E9WWIoYSk7cmV0dXJuIG51bGw9PT1hP251bGw6YS5zdGF0ZU5vZGV9LGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOnNsLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlfHxcbmlsLGZpbmRIb3N0SW5zdGFuY2VzRm9yUmVmcmVzaDpudWxsLHNjaGVkdWxlUmVmcmVzaDpudWxsLHNjaGVkdWxlUm9vdDpudWxsLHNldFJlZnJlc2hIYW5kbGVyOm51bGwsZ2V0Q3VycmVudEZpYmVyOm51bGwscmVjb25jaWxlclZlcnNpb246XCIxOC4xLjAtbmV4dC0yMmVkYjlmNzctMjAyMjA0MjZcIn07aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18pe3ZhciB1bD1fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187aWYoIXVsLmlzRGlzYWJsZWQmJnVsLnN1cHBvcnRzRmliZXIpdHJ5e2pjPXVsLmluamVjdCh0bCksa2M9dWx9Y2F0Y2goYSl7fX1leHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEPXJsO1xuZXhwb3J0cy5jcmVhdGVQb3J0YWw9ZnVuY3Rpb24oYSxiKXt2YXIgYz0yPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06bnVsbDtpZighbWwoYikpdGhyb3cgRXJyb3IocCgyMDApKTtyZXR1cm4gYmwoYSxiLG51bGwsYyl9O2V4cG9ydHMuY3JlYXRlUm9vdD1mdW5jdGlvbihhLGIpe2lmKCFtbChhKSl0aHJvdyBFcnJvcihwKDI5OSkpO3ZhciBjPSExLGQ9XCJcIixlPWpsO251bGwhPT1iJiZ2b2lkIDAhPT1iJiYoITA9PT1iLnVuc3RhYmxlX3N0cmljdE1vZGUmJihjPSEwKSx2b2lkIDAhPT1iLmlkZW50aWZpZXJQcmVmaXgmJihkPWIuaWRlbnRpZmllclByZWZpeCksdm9pZCAwIT09Yi5vblJlY292ZXJhYmxlRXJyb3ImJihlPWIub25SZWNvdmVyYWJsZUVycm9yKSk7Yj1hbChhLDEsITEsbnVsbCxudWxsLGMsITEsZCxlKTthW3RmXT1iLmN1cnJlbnQ7cmYoOD09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlOmEpO3JldHVybiBuZXcga2woYil9O1xuZXhwb3J0cy5maW5kRE9NTm9kZT1mdW5jdGlvbihhKXtpZihudWxsPT1hKXJldHVybiBudWxsO2lmKDE9PT1hLm5vZGVUeXBlKXJldHVybiBhO3ZhciBiPWEuX3JlYWN0SW50ZXJuYWxzO2lmKHZvaWQgMD09PWIpe2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBhLnJlbmRlcil0aHJvdyBFcnJvcihwKDE4OCkpO2E9T2JqZWN0LmtleXMoYSkuam9pbihcIixcIik7dGhyb3cgRXJyb3IocCgyNjgsYSkpO31hPVliKGIpO2E9bnVsbD09PWE/bnVsbDphLnN0YXRlTm9kZTtyZXR1cm4gYX07ZXhwb3J0cy5mbHVzaFN5bmM9ZnVuY3Rpb24oYSl7cmV0dXJuIFFrKGEpfTtleHBvcnRzLmh5ZHJhdGU9ZnVuY3Rpb24oYSxiLGMpe2lmKCFubChiKSl0aHJvdyBFcnJvcihwKDIwMCkpO3JldHVybiBxbChudWxsLGEsYiwhMCxjKX07XG5leHBvcnRzLmh5ZHJhdGVSb290PWZ1bmN0aW9uKGEsYixjKXtpZighbWwoYSkpdGhyb3cgRXJyb3IocCg0MDUpKTt2YXIgZD1udWxsIT1jJiZjLmh5ZHJhdGVkU291cmNlc3x8bnVsbCxlPSExLGY9XCJcIixnPWpsO251bGwhPT1jJiZ2b2lkIDAhPT1jJiYoITA9PT1jLnVuc3RhYmxlX3N0cmljdE1vZGUmJihlPSEwKSx2b2lkIDAhPT1jLmlkZW50aWZpZXJQcmVmaXgmJihmPWMuaWRlbnRpZmllclByZWZpeCksdm9pZCAwIT09Yy5vblJlY292ZXJhYmxlRXJyb3ImJihnPWMub25SZWNvdmVyYWJsZUVycm9yKSk7Yj1kbChiLG51bGwsYSwxLG51bGwhPWM/YzpudWxsLGUsITEsZixnKTthW3RmXT1iLmN1cnJlbnQ7cmYoYSk7aWYoZClmb3IoYT0wO2E8ZC5sZW5ndGg7YSsrKWM9ZFthXSxlPWMuX2dldFZlcnNpb24sZT1lKGMuX3NvdXJjZSksbnVsbD09Yi5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhP2IubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YT1bYyxlXTpiLm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGEucHVzaChjLFxuZSk7cmV0dXJuIG5ldyBsbChiKX07ZXhwb3J0cy5yZW5kZXI9ZnVuY3Rpb24oYSxiLGMpe2lmKCFubChiKSl0aHJvdyBFcnJvcihwKDIwMCkpO3JldHVybiBxbChudWxsLGEsYiwhMSxjKX07ZXhwb3J0cy51bm1vdW50Q29tcG9uZW50QXROb2RlPWZ1bmN0aW9uKGEpe2lmKCFubChhKSl0aHJvdyBFcnJvcihwKDQwKSk7cmV0dXJuIGEuX3JlYWN0Um9vdENvbnRhaW5lcj8oUWsoZnVuY3Rpb24oKXtxbChudWxsLG51bGwsYSwhMSxmdW5jdGlvbigpe2EuX3JlYWN0Um9vdENvbnRhaW5lcj1udWxsO2FbdGZdPW51bGx9KX0pLCEwKTohMX07ZXhwb3J0cy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcz1QaztcbmV4cG9ydHMudW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI9ZnVuY3Rpb24oYSxiLGMsZCl7aWYoIW5sKGMpKXRocm93IEVycm9yKHAoMjAwKSk7aWYobnVsbD09YXx8dm9pZCAwPT09YS5fcmVhY3RJbnRlcm5hbHMpdGhyb3cgRXJyb3IocCgzOCkpO3JldHVybiBxbChhLGIsYywhMSxkKX07ZXhwb3J0cy52ZXJzaW9uPVwiMTguMS4wLW5leHQtMjJlZGI5Zjc3LTIwMjIwNDI2XCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///448\n')},745:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("var __webpack_unused_export__;\n\n\nvar m = __webpack_require__(935);\nif (true) {\n  exports.s = m.createRoot;\n  __webpack_unused_export__ = m.hydrateRoot;\n} else { var i; }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQ1LmpzIiwibWFwcGluZ3MiOiI7QUFBYTs7QUFFYixRQUFRLG1CQUFPLENBQUMsR0FBVztBQUMzQixJQUFJLElBQXFDO0FBQ3pDLEVBQUUsU0FBa0I7QUFDcEIsRUFBRSx5QkFBbUI7QUFDckIsRUFBRSxLQUFLLFVBa0JOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2NsaWVudC5qcz8xMWIxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIG0gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGV4cG9ydHMuY3JlYXRlUm9vdCA9IG0uY3JlYXRlUm9vdDtcbiAgZXhwb3J0cy5oeWRyYXRlUm9vdCA9IG0uaHlkcmF0ZVJvb3Q7XG59IGVsc2Uge1xuICB2YXIgaSA9IG0uX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG4gIGV4cG9ydHMuY3JlYXRlUm9vdCA9IGZ1bmN0aW9uKGMsIG8pIHtcbiAgICBpLnVzaW5nQ2xpZW50RW50cnlQb2ludCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBtLmNyZWF0ZVJvb3QoYywgbyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGkudXNpbmdDbGllbnRFbnRyeVBvaW50ID0gZmFsc2U7XG4gICAgfVxuICB9O1xuICBleHBvcnRzLmh5ZHJhdGVSb290ID0gZnVuY3Rpb24oYywgaCwgbykge1xuICAgIGkudXNpbmdDbGllbnRFbnRyeVBvaW50ID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG0uaHlkcmF0ZVJvb3QoYywgaCwgbyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGkudXNpbmdDbGllbnRFbnRyeVBvaW50ID0gZmFsc2U7XG4gICAgfVxuICB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///745\n")},935:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'\n  ) {\n    return;\n  }\n  if (false) {}\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\n\nif (true) {\n  // DCE check should happen before ReactDOM bundle executes so that\n  // DevTools can report bad minification during injection.\n  checkDCE();\n  module.exports = __webpack_require__(448);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTM1LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDLEVBQUUsRUFTMUM7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEVBQUUseUNBQTZEO0FBQy9ELEVBQUUsS0FBSyxFQUVOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzPzhiYzgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjaGVja0RDRSgpIHtcbiAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuICBpZiAoXG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRoaXMgYnJhbmNoIGlzIHVucmVhY2hhYmxlIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZFxuICAgIC8vIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgY29uZGl0aW9uIGlzIHRydWUgb25seSBpbiBkZXZlbG9wbWVudC5cbiAgICAvLyBUaGVyZWZvcmUgaWYgdGhlIGJyYW5jaCBpcyBzdGlsbCBoZXJlLCBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2Fzbid0XG4gICAgLy8gcHJvcGVybHkgYXBwbGllZC5cbiAgICAvLyBEb24ndCBjaGFuZ2UgdGhlIG1lc3NhZ2UuIFJlYWN0IERldlRvb2xzIHJlbGllcyBvbiBpdC4gQWxzbyBtYWtlIHN1cmVcbiAgICAvLyB0aGlzIG1lc3NhZ2UgZG9lc24ndCBvY2N1ciBlbHNld2hlcmUgaW4gdGhpcyBmdW5jdGlvbiwgb3IgaXQgd2lsbCBjYXVzZVxuICAgIC8vIGEgZmFsc2UgcG9zaXRpdmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdeX14nKTtcbiAgfVxuICB0cnkge1xuICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBjb2RlIGFib3ZlIGhhcyBiZWVuIGRlYWQgY29kZSBlbGltaW5hdGVkIChEQ0UnZCkuXG4gICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFKGNoZWNrRENFKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gRGV2VG9vbHMgc2hvdWxkbid0IGNyYXNoIFJlYWN0LCBubyBtYXR0ZXIgd2hhdC5cbiAgICAvLyBXZSBzaG91bGQgc3RpbGwgcmVwb3J0IGluIGNhc2Ugd2UgYnJlYWsgdGhpcyBjb2RlLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBEQ0UgY2hlY2sgc2hvdWxkIGhhcHBlbiBiZWZvcmUgUmVhY3RET00gYnVuZGxlIGV4ZWN1dGVzIHNvIHRoYXRcbiAgLy8gRGV2VG9vbHMgY2FuIHJlcG9ydCBiYWQgbWluaWZpY2F0aW9uIGR1cmluZyBpbmplY3Rpb24uXG4gIGNoZWNrRENFKCk7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///935\n")},921:(__unused_webpack_module,exports)=>{"use strict";eval('/** @license React v16.13.1\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?\nSymbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;\nfunction z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;exports.Fragment=e;exports.Lazy=t;exports.Memo=r;exports.Portal=d;\nexports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;exports.isAsyncMode=function(a){return A(a)||z(a)===l};exports.isConcurrentMode=A;exports.isContextConsumer=function(a){return z(a)===k};exports.isContextProvider=function(a){return z(a)===h};exports.isElement=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return z(a)===n};exports.isFragment=function(a){return z(a)===e};exports.isLazy=function(a){return z(a)===t};\nexports.isMemo=function(a){return z(a)===r};exports.isPortal=function(a){return z(a)===d};exports.isProfiler=function(a){return z(a)===g};exports.isStrictMode=function(a){return z(a)===f};exports.isSuspense=function(a){return z(a)===p};\nexports.isValidElementType=function(a){return"string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};exports.typeOf=z;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTIxLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYjtBQUNBLGNBQWMsa0NBQWtDLGlCQUFpQixVQUFVLDBCQUEwQixtREFBbUQsa0NBQWtDLDRDQUE0QyxrQkFBa0Isa0JBQWtCLGNBQWMsZ0JBQWdCLGlCQUFpQixHQUFHLHNCQUFzQixHQUFHLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLGVBQWUsR0FBRyxrQkFBa0IsR0FBRyxnQkFBZ0IsR0FBRyxZQUFZLEdBQUcsWUFBWSxHQUFHLGNBQWM7QUFDL2UsZ0JBQWdCLEdBQUcsa0JBQWtCLEdBQUcsZ0JBQWdCLEdBQUcsbUJBQW1CLGFBQWEsdUJBQXVCLHdCQUF3QixHQUFHLHlCQUF5QixhQUFhLGlCQUFpQix5QkFBeUIsYUFBYSxpQkFBaUIsaUJBQWlCLGFBQWEscURBQXFELG9CQUFvQixhQUFhLGlCQUFpQixrQkFBa0IsYUFBYSxpQkFBaUIsY0FBYyxhQUFhO0FBQzNjLGNBQWMsYUFBYSxpQkFBaUIsZ0JBQWdCLGFBQWEsaUJBQWlCLGtCQUFrQixhQUFhLGlCQUFpQixvQkFBb0IsYUFBYSxpQkFBaUIsa0JBQWtCLGFBQWE7QUFDM04sMEJBQTBCLGFBQWEsNlFBQTZRLGNBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanM/YTkzZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEzLjFcbiAqIHJlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO3ZhciBiPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5mb3IsYz1iP1N5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpOjYwMTAzLGQ9Yj9TeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpOjYwMTA2LGU9Yj9TeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIik6NjAxMDcsZj1iP1N5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKTo2MDEwOCxnPWI/U3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpOjYwMTE0LGg9Yj9TeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIik6NjAxMDksaz1iP1N5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpOjYwMTEwLGw9Yj9TeW1ib2wuZm9yKFwicmVhY3QuYXN5bmNfbW9kZVwiKTo2MDExMSxtPWI/U3ltYm9sLmZvcihcInJlYWN0LmNvbmN1cnJlbnRfbW9kZVwiKTo2MDExMSxuPWI/U3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpOjYwMTEyLHA9Yj9TeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIik6NjAxMTMscT1iP1xuU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIik6NjAxMjAscj1iP1N5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpOjYwMTE1LHQ9Yj9TeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKTo2MDExNix2PWI/U3ltYm9sLmZvcihcInJlYWN0LmJsb2NrXCIpOjYwMTIxLHc9Yj9TeW1ib2wuZm9yKFwicmVhY3QuZnVuZGFtZW50YWxcIik6NjAxMTcseD1iP1N5bWJvbC5mb3IoXCJyZWFjdC5yZXNwb25kZXJcIik6NjAxMTgseT1iP1N5bWJvbC5mb3IoXCJyZWFjdC5zY29wZVwiKTo2MDExOTtcbmZ1bmN0aW9uIHooYSl7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBhJiZudWxsIT09YSl7dmFyIHU9YS4kJHR5cGVvZjtzd2l0Y2godSl7Y2FzZSBjOnN3aXRjaChhPWEudHlwZSxhKXtjYXNlIGw6Y2FzZSBtOmNhc2UgZTpjYXNlIGc6Y2FzZSBmOmNhc2UgcDpyZXR1cm4gYTtkZWZhdWx0OnN3aXRjaChhPWEmJmEuJCR0eXBlb2YsYSl7Y2FzZSBrOmNhc2UgbjpjYXNlIHQ6Y2FzZSByOmNhc2UgaDpyZXR1cm4gYTtkZWZhdWx0OnJldHVybiB1fX1jYXNlIGQ6cmV0dXJuIHV9fX1mdW5jdGlvbiBBKGEpe3JldHVybiB6KGEpPT09bX1leHBvcnRzLkFzeW5jTW9kZT1sO2V4cG9ydHMuQ29uY3VycmVudE1vZGU9bTtleHBvcnRzLkNvbnRleHRDb25zdW1lcj1rO2V4cG9ydHMuQ29udGV4dFByb3ZpZGVyPWg7ZXhwb3J0cy5FbGVtZW50PWM7ZXhwb3J0cy5Gb3J3YXJkUmVmPW47ZXhwb3J0cy5GcmFnbWVudD1lO2V4cG9ydHMuTGF6eT10O2V4cG9ydHMuTWVtbz1yO2V4cG9ydHMuUG9ydGFsPWQ7XG5leHBvcnRzLlByb2ZpbGVyPWc7ZXhwb3J0cy5TdHJpY3RNb2RlPWY7ZXhwb3J0cy5TdXNwZW5zZT1wO2V4cG9ydHMuaXNBc3luY01vZGU9ZnVuY3Rpb24oYSl7cmV0dXJuIEEoYSl8fHooYSk9PT1sfTtleHBvcnRzLmlzQ29uY3VycmVudE1vZGU9QTtleHBvcnRzLmlzQ29udGV4dENvbnN1bWVyPWZ1bmN0aW9uKGEpe3JldHVybiB6KGEpPT09a307ZXhwb3J0cy5pc0NvbnRleHRQcm92aWRlcj1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PWh9O2V4cG9ydHMuaXNFbGVtZW50PWZ1bmN0aW9uKGEpe3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEmJmEuJCR0eXBlb2Y9PT1jfTtleHBvcnRzLmlzRm9yd2FyZFJlZj1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PW59O2V4cG9ydHMuaXNGcmFnbWVudD1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PWV9O2V4cG9ydHMuaXNMYXp5PWZ1bmN0aW9uKGEpe3JldHVybiB6KGEpPT09dH07XG5leHBvcnRzLmlzTWVtbz1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PXJ9O2V4cG9ydHMuaXNQb3J0YWw9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1kfTtleHBvcnRzLmlzUHJvZmlsZXI9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1nfTtleHBvcnRzLmlzU3RyaWN0TW9kZT1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PWZ9O2V4cG9ydHMuaXNTdXNwZW5zZT1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PXB9O1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGU9ZnVuY3Rpb24oYSl7cmV0dXJuXCJzdHJpbmdcIj09PXR5cGVvZiBhfHxcImZ1bmN0aW9uXCI9PT10eXBlb2YgYXx8YT09PWV8fGE9PT1tfHxhPT09Z3x8YT09PWZ8fGE9PT1wfHxhPT09cXx8XCJvYmplY3RcIj09PXR5cGVvZiBhJiZudWxsIT09YSYmKGEuJCR0eXBlb2Y9PT10fHxhLiQkdHlwZW9mPT09cnx8YS4kJHR5cGVvZj09PWh8fGEuJCR0eXBlb2Y9PT1rfHxhLiQkdHlwZW9mPT09bnx8YS4kJHR5cGVvZj09PXd8fGEuJCR0eXBlb2Y9PT14fHxhLiQkdHlwZW9mPT09eXx8YS4kJHR5cGVvZj09PXYpfTtleHBvcnRzLnR5cGVPZj16O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///921\n')},864:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(921);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODY0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx5Q0FBNEQ7QUFDOUQsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcz80Y2VjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///864\n")},511:(__unused_webpack_module,exports)=>{"use strict";eval("var __webpack_unused_export__;\n/**\n * @license React\n * react-reconciler-constants.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexports.ConcurrentRoot=1;__webpack_unused_export__=4;exports.DefaultEventPriority=16;__webpack_unused_export__=1;__webpack_unused_export__=536870912;__webpack_unused_export__=0;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTExLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYSxzQkFBc0IsR0FBRyx5QkFBK0IsR0FBRyw0QkFBNEIsSUFBSSx5QkFBNkIsR0FBRyx5QkFBeUIsV0FBVyx5QkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWNvbmNpbGVyL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLWNvbnN0YW50cy5wcm9kdWN0aW9uLm1pbi5qcz84MzUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LXJlY29uY2lsZXItY29uc3RhbnRzLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztleHBvcnRzLkNvbmN1cnJlbnRSb290PTE7ZXhwb3J0cy5Db250aW51b3VzRXZlbnRQcmlvcml0eT00O2V4cG9ydHMuRGVmYXVsdEV2ZW50UHJpb3JpdHk9MTY7ZXhwb3J0cy5EaXNjcmV0ZUV2ZW50UHJpb3JpdHk9MTtleHBvcnRzLklkbGVFdmVudFByaW9yaXR5PTUzNjg3MDkxMjtleHBvcnRzLkxlZ2FjeVJvb3Q9MDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///511\n")},287:(module,__unused_webpack_exports,__webpack_require__)=>{eval('/**\n * @license React\n * react-reconciler.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nmodule.exports = function $$$reconciler($$$hostConfig) {\n    var exports = {};\n\'use strict\';var aa=__webpack_require__(294),ba=__webpack_require__(840),ca=Object.assign;function n(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}\nvar da=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,ea=Symbol.for("react.element"),fa=Symbol.for("react.portal"),ha=Symbol.for("react.fragment"),ia=Symbol.for("react.strict_mode"),ja=Symbol.for("react.profiler"),ka=Symbol.for("react.provider"),la=Symbol.for("react.context"),ma=Symbol.for("react.forward_ref"),na=Symbol.for("react.suspense"),oa=Symbol.for("react.suspense_list"),pa=Symbol.for("react.memo"),qa=Symbol.for("react.lazy");Symbol.for("react.scope");Symbol.for("react.debug_trace_mode");\nvar ra=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden");Symbol.for("react.cache");Symbol.for("react.tracing_marker");var sa=Symbol.iterator;function ta(a){if(null===a||"object"!==typeof a)return null;a=sa&&a[sa]||a["@@iterator"];return"function"===typeof a?a:null}\nfunction ua(a){if(null==a)return null;if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case ha:return"Fragment";case fa:return"Portal";case ja:return"Profiler";case ia:return"StrictMode";case na:return"Suspense";case oa:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case la:return(a.displayName||"Context")+".Consumer";case ka:return(a._context.displayName||"Context")+".Provider";case ma:var b=a.render;a=a.displayName;a||(a=b.displayName||\nb.name||"",a=""!==a?"ForwardRef("+a+")":"ForwardRef");return a;case pa:return b=a.displayName||null,null!==b?b:ua(a.type)||"Memo";case qa:b=a._payload;a=a._init;try{return ua(a(b))}catch(c){}}return null}\nfunction va(a){var b=a.type;switch(a.tag){case 24:return"Cache";case 9:return(b.displayName||"Context")+".Consumer";case 10:return(b._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return a=b.render,a=a.displayName||a.name||"",b.displayName||(""!==a?"ForwardRef("+a+")":"ForwardRef");case 7:return"Fragment";case 5:return b;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return ua(b);case 8:return b===ia?"StrictMode":"Mode";case 22:return"Offscreen";\ncase 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof b)return b.displayName||b.name||null;if("string"===typeof b)return b}return null}function wa(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.flags&4098)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function xa(a){if(wa(a)!==a)throw Error(n(188));}\nfunction ya(a){var b=a.alternate;if(!b){b=wa(a);if(null===b)throw Error(n(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return xa(e),a;if(f===d)return xa(e),b;f=f.sibling}throw Error(n(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===\nc){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(n(189));}}if(c.alternate!==d)throw Error(n(190));}if(3!==c.tag)throw Error(n(188));return c.stateNode.current===c?a:b}function Aa(a){a=ya(a);return null!==a?Ba(a):null}function Ba(a){if(5===a.tag||6===a.tag)return a;for(a=a.child;null!==a;){var b=Ba(a);if(null!==b)return b;a=a.sibling}return null}\nfunction Ca(a){if(5===a.tag||6===a.tag)return a;for(a=a.child;null!==a;){if(4!==a.tag){var b=Ca(a);if(null!==b)return b}a=a.sibling}return null}\nvar Da=Array.isArray,Ea=$$$hostConfig.getPublicInstance,Fa=$$$hostConfig.getRootHostContext,Ga=$$$hostConfig.getChildHostContext,Ha=$$$hostConfig.prepareForCommit,Ia=$$$hostConfig.resetAfterCommit,Ja=$$$hostConfig.createInstance,Ka=$$$hostConfig.appendInitialChild,La=$$$hostConfig.finalizeInitialChildren,Ma=$$$hostConfig.prepareUpdate,Na=$$$hostConfig.shouldSetTextContent,Oa=$$$hostConfig.createTextInstance,Pa=$$$hostConfig.scheduleTimeout,Qa=$$$hostConfig.cancelTimeout,Ra=$$$hostConfig.noTimeout,\nSa=$$$hostConfig.isPrimaryRenderer,Ta=$$$hostConfig.supportsMutation,Ua=$$$hostConfig.supportsPersistence,Va=$$$hostConfig.supportsHydration,Wa=$$$hostConfig.getInstanceFromNode,Xa=$$$hostConfig.preparePortalMount,Ya=$$$hostConfig.getCurrentEventPriority,Za=$$$hostConfig.detachDeletedInstance,$a=$$$hostConfig.supportsMicrotasks,ab=$$$hostConfig.scheduleMicrotask,bb=$$$hostConfig.supportsTestSelectors,cb=$$$hostConfig.findFiberRoot,db=$$$hostConfig.getBoundingRect,eb=$$$hostConfig.getTextContent,fb=\n$$$hostConfig.isHiddenSubtree,gb=$$$hostConfig.matchAccessibilityRole,hb=$$$hostConfig.setFocusIfFocusable,ib=$$$hostConfig.setupIntersectionObserver,jb=$$$hostConfig.appendChild,kb=$$$hostConfig.appendChildToContainer,lb=$$$hostConfig.commitTextUpdate,mb=$$$hostConfig.commitMount,nb=$$$hostConfig.commitUpdate,ob=$$$hostConfig.insertBefore,pb=$$$hostConfig.insertInContainerBefore,qb=$$$hostConfig.removeChild,rb=$$$hostConfig.removeChildFromContainer,sb=$$$hostConfig.resetTextContent,tb=$$$hostConfig.hideInstance,\nub=$$$hostConfig.hideTextInstance,vb=$$$hostConfig.unhideInstance,wb=$$$hostConfig.unhideTextInstance,xb=$$$hostConfig.clearContainer,yb=$$$hostConfig.cloneInstance,zb=$$$hostConfig.createContainerChildSet,Ab=$$$hostConfig.appendChildToContainerChildSet,Bb=$$$hostConfig.finalizeContainerChildren,Cb=$$$hostConfig.replaceContainerChildren,Eb=$$$hostConfig.cloneHiddenInstance,Fb=$$$hostConfig.cloneHiddenTextInstance,Gb=$$$hostConfig.canHydrateInstance,Hb=$$$hostConfig.canHydrateTextInstance,Ib=$$$hostConfig.canHydrateSuspenseInstance,\nJb=$$$hostConfig.isSuspenseInstancePending,Kb=$$$hostConfig.isSuspenseInstanceFallback,Lb=$$$hostConfig.registerSuspenseInstanceRetry,Mb=$$$hostConfig.getNextHydratableSibling,Nb=$$$hostConfig.getFirstHydratableChild,Ob=$$$hostConfig.getFirstHydratableChildWithinContainer,Pb=$$$hostConfig.getFirstHydratableChildWithinSuspenseInstance,Qb=$$$hostConfig.hydrateInstance,Rb=$$$hostConfig.hydrateTextInstance,Sb=$$$hostConfig.hydrateSuspenseInstance,Tb=$$$hostConfig.getNextHydratableInstanceAfterSuspenseInstance,\nUb=$$$hostConfig.commitHydratedContainer,Vb=$$$hostConfig.commitHydratedSuspenseInstance,Wb=$$$hostConfig.clearSuspenseBoundary,Xb=$$$hostConfig.clearSuspenseBoundaryFromContainer,Yb=$$$hostConfig.shouldDeleteUnhydratedTailInstances,Zb=$$$hostConfig.didNotMatchHydratedContainerTextInstance,$b=$$$hostConfig.didNotMatchHydratedTextInstance,ac;function bc(a){if(void 0===ac)try{throw Error();}catch(c){var b=c.stack.trim().match(/\\n( *(at )?)/);ac=b&&b[1]||""}return"\\n"+ac+a}var cc=!1;\nfunction dc(a,b){if(!a||cc)return"";cc=!0;var c=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(b)if(b=function(){throw Error();},Object.defineProperty(b.prototype,"props",{set:function(){throw Error();}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(b,[])}catch(l){var d=l}Reflect.construct(a,[],b)}else{try{b.call()}catch(l){d=l}a.call(b.prototype)}else{try{throw Error();}catch(l){d=l}a()}}catch(l){if(l&&d&&"string"===typeof l.stack){for(var e=l.stack.split("\\n"),\nf=d.stack.split("\\n"),g=e.length-1,h=f.length-1;1<=g&&0<=h&&e[g]!==f[h];)h--;for(;1<=g&&0<=h;g--,h--)if(e[g]!==f[h]){if(1!==g||1!==h){do if(g--,h--,0>h||e[g]!==f[h]){var k="\\n"+e[g].replace(" at new "," at ");a.displayName&&k.includes("<anonymous>")&&(k=k.replace("<anonymous>",a.displayName));return k}while(1<=g&&0<=h)}break}}}finally{cc=!1,Error.prepareStackTrace=c}return(a=a?a.displayName||a.name:"")?bc(a):""}var ec=Object.prototype.hasOwnProperty,fc=[],gc=-1;function hc(a){return{current:a}}\nfunction p(a){0>gc||(a.current=fc[gc],fc[gc]=null,gc--)}function v(a,b){gc++;fc[gc]=a.current;a.current=b}var ic={},x=hc(ic),z=hc(!1),jc=ic;function kc(a,b){var c=a.type.contextTypes;if(!c)return ic;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}\nfunction A(a){a=a.childContextTypes;return null!==a&&void 0!==a}function lc(){p(z);p(x)}function mc(a,b,c){if(x.current!==ic)throw Error(n(168));v(x,b);v(z,c)}function nc(a,b,c){var d=a.stateNode;b=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in b))throw Error(n(108,va(a)||"Unknown",e));return ca({},c,d)}\nfunction pc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||ic;jc=x.current;v(x,a);v(z,z.current);return!0}function qc(a,b,c){var d=a.stateNode;if(!d)throw Error(n(169));c?(a=nc(a,b,jc),d.__reactInternalMemoizedMergedChildContext=a,p(z),p(x),v(x,a)):p(z);v(z,c)}var sc=Math.clz32?Math.clz32:rc,tc=Math.log,uc=Math.LN2;function rc(a){a>>>=0;return 0===a?32:31-(tc(a)/uc|0)|0}var vc=64,wc=4194304;\nfunction xc(a){switch(a&-a){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return a&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return a&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;\ndefault:return a}}function yc(a,b){var c=a.pendingLanes;if(0===c)return 0;var d=0,e=a.suspendedLanes,f=a.pingedLanes,g=c&268435455;if(0!==g){var h=g&~e;0!==h?d=xc(h):(f&=g,0!==f&&(d=xc(f)))}else g=c&~e,0!==g?d=xc(g):0!==f&&(d=xc(f));if(0===d)return 0;if(0!==b&&b!==d&&0===(b&e)&&(e=d&-d,f=b&-b,e>=f||16===e&&0!==(f&4194240)))return b;0!==(d&4)&&(d|=c&16);b=a.entangledLanes;if(0!==b)for(a=a.entanglements,b&=d;0<b;)c=31-sc(b),e=1<<c,d|=a[c],b&=~e;return d}\nfunction zc(a,b){switch(a){case 1:case 2:case 4:return b+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return b+5E3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}\nfunction Ac(a,b){for(var c=a.suspendedLanes,d=a.pingedLanes,e=a.expirationTimes,f=a.pendingLanes;0<f;){var g=31-sc(f),h=1<<g,k=e[g];if(-1===k){if(0===(h&c)||0!==(h&d))e[g]=zc(h,b)}else k<=b&&(a.expiredLanes|=h);f&=~h}}function Bc(a){a=a.pendingLanes&-1073741825;return 0!==a?a:a&1073741824?1073741824:0}function Cc(){var a=vc;vc<<=1;0===(vc&4194240)&&(vc=64);return a}function Dc(a){for(var b=[],c=0;31>c;c++)b.push(a);return b}\nfunction Ec(a,b,c){a.pendingLanes|=b;536870912!==b&&(a.suspendedLanes=0,a.pingedLanes=0);a=a.eventTimes;b=31-sc(b);a[b]=c}function Fc(a,b){var c=a.pendingLanes&~b;a.pendingLanes=b;a.suspendedLanes=0;a.pingedLanes=0;a.expiredLanes&=b;a.mutableReadLanes&=b;a.entangledLanes&=b;b=a.entanglements;var d=a.eventTimes;for(a=a.expirationTimes;0<c;){var e=31-sc(c),f=1<<e;b[e]=0;d[e]=-1;a[e]=-1;c&=~f}}\nfunction Gc(a,b){var c=a.entangledLanes|=b;for(a=a.entanglements;c;){var d=31-sc(c),e=1<<d;e&b|a[d]&b&&(a[d]|=b);c&=~e}}var C=0;function Hc(a){a&=-a;return 1<a?4<a?0!==(a&268435455)?16:536870912:4:1}var Ic=ba.unstable_scheduleCallback,Jc=ba.unstable_cancelCallback,Kc=ba.unstable_shouldYield,Lc=ba.unstable_requestPaint,D=ba.unstable_now,Mc=ba.unstable_ImmediatePriority,Nc=ba.unstable_UserBlockingPriority,Oc=ba.unstable_NormalPriority,Pc=ba.unstable_IdlePriority,Qc=null,Rc=null;\nfunction Sc(a){if(Rc&&"function"===typeof Rc.onCommitFiberRoot)try{Rc.onCommitFiberRoot(Qc,a,void 0,128===(a.current.flags&128))}catch(b){}}function Tc(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var Uc="function"===typeof Object.is?Object.is:Tc,Vc=null,Wc=!1,Xc=!1;function Yc(a){null===Vc?Vc=[a]:Vc.push(a)}function Zc(a){Wc=!0;Yc(a)}\nfunction $c(){if(!Xc&&null!==Vc){Xc=!0;var a=0,b=C;try{var c=Vc;for(C=1;a<c.length;a++){var d=c[a];do d=d(!0);while(null!==d)}Vc=null;Wc=!1}catch(e){throw null!==Vc&&(Vc=Vc.slice(a+1)),Ic(Mc,$c),e;}finally{C=b,Xc=!1}}return null}var ad=da.ReactCurrentBatchConfig;\nfunction bd(a,b){if(Uc(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++){var e=c[d];if(!ec.call(b,e)||!Uc(a[e],b[e]))return!1}return!0}\nfunction cd(a){switch(a.tag){case 5:return bc(a.type);case 16:return bc("Lazy");case 13:return bc("Suspense");case 19:return bc("SuspenseList");case 0:case 2:case 15:return a=dc(a.type,!1),a;case 11:return a=dc(a.type.render,!1),a;case 1:return a=dc(a.type,!0),a;default:return""}}function dd(a,b){if(a&&a.defaultProps){b=ca({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c]);return b}return b}var ed=hc(null),fd=null,gd=null,hd=null;function id(){hd=gd=fd=null}\nfunction jd(a,b,c){Sa?(v(ed,b._currentValue),b._currentValue=c):(v(ed,b._currentValue2),b._currentValue2=c)}function kd(a){var b=ed.current;p(ed);Sa?a._currentValue=b:a._currentValue2=b}function ld(a,b,c){for(;null!==a;){var d=a.alternate;(a.childLanes&b)!==b?(a.childLanes|=b,null!==d&&(d.childLanes|=b)):null!==d&&(d.childLanes&b)!==b&&(d.childLanes|=b);if(a===c)break;a=a.return}}\nfunction md(a,b){fd=a;hd=gd=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(0!==(a.lanes&b)&&(F=!0),a.firstContext=null)}function nd(a){var b=Sa?a._currentValue:a._currentValue2;if(hd!==a)if(a={context:a,memoizedValue:b,next:null},null===gd){if(null===fd)throw Error(n(308));gd=a;fd.dependencies={lanes:0,firstContext:a}}else gd=gd.next=a;return b}var od=null,pd=!1;\nfunction qd(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function rd(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,effects:a.effects})}function sd(a,b){return{eventTime:a,lane:b,tag:0,payload:null,callback:null,next:null}}\nfunction td(a,b){var c=a.updateQueue;null!==c&&(c=c.shared,ud(a)?(a=c.interleaved,null===a?(b.next=b,null===od?od=[c]:od.push(c)):(b.next=a.next,a.next=b),c.interleaved=b):(a=c.pending,null===a?b.next=b:(b.next=a.next,a.next=b),c.pending=b))}function vd(a,b,c){b=b.updateQueue;if(null!==b&&(b=b.shared,0!==(c&4194240))){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;Gc(a,c)}}\nfunction wd(a,b){var c=a.updateQueue,d=a.alternate;if(null!==d&&(d=d.updateQueue,c===d)){var e=null,f=null;c=c.firstBaseUpdate;if(null!==c){do{var g={eventTime:c.eventTime,lane:c.lane,tag:c.tag,payload:c.payload,callback:c.callback,next:null};null===f?e=f=g:f=f.next=g;c=c.next}while(null!==c);null===f?e=f=b:f=f.next=b}else e=f=b;c={baseState:d.baseState,firstBaseUpdate:e,lastBaseUpdate:f,shared:d.shared,effects:d.effects};a.updateQueue=c;return}a=c.lastBaseUpdate;null===a?c.firstBaseUpdate=b:a.next=\nb;c.lastBaseUpdate=b}\nfunction xd(a,b,c,d){var e=a.updateQueue;pd=!1;var f=e.firstBaseUpdate,g=e.lastBaseUpdate,h=e.shared.pending;if(null!==h){e.shared.pending=null;var k=h,l=k.next;k.next=null;null===g?f=l:g.next=l;g=k;var m=a.alternate;null!==m&&(m=m.updateQueue,h=m.lastBaseUpdate,h!==g&&(null===h?m.firstBaseUpdate=l:h.next=l,m.lastBaseUpdate=k))}if(null!==f){var r=e.baseState;g=0;m=l=k=null;h=f;do{var q=h.lane,B=h.eventTime;if((d&q)===q){null!==m&&(m=m.next={eventTime:B,lane:0,tag:h.tag,payload:h.payload,callback:h.callback,\nnext:null});a:{var w=a,Z=h;q=b;B=c;switch(Z.tag){case 1:w=Z.payload;if("function"===typeof w){r=w.call(B,r,q);break a}r=w;break a;case 3:w.flags=w.flags&-65537|128;case 0:w=Z.payload;q="function"===typeof w?w.call(B,r,q):w;if(null===q||void 0===q)break a;r=ca({},r,q);break a;case 2:pd=!0}}null!==h.callback&&0!==h.lane&&(a.flags|=64,q=e.effects,null===q?e.effects=[h]:q.push(h))}else B={eventTime:B,lane:q,tag:h.tag,payload:h.payload,callback:h.callback,next:null},null===m?(l=m=B,k=r):m=m.next=B,g|=\nq;h=h.next;if(null===h)if(h=e.shared.pending,null===h)break;else q=h,h=q.next,q.next=null,e.lastBaseUpdate=q,e.shared.pending=null}while(1);null===m&&(k=r);e.baseState=k;e.firstBaseUpdate=l;e.lastBaseUpdate=m;b=e.shared.interleaved;if(null!==b){e=b;do g|=e.lane,e=e.next;while(e!==b)}else null===f&&(e.shared.lanes=0);yd|=g;a.lanes=g;a.memoizedState=r}}\nfunction zd(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=c;if("function"!==typeof e)throw Error(n(191,e));e.call(d)}}}var Ad=(new aa.Component).refs;function Bd(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:ca({},b,c);a.memoizedState=c;0===a.lanes&&(a.updateQueue.baseState=c)}\nvar Ed={isMounted:function(a){return(a=a._reactInternals)?wa(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternals;var d=G(),e=Cd(a),f=sd(d,e);f.payload=b;void 0!==c&&null!==c&&(f.callback=c);td(a,f);b=Dd(a,e,d);null!==b&&vd(b,a,e)},enqueueReplaceState:function(a,b,c){a=a._reactInternals;var d=G(),e=Cd(a),f=sd(d,e);f.tag=1;f.payload=b;void 0!==c&&null!==c&&(f.callback=c);td(a,f);b=Dd(a,e,d);null!==b&&vd(b,a,e)},enqueueForceUpdate:function(a,b){a=a._reactInternals;var c=G(),d=Cd(a),e=sd(c,\nd);e.tag=2;void 0!==b&&null!==b&&(e.callback=b);td(a,e);b=Dd(a,d,c);null!==b&&vd(b,a,d)}};function Fd(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!bd(c,d)||!bd(e,f):!0}\nfunction Gd(a,b,c){var d=!1,e=ic;var f=b.contextType;"object"===typeof f&&null!==f?f=nd(f):(e=A(b)?jc:x.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?kc(a,e):ic);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Ed;a.stateNode=b;b._reactInternals=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}\nfunction Hd(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Ed.enqueueReplaceState(b,b.state,null)}\nfunction Id(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=Ad;qd(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=nd(f):(f=A(b)?jc:x.current,e.context=kc(a,f));e.state=a.memoizedState;f=b.getDerivedStateFromProps;"function"===typeof f&&(Bd(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,\n"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Ed.enqueueReplaceState(e,e.state,null),xd(a,c,e,d),e.state=a.memoizedState);"function"===typeof e.componentDidMount&&(a.flags|=4194308)}var Jd=[],Kd=0,Ld=null,Md=0,Nd=[],Od=0,Pd=null,Qd=1,Rd="";function Sd(a,b){Jd[Kd++]=Md;Jd[Kd++]=Ld;Ld=a;Md=b}\nfunction Td(a,b,c){Nd[Od++]=Qd;Nd[Od++]=Rd;Nd[Od++]=Pd;Pd=a;var d=Qd;a=Rd;var e=32-sc(d)-1;d&=~(1<<e);c+=1;var f=32-sc(b)+e;if(30<f){var g=e-e%5;f=(d&(1<<g)-1).toString(32);d>>=g;e-=g;Qd=1<<32-sc(b)+e|c<<e|d;Rd=f+a}else Qd=1<<f|c<<e|d,Rd=a}function Ud(a){null!==a.return&&(Sd(a,1),Td(a,1,0))}function Vd(a){for(;a===Ld;)Ld=Jd[--Kd],Jd[Kd]=null,Md=Jd[--Kd],Jd[Kd]=null;for(;a===Pd;)Pd=Nd[--Od],Nd[Od]=null,Rd=Nd[--Od],Nd[Od]=null,Qd=Nd[--Od],Nd[Od]=null}var Wd=null,Xd=null,H=!1,Yd=!1,Zd=null;\nfunction $d(a,b){var c=ae(5,null,null,0);c.elementType="DELETED";c.stateNode=b;c.return=a;b=a.deletions;null===b?(a.deletions=[c],a.flags|=16):b.push(c)}\nfunction be(a,b){switch(a.tag){case 5:return b=Gb(b,a.type,a.pendingProps),null!==b?(a.stateNode=b,Wd=a,Xd=Nb(b),!0):!1;case 6:return b=Hb(b,a.pendingProps),null!==b?(a.stateNode=b,Wd=a,Xd=null,!0):!1;case 13:b=Ib(b);if(null!==b){var c=null!==Pd?{id:Qd,overflow:Rd}:null;a.memoizedState={dehydrated:b,treeContext:c,retryLane:1073741824};c=ae(18,null,null,0);c.stateNode=b;c.return=a;a.child=c;Wd=a;Xd=null;return!0}return!1;default:return!1}}function ce(a){return 0!==(a.mode&1)&&0===(a.flags&128)}\nfunction de(a){if(H){var b=Xd;if(b){var c=b;if(!be(a,b)){if(ce(a))throw Error(n(418));b=Mb(c);var d=Wd;b&&be(a,b)?$d(d,c):(a.flags=a.flags&-4097|2,H=!1,Wd=a)}}else{if(ce(a))throw Error(n(418));a.flags=a.flags&-4097|2;H=!1;Wd=a}}}function ee(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;Wd=a}\nfunction fe(a){if(!Va||a!==Wd)return!1;if(!H)return ee(a),H=!0,!1;if(3!==a.tag&&(5!==a.tag||Yb(a.type)&&!Na(a.type,a.memoizedProps))){var b=Xd;if(b){if(ce(a)){for(a=Xd;a;)a=Mb(a);throw Error(n(418));}for(;b;)$d(a,b),b=Mb(b)}}ee(a);if(13===a.tag){if(!Va)throw Error(n(316));a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(n(317));Xd=Tb(a)}else Xd=Wd?Mb(a.stateNode):null;return!0}function ge(){Va&&(Xd=Wd=null,Yd=H=!1)}function he(a){null===Zd?Zd=[a]:Zd.push(a)}\nfunction ie(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(n(309));var d=c.stateNode}if(!d)throw Error(n(147,a));var e=d,f=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===f)return b.ref;b=function(a){var b=e.refs;b===Ad&&(b=e.refs={});null===a?delete b[f]:b[f]=a};b._stringRef=f;return b}if("string"!==typeof a)throw Error(n(284));if(!c._owner)throw Error(n(290,a));}return a}\nfunction je(a,b){a=Object.prototype.toString.call(b);throw Error(n(31,"[object Object]"===a?"object with keys {"+Object.keys(b).join(", ")+"}":a));}function ke(a){var b=a._init;return b(a._payload)}\nfunction le(a){function b(b,c){if(a){var d=b.deletions;null===d?(b.deletions=[c],b.flags|=16):d.push(c)}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b){a=me(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return b.flags|=1048576,c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.flags|=2,c):d;b.flags|=2;return c}function g(b){a&&\nnull===b.alternate&&(b.flags|=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=ne(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function k(a,b,c,d){var f=c.type;if(f===ha)return m(a,b,c.props.children,d,c.key);if(null!==b&&(b.elementType===f||"object"===typeof f&&null!==f&&f.$$typeof===qa&&ke(f)===b.type))return d=e(b,c.props),d.ref=ie(a,b,c),d.return=a,d;d=oe(c.type,c.key,c.props,null,a.mode,d);d.ref=ie(a,b,c);d.return=a;return d}function l(a,b,c,d){if(null===b||4!==b.tag||\nb.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=pe(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function m(a,b,c,d,f){if(null===b||7!==b.tag)return b=qe(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function r(a,b,c){if("string"===typeof b&&""!==b||"number"===typeof b)return b=ne(""+b,a.mode,c),b.return=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case ea:return c=oe(b.type,b.key,b.props,null,a.mode,c),\nc.ref=ie(a,null,b),c.return=a,c;case fa:return b=pe(b,a.mode,c),b.return=a,b;case qa:var d=b._init;return r(a,d(b._payload),c)}if(Da(b)||ta(b))return b=qe(b,a.mode,c,null),b.return=a,b;je(a,b)}return null}function q(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c&&""!==c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case ea:return c.key===e?k(a,b,c,d):null;case fa:return c.key===e?l(a,b,c,d):null;case qa:return e=c._init,q(a,\nb,e(c._payload),d)}if(Da(c)||ta(c))return null!==e?null:m(a,b,c,d,null);je(a,c)}return null}function B(a,b,c,d,e){if("string"===typeof d&&""!==d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case ea:return a=a.get(null===d.key?c:d.key)||null,k(b,a,d,e);case fa:return a=a.get(null===d.key?c:d.key)||null,l(b,a,d,e);case qa:var f=d._init;return B(a,b,c,f(d._payload),e)}if(Da(d)||ta(d))return a=a.get(c)||null,m(b,a,d,e,null);je(b,d)}return null}\nfunction w(e,g,h,k){for(var l=null,m=null,u=g,t=g=0,E=null;null!==u&&t<h.length;t++){u.index>t?(E=u,u=null):E=u.sibling;var y=q(e,u,h[t],k);if(null===y){null===u&&(u=E);break}a&&u&&null===y.alternate&&b(e,u);g=f(y,g,t);null===m?l=y:m.sibling=y;m=y;u=E}if(t===h.length)return c(e,u),H&&Sd(e,t),l;if(null===u){for(;t<h.length;t++)u=r(e,h[t],k),null!==u&&(g=f(u,g,t),null===m?l=u:m.sibling=u,m=u);H&&Sd(e,t);return l}for(u=d(e,u);t<h.length;t++)E=B(u,e,t,h[t],k),null!==E&&(a&&null!==E.alternate&&u.delete(null===\nE.key?t:E.key),g=f(E,g,t),null===m?l=E:m.sibling=E,m=E);a&&u.forEach(function(a){return b(e,a)});H&&Sd(e,t);return l}function Z(e,g,h,k){var l=ta(h);if("function"!==typeof l)throw Error(n(150));h=l.call(h);if(null==h)throw Error(n(151));for(var u=l=null,m=g,t=g=0,E=null,y=h.next();null!==m&&!y.done;t++,y=h.next()){m.index>t?(E=m,m=null):E=m.sibling;var w=q(e,m,y.value,k);if(null===w){null===m&&(m=E);break}a&&m&&null===w.alternate&&b(e,m);g=f(w,g,t);null===u?l=w:u.sibling=w;u=w;m=E}if(y.done)return c(e,\nm),H&&Sd(e,t),l;if(null===m){for(;!y.done;t++,y=h.next())y=r(e,y.value,k),null!==y&&(g=f(y,g,t),null===u?l=y:u.sibling=y,u=y);H&&Sd(e,t);return l}for(m=d(e,m);!y.done;t++,y=h.next())y=B(m,e,t,y.value,k),null!==y&&(a&&null!==y.alternate&&m.delete(null===y.key?t:y.key),g=f(y,g,t),null===u?l=y:u.sibling=y,u=y);a&&m.forEach(function(a){return b(e,a)});H&&Sd(e,t);return l}function za(a,d,f,h){"object"===typeof f&&null!==f&&f.type===ha&&null===f.key&&(f=f.props.children);if("object"===typeof f&&null!==\nf){switch(f.$$typeof){case ea:a:{for(var k=f.key,l=d;null!==l;){if(l.key===k){k=f.type;if(k===ha){if(7===l.tag){c(a,l.sibling);d=e(l,f.props.children);d.return=a;a=d;break a}}else if(l.elementType===k||"object"===typeof k&&null!==k&&k.$$typeof===qa&&ke(k)===l.type){c(a,l.sibling);d=e(l,f.props);d.ref=ie(a,l,f);d.return=a;a=d;break a}c(a,l);break}else b(a,l);l=l.sibling}f.type===ha?(d=qe(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=oe(f.type,f.key,f.props,null,a.mode,h),h.ref=ie(a,d,f),h.return=\na,a=h)}return g(a);case fa:a:{for(l=f.key;null!==d;){if(d.key===l)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=pe(f,a.mode,h);d.return=a;a=d}return g(a);case qa:return l=f._init,za(a,d,l(f._payload),h)}if(Da(f))return w(a,d,f,h);if(ta(f))return Z(a,d,f,h);je(a,f)}return"string"===typeof f&&""!==f||"number"===typeof f?(f=""+f,null!==d&&\n6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=ne(f,a.mode,h),d.return=a,a=d),g(a)):c(a,d)}return za}var re=le(!0),se=le(!1),te={},ue=hc(te),ve=hc(te),we=hc(te);function xe(a){if(a===te)throw Error(n(174));return a}function ye(a,b){v(we,b);v(ve,a);v(ue,te);a=Fa(b);p(ue);v(ue,a)}function ze(){p(ue);p(ve);p(we)}function Ae(a){var b=xe(we.current),c=xe(ue.current);b=Ga(c,a.type,b);c!==b&&(v(ve,a),v(ue,b))}function Be(a){ve.current===a&&(p(ue),p(ve))}var I=hc(0);\nfunction Ce(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||Jb(c)||Kb(c)))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.flags&128))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}var De=[];\nfunction Ee(){for(var a=0;a<De.length;a++){var b=De[a];Sa?b._workInProgressVersionPrimary=null:b._workInProgressVersionSecondary=null}De.length=0}var Fe=da.ReactCurrentDispatcher,Ge=da.ReactCurrentBatchConfig,He=0,J=null,K=null,L=null,Ie=!1,Je=!1,Ke=0,Le=0;function M(){throw Error(n(321));}function Me(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Uc(a[c],b[c]))return!1;return!0}\nfunction Ne(a,b,c,d,e,f){He=f;J=b;b.memoizedState=null;b.updateQueue=null;b.lanes=0;Fe.current=null===a||null===a.memoizedState?Oe:Pe;a=c(d,e);if(Je){f=0;do{Je=!1;Ke=0;if(25<=f)throw Error(n(301));f+=1;L=K=null;b.updateQueue=null;Fe.current=Qe;a=c(d,e)}while(Je)}Fe.current=Re;b=null!==K&&null!==K.next;He=0;L=K=J=null;Ie=!1;if(b)throw Error(n(300));return a}function Se(){var a=0!==Ke;Ke=0;return a}\nfunction Te(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===L?J.memoizedState=L=a:L=L.next=a;return L}function Ue(){if(null===K){var a=J.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===L?J.memoizedState:L.next;if(null!==b)L=b,K=a;else{if(null===a)throw Error(n(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===L?J.memoizedState=L=a:L=L.next=a}return L}\nfunction Ve(a,b){return"function"===typeof b?b(a):b}\nfunction We(a){var b=Ue(),c=b.queue;if(null===c)throw Error(n(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){f=e.next;d=d.baseState;var h=g=null,k=null,l=f;do{var m=l.lane;if((He&m)===m)null!==k&&(k=k.next={lane:0,action:l.action,hasEagerState:l.hasEagerState,eagerState:l.eagerState,next:null}),d=l.hasEagerState?l.eagerState:a(d,l.action);else{var r={lane:m,action:l.action,hasEagerState:l.hasEagerState,\neagerState:l.eagerState,next:null};null===k?(h=k=r,g=d):k=k.next=r;J.lanes|=m;yd|=m}l=l.next}while(null!==l&&l!==f);null===k?g=d:k.next=h;Uc(d,b.memoizedState)||(F=!0);b.memoizedState=d;b.baseState=g;b.baseQueue=k;c.lastRenderedState=d}a=c.interleaved;if(null!==a){e=a;do f=e.lane,J.lanes|=f,yd|=f,e=e.next;while(e!==a)}else null===e&&(c.lanes=0);return[b.memoizedState,c.dispatch]}\nfunction Xe(a){var b=Ue(),c=b.queue;if(null===c)throw Error(n(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Uc(f,b.memoizedState)||(F=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function Ye(){}\nfunction Ze(a,b){var c=J,d=Ue(),e=b(),f=!Uc(d.memoizedState,e);f&&(d.memoizedState=e,F=!0);d=d.queue;$e(af.bind(null,c,d,a),[a]);if(d.getSnapshot!==b||f||null!==L&&L.memoizedState.tag&1){c.flags|=2048;bf(9,cf.bind(null,c,d,e,b),void 0,null);if(null===N)throw Error(n(349));0!==(He&30)||df(c,b,e)}return e}function df(a,b,c){a.flags|=16384;a={getSnapshot:b,value:c};b=J.updateQueue;null===b?(b={lastEffect:null,stores:null},J.updateQueue=b,b.stores=[a]):(c=b.stores,null===c?b.stores=[a]:c.push(a))}\nfunction cf(a,b,c,d){b.value=c;b.getSnapshot=d;ef(b)&&Dd(a,1,-1)}function af(a,b,c){return c(function(){ef(b)&&Dd(a,1,-1)})}function ef(a){var b=a.getSnapshot;a=a.value;try{var c=b();return!Uc(a,c)}catch(d){return!0}}function ff(a){var b=Te();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Ve,lastRenderedState:a};b.queue=a;a=a.dispatch=gf.bind(null,J,a);return[b.memoizedState,a]}\nfunction bf(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=J.updateQueue;null===b?(b={lastEffect:null,stores:null},J.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function hf(){return Ue().memoizedState}function jf(a,b,c,d){var e=Te();J.flags|=a;e.memoizedState=bf(1|b,c,void 0,void 0===d?null:d)}\nfunction kf(a,b,c,d){var e=Ue();d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&Me(d,g.deps)){e.memoizedState=bf(b,c,f,d);return}}J.flags|=a;e.memoizedState=bf(1|b,c,f,d)}function lf(a,b){return jf(8390656,8,a,b)}function $e(a,b){return kf(2048,8,a,b)}function mf(a,b){return kf(4,2,a,b)}function nf(a,b){return kf(4,4,a,b)}\nfunction of(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function pf(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return kf(4,4,of.bind(null,b,a),c)}function qf(){}function rf(a,b){var c=Ue();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Me(b,d[1]))return d[0];c.memoizedState=[a,b];return a}\nfunction sf(a,b){var c=Ue();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Me(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function tf(a,b,c){if(0===(He&21))return a.baseState&&(a.baseState=!1,F=!0),a.memoizedState=c;Uc(c,b)||(c=Cc(),J.lanes|=c,yd|=c,a.baseState=!0);return b}function uf(a,b){var c=C;C=0!==c&&4>c?c:4;a(!0);var d=Ge.transition;Ge.transition={};try{a(!1),b()}finally{C=c,Ge.transition=d}}function vf(){return Ue().memoizedState}\nfunction wf(a,b,c){var d=Cd(a);c={lane:d,action:c,hasEagerState:!1,eagerState:null,next:null};xf(a)?yf(b,c):(zf(a,b,c),c=G(),a=Dd(a,d,c),null!==a&&Af(a,b,d))}\nfunction gf(a,b,c){var d=Cd(a),e={lane:d,action:c,hasEagerState:!1,eagerState:null,next:null};if(xf(a))yf(b,e);else{zf(a,b,e);var f=a.alternate;if(0===a.lanes&&(null===f||0===f.lanes)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,h=f(g,c);e.hasEagerState=!0;e.eagerState=h;if(Uc(h,g))return}catch(k){}finally{}c=G();a=Dd(a,d,c);null!==a&&Af(a,b,d)}}function xf(a){var b=a.alternate;return a===J||null!==b&&b===J}\nfunction yf(a,b){Je=Ie=!0;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}function zf(a,b,c){ud(a)?(a=b.interleaved,null===a?(c.next=c,null===od?od=[b]:od.push(b)):(c.next=a.next,a.next=c),b.interleaved=c):(a=b.pending,null===a?c.next=c:(c.next=a.next,a.next=c),b.pending=c)}function Af(a,b,c){if(0!==(c&4194240)){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;Gc(a,c)}}\nvar Re={readContext:nd,useCallback:M,useContext:M,useEffect:M,useImperativeHandle:M,useInsertionEffect:M,useLayoutEffect:M,useMemo:M,useReducer:M,useRef:M,useState:M,useDebugValue:M,useDeferredValue:M,useTransition:M,useMutableSource:M,useSyncExternalStore:M,useId:M,unstable_isNewReconciler:!1},Oe={readContext:nd,useCallback:function(a,b){Te().memoizedState=[a,void 0===b?null:b];return a},useContext:nd,useEffect:lf,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return jf(4194308,\n4,of.bind(null,b,a),c)},useLayoutEffect:function(a,b){return jf(4194308,4,a,b)},useInsertionEffect:function(a,b){return jf(4,2,a,b)},useMemo:function(a,b){var c=Te();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=Te();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};d.queue=a;a=a.dispatch=wf.bind(null,J,a);return[d.memoizedState,a]},useRef:function(a){var b=\nTe();a={current:a};return b.memoizedState=a},useState:ff,useDebugValue:qf,useDeferredValue:function(a){return Te().memoizedState=a},useTransition:function(){var a=ff(!1),b=a[0];a=uf.bind(null,a[1]);Te().memoizedState=a;return[b,a]},useMutableSource:function(){},useSyncExternalStore:function(a,b,c){var d=J,e=Te();if(H){if(void 0===c)throw Error(n(407));c=c()}else{c=b();if(null===N)throw Error(n(349));0!==(He&30)||df(d,b,c)}e.memoizedState=c;var f={value:c,getSnapshot:b};e.queue=f;lf(af.bind(null,d,\nf,a),[a]);d.flags|=2048;bf(9,cf.bind(null,d,f,c,b),void 0,null);return c},useId:function(){var a=Te(),b=N.identifierPrefix;if(H){var c=Rd;var d=Qd;c=(d&~(1<<32-sc(d)-1)).toString(32)+c;b=":"+b+"R"+c;c=Ke++;0<c&&(b+="H"+c.toString(32));b+=":"}else c=Le++,b=":"+b+"r"+c.toString(32)+":";return a.memoizedState=b},unstable_isNewReconciler:!1},Pe={readContext:nd,useCallback:rf,useContext:nd,useEffect:$e,useImperativeHandle:pf,useInsertionEffect:mf,useLayoutEffect:nf,useMemo:sf,useReducer:We,useRef:hf,useState:function(){return We(Ve)},\nuseDebugValue:qf,useDeferredValue:function(a){var b=Ue();return tf(b,K.memoizedState,a)},useTransition:function(){var a=We(Ve)[0],b=Ue().memoizedState;return[a,b]},useMutableSource:Ye,useSyncExternalStore:Ze,useId:vf,unstable_isNewReconciler:!1},Qe={readContext:nd,useCallback:rf,useContext:nd,useEffect:$e,useImperativeHandle:pf,useInsertionEffect:mf,useLayoutEffect:nf,useMemo:sf,useReducer:Xe,useRef:hf,useState:function(){return Xe(Ve)},useDebugValue:qf,useDeferredValue:function(a){var b=Ue();return null===\nK?b.memoizedState=a:tf(b,K.memoizedState,a)},useTransition:function(){var a=Xe(Ve)[0],b=Ue().memoizedState;return[a,b]},useMutableSource:Ye,useSyncExternalStore:Ze,useId:vf,unstable_isNewReconciler:!1};function Bf(a,b){try{var c="",d=b;do c+=cd(d),d=d.return;while(d);var e=c}catch(f){e="\\nError generating stack: "+f.message+"\\n"+f.stack}return{value:a,source:b,stack:e}}function Cf(a,b){try{console.error(b.value)}catch(c){setTimeout(function(){throw c;})}}\nvar Df="function"===typeof WeakMap?WeakMap:Map;function Ef(a,b,c){c=sd(-1,c);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){Ff||(Ff=!0,Gf=d);Cf(a,b)};return c}\nfunction Hf(a,b,c){c=sd(-1,c);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){return d(e)};c.callback=function(){Cf(a,b)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){Cf(a,b);"function"!==typeof d&&(null===If?If=new Set([this]):If.add(this));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}\nfunction Jf(a,b,c){var d=a.pingCache;if(null===d){d=a.pingCache=new Df;var e=new Set;d.set(b,e)}else e=d.get(b),void 0===e&&(e=new Set,d.set(b,e));e.has(c)||(e.add(c),a=Kf.bind(null,a,b,c),b.then(a,a))}function Lf(a){do{var b;if(b=13===a.tag)b=a.memoizedState,b=null!==b?null!==b.dehydrated?!0:!1:!0;if(b)return a;a=a.return}while(null!==a);return null}\nfunction Mf(a,b,c,d,e){if(0===(a.mode&1))return a===b?a.flags|=65536:(a.flags|=128,c.flags|=131072,c.flags&=-52805,1===c.tag&&(null===c.alternate?c.tag=17:(b=sd(-1,1),b.tag=2,td(c,b))),c.lanes|=1),a;a.flags|=65536;a.lanes=e;return a}function Nf(a){a.flags|=4}function Of(a,b){if(null!==a&&a.child===b.child)return!0;if(0!==(b.flags&16))return!1;for(a=b.child;null!==a;){if(0!==(a.flags&12854)||0!==(a.subtreeFlags&12854))return!1;a=a.sibling}return!0}var Pf,Qf,Rf,Sf;\nif(Ta)Pf=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)Ka(a,c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}},Qf=function(){},Rf=function(a,b,c,d,e){a=a.memoizedProps;if(a!==d){var f=b.stateNode,g=xe(ue.current);c=Ma(f,c,a,d,e,g);(b.updateQueue=c)&&Nf(b)}},Sf=function(a,b,c,d){c!==d&&Nf(b)};else if(Ua){Pf=function(a,\nb,c,d){for(var e=b.child;null!==e;){if(5===e.tag){var f=e.stateNode;c&&d&&(f=Eb(f,e.type,e.memoizedProps,e));Ka(a,f)}else if(6===e.tag)f=e.stateNode,c&&d&&(f=Fb(f,e.memoizedProps,e)),Ka(a,f);else if(4!==e.tag)if(22===e.tag&&null!==e.memoizedState)f=e.child,null!==f&&(f.return=e),Pf(a,e,!0,!0);else if(null!==e.child){e.child.return=e;e=e.child;continue}if(e===b)break;for(;null===e.sibling;){if(null===e.return||e.return===b)return;e=e.return}e.sibling.return=e.return;e=e.sibling}};var Tf=function(a,\nb,c,d){for(var e=b.child;null!==e;){if(5===e.tag){var f=e.stateNode;c&&d&&(f=Eb(f,e.type,e.memoizedProps,e));Ab(a,f)}else if(6===e.tag)f=e.stateNode,c&&d&&(f=Fb(f,e.memoizedProps,e)),Ab(a,f);else if(4!==e.tag)if(22===e.tag&&null!==e.memoizedState)f=e.child,null!==f&&(f.return=e),Tf(a,e,!0,!0);else if(null!==e.child){e.child.return=e;e=e.child;continue}if(e===b)break;for(;null===e.sibling;){if(null===e.return||e.return===b)return;e=e.return}e.sibling.return=e.return;e=e.sibling}};Qf=function(a,b){var c=\nb.stateNode;if(!Of(a,b)){a=c.containerInfo;var d=zb(a);Tf(d,b,!1,!1);c.pendingChildren=d;Nf(b);Bb(a,d)}};Rf=function(a,b,c,d,e){var f=a.stateNode,g=a.memoizedProps;if((a=Of(a,b))&&g===d)b.stateNode=f;else{var h=b.stateNode,k=xe(ue.current),l=null;g!==d&&(l=Ma(h,c,g,d,e,k));a&&null===l?b.stateNode=f:(f=yb(f,l,c,g,d,b,a,h),La(f,c,d,e,k)&&Nf(b),b.stateNode=f,a?Nf(b):Pf(f,b,!1,!1))}};Sf=function(a,b,c,d){c!==d?(a=xe(we.current),c=xe(ue.current),b.stateNode=Oa(d,a,c,b),Nf(b)):b.stateNode=a.stateNode}}else Qf=\nfunction(){},Rf=function(){},Sf=function(){};function Uf(a,b){if(!H)switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}\nfunction O(a){var b=null!==a.alternate&&a.alternate.child===a.child,c=0,d=0;if(b)for(var e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags&14680064,d|=e.flags&14680064,e.return=a,e=e.sibling;else for(e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags,d|=e.flags,e.return=a,e=e.sibling;a.subtreeFlags|=d;a.childLanes=c;return b}\nfunction Vf(a,b,c){var d=b.pendingProps;Vd(b);switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return O(b),null;case 1:return A(b.type)&&lc(),O(b),null;case 3:d=b.stateNode;ze();p(z);p(x);Ee();d.pendingContext&&(d.context=d.pendingContext,d.pendingContext=null);if(null===a||null===a.child)fe(b)?Nf(b):null===a||a.memoizedState.isDehydrated&&0===(b.flags&256)||(b.flags|=1024,null!==Zd&&(Wf(Zd),Zd=null));Qf(a,b);O(b);return null;case 5:Be(b);c=xe(we.current);var e=\nb.type;if(null!==a&&null!=b.stateNode)Rf(a,b,e,d,c),a.ref!==b.ref&&(b.flags|=512,b.flags|=2097152);else{if(!d){if(null===b.stateNode)throw Error(n(166));O(b);return null}a=xe(ue.current);if(fe(b)){if(!Va)throw Error(n(175));a=Qb(b.stateNode,b.type,b.memoizedProps,c,a,b,!Yd);b.updateQueue=a;null!==a&&Nf(b)}else{var f=Ja(e,d,c,a,b);Pf(f,b,!1,!1);b.stateNode=f;La(f,e,d,c,a)&&Nf(b)}null!==b.ref&&(b.flags|=512,b.flags|=2097152)}O(b);return null;case 6:if(a&&null!=b.stateNode)Sf(a,b,a.memoizedProps,d);\nelse{if("string"!==typeof d&&null===b.stateNode)throw Error(n(166));a=xe(we.current);c=xe(ue.current);if(fe(b)){if(!Va)throw Error(n(176));a=b.stateNode;d=b.memoizedProps;if(c=Rb(a,d,b,!Yd))if(e=Wd,null!==e)switch(e.tag){case 3:Zb(e.stateNode.containerInfo,a,d,0!==(e.mode&1));break;case 5:$b(e.type,e.memoizedProps,e.stateNode,a,d,0!==(e.mode&1))}c&&Nf(b)}else b.stateNode=Oa(d,a,c,b)}O(b);return null;case 13:p(I);d=b.memoizedState;if(H&&null!==Xd&&0!==(b.mode&1)&&0===(b.flags&128)){for(a=Xd;a;)a=Mb(a);\nge();b.flags|=98560;return b}if(null!==d&&null!==d.dehydrated){d=fe(b);if(null===a){if(!d)throw Error(n(318));if(!Va)throw Error(n(344));a=b.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(n(317));Sb(a,b)}else ge(),0===(b.flags&128)&&(b.memoizedState=null),b.flags|=4;O(b);return null}null!==Zd&&(Wf(Zd),Zd=null);if(0!==(b.flags&128))return b.lanes=c,b;d=null!==d;c=!1;null===a?fe(b):c=null!==a.memoizedState;d!==c&&d&&(b.child.flags|=8192,0!==(b.mode&1)&&(null===a||0!==(I.current&1)?0===\nP&&(P=3):Xf()));null!==b.updateQueue&&(b.flags|=4);O(b);return null;case 4:return ze(),Qf(a,b),null===a&&Xa(b.stateNode.containerInfo),O(b),null;case 10:return kd(b.type._context),O(b),null;case 17:return A(b.type)&&lc(),O(b),null;case 19:p(I);e=b.memoizedState;if(null===e)return O(b),null;d=0!==(b.flags&128);f=e.rendering;if(null===f)if(d)Uf(e,!1);else{if(0!==P||null!==a&&0!==(a.flags&128))for(a=b.child;null!==a;){f=Ce(a);if(null!==f){b.flags|=128;Uf(e,!1);a=f.updateQueue;null!==a&&(b.updateQueue=\na,b.flags|=4);b.subtreeFlags=0;a=c;for(d=b.child;null!==d;)c=d,e=a,c.flags&=14680066,f=c.alternate,null===f?(c.childLanes=0,c.lanes=e,c.child=null,c.subtreeFlags=0,c.memoizedProps=null,c.memoizedState=null,c.updateQueue=null,c.dependencies=null,c.stateNode=null):(c.childLanes=f.childLanes,c.lanes=f.lanes,c.child=f.child,c.subtreeFlags=0,c.deletions=null,c.memoizedProps=f.memoizedProps,c.memoizedState=f.memoizedState,c.updateQueue=f.updateQueue,c.type=f.type,e=f.dependencies,c.dependencies=null===\ne?null:{lanes:e.lanes,firstContext:e.firstContext}),d=d.sibling;v(I,I.current&1|2);return b.child}a=a.sibling}null!==e.tail&&D()>Yf&&(b.flags|=128,d=!0,Uf(e,!1),b.lanes=4194304)}else{if(!d)if(a=Ce(f),null!==a){if(b.flags|=128,d=!0,a=a.updateQueue,null!==a&&(b.updateQueue=a,b.flags|=4),Uf(e,!0),null===e.tail&&"hidden"===e.tailMode&&!f.alternate&&!H)return O(b),null}else 2*D()-e.renderingStartTime>Yf&&1073741824!==c&&(b.flags|=128,d=!0,Uf(e,!1),b.lanes=4194304);e.isBackwards?(f.sibling=b.child,b.child=\nf):(a=e.last,null!==a?a.sibling=f:b.child=f,e.last=f)}if(null!==e.tail)return b=e.tail,e.rendering=b,e.tail=b.sibling,e.renderingStartTime=D(),b.sibling=null,a=I.current,v(I,d?a&1|2:a&1),b;O(b);return null;case 22:case 23:return Zf(),d=null!==b.memoizedState,null!==a&&null!==a.memoizedState!==d&&(b.flags|=8192),d&&0!==(b.mode&1)?0!==($f&1073741824)&&(O(b),Ta&&b.subtreeFlags&6&&(b.flags|=8192)):O(b),null;case 24:return null;case 25:return null}throw Error(n(156,b.tag));}\nvar ag=da.ReactCurrentOwner,F=!1;function Q(a,b,c,d){b.child=null===a?se(b,null,c,d):re(b,a.child,c,d)}function bg(a,b,c,d,e){c=c.render;var f=b.ref;md(b,e);d=Ne(a,b,c,d,f,e);c=Se();if(null!==a&&!F)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,cg(a,b,e);H&&c&&Ud(b);b.flags|=1;Q(a,b,d,e);return b.child}\nfunction dg(a,b,c,d,e){if(null===a){var f=c.type;if("function"===typeof f&&!eg(f)&&void 0===f.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=f,fg(a,b,f,d,e);a=oe(c.type,null,d,b,b.mode,e);a.ref=b.ref;a.return=b;return b.child=a}f=a.child;if(0===(a.lanes&e)){var g=f.memoizedProps;c=c.compare;c=null!==c?c:bd;if(c(g,d)&&a.ref===b.ref)return cg(a,b,e)}b.flags|=1;a=me(f,d);a.ref=b.ref;a.return=b;return b.child=a}\nfunction fg(a,b,c,d,e){if(null!==a){var f=a.memoizedProps;if(bd(f,d)&&a.ref===b.ref)if(F=!1,b.pendingProps=d=f,0!==(a.lanes&e))0!==(a.flags&131072)&&(F=!0);else return b.lanes=a.lanes,cg(a,b,e)}return gg(a,b,c,d,e)}\nfunction hg(a,b,c){var d=b.pendingProps,e=d.children,f=null!==a?a.memoizedState:null;if("hidden"===d.mode)if(0===(b.mode&1))b.memoizedState={baseLanes:0,cachePool:null,transitions:null},v(ig,$f),$f|=c;else if(0!==(c&1073741824))b.memoizedState={baseLanes:0,cachePool:null,transitions:null},d=null!==f?f.baseLanes:c,v(ig,$f),$f|=d;else return a=null!==f?f.baseLanes|c:c,b.lanes=b.childLanes=1073741824,b.memoizedState={baseLanes:a,cachePool:null,transitions:null},b.updateQueue=null,v(ig,$f),$f|=a,null;\nelse null!==f?(d=f.baseLanes|c,b.memoizedState=null):d=c,v(ig,$f),$f|=d;Q(a,b,e,c);return b.child}function jg(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.flags|=512,b.flags|=2097152}function gg(a,b,c,d,e){var f=A(c)?jc:x.current;f=kc(b,f);md(b,e);c=Ne(a,b,c,d,f,e);d=Se();if(null!==a&&!F)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,cg(a,b,e);H&&d&&Ud(b);b.flags|=1;Q(a,b,c,e);return b.child}\nfunction kg(a,b,c,d,e){if(A(c)){var f=!0;pc(b)}else f=!1;md(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2),Gd(b,c,d),Id(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var k=g.context,l=c.contextType;"object"===typeof l&&null!==l?l=nd(l):(l=A(c)?jc:x.current,l=kc(b,l));var m=c.getDerivedStateFromProps,r="function"===typeof m||"function"===typeof g.getSnapshotBeforeUpdate;r||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==\ntypeof g.componentWillReceiveProps||(h!==d||k!==l)&&Hd(b,g,d,l);pd=!1;var q=b.memoizedState;g.state=q;xd(b,d,g,e);k=b.memoizedState;h!==d||q!==k||z.current||pd?("function"===typeof m&&(Bd(b,c,m,d),k=b.memoizedState),(h=pd||Fd(b,c,h,d,q,k,l))?(r||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&\n(b.flags|=4194308)):("function"===typeof g.componentDidMount&&(b.flags|=4194308),b.memoizedProps=d,b.memoizedState=k),g.props=d,g.state=k,g.context=l,d=h):("function"===typeof g.componentDidMount&&(b.flags|=4194308),d=!1)}else{g=b.stateNode;rd(a,b);h=b.memoizedProps;l=b.type===b.elementType?h:dd(b.type,h);g.props=l;r=b.pendingProps;q=g.context;k=c.contextType;"object"===typeof k&&null!==k?k=nd(k):(k=A(c)?jc:x.current,k=kc(b,k));var B=c.getDerivedStateFromProps;(m="function"===typeof B||"function"===\ntypeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==r||q!==k)&&Hd(b,g,d,k);pd=!1;q=b.memoizedState;g.state=q;xd(b,d,g,e);var w=b.memoizedState;h!==r||q!==w||z.current||pd?("function"===typeof B&&(Bd(b,c,B,d),w=b.memoizedState),(l=pd||Fd(b,c,l,d,q,w,k)||!1)?(m||"function"!==typeof g.UNSAFE_componentWillUpdate&&"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,\nw,k),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,w,k)),"function"===typeof g.componentDidUpdate&&(b.flags|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.flags|=1024)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&q===a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&q===a.memoizedState||(b.flags|=1024),b.memoizedProps=d,b.memoizedState=w),g.props=d,g.state=w,g.context=k,d=l):("function"!==\ntypeof g.componentDidUpdate||h===a.memoizedProps&&q===a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&q===a.memoizedState||(b.flags|=1024),d=!1)}return lg(a,b,c,d,f,e)}\nfunction lg(a,b,c,d,e,f){jg(a,b);var g=0!==(b.flags&128);if(!d&&!g)return e&&qc(b,c,!1),cg(a,b,f);d=b.stateNode;ag.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?null:d.render();b.flags|=1;null!==a&&g?(b.child=re(b,a.child,null,f),b.child=re(b,null,h,f)):Q(a,b,h,f);b.memoizedState=d.state;e&&qc(b,c,!0);return b.child}function mg(a){var b=a.stateNode;b.pendingContext?mc(a,b.pendingContext,b.pendingContext!==b.context):b.context&&mc(a,b.context,!1);ye(a,b.containerInfo)}\nfunction ng(a,b,c,d,e){ge();he(e);b.flags|=256;Q(a,b,c,d);return b.child}var og={dehydrated:null,treeContext:null,retryLane:0};function pg(a){return{baseLanes:a,cachePool:null,transitions:null}}function qg(a,b){return{baseLanes:a.baseLanes|b,cachePool:null,transitions:a.transitions}}\nfunction rg(a,b,c){var d=b.pendingProps,e=I.current,f=!1,g=0!==(b.flags&128),h;(h=g)||(h=null!==a&&null===a.memoizedState?!1:0!==(e&2));if(h)f=!0,b.flags&=-129;else if(null===a||null!==a.memoizedState)e|=1;v(I,e&1);if(null===a){de(b);a=b.memoizedState;if(null!==a&&(a=a.dehydrated,null!==a))return 0===(b.mode&1)?b.lanes=1:Kb(a)?b.lanes=8:b.lanes=1073741824,null;e=d.children;a=d.fallback;return f?(d=b.mode,f=b.child,e={mode:"hidden",children:e},0===(d&1)&&null!==f?(f.childLanes=0,f.pendingProps=e):\nf=sg(e,d,0,null),a=qe(a,d,c,null),f.return=b,a.return=b,f.sibling=a,b.child=f,b.child.memoizedState=pg(c),b.memoizedState=og,a):tg(b,e)}e=a.memoizedState;if(null!==e){h=e.dehydrated;if(null!==h){if(g){if(b.flags&256)return b.flags&=-257,ug(a,b,c,Error(n(422)));if(null!==b.memoizedState)return b.child=a.child,b.flags|=128,null;f=d.fallback;e=b.mode;d=sg({mode:"visible",children:d.children},e,0,null);f=qe(f,e,c,null);f.flags|=2;d.return=b;f.return=b;d.sibling=f;b.child=d;0!==(b.mode&1)&&re(b,a.child,\nnull,c);b.child.memoizedState=pg(c);b.memoizedState=og;return f}if(0===(b.mode&1))b=ug(a,b,c,null);else if(Kb(h))b=ug(a,b,c,Error(n(419)));else if(d=0!==(c&a.childLanes),F||d){d=N;if(null!==d){switch(c&-c){case 4:f=2;break;case 16:f=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:f=32;break;case 536870912:f=\n268435456;break;default:f=0}d=0!==(f&(d.suspendedLanes|c))?0:f;0!==d&&d!==e.retryLane&&(e.retryLane=d,Dd(a,d,-1))}Xf();b=ug(a,b,c,Error(n(421)))}else Jb(h)?(b.flags|=128,b.child=a.child,b=vg.bind(null,a),Lb(h,b),b=null):(c=e.treeContext,Va&&(Xd=Pb(h),Wd=b,H=!0,Zd=null,Yd=!1,null!==c&&(Nd[Od++]=Qd,Nd[Od++]=Rd,Nd[Od++]=Pd,Qd=c.id,Rd=c.overflow,Pd=b)),b=tg(b,b.pendingProps.children),b.flags|=4096);return b}if(f)return d=wg(a,b,d.children,d.fallback,c),f=b.child,e=a.child.memoizedState,f.memoizedState=\nnull===e?pg(c):qg(e,c),f.childLanes=a.childLanes&~c,b.memoizedState=og,d;c=xg(a,b,d.children,c);b.memoizedState=null;return c}if(f)return d=wg(a,b,d.children,d.fallback,c),f=b.child,e=a.child.memoizedState,f.memoizedState=null===e?pg(c):qg(e,c),f.childLanes=a.childLanes&~c,b.memoizedState=og,d;c=xg(a,b,d.children,c);b.memoizedState=null;return c}function tg(a,b){b=sg({mode:"visible",children:b},a.mode,0,null);b.return=a;return a.child=b}\nfunction xg(a,b,c,d){var e=a.child;a=e.sibling;c=me(e,{mode:"visible",children:c});0===(b.mode&1)&&(c.lanes=d);c.return=b;c.sibling=null;null!==a&&(d=b.deletions,null===d?(b.deletions=[a],b.flags|=16):d.push(a));return b.child=c}\nfunction wg(a,b,c,d,e){var f=b.mode;a=a.child;var g=a.sibling,h={mode:"hidden",children:c};0===(f&1)&&b.child!==a?(c=b.child,c.childLanes=0,c.pendingProps=h,b.deletions=null):(c=me(a,h),c.subtreeFlags=a.subtreeFlags&14680064);null!==g?d=me(g,d):(d=qe(d,f,e,null),d.flags|=2);d.return=b;c.return=b;c.sibling=d;b.child=c;return d}function ug(a,b,c,d){null!==d&&he(d);re(b,a.child,null,c);a=tg(b,b.pendingProps.children);a.flags|=2;b.memoizedState=null;return a}\nfunction yg(a,b,c){a.lanes|=b;var d=a.alternate;null!==d&&(d.lanes|=b);ld(a.return,b,c)}function zg(a,b,c,d,e){var f=a.memoizedState;null===f?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailMode:e}:(f.isBackwards=b,f.rendering=null,f.renderingStartTime=0,f.last=d,f.tail=c,f.tailMode=e)}\nfunction Ag(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;Q(a,b,d.children,c);d=I.current;if(0!==(d&2))d=d&1|2,b.flags|=128;else{if(null!==a&&0!==(a.flags&128))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&yg(a,c,b);else if(19===a.tag)yg(a,c,b);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}v(I,d);if(0===(b.mode&1))b.memoizedState=\nnull;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Ce(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);zg(b,!1,e,c,f);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Ce(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}zg(b,!0,c,null,f);break;case "together":zg(b,!1,null,null,void 0);break;default:b.memoizedState=null}return b.child}\nfunction cg(a,b,c){null!==a&&(b.dependencies=a.dependencies);yd|=b.lanes;if(0===(c&b.childLanes))return null;if(null!==a&&b.child!==a.child)throw Error(n(153));if(null!==b.child){a=b.child;c=me(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=me(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}\nfunction Bg(a,b,c){switch(b.tag){case 3:mg(b);ge();break;case 5:Ae(b);break;case 1:A(b.type)&&pc(b);break;case 4:ye(b,b.stateNode.containerInfo);break;case 10:jd(b,b.type._context,b.memoizedProps.value);break;case 13:var d=b.memoizedState;if(null!==d){if(null!==d.dehydrated)return v(I,I.current&1),b.flags|=128,null;if(0!==(c&b.child.childLanes))return rg(a,b,c);v(I,I.current&1);a=cg(a,b,c);return null!==a?a.sibling:null}v(I,I.current&1);break;case 19:d=0!==(c&b.childLanes);if(0!==(a.flags&128)){if(d)return Ag(a,\nb,c);b.flags|=128}var e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null,e.lastEffect=null);v(I,I.current);if(d)break;else return null;case 22:case 23:return b.lanes=0,hg(a,b,c)}return cg(a,b,c)}\nfunction Cg(a,b){Vd(b);switch(b.tag){case 1:return A(b.type)&&lc(),a=b.flags,a&65536?(b.flags=a&-65537|128,b):null;case 3:return ze(),p(z),p(x),Ee(),a=b.flags,0!==(a&65536)&&0===(a&128)?(b.flags=a&-65537|128,b):null;case 5:return Be(b),null;case 13:p(I);a=b.memoizedState;if(null!==a&&null!==a.dehydrated){if(null===b.alternate)throw Error(n(340));ge()}a=b.flags;return a&65536?(b.flags=a&-65537|128,b):null;case 19:return p(I),null;case 4:return ze(),null;case 10:return kd(b.type._context),null;case 22:case 23:return Zf(),\nnull;case 24:return null;default:return null}}var Dg=!1,R=!1,Eg="function"===typeof WeakSet?WeakSet:Set,S=null;function Fg(a,b){var c=a.ref;if(null!==c)if("function"===typeof c)try{c(null)}catch(d){T(a,b,d)}else c.current=null}function Gg(a,b,c){try{c()}catch(d){T(a,b,d)}}var Hg=!1;\nfunction Ig(a,b){Ha(a.containerInfo);for(S=b;null!==S;)if(a=S,b=a.child,0!==(a.subtreeFlags&1028)&&null!==b)b.return=a,S=b;else for(;null!==S;){a=S;try{var c=a.alternate;if(0!==(a.flags&1024))switch(a.tag){case 0:case 11:case 15:break;case 1:if(null!==c){var d=c.memoizedProps,e=c.memoizedState,f=a.stateNode,g=f.getSnapshotBeforeUpdate(a.elementType===a.type?d:dd(a.type,d),e);f.__reactInternalSnapshotBeforeUpdate=g}break;case 3:Ta&&xb(a.stateNode.containerInfo);break;case 5:case 6:case 4:case 17:break;\ndefault:throw Error(n(163));}}catch(h){T(a,a.return,h)}b=a.sibling;if(null!==b){b.return=a.return;S=b;break}S=a.return}c=Hg;Hg=!1;return c}function Jg(a,b,c){var d=b.updateQueue;d=null!==d?d.lastEffect:null;if(null!==d){var e=d=d.next;do{if((e.tag&a)===a){var f=e.destroy;e.destroy=void 0;void 0!==f&&Gg(b,c,f)}e=e.next}while(e!==d)}}function Kg(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}\nfunction Lg(a){var b=a.ref;if(null!==b){var c=a.stateNode;switch(a.tag){case 5:a=Ea(c);break;default:a=c}"function"===typeof b?b(a):b.current=a}}function Mg(a){var b=a.alternate;null!==b&&(a.alternate=null,Mg(b));a.child=null;a.deletions=null;a.sibling=null;5===a.tag&&(b=a.stateNode,null!==b&&Za(b));a.stateNode=null;a.return=null;a.dependencies=null;a.memoizedProps=null;a.memoizedState=null;a.pendingProps=null;a.stateNode=null;a.updateQueue=null}\nfunction Ng(a){return 5===a.tag||3===a.tag||4===a.tag}function Og(a){a:for(;;){for(;null===a.sibling;){if(null===a.return||Ng(a.return))return null;a=a.return}a.sibling.return=a.return;for(a=a.sibling;5!==a.tag&&6!==a.tag&&18!==a.tag;){if(a.flags&2)continue a;if(null===a.child||4===a.tag)continue a;else a.child.return=a,a=a.child}if(!(a.flags&2))return a.stateNode}}\nfunction Pg(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?pb(c,a,b):kb(c,a);else if(4!==d&&(a=a.child,null!==a))for(Pg(a,b,c),a=a.sibling;null!==a;)Pg(a,b,c),a=a.sibling}function Qg(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?ob(c,a,b):jb(c,a);else if(4!==d&&(a=a.child,null!==a))for(Qg(a,b,c),a=a.sibling;null!==a;)Qg(a,b,c),a=a.sibling}var U=null,Rg=!1;function Sg(a,b,c){for(c=c.child;null!==c;)Tg(a,b,c),c=c.sibling}\nfunction Tg(a,b,c){if(Rc&&"function"===typeof Rc.onCommitFiberUnmount)try{Rc.onCommitFiberUnmount(Qc,c)}catch(h){}switch(c.tag){case 5:R||Fg(c,b);case 6:if(Ta){var d=U,e=Rg;U=null;Sg(a,b,c);U=d;Rg=e;null!==U&&(Rg?rb(U,c.stateNode):qb(U,c.stateNode))}else Sg(a,b,c);break;case 18:Ta&&null!==U&&(Rg?Xb(U,c.stateNode):Wb(U,c.stateNode));break;case 4:Ta?(d=U,e=Rg,U=c.stateNode.containerInfo,Rg=!0,Sg(a,b,c),U=d,Rg=e):(Ua&&(d=c.stateNode.containerInfo,e=zb(d),Cb(d,e)),Sg(a,b,c));break;case 0:case 11:case 14:case 15:if(!R&&\n(d=c.updateQueue,null!==d&&(d=d.lastEffect,null!==d))){e=d=d.next;do{var f=e,g=f.destroy;f=f.tag;void 0!==g&&(0!==(f&2)?Gg(c,b,g):0!==(f&4)&&Gg(c,b,g));e=e.next}while(e!==d)}Sg(a,b,c);break;case 1:if(!R&&(Fg(c,b),d=c.stateNode,"function"===typeof d.componentWillUnmount))try{d.props=c.memoizedProps,d.state=c.memoizedState,d.componentWillUnmount()}catch(h){T(c,b,h)}Sg(a,b,c);break;case 21:Sg(a,b,c);break;case 22:c.mode&1?(R=(d=R)||null!==c.memoizedState,Sg(a,b,c),R=d):Sg(a,b,c);break;default:Sg(a,b,\nc)}}function Ug(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Eg);b.forEach(function(b){var d=Vg.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}\nfunction Wg(a,b){var c=b.deletions;if(null!==c)for(var d=0;d<c.length;d++){var e=c[d];try{var f=a,g=b;if(Ta){var h=g;a:for(;null!==h;){switch(h.tag){case 5:U=h.stateNode;Rg=!1;break a;case 3:U=h.stateNode.containerInfo;Rg=!0;break a;case 4:U=h.stateNode.containerInfo;Rg=!0;break a}h=h.return}if(null===U)throw Error(n(160));Tg(f,g,e);U=null;Rg=!1}else Tg(f,g,e);var k=e.alternate;null!==k&&(k.return=null);e.return=null}catch(l){T(e,b,l)}}if(b.subtreeFlags&12854)for(b=b.child;null!==b;)Xg(b,a),b=b.sibling}\nfunction Xg(a,b){var c=a.alternate,d=a.flags;switch(a.tag){case 0:case 11:case 14:case 15:Wg(b,a);Yg(a);if(d&4){try{Jg(3,a,a.return),Kg(3,a)}catch(k){T(a,a.return,k)}try{Jg(5,a,a.return)}catch(k){T(a,a.return,k)}}break;case 1:Wg(b,a);Yg(a);d&512&&null!==c&&Fg(c,c.return);break;case 5:Wg(b,a);Yg(a);d&512&&null!==c&&Fg(c,c.return);if(Ta){if(a.flags&32){var e=a.stateNode;try{sb(e)}catch(k){T(a,a.return,k)}}if(d&4&&(e=a.stateNode,null!=e)){var f=a.memoizedProps;c=null!==c?c.memoizedProps:f;d=a.type;b=\na.updateQueue;a.updateQueue=null;if(null!==b)try{nb(e,b,d,c,f,a)}catch(k){T(a,a.return,k)}}}break;case 6:Wg(b,a);Yg(a);if(d&4&&Ta){if(null===a.stateNode)throw Error(n(162));e=a.stateNode;f=a.memoizedProps;c=null!==c?c.memoizedProps:f;try{lb(e,c,f)}catch(k){T(a,a.return,k)}}break;case 3:Wg(b,a);Yg(a);if(d&4){if(Ta&&Va&&null!==c&&c.memoizedState.isDehydrated)try{Ub(b.containerInfo)}catch(k){T(a,a.return,k)}if(Ua){c=b.containerInfo;e=b.pendingChildren;try{Cb(c,e)}catch(k){T(a,a.return,k)}}}break;case 4:Wg(b,\na);Yg(a);if(d&4&&Ua){e=a.stateNode;c=e.containerInfo;e=e.pendingChildren;try{Cb(c,e)}catch(k){T(a,a.return,k)}}break;case 13:Wg(b,a);Yg(a);c=a.child;c.flags&8192&&null!==c.memoizedState&&(null===c.alternate||null===c.alternate.memoizedState)&&(Zg=D());d&4&&Ug(a);break;case 22:c=null!==c&&null!==c.memoizedState;if(a.mode&1){var g=R;R=g||c;Wg(b,a);R=g}else Wg(b,a);Yg(a);if(d&8192){d=null!==a.memoizedState;if(Ta)a:if(b=null,Ta)for(g=a;;){if(5===g.tag){if(null===b){b=g;try{e=g.stateNode,d?tb(e):vb(g.stateNode,\ng.memoizedProps)}catch(k){T(a,a.return,k)}}}else if(6===g.tag){if(null===b)try{f=g.stateNode,d?ub(f):wb(f,g.memoizedProps)}catch(k){T(a,a.return,k)}}else if((22!==g.tag&&23!==g.tag||null===g.memoizedState||g===a)&&null!==g.child){g.child.return=g;g=g.child;continue}if(g===a)break a;for(;null===g.sibling;){if(null===g.return||g.return===a)break a;b===g&&(b=null);g=g.return}b===g&&(b=null);g.sibling.return=g.return;g=g.sibling}if(d&&!c&&0!==(a.mode&1))for(S=a,a=a.child;null!==a;){for(c=S=a;null!==S;){e=\nS;f=e.child;switch(e.tag){case 0:case 11:case 14:case 15:Jg(4,e,e.return);break;case 1:Fg(e,e.return);var h=e.stateNode;if("function"===typeof h.componentWillUnmount){d=e;b=e.return;try{g=d,h.props=g.memoizedProps,h.state=g.memoizedState,h.componentWillUnmount()}catch(k){T(d,b,k)}}break;case 5:Fg(e,e.return);break;case 22:if(null!==e.memoizedState){$g(c);continue}}null!==f?(f.return=e,S=f):$g(c)}a=a.sibling}}break;case 19:Wg(b,a);Yg(a);d&4&&Ug(a);break;case 21:break;default:Wg(b,a),Yg(a)}}\nfunction Yg(a){var b=a.flags;if(b&2){try{if(Ta){b:{for(var c=a.return;null!==c;){if(Ng(c)){var d=c;break b}c=c.return}throw Error(n(160));}switch(d.tag){case 5:var e=d.stateNode;d.flags&32&&(sb(e),d.flags&=-33);var f=Og(a);Qg(a,f,e);break;case 3:case 4:var g=d.stateNode.containerInfo,h=Og(a);Pg(a,h,g);break;default:throw Error(n(161));}}}catch(k){T(a,a.return,k)}a.flags&=-3}b&4096&&(a.flags&=-4097)}function ah(a,b,c){S=a;bh(a,b,c)}\nfunction bh(a,b,c){for(var d=0!==(a.mode&1);null!==S;){var e=S,f=e.child;if(22===e.tag&&d){var g=null!==e.memoizedState||Dg;if(!g){var h=e.alternate,k=null!==h&&null!==h.memoizedState||R;h=Dg;var l=R;Dg=g;if((R=k)&&!l)for(S=e;null!==S;)g=S,k=g.child,22===g.tag&&null!==g.memoizedState?ch(e):null!==k?(k.return=g,S=k):ch(e);for(;null!==f;)S=f,bh(f,b,c),f=f.sibling;S=e;Dg=h;R=l}dh(a,b,c)}else 0!==(e.subtreeFlags&8772)&&null!==f?(f.return=e,S=f):dh(a,b,c)}}\nfunction dh(a){for(;null!==S;){var b=S;if(0!==(b.flags&8772)){var c=b.alternate;try{if(0!==(b.flags&8772))switch(b.tag){case 0:case 11:case 15:R||Kg(5,b);break;case 1:var d=b.stateNode;if(b.flags&4&&!R)if(null===c)d.componentDidMount();else{var e=b.elementType===b.type?c.memoizedProps:dd(b.type,c.memoizedProps);d.componentDidUpdate(e,c.memoizedState,d.__reactInternalSnapshotBeforeUpdate)}var f=b.updateQueue;null!==f&&zd(b,f,d);break;case 3:var g=b.updateQueue;if(null!==g){c=null;if(null!==b.child)switch(b.child.tag){case 5:c=\nEa(b.child.stateNode);break;case 1:c=b.child.stateNode}zd(b,g,c)}break;case 5:var h=b.stateNode;null===c&&b.flags&4&&mb(h,b.type,b.memoizedProps,b);break;case 6:break;case 4:break;case 12:break;case 13:if(Va&&null===b.memoizedState){var k=b.alternate;if(null!==k){var l=k.memoizedState;if(null!==l){var m=l.dehydrated;null!==m&&Vb(m)}}}break;case 19:case 17:case 21:case 22:case 23:break;default:throw Error(n(163));}R||b.flags&512&&Lg(b)}catch(r){T(b,b.return,r)}}if(b===a){S=null;break}c=b.sibling;if(null!==\nc){c.return=b.return;S=c;break}S=b.return}}function $g(a){for(;null!==S;){var b=S;if(b===a){S=null;break}var c=b.sibling;if(null!==c){c.return=b.return;S=c;break}S=b.return}}\nfunction ch(a){for(;null!==S;){var b=S;try{switch(b.tag){case 0:case 11:case 15:var c=b.return;try{Kg(4,b)}catch(k){T(b,c,k)}break;case 1:var d=b.stateNode;if("function"===typeof d.componentDidMount){var e=b.return;try{d.componentDidMount()}catch(k){T(b,e,k)}}var f=b.return;try{Lg(b)}catch(k){T(b,f,k)}break;case 5:var g=b.return;try{Lg(b)}catch(k){T(b,g,k)}}}catch(k){T(b,b.return,k)}if(b===a){S=null;break}var h=b.sibling;if(null!==h){h.return=b.return;S=h;break}S=b.return}}\nvar eh=0,fh=1,gh=2,hh=3,ih=4;if("function"===typeof Symbol&&Symbol.for){var jh=Symbol.for;eh=jh("selector.component");fh=jh("selector.has_pseudo_class");gh=jh("selector.role");hh=jh("selector.test_id");ih=jh("selector.text")}function kh(a){var b=Wa(a);if(null!=b){if("string"!==typeof b.memoizedProps["data-testname"])throw Error(n(364));return b}a=cb(a);if(null===a)throw Error(n(362));return a.stateNode.current}\nfunction lh(a,b){switch(b.$$typeof){case eh:if(a.type===b.value)return!0;break;case fh:a:{b=b.value;a=[a,0];for(var c=0;c<a.length;){var d=a[c++],e=a[c++],f=b[e];if(5!==d.tag||!fb(d)){for(;null!=f&&lh(d,f);)e++,f=b[e];if(e===b.length){b=!0;break a}else for(d=d.child;null!==d;)a.push(d,e),d=d.sibling}}b=!1}return b;case gh:if(5===a.tag&&gb(a.stateNode,b.value))return!0;break;case ih:if(5===a.tag||6===a.tag)if(a=eb(a),null!==a&&0<=a.indexOf(b.value))return!0;break;case hh:if(5===a.tag&&(a=a.memoizedProps["data-testname"],\n"string"===typeof a&&a.toLowerCase()===b.value.toLowerCase()))return!0;break;default:throw Error(n(365));}return!1}function mh(a){switch(a.$$typeof){case eh:return"<"+(ua(a.value)||"Unknown")+">";case fh:return":has("+(mh(a)||"")+")";case gh:return\'[role="\'+a.value+\'"]\';case ih:return\'"\'+a.value+\'"\';case hh:return\'[data-testname="\'+a.value+\'"]\';default:throw Error(n(365));}}\nfunction nh(a,b){var c=[];a=[a,0];for(var d=0;d<a.length;){var e=a[d++],f=a[d++],g=b[f];if(5!==e.tag||!fb(e)){for(;null!=g&&lh(e,g);)f++,g=b[f];if(f===b.length)c.push(e);else for(e=e.child;null!==e;)a.push(e,f),e=e.sibling}}return c}function oh(a,b){if(!bb)throw Error(n(363));a=kh(a);a=nh(a,b);b=[];a=Array.from(a);for(var c=0;c<a.length;){var d=a[c++];if(5===d.tag)fb(d)||b.push(d.stateNode);else for(d=d.child;null!==d;)a.push(d),d=d.sibling}return b}\nvar ph=Math.ceil,qh=da.ReactCurrentDispatcher,rh=da.ReactCurrentOwner,V=da.ReactCurrentBatchConfig,W=0,N=null,X=null,Y=0,$f=0,ig=hc(0),P=0,sh=null,yd=0,th=0,uh=0,vh=null,wh=null,Zg=0,Yf=Infinity,xh=null;function yh(){Yf=D()+500}var Ff=!1,Gf=null,If=null,zh=!1,Ah=null,Bh=0,Ch=0,Dh=null,Eh=-1,Fh=0;function G(){return 0!==(W&6)?D():-1!==Eh?Eh:Eh=D()}function Cd(a){if(0===(a.mode&1))return 1;if(0!==(W&2)&&0!==Y)return Y&-Y;if(null!==ad.transition)return 0===Fh&&(Fh=Cc()),Fh;a=C;return 0!==a?a:Ya()}\nfunction Dd(a,b,c){if(50<Ch)throw Ch=0,Dh=null,Error(n(185));var d=Gh(a,b);if(null===d)return null;Ec(d,b,c);if(0===(W&2)||d!==N)d===N&&(0===(W&2)&&(th|=b),4===P&&Hh(d,Y)),Ih(d,c),1===b&&0===W&&0===(a.mode&1)&&(yh(),Wc&&$c());return d}function Gh(a,b){a.lanes|=b;var c=a.alternate;null!==c&&(c.lanes|=b);c=a;for(a=a.return;null!==a;)a.childLanes|=b,c=a.alternate,null!==c&&(c.childLanes|=b),c=a,a=a.return;return 3===c.tag?c.stateNode:null}\nfunction ud(a){return(null!==N||null!==od)&&0!==(a.mode&1)&&0===(W&2)}\nfunction Ih(a,b){var c=a.callbackNode;Ac(a,b);var d=yc(a,a===N?Y:0);if(0===d)null!==c&&Jc(c),a.callbackNode=null,a.callbackPriority=0;else if(b=d&-d,a.callbackPriority!==b){null!=c&&Jc(c);if(1===b)0===a.tag?Zc(Jh.bind(null,a)):Yc(Jh.bind(null,a)),$a?ab(function(){0===W&&$c()}):Ic(Mc,$c),c=null;else{switch(Hc(d)){case 1:c=Mc;break;case 4:c=Nc;break;case 16:c=Oc;break;case 536870912:c=Pc;break;default:c=Oc}c=Kh(c,Lh.bind(null,a))}a.callbackPriority=b;a.callbackNode=c}}\nfunction Lh(a,b){Eh=-1;Fh=0;if(0!==(W&6))throw Error(n(327));var c=a.callbackNode;if(Mh()&&a.callbackNode!==c)return null;var d=yc(a,a===N?Y:0);if(0===d)return null;if(0!==(d&30)||0!==(d&a.expiredLanes)||b)b=Nh(a,d);else{b=d;var e=W;W|=2;var f=Oh();if(N!==a||Y!==b)xh=null,yh(),Ph(a,b);do try{Qh();break}catch(h){Rh(a,h)}while(1);id();qh.current=f;W=e;null!==X?b=0:(N=null,Y=0,b=P)}if(0!==b){2===b&&(e=Bc(a),0!==e&&(d=e,b=Sh(a,e)));if(1===b)throw c=sh,Ph(a,0),Hh(a,d),Ih(a,D()),c;if(6===b)Hh(a,d);else{e=\na.current.alternate;if(0===(d&30)&&!Th(e)&&(b=Nh(a,d),2===b&&(f=Bc(a),0!==f&&(d=f,b=Sh(a,f))),1===b))throw c=sh,Ph(a,0),Hh(a,d),Ih(a,D()),c;a.finishedWork=e;a.finishedLanes=d;switch(b){case 0:case 1:throw Error(n(345));case 2:Uh(a,wh,xh);break;case 3:Hh(a,d);if((d&130023424)===d&&(b=Zg+500-D(),10<b)){if(0!==yc(a,0))break;e=a.suspendedLanes;if((e&d)!==d){G();a.pingedLanes|=a.suspendedLanes&e;break}a.timeoutHandle=Pa(Uh.bind(null,a,wh,xh),b);break}Uh(a,wh,xh);break;case 4:Hh(a,d);if((d&4194240)===d)break;\nb=a.eventTimes;for(e=-1;0<d;){var g=31-sc(d);f=1<<g;g=b[g];g>e&&(e=g);d&=~f}d=e;d=D()-d;d=(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*ph(d/1960))-d;if(10<d){a.timeoutHandle=Pa(Uh.bind(null,a,wh,xh),d);break}Uh(a,wh,xh);break;case 5:Uh(a,wh,xh);break;default:throw Error(n(329));}}}Ih(a,D());return a.callbackNode===c?Lh.bind(null,a):null}\nfunction Sh(a,b){var c=vh;a.current.memoizedState.isDehydrated&&(Ph(a,b).flags|=256);a=Nh(a,b);2!==a&&(b=wh,wh=c,null!==b&&Wf(b));return a}function Wf(a){null===wh?wh=a:wh.push.apply(wh,a)}\nfunction Th(a){for(var b=a;;){if(b.flags&16384){var c=b.updateQueue;if(null!==c&&(c=c.stores,null!==c))for(var d=0;d<c.length;d++){var e=c[d],f=e.getSnapshot;e=e.value;try{if(!Uc(f(),e))return!1}catch(g){return!1}}}c=b.child;if(b.subtreeFlags&16384&&null!==c)c.return=b,b=c;else{if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return!0;b=b.return}b.sibling.return=b.return;b=b.sibling}}return!0}\nfunction Hh(a,b){b&=~uh;b&=~th;a.suspendedLanes|=b;a.pingedLanes&=~b;for(a=a.expirationTimes;0<b;){var c=31-sc(b),d=1<<c;a[c]=-1;b&=~d}}function Jh(a){if(0!==(W&6))throw Error(n(327));Mh();var b=yc(a,0);if(0===(b&1))return Ih(a,D()),null;var c=Nh(a,b);if(0!==a.tag&&2===c){var d=Bc(a);0!==d&&(b=d,c=Sh(a,d))}if(1===c)throw c=sh,Ph(a,0),Hh(a,b),Ih(a,D()),c;if(6===c)throw Error(n(345));a.finishedWork=a.current.alternate;a.finishedLanes=b;Uh(a,wh,xh);Ih(a,D());return null}\nfunction Vh(a){null!==Ah&&0===Ah.tag&&0===(W&6)&&Mh();var b=W;W|=1;var c=V.transition,d=C;try{if(V.transition=null,C=1,a)return a()}finally{C=d,V.transition=c,W=b,0===(W&6)&&$c()}}function Zf(){$f=ig.current;p(ig)}\nfunction Ph(a,b){a.finishedWork=null;a.finishedLanes=0;var c=a.timeoutHandle;c!==Ra&&(a.timeoutHandle=Ra,Qa(c));if(null!==X)for(c=X.return;null!==c;){var d=c;Vd(d);switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&lc();break;case 3:ze();p(z);p(x);Ee();break;case 5:Be(d);break;case 4:ze();break;case 13:p(I);break;case 19:p(I);break;case 10:kd(d.type._context);break;case 22:case 23:Zf()}c=c.return}N=a;X=a=me(a.current,null);Y=$f=b;P=0;sh=null;uh=th=yd=0;wh=vh=null;if(null!==od){for(b=\n0;b<od.length;b++)if(c=od[b],d=c.interleaved,null!==d){c.interleaved=null;var e=d.next,f=c.pending;if(null!==f){var g=f.next;f.next=e;d.next=g}c.pending=d}od=null}return a}\nfunction Rh(a,b){do{var c=X;try{id();Fe.current=Re;if(Ie){for(var d=J.memoizedState;null!==d;){var e=d.queue;null!==e&&(e.pending=null);d=d.next}Ie=!1}He=0;L=K=J=null;Je=!1;Ke=0;rh.current=null;if(null===c||null===c.return){P=1;sh=b;X=null;break}a:{var f=a,g=c.return,h=c,k=b;b=Y;h.flags|=32768;if(null!==k&&"object"===typeof k&&"function"===typeof k.then){var l=k,m=h,r=m.tag;if(0===(m.mode&1)&&(0===r||11===r||15===r)){var q=m.alternate;q?(m.updateQueue=q.updateQueue,m.memoizedState=q.memoizedState,\nm.lanes=q.lanes):(m.updateQueue=null,m.memoizedState=null)}var B=Lf(g);if(null!==B){B.flags&=-257;Mf(B,g,h,f,b);B.mode&1&&Jf(f,l,b);b=B;k=l;var w=b.updateQueue;if(null===w){var Z=new Set;Z.add(k);b.updateQueue=Z}else w.add(k);break a}else{if(0===(b&1)){Jf(f,l,b);Xf();break a}k=Error(n(426))}}else if(H&&h.mode&1){var za=Lf(g);if(null!==za){0===(za.flags&65536)&&(za.flags|=256);Mf(za,g,h,f,b);he(k);break a}}f=k;4!==P&&(P=2);null===vh?vh=[f]:vh.push(f);k=Bf(k,h);h=g;do{switch(h.tag){case 3:h.flags|=\n65536;b&=-b;h.lanes|=b;var E=Ef(h,k,b);wd(h,E);break a;case 1:f=k;var u=h.type,t=h.stateNode;if(0===(h.flags&128)&&("function"===typeof u.getDerivedStateFromError||null!==t&&"function"===typeof t.componentDidCatch&&(null===If||!If.has(t)))){h.flags|=65536;b&=-b;h.lanes|=b;var Db=Hf(h,f,b);wd(h,Db);break a}}h=h.return}while(null!==h)}Wh(c)}catch(oc){b=oc;X===c&&null!==c&&(X=c=c.return);continue}break}while(1)}function Oh(){var a=qh.current;qh.current=Re;return null===a?Re:a}\nfunction Xf(){if(0===P||3===P||2===P)P=4;null===N||0===(yd&268435455)&&0===(th&268435455)||Hh(N,Y)}function Nh(a,b){var c=W;W|=2;var d=Oh();if(N!==a||Y!==b)xh=null,Ph(a,b);do try{Xh();break}catch(e){Rh(a,e)}while(1);id();W=c;qh.current=d;if(null!==X)throw Error(n(261));N=null;Y=0;return P}function Xh(){for(;null!==X;)Yh(X)}function Qh(){for(;null!==X&&!Kc();)Yh(X)}function Yh(a){var b=Zh(a.alternate,a,$f);a.memoizedProps=a.pendingProps;null===b?Wh(a):X=b;rh.current=null}\nfunction Wh(a){var b=a;do{var c=b.alternate;a=b.return;if(0===(b.flags&32768)){if(c=Vf(c,b,$f),null!==c){X=c;return}}else{c=Cg(c,b);if(null!==c){c.flags&=32767;X=c;return}if(null!==a)a.flags|=32768,a.subtreeFlags=0,a.deletions=null;else{P=6;X=null;return}}b=b.sibling;if(null!==b){X=b;return}X=b=a}while(null!==b);0===P&&(P=5)}function Uh(a,b,c){var d=C,e=V.transition;try{V.transition=null,C=1,$h(a,b,c,d)}finally{V.transition=e,C=d}return null}\nfunction $h(a,b,c,d){do Mh();while(null!==Ah);if(0!==(W&6))throw Error(n(327));c=a.finishedWork;var e=a.finishedLanes;if(null===c)return null;a.finishedWork=null;a.finishedLanes=0;if(c===a.current)throw Error(n(177));a.callbackNode=null;a.callbackPriority=0;var f=c.lanes|c.childLanes;Fc(a,f);a===N&&(X=N=null,Y=0);0===(c.subtreeFlags&2064)&&0===(c.flags&2064)||zh||(zh=!0,Kh(Oc,function(){Mh();return null}));f=0!==(c.flags&15990);if(0!==(c.subtreeFlags&15990)||f){f=V.transition;V.transition=null;var g=\nC;C=1;var h=W;W|=4;rh.current=null;Ig(a,c);Xg(c,a);Ia(a.containerInfo);a.current=c;ah(c,a,e);Lc();W=h;C=g;V.transition=f}else a.current=c;zh&&(zh=!1,Ah=a,Bh=e);f=a.pendingLanes;0===f&&(If=null);Sc(c.stateNode,d);Ih(a,D());if(null!==b)for(d=a.onRecoverableError,c=0;c<b.length;c++)d(b[c]);if(Ff)throw Ff=!1,a=Gf,Gf=null,a;0!==(Bh&1)&&0!==a.tag&&Mh();f=a.pendingLanes;0!==(f&1)?a===Dh?Ch++:(Ch=0,Dh=a):Ch=0;$c();return null}\nfunction Mh(){if(null!==Ah){var a=Hc(Bh),b=V.transition,c=C;try{V.transition=null;C=16>a?16:a;if(null===Ah)var d=!1;else{a=Ah;Ah=null;Bh=0;if(0!==(W&6))throw Error(n(331));var e=W;W|=4;for(S=a.current;null!==S;){var f=S,g=f.child;if(0!==(S.flags&16)){var h=f.deletions;if(null!==h){for(var k=0;k<h.length;k++){var l=h[k];for(S=l;null!==S;){var m=S;switch(m.tag){case 0:case 11:case 15:Jg(8,m,f)}var r=m.child;if(null!==r)r.return=m,S=r;else for(;null!==S;){m=S;var q=m.sibling,B=m.return;Mg(m);if(m===\nl){S=null;break}if(null!==q){q.return=B;S=q;break}S=B}}}var w=f.alternate;if(null!==w){var Z=w.child;if(null!==Z){w.child=null;do{var za=Z.sibling;Z.sibling=null;Z=za}while(null!==Z)}}S=f}}if(0!==(f.subtreeFlags&2064)&&null!==g)g.return=f,S=g;else b:for(;null!==S;){f=S;if(0!==(f.flags&2048))switch(f.tag){case 0:case 11:case 15:Jg(9,f,f.return)}var E=f.sibling;if(null!==E){E.return=f.return;S=E;break b}S=f.return}}var u=a.current;for(S=u;null!==S;){g=S;var t=g.child;if(0!==(g.subtreeFlags&2064)&&null!==\nt)t.return=g,S=t;else b:for(g=u;null!==S;){h=S;if(0!==(h.flags&2048))try{switch(h.tag){case 0:case 11:case 15:Kg(9,h)}}catch(oc){T(h,h.return,oc)}if(h===g){S=null;break b}var Db=h.sibling;if(null!==Db){Db.return=h.return;S=Db;break b}S=h.return}}W=e;$c();if(Rc&&"function"===typeof Rc.onPostCommitFiberRoot)try{Rc.onPostCommitFiberRoot(Qc,a)}catch(oc){}d=!0}return d}finally{C=c,V.transition=b}}return!1}function ai(a,b,c){b=Bf(c,b);b=Ef(a,b,1);td(a,b);b=G();a=Gh(a,1);null!==a&&(Ec(a,1,b),Ih(a,b))}\nfunction T(a,b,c){if(3===a.tag)ai(a,a,c);else for(;null!==b;){if(3===b.tag){ai(b,a,c);break}else if(1===b.tag){var d=b.stateNode;if("function"===typeof b.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===If||!If.has(d))){a=Bf(c,a);a=Hf(b,a,1);td(b,a);a=G();b=Gh(b,1);null!==b&&(Ec(b,1,a),Ih(b,a));break}}b=b.return}}\nfunction Kf(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);b=G();a.pingedLanes|=a.suspendedLanes&c;N===a&&(Y&c)===c&&(4===P||3===P&&(Y&130023424)===Y&&500>D()-Zg?Ph(a,0):uh|=c);Ih(a,b)}function bi(a,b){0===b&&(0===(a.mode&1)?b=1:(b=wc,wc<<=1,0===(wc&130023424)&&(wc=4194304)));var c=G();a=Gh(a,b);null!==a&&(Ec(a,b,c),Ih(a,c))}function vg(a){var b=a.memoizedState,c=0;null!==b&&(c=b.retryLane);bi(a,c)}\nfunction Vg(a,b){var c=0;switch(a.tag){case 13:var d=a.stateNode;var e=a.memoizedState;null!==e&&(c=e.retryLane);break;case 19:d=a.stateNode;break;default:throw Error(n(314));}null!==d&&d.delete(b);bi(a,c)}var Zh;\nZh=function(a,b,c){if(null!==a)if(a.memoizedProps!==b.pendingProps||z.current)F=!0;else{if(0===(a.lanes&c)&&0===(b.flags&128))return F=!1,Bg(a,b,c);F=0!==(a.flags&131072)?!0:!1}else F=!1,H&&0!==(b.flags&1048576)&&Td(b,Md,b.index);b.lanes=0;switch(b.tag){case 2:var d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2);a=b.pendingProps;var e=kc(b,x.current);md(b,c);e=Ne(null,b,d,a,e,c);var f=Se();b.flags|=1;"object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof?\n(b.tag=1,b.memoizedState=null,b.updateQueue=null,A(d)?(f=!0,pc(b)):f=!1,b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null,qd(b),e.updater=Ed,b.stateNode=e,e._reactInternals=b,Id(b,d,a,c),b=lg(null,b,d,!0,f,c)):(b.tag=0,H&&f&&Ud(b),Q(null,b,e,c),b=b.child);return b;case 16:d=b.elementType;a:{null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2);a=b.pendingProps;e=d._init;d=e(d._payload);b.type=d;e=b.tag=ci(d);a=dd(d,a);switch(e){case 0:b=gg(null,b,d,a,c);break a;case 1:b=kg(null,b,d,\na,c);break a;case 11:b=bg(null,b,d,a,c);break a;case 14:b=dg(null,b,d,dd(d.type,a),c);break a}throw Error(n(306,d,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:dd(d,e),gg(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:dd(d,e),kg(a,b,d,e,c);case 3:a:{mg(b);if(null===a)throw Error(n(387));d=b.pendingProps;f=b.memoizedState;e=f.element;rd(a,b);xd(b,d,null,c);var g=b.memoizedState;d=g.element;if(Va&&f.isDehydrated)if(f={element:d,isDehydrated:!1,\ncache:g.cache,pendingSuspenseBoundaries:g.pendingSuspenseBoundaries,transitions:g.transitions},b.updateQueue.baseState=f,b.memoizedState=f,b.flags&256){e=Error(n(423));b=ng(a,b,d,c,e);break a}else if(d!==e){e=Error(n(424));b=ng(a,b,d,c,e);break a}else for(Va&&(Xd=Ob(b.stateNode.containerInfo),Wd=b,H=!0,Zd=null,Yd=!1),c=se(b,null,d,c),b.child=c;c;)c.flags=c.flags&-3|4096,c=c.sibling;else{ge();if(d===e){b=cg(a,b,c);break a}Q(a,b,d,c)}b=b.child}return b;case 5:return Ae(b),null===a&&de(b),d=b.type,e=\nb.pendingProps,f=null!==a?a.memoizedProps:null,g=e.children,Na(d,e)?g=null:null!==f&&Na(d,f)&&(b.flags|=32),jg(a,b),Q(a,b,g,c),b.child;case 6:return null===a&&de(b),null;case 13:return rg(a,b,c);case 4:return ye(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=re(b,null,d,c):Q(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:dd(d,e),bg(a,b,d,e,c);case 7:return Q(a,b,b.pendingProps,c),b.child;case 8:return Q(a,b,b.pendingProps.children,c),b.child;case 12:return Q(a,\nb,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;f=b.memoizedProps;g=e.value;jd(b,d,g);if(null!==f)if(Uc(f.value,g)){if(f.children===e.children&&!z.current){b=cg(a,b,c);break a}}else for(f=b.child,null!==f&&(f.return=b);null!==f;){var h=f.dependencies;if(null!==h){g=f.child;for(var k=h.firstContext;null!==k;){if(k.context===d){if(1===f.tag){k=sd(-1,c&-c);k.tag=2;var l=f.updateQueue;if(null!==l){l=l.shared;var m=l.pending;null===m?k.next=k:(k.next=m.next,m.next=k);\nl.pending=k}}f.lanes|=c;k=f.alternate;null!==k&&(k.lanes|=c);ld(f.return,c,b);h.lanes|=c;break}k=k.next}}else if(10===f.tag)g=f.type===b.type?null:f.child;else if(18===f.tag){g=f.return;if(null===g)throw Error(n(341));g.lanes|=c;h=g.alternate;null!==h&&(h.lanes|=c);ld(g,c,b);g=f.sibling}else g=f.child;if(null!==g)g.return=f;else for(g=f;null!==g;){if(g===b){g=null;break}f=g.sibling;if(null!==f){f.return=g.return;g=f;break}g=g.return}f=g}Q(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,\nd=b.pendingProps.children,md(b,c),e=nd(e),d=d(e),b.flags|=1,Q(a,b,d,c),b.child;case 14:return d=b.type,e=dd(d,b.pendingProps),e=dd(d.type,e),dg(a,b,d,e,c);case 15:return fg(a,b,b.type,b.pendingProps,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:dd(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2),b.tag=1,A(d)?(a=!0,pc(b)):a=!1,md(b,c),Gd(b,d,e),Id(b,d,e,c),lg(null,b,d,!0,a,c);case 19:return Ag(a,b,c);case 22:return hg(a,b,c)}throw Error(n(156,b.tag));};\nfunction Kh(a,b){return Ic(a,b)}function di(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.subtreeFlags=this.flags=0;this.deletions=null;this.childLanes=this.lanes=0;this.alternate=null}function ae(a,b,c,d){return new di(a,b,c,d)}\nfunction eg(a){a=a.prototype;return!(!a||!a.isReactComponent)}function ci(a){if("function"===typeof a)return eg(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===ma)return 11;if(a===pa)return 14}return 2}\nfunction me(a,b){var c=a.alternate;null===c?(c=ae(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.type=a.type,c.flags=0,c.subtreeFlags=0,c.deletions=null);c.flags=a.flags&14680064;c.childLanes=a.childLanes;c.lanes=a.lanes;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{lanes:b.lanes,firstContext:b.firstContext};\nc.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}\nfunction oe(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)eg(a)&&(g=1);else if("string"===typeof a)g=5;else a:switch(a){case ha:return qe(c.children,e,f,b);case ia:g=8;e|=8;break;case ja:return a=ae(12,c,b,e|2),a.elementType=ja,a.lanes=f,a;case na:return a=ae(13,c,b,e),a.elementType=na,a.lanes=f,a;case oa:return a=ae(19,c,b,e),a.elementType=oa,a.lanes=f,a;case ra:return sg(c,e,f,b);default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case ka:g=10;break a;case la:g=9;break a;case ma:g=11;\nbreak a;case pa:g=14;break a;case qa:g=16;d=null;break a}throw Error(n(130,null==a?a:typeof a,""));}b=ae(g,c,b,e);b.elementType=a;b.type=d;b.lanes=f;return b}function qe(a,b,c,d){a=ae(7,a,d,b);a.lanes=c;return a}function sg(a,b,c,d){a=ae(22,a,d,b);a.elementType=ra;a.lanes=c;a.stateNode={};return a}function ne(a,b,c){a=ae(6,a,null,b);a.lanes=c;return a}\nfunction pe(a,b,c){b=ae(4,null!==a.children?a.children:[],a.key,b);b.lanes=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}\nfunction ei(a,b,c,d,e){this.tag=b;this.containerInfo=a;this.finishedWork=this.pingCache=this.current=this.pendingChildren=null;this.timeoutHandle=Ra;this.callbackNode=this.pendingContext=this.context=null;this.callbackPriority=0;this.eventTimes=Dc(0);this.expirationTimes=Dc(-1);this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0;this.entanglements=Dc(0);this.identifierPrefix=d;this.onRecoverableError=e;Va&&(this.mutableSourceEagerHydrationData=\nnull)}function fi(a,b,c,d,e,f,g,h,k){a=new ei(a,b,c,h,k);1===b?(b=1,!0===f&&(b|=8)):b=0;f=ae(3,null,null,b);a.current=f;f.stateNode=a;f.memoizedState={element:d,isDehydrated:c,cache:null,transitions:null,pendingSuspenseBoundaries:null};qd(f);return a}\nfunction gi(a){if(!a)return ic;a=a._reactInternals;a:{if(wa(a)!==a||1!==a.tag)throw Error(n(170));var b=a;do{switch(b.tag){case 3:b=b.stateNode.context;break a;case 1:if(A(b.type)){b=b.stateNode.__reactInternalMemoizedMergedChildContext;break a}}b=b.return}while(null!==b);throw Error(n(171));}if(1===a.tag){var c=a.type;if(A(c))return nc(a,c,b)}return b}\nfunction hi(a){var b=a._reactInternals;if(void 0===b){if("function"===typeof a.render)throw Error(n(188));a=Object.keys(a).join(",");throw Error(n(268,a));}a=Aa(b);return null===a?null:a.stateNode}function ii(a,b){a=a.memoizedState;if(null!==a&&null!==a.dehydrated){var c=a.retryLane;a.retryLane=0!==c&&c<b?c:b}}function ji(a,b){ii(a,b);(a=a.alternate)&&ii(a,b)}function ki(a){a=Aa(a);return null===a?null:a.stateNode}function li(){return null}\nexports.attemptContinuousHydration=function(a){if(13===a.tag){var b=G();Dd(a,134217728,b);ji(a,134217728)}};exports.attemptDiscreteHydration=function(a){if(13===a.tag){var b=G();Dd(a,1,b);ji(a,1)}};exports.attemptHydrationAtCurrentPriority=function(a){if(13===a.tag){var b=G(),c=Cd(a);Dd(a,c,b);ji(a,c)}};\nexports.attemptSynchronousHydration=function(a){switch(a.tag){case 3:var b=a.stateNode;if(b.current.memoizedState.isDehydrated){var c=xc(b.pendingLanes);0!==c&&(Gc(b,c|1),Ih(b,D()),0===(W&6)&&(yh(),$c()))}break;case 13:var d=G();Vh(function(){return Dd(a,1,d)});ji(a,1)}};exports.batchedUpdates=function(a,b){var c=W;W|=1;try{return a(b)}finally{W=c,0===W&&(yh(),Wc&&$c())}};exports.createComponentSelector=function(a){return{$$typeof:eh,value:a}};\nexports.createContainer=function(a,b,c,d,e,f,g){return fi(a,b,!1,null,c,d,e,f,g)};exports.createHasPseudoClassSelector=function(a){return{$$typeof:fh,value:a}};exports.createHydrationContainer=function(a,b,c,d,e,f,g,h,k){a=fi(c,d,!0,a,e,f,g,h,k);a.context=gi(null);c=a.current;d=G();e=Cd(c);f=sd(d,e);f.callback=void 0!==b&&null!==b?b:null;td(c,f);a.current.lanes=e;Ec(a,e,d);Ih(a,d);return a};\nexports.createPortal=function(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:fa,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}};exports.createRoleSelector=function(a){return{$$typeof:gh,value:a}};exports.createTestNameSelector=function(a){return{$$typeof:hh,value:a}};exports.createTextSelector=function(a){return{$$typeof:ih,value:a}};\nexports.deferredUpdates=function(a){var b=C,c=V.transition;try{return V.transition=null,C=16,a()}finally{C=b,V.transition=c}};exports.discreteUpdates=function(a,b,c,d,e){var f=C,g=V.transition;try{return V.transition=null,C=1,a(b,c,d,e)}finally{C=f,V.transition=g,0===W&&yh()}};exports.findAllNodes=oh;\nexports.findBoundingRects=function(a,b){if(!bb)throw Error(n(363));b=oh(a,b);a=[];for(var c=0;c<b.length;c++)a.push(db(b[c]));for(b=a.length-1;0<b;b--){c=a[b];for(var d=c.x,e=d+c.width,f=c.y,g=f+c.height,h=b-1;0<=h;h--)if(b!==h){var k=a[h],l=k.x,m=l+k.width,r=k.y,q=r+k.height;if(d>=l&&f>=r&&e<=m&&g<=q){a.splice(b,1);break}else if(!(d!==l||c.width!==k.width||q<f||r>g)){r>f&&(k.height+=r-f,k.y=f);q<g&&(k.height=g-r);a.splice(b,1);break}else if(!(f!==r||c.height!==k.height||m<d||l>e)){l>d&&(k.width+=\nl-d,k.x=d);m<e&&(k.width=e-l);a.splice(b,1);break}}}return a};exports.findHostInstance=hi;exports.findHostInstanceWithNoPortals=function(a){a=ya(a);a=null!==a?Ca(a):null;return null===a?null:a.stateNode};exports.findHostInstanceWithWarning=function(a){return hi(a)};exports.flushControlled=function(a){var b=W;W|=1;var c=V.transition,d=C;try{V.transition=null,C=1,a()}finally{C=d,V.transition=c,W=b,0===W&&(yh(),$c())}};exports.flushPassiveEffects=Mh;exports.flushSync=Vh;\nexports.focusWithin=function(a,b){if(!bb)throw Error(n(363));a=kh(a);b=nh(a,b);b=Array.from(b);for(a=0;a<b.length;){var c=b[a++];if(!fb(c)){if(5===c.tag&&hb(c.stateNode))return!0;for(c=c.child;null!==c;)b.push(c),c=c.sibling}}return!1};exports.getCurrentUpdatePriority=function(){return C};\nexports.getFindAllNodesFailureDescription=function(a,b){if(!bb)throw Error(n(363));var c=0,d=[];a=[kh(a),0];for(var e=0;e<a.length;){var f=a[e++],g=a[e++],h=b[g];if(5!==f.tag||!fb(f))if(lh(f,h)&&(d.push(mh(h)),g++,g>c&&(c=g)),g<b.length)for(f=f.child;null!==f;)a.push(f,g),f=f.sibling}if(c<b.length){for(a=[];c<b.length;c++)a.push(mh(b[c]));return"findAllNodes was able to match part of the selector:\\n  "+(d.join(" > ")+"\\n\\nNo matching component was found for:\\n  ")+a.join(" > ")}return null};\nexports.getPublicRootInstance=function(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return Ea(a.child.stateNode);default:return a.child.stateNode}};\nexports.injectIntoDevTools=function(a){a={bundleType:a.bundleType,version:a.version,rendererPackageName:a.rendererPackageName,rendererConfig:a.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:ki,findFiberByHostInstance:a.findFiberByHostInstance||\nli,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.1.0"};if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)a=!1;else{var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)a=!0;else{try{Qc=b.inject(a),Rc=b}catch(c){}a=b.checkDCE?!0:!1}}return a};exports.isAlreadyRendering=function(){return!1};\nexports.observeVisibleRects=function(a,b,c,d){if(!bb)throw Error(n(363));a=oh(a,b);var e=ib(a,c,d).disconnect;return{disconnect:function(){e()}}};exports.registerMutableSourceForHydration=function(a,b){var c=b._getVersion;c=c(b._source);null==a.mutableSourceEagerHydrationData?a.mutableSourceEagerHydrationData=[b,c]:a.mutableSourceEagerHydrationData.push(b,c)};exports.runWithPriority=function(a,b){var c=C;try{return C=a,b()}finally{C=c}};exports.shouldError=function(){return null};\nexports.shouldSuspend=function(){return!1};exports.updateContainer=function(a,b,c,d){var e=b.current,f=G(),g=Cd(e);c=gi(c);null===b.context?b.context=c:b.pendingContext=c;b=sd(f,g);b.payload={element:a};d=void 0===d?null:d;null!==d&&(b.callback=d);td(e,b);a=Dd(e,g,f);null!==a&&vd(a,e,g);return g};\n\n    return exports;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFHO0FBQzFDLG1KQUFtSiw0REFBNEQsS0FBSyxxQ0FBcUMsdUNBQXVDLEtBQUssSUFBSSxvQkFBb0IsVUFBVSxvQkFBb0IsVUFBVSxzQ0FBc0M7QUFDM1ksOENBQThDLDJCQUEyQixVQUFVLDJCQUEyQixPQUFPLHNCQUFzQixPQUFPLHdEQUF3RCxvQkFBb0IsZUFBZSw2SEFBNkgsc0NBQXNDLFFBQVEsSUFBSSxlQUFlLFFBQVEsTUFBTSwrQkFBK0I7QUFDeGQsaUNBQWlDLFVBQVUsMENBQTBDLDhCQUE4QixRQUFRLGdEQUFnRCxVQUFVLFdBQVcsV0FBVyxvQkFBb0IseUJBQXlCLFFBQVEsWUFBWSxvQkFBb0I7O0FBRWhTO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWNvbmNpbGVyL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLnByb2R1Y3Rpb24ubWluLmpzP2Y4OGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtcmVjb25jaWxlci5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICQkJHJlY29uY2lsZXIoJCQkaG9zdENvbmZpZykge1xuICAgIHZhciBleHBvcnRzID0ge307XG4ndXNlIHN0cmljdCc7dmFyIGFhPXJlcXVpcmUoXCJyZWFjdFwiKSxiYT1yZXF1aXJlKFwic2NoZWR1bGVyXCIpLGNhPU9iamVjdC5hc3NpZ247ZnVuY3Rpb24gbihhKXtmb3IodmFyIGI9XCJodHRwczovL3JlYWN0anMub3JnL2RvY3MvZXJyb3ItZGVjb2Rlci5odG1sP2ludmFyaWFudD1cIithLGM9MTtjPGFyZ3VtZW50cy5sZW5ndGg7YysrKWIrPVwiJmFyZ3NbXT1cIitlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW2NdKTtyZXR1cm5cIk1pbmlmaWVkIFJlYWN0IGVycm9yICNcIithK1wiOyB2aXNpdCBcIitiK1wiIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy5cIn1cbnZhciBkYT1hYS5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCxlYT1TeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSxmYT1TeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLGhhPVN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxpYT1TeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksamE9U3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLGthPVN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSxsYT1TeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxtYT1TeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksbmE9U3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLG9hPVN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLHBhPVN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLHFhPVN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpO1N5bWJvbC5mb3IoXCJyZWFjdC5zY29wZVwiKTtTeW1ib2wuZm9yKFwicmVhY3QuZGVidWdfdHJhY2VfbW9kZVwiKTtcbnZhciByYT1TeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpO1N5bWJvbC5mb3IoXCJyZWFjdC5sZWdhY3lfaGlkZGVuXCIpO1N5bWJvbC5mb3IoXCJyZWFjdC5jYWNoZVwiKTtTeW1ib2wuZm9yKFwicmVhY3QudHJhY2luZ19tYXJrZXJcIik7dmFyIHNhPVN5bWJvbC5pdGVyYXRvcjtmdW5jdGlvbiB0YShhKXtpZihudWxsPT09YXx8XCJvYmplY3RcIiE9PXR5cGVvZiBhKXJldHVybiBudWxsO2E9c2EmJmFbc2FdfHxhW1wiQEBpdGVyYXRvclwiXTtyZXR1cm5cImZ1bmN0aW9uXCI9PT10eXBlb2YgYT9hOm51bGx9XG5mdW5jdGlvbiB1YShhKXtpZihudWxsPT1hKXJldHVybiBudWxsO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBhKXJldHVybiBhLmRpc3BsYXlOYW1lfHxhLm5hbWV8fG51bGw7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBhKXJldHVybiBhO3N3aXRjaChhKXtjYXNlIGhhOnJldHVyblwiRnJhZ21lbnRcIjtjYXNlIGZhOnJldHVyblwiUG9ydGFsXCI7Y2FzZSBqYTpyZXR1cm5cIlByb2ZpbGVyXCI7Y2FzZSBpYTpyZXR1cm5cIlN0cmljdE1vZGVcIjtjYXNlIG5hOnJldHVyblwiU3VzcGVuc2VcIjtjYXNlIG9hOnJldHVyblwiU3VzcGVuc2VMaXN0XCJ9aWYoXCJvYmplY3RcIj09PXR5cGVvZiBhKXN3aXRjaChhLiQkdHlwZW9mKXtjYXNlIGxhOnJldHVybihhLmRpc3BsYXlOYW1lfHxcIkNvbnRleHRcIikrXCIuQ29uc3VtZXJcIjtjYXNlIGthOnJldHVybihhLl9jb250ZXh0LmRpc3BsYXlOYW1lfHxcIkNvbnRleHRcIikrXCIuUHJvdmlkZXJcIjtjYXNlIG1hOnZhciBiPWEucmVuZGVyO2E9YS5kaXNwbGF5TmFtZTthfHwoYT1iLmRpc3BsYXlOYW1lfHxcbmIubmFtZXx8XCJcIixhPVwiXCIhPT1hP1wiRm9yd2FyZFJlZihcIithK1wiKVwiOlwiRm9yd2FyZFJlZlwiKTtyZXR1cm4gYTtjYXNlIHBhOnJldHVybiBiPWEuZGlzcGxheU5hbWV8fG51bGwsbnVsbCE9PWI/Yjp1YShhLnR5cGUpfHxcIk1lbW9cIjtjYXNlIHFhOmI9YS5fcGF5bG9hZDthPWEuX2luaXQ7dHJ5e3JldHVybiB1YShhKGIpKX1jYXRjaChjKXt9fXJldHVybiBudWxsfVxuZnVuY3Rpb24gdmEoYSl7dmFyIGI9YS50eXBlO3N3aXRjaChhLnRhZyl7Y2FzZSAyNDpyZXR1cm5cIkNhY2hlXCI7Y2FzZSA5OnJldHVybihiLmRpc3BsYXlOYW1lfHxcIkNvbnRleHRcIikrXCIuQ29uc3VtZXJcIjtjYXNlIDEwOnJldHVybihiLl9jb250ZXh0LmRpc3BsYXlOYW1lfHxcIkNvbnRleHRcIikrXCIuUHJvdmlkZXJcIjtjYXNlIDE4OnJldHVyblwiRGVoeWRyYXRlZEZyYWdtZW50XCI7Y2FzZSAxMTpyZXR1cm4gYT1iLnJlbmRlcixhPWEuZGlzcGxheU5hbWV8fGEubmFtZXx8XCJcIixiLmRpc3BsYXlOYW1lfHwoXCJcIiE9PWE/XCJGb3J3YXJkUmVmKFwiK2ErXCIpXCI6XCJGb3J3YXJkUmVmXCIpO2Nhc2UgNzpyZXR1cm5cIkZyYWdtZW50XCI7Y2FzZSA1OnJldHVybiBiO2Nhc2UgNDpyZXR1cm5cIlBvcnRhbFwiO2Nhc2UgMzpyZXR1cm5cIlJvb3RcIjtjYXNlIDY6cmV0dXJuXCJUZXh0XCI7Y2FzZSAxNjpyZXR1cm4gdWEoYik7Y2FzZSA4OnJldHVybiBiPT09aWE/XCJTdHJpY3RNb2RlXCI6XCJNb2RlXCI7Y2FzZSAyMjpyZXR1cm5cIk9mZnNjcmVlblwiO1xuY2FzZSAxMjpyZXR1cm5cIlByb2ZpbGVyXCI7Y2FzZSAyMTpyZXR1cm5cIlNjb3BlXCI7Y2FzZSAxMzpyZXR1cm5cIlN1c3BlbnNlXCI7Y2FzZSAxOTpyZXR1cm5cIlN1c3BlbnNlTGlzdFwiO2Nhc2UgMjU6cmV0dXJuXCJUcmFjaW5nTWFya2VyXCI7Y2FzZSAxOmNhc2UgMDpjYXNlIDE3OmNhc2UgMjpjYXNlIDE0OmNhc2UgMTU6aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGIpcmV0dXJuIGIuZGlzcGxheU5hbWV8fGIubmFtZXx8bnVsbDtpZihcInN0cmluZ1wiPT09dHlwZW9mIGIpcmV0dXJuIGJ9cmV0dXJuIG51bGx9ZnVuY3Rpb24gd2EoYSl7dmFyIGI9YSxjPWE7aWYoYS5hbHRlcm5hdGUpZm9yKDtiLnJldHVybjspYj1iLnJldHVybjtlbHNle2E9YjtkbyBiPWEsMCE9PShiLmZsYWdzJjQwOTgpJiYoYz1iLnJldHVybiksYT1iLnJldHVybjt3aGlsZShhKX1yZXR1cm4gMz09PWIudGFnP2M6bnVsbH1mdW5jdGlvbiB4YShhKXtpZih3YShhKSE9PWEpdGhyb3cgRXJyb3IobigxODgpKTt9XG5mdW5jdGlvbiB5YShhKXt2YXIgYj1hLmFsdGVybmF0ZTtpZighYil7Yj13YShhKTtpZihudWxsPT09Yil0aHJvdyBFcnJvcihuKDE4OCkpO3JldHVybiBiIT09YT9udWxsOmF9Zm9yKHZhciBjPWEsZD1iOzspe3ZhciBlPWMucmV0dXJuO2lmKG51bGw9PT1lKWJyZWFrO3ZhciBmPWUuYWx0ZXJuYXRlO2lmKG51bGw9PT1mKXtkPWUucmV0dXJuO2lmKG51bGwhPT1kKXtjPWQ7Y29udGludWV9YnJlYWt9aWYoZS5jaGlsZD09PWYuY2hpbGQpe2ZvcihmPWUuY2hpbGQ7Zjspe2lmKGY9PT1jKXJldHVybiB4YShlKSxhO2lmKGY9PT1kKXJldHVybiB4YShlKSxiO2Y9Zi5zaWJsaW5nfXRocm93IEVycm9yKG4oMTg4KSk7fWlmKGMucmV0dXJuIT09ZC5yZXR1cm4pYz1lLGQ9ZjtlbHNle2Zvcih2YXIgZz0hMSxoPWUuY2hpbGQ7aDspe2lmKGg9PT1jKXtnPSEwO2M9ZTtkPWY7YnJlYWt9aWYoaD09PWQpe2c9ITA7ZD1lO2M9ZjticmVha31oPWguc2libGluZ31pZighZyl7Zm9yKGg9Zi5jaGlsZDtoOyl7aWYoaD09PVxuYyl7Zz0hMDtjPWY7ZD1lO2JyZWFrfWlmKGg9PT1kKXtnPSEwO2Q9ZjtjPWU7YnJlYWt9aD1oLnNpYmxpbmd9aWYoIWcpdGhyb3cgRXJyb3IobigxODkpKTt9fWlmKGMuYWx0ZXJuYXRlIT09ZCl0aHJvdyBFcnJvcihuKDE5MCkpO31pZigzIT09Yy50YWcpdGhyb3cgRXJyb3IobigxODgpKTtyZXR1cm4gYy5zdGF0ZU5vZGUuY3VycmVudD09PWM/YTpifWZ1bmN0aW9uIEFhKGEpe2E9eWEoYSk7cmV0dXJuIG51bGwhPT1hP0JhKGEpOm51bGx9ZnVuY3Rpb24gQmEoYSl7aWYoNT09PWEudGFnfHw2PT09YS50YWcpcmV0dXJuIGE7Zm9yKGE9YS5jaGlsZDtudWxsIT09YTspe3ZhciBiPUJhKGEpO2lmKG51bGwhPT1iKXJldHVybiBiO2E9YS5zaWJsaW5nfXJldHVybiBudWxsfVxuZnVuY3Rpb24gQ2EoYSl7aWYoNT09PWEudGFnfHw2PT09YS50YWcpcmV0dXJuIGE7Zm9yKGE9YS5jaGlsZDtudWxsIT09YTspe2lmKDQhPT1hLnRhZyl7dmFyIGI9Q2EoYSk7aWYobnVsbCE9PWIpcmV0dXJuIGJ9YT1hLnNpYmxpbmd9cmV0dXJuIG51bGx9XG52YXIgRGE9QXJyYXkuaXNBcnJheSxFYT0kJCRob3N0Q29uZmlnLmdldFB1YmxpY0luc3RhbmNlLEZhPSQkJGhvc3RDb25maWcuZ2V0Um9vdEhvc3RDb250ZXh0LEdhPSQkJGhvc3RDb25maWcuZ2V0Q2hpbGRIb3N0Q29udGV4dCxIYT0kJCRob3N0Q29uZmlnLnByZXBhcmVGb3JDb21taXQsSWE9JCQkaG9zdENvbmZpZy5yZXNldEFmdGVyQ29tbWl0LEphPSQkJGhvc3RDb25maWcuY3JlYXRlSW5zdGFuY2UsS2E9JCQkaG9zdENvbmZpZy5hcHBlbmRJbml0aWFsQ2hpbGQsTGE9JCQkaG9zdENvbmZpZy5maW5hbGl6ZUluaXRpYWxDaGlsZHJlbixNYT0kJCRob3N0Q29uZmlnLnByZXBhcmVVcGRhdGUsTmE9JCQkaG9zdENvbmZpZy5zaG91bGRTZXRUZXh0Q29udGVudCxPYT0kJCRob3N0Q29uZmlnLmNyZWF0ZVRleHRJbnN0YW5jZSxQYT0kJCRob3N0Q29uZmlnLnNjaGVkdWxlVGltZW91dCxRYT0kJCRob3N0Q29uZmlnLmNhbmNlbFRpbWVvdXQsUmE9JCQkaG9zdENvbmZpZy5ub1RpbWVvdXQsXG5TYT0kJCRob3N0Q29uZmlnLmlzUHJpbWFyeVJlbmRlcmVyLFRhPSQkJGhvc3RDb25maWcuc3VwcG9ydHNNdXRhdGlvbixVYT0kJCRob3N0Q29uZmlnLnN1cHBvcnRzUGVyc2lzdGVuY2UsVmE9JCQkaG9zdENvbmZpZy5zdXBwb3J0c0h5ZHJhdGlvbixXYT0kJCRob3N0Q29uZmlnLmdldEluc3RhbmNlRnJvbU5vZGUsWGE9JCQkaG9zdENvbmZpZy5wcmVwYXJlUG9ydGFsTW91bnQsWWE9JCQkaG9zdENvbmZpZy5nZXRDdXJyZW50RXZlbnRQcmlvcml0eSxaYT0kJCRob3N0Q29uZmlnLmRldGFjaERlbGV0ZWRJbnN0YW5jZSwkYT0kJCRob3N0Q29uZmlnLnN1cHBvcnRzTWljcm90YXNrcyxhYj0kJCRob3N0Q29uZmlnLnNjaGVkdWxlTWljcm90YXNrLGJiPSQkJGhvc3RDb25maWcuc3VwcG9ydHNUZXN0U2VsZWN0b3JzLGNiPSQkJGhvc3RDb25maWcuZmluZEZpYmVyUm9vdCxkYj0kJCRob3N0Q29uZmlnLmdldEJvdW5kaW5nUmVjdCxlYj0kJCRob3N0Q29uZmlnLmdldFRleHRDb250ZW50LGZiPVxuJCQkaG9zdENvbmZpZy5pc0hpZGRlblN1YnRyZWUsZ2I9JCQkaG9zdENvbmZpZy5tYXRjaEFjY2Vzc2liaWxpdHlSb2xlLGhiPSQkJGhvc3RDb25maWcuc2V0Rm9jdXNJZkZvY3VzYWJsZSxpYj0kJCRob3N0Q29uZmlnLnNldHVwSW50ZXJzZWN0aW9uT2JzZXJ2ZXIsamI9JCQkaG9zdENvbmZpZy5hcHBlbmRDaGlsZCxrYj0kJCRob3N0Q29uZmlnLmFwcGVuZENoaWxkVG9Db250YWluZXIsbGI9JCQkaG9zdENvbmZpZy5jb21taXRUZXh0VXBkYXRlLG1iPSQkJGhvc3RDb25maWcuY29tbWl0TW91bnQsbmI9JCQkaG9zdENvbmZpZy5jb21taXRVcGRhdGUsb2I9JCQkaG9zdENvbmZpZy5pbnNlcnRCZWZvcmUscGI9JCQkaG9zdENvbmZpZy5pbnNlcnRJbkNvbnRhaW5lckJlZm9yZSxxYj0kJCRob3N0Q29uZmlnLnJlbW92ZUNoaWxkLHJiPSQkJGhvc3RDb25maWcucmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyLHNiPSQkJGhvc3RDb25maWcucmVzZXRUZXh0Q29udGVudCx0Yj0kJCRob3N0Q29uZmlnLmhpZGVJbnN0YW5jZSxcbnViPSQkJGhvc3RDb25maWcuaGlkZVRleHRJbnN0YW5jZSx2Yj0kJCRob3N0Q29uZmlnLnVuaGlkZUluc3RhbmNlLHdiPSQkJGhvc3RDb25maWcudW5oaWRlVGV4dEluc3RhbmNlLHhiPSQkJGhvc3RDb25maWcuY2xlYXJDb250YWluZXIseWI9JCQkaG9zdENvbmZpZy5jbG9uZUluc3RhbmNlLHpiPSQkJGhvc3RDb25maWcuY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQsQWI9JCQkaG9zdENvbmZpZy5hcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQsQmI9JCQkaG9zdENvbmZpZy5maW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuLENiPSQkJGhvc3RDb25maWcucmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuLEViPSQkJGhvc3RDb25maWcuY2xvbmVIaWRkZW5JbnN0YW5jZSxGYj0kJCRob3N0Q29uZmlnLmNsb25lSGlkZGVuVGV4dEluc3RhbmNlLEdiPSQkJGhvc3RDb25maWcuY2FuSHlkcmF0ZUluc3RhbmNlLEhiPSQkJGhvc3RDb25maWcuY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSxJYj0kJCRob3N0Q29uZmlnLmNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlLFxuSmI9JCQkaG9zdENvbmZpZy5pc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nLEtiPSQkJGhvc3RDb25maWcuaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2ssTGI9JCQkaG9zdENvbmZpZy5yZWdpc3RlclN1c3BlbnNlSW5zdGFuY2VSZXRyeSxNYj0kJCRob3N0Q29uZmlnLmdldE5leHRIeWRyYXRhYmxlU2libGluZyxOYj0kJCRob3N0Q29uZmlnLmdldEZpcnN0SHlkcmF0YWJsZUNoaWxkLE9iPSQkJGhvc3RDb25maWcuZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXIsUGI9JCQkaG9zdENvbmZpZy5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblN1c3BlbnNlSW5zdGFuY2UsUWI9JCQkaG9zdENvbmZpZy5oeWRyYXRlSW5zdGFuY2UsUmI9JCQkaG9zdENvbmZpZy5oeWRyYXRlVGV4dEluc3RhbmNlLFNiPSQkJGhvc3RDb25maWcuaHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UsVGI9JCQkaG9zdENvbmZpZy5nZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlLFxuVWI9JCQkaG9zdENvbmZpZy5jb21taXRIeWRyYXRlZENvbnRhaW5lcixWYj0kJCRob3N0Q29uZmlnLmNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZSxXYj0kJCRob3N0Q29uZmlnLmNsZWFyU3VzcGVuc2VCb3VuZGFyeSxYYj0kJCRob3N0Q29uZmlnLmNsZWFyU3VzcGVuc2VCb3VuZGFyeUZyb21Db250YWluZXIsWWI9JCQkaG9zdENvbmZpZy5zaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcyxaYj0kJCRob3N0Q29uZmlnLmRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UsJGI9JCQkaG9zdENvbmZpZy5kaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlLGFjO2Z1bmN0aW9uIGJjKGEpe2lmKHZvaWQgMD09PWFjKXRyeXt0aHJvdyBFcnJvcigpO31jYXRjaChjKXt2YXIgYj1jLnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO2FjPWImJmJbMV18fFwiXCJ9cmV0dXJuXCJcXG5cIithYythfXZhciBjYz0hMTtcbmZ1bmN0aW9uIGRjKGEsYil7aWYoIWF8fGNjKXJldHVyblwiXCI7Y2M9ITA7dmFyIGM9RXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7RXJyb3IucHJlcGFyZVN0YWNrVHJhY2U9dm9pZCAwO3RyeXtpZihiKWlmKGI9ZnVuY3Rpb24oKXt0aHJvdyBFcnJvcigpO30sT2JqZWN0LmRlZmluZVByb3BlcnR5KGIucHJvdG90eXBlLFwicHJvcHNcIix7c2V0OmZ1bmN0aW9uKCl7dGhyb3cgRXJyb3IoKTt9fSksXCJvYmplY3RcIj09PXR5cGVvZiBSZWZsZWN0JiZSZWZsZWN0LmNvbnN0cnVjdCl7dHJ5e1JlZmxlY3QuY29uc3RydWN0KGIsW10pfWNhdGNoKGwpe3ZhciBkPWx9UmVmbGVjdC5jb25zdHJ1Y3QoYSxbXSxiKX1lbHNle3RyeXtiLmNhbGwoKX1jYXRjaChsKXtkPWx9YS5jYWxsKGIucHJvdG90eXBlKX1lbHNle3RyeXt0aHJvdyBFcnJvcigpO31jYXRjaChsKXtkPWx9YSgpfX1jYXRjaChsKXtpZihsJiZkJiZcInN0cmluZ1wiPT09dHlwZW9mIGwuc3RhY2spe2Zvcih2YXIgZT1sLnN0YWNrLnNwbGl0KFwiXFxuXCIpLFxuZj1kLnN0YWNrLnNwbGl0KFwiXFxuXCIpLGc9ZS5sZW5ndGgtMSxoPWYubGVuZ3RoLTE7MTw9ZyYmMDw9aCYmZVtnXSE9PWZbaF07KWgtLTtmb3IoOzE8PWcmJjA8PWg7Zy0tLGgtLSlpZihlW2ddIT09ZltoXSl7aWYoMSE9PWd8fDEhPT1oKXtkbyBpZihnLS0saC0tLDA+aHx8ZVtnXSE9PWZbaF0pe3ZhciBrPVwiXFxuXCIrZVtnXS5yZXBsYWNlKFwiIGF0IG5ldyBcIixcIiBhdCBcIik7YS5kaXNwbGF5TmFtZSYmay5pbmNsdWRlcyhcIjxhbm9ueW1vdXM+XCIpJiYoaz1rLnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLGEuZGlzcGxheU5hbWUpKTtyZXR1cm4ga313aGlsZSgxPD1nJiYwPD1oKX1icmVha319fWZpbmFsbHl7Y2M9ITEsRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U9Y31yZXR1cm4oYT1hP2EuZGlzcGxheU5hbWV8fGEubmFtZTpcIlwiKT9iYyhhKTpcIlwifXZhciBlYz1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LGZjPVtdLGdjPS0xO2Z1bmN0aW9uIGhjKGEpe3JldHVybntjdXJyZW50OmF9fVxuZnVuY3Rpb24gcChhKXswPmdjfHwoYS5jdXJyZW50PWZjW2djXSxmY1tnY109bnVsbCxnYy0tKX1mdW5jdGlvbiB2KGEsYil7Z2MrKztmY1tnY109YS5jdXJyZW50O2EuY3VycmVudD1ifXZhciBpYz17fSx4PWhjKGljKSx6PWhjKCExKSxqYz1pYztmdW5jdGlvbiBrYyhhLGIpe3ZhciBjPWEudHlwZS5jb250ZXh0VHlwZXM7aWYoIWMpcmV0dXJuIGljO3ZhciBkPWEuc3RhdGVOb2RlO2lmKGQmJmQuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dD09PWIpcmV0dXJuIGQuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ7dmFyIGU9e30sZjtmb3IoZiBpbiBjKWVbZl09YltmXTtkJiYoYT1hLnN0YXRlTm9kZSxhLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9YixhLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0PWUpO3JldHVybiBlfVxuZnVuY3Rpb24gQShhKXthPWEuY2hpbGRDb250ZXh0VHlwZXM7cmV0dXJuIG51bGwhPT1hJiZ2b2lkIDAhPT1hfWZ1bmN0aW9uIGxjKCl7cCh6KTtwKHgpfWZ1bmN0aW9uIG1jKGEsYixjKXtpZih4LmN1cnJlbnQhPT1pYyl0aHJvdyBFcnJvcihuKDE2OCkpO3YoeCxiKTt2KHosYyl9ZnVuY3Rpb24gbmMoYSxiLGMpe3ZhciBkPWEuc3RhdGVOb2RlO2I9Yi5jaGlsZENvbnRleHRUeXBlcztpZihcImZ1bmN0aW9uXCIhPT10eXBlb2YgZC5nZXRDaGlsZENvbnRleHQpcmV0dXJuIGM7ZD1kLmdldENoaWxkQ29udGV4dCgpO2Zvcih2YXIgZSBpbiBkKWlmKCEoZSBpbiBiKSl0aHJvdyBFcnJvcihuKDEwOCx2YShhKXx8XCJVbmtub3duXCIsZSkpO3JldHVybiBjYSh7fSxjLGQpfVxuZnVuY3Rpb24gcGMoYSl7YT0oYT1hLnN0YXRlTm9kZSkmJmEuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHR8fGljO2pjPXguY3VycmVudDt2KHgsYSk7dih6LHouY3VycmVudCk7cmV0dXJuITB9ZnVuY3Rpb24gcWMoYSxiLGMpe3ZhciBkPWEuc3RhdGVOb2RlO2lmKCFkKXRocm93IEVycm9yKG4oMTY5KSk7Yz8oYT1uYyhhLGIsamMpLGQuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQ9YSxwKHopLHAoeCksdih4LGEpKTpwKHopO3YoeixjKX12YXIgc2M9TWF0aC5jbHozMj9NYXRoLmNsejMyOnJjLHRjPU1hdGgubG9nLHVjPU1hdGguTE4yO2Z1bmN0aW9uIHJjKGEpe2E+Pj49MDtyZXR1cm4gMD09PWE/MzI6MzEtKHRjKGEpL3VjfDApfDB9dmFyIHZjPTY0LHdjPTQxOTQzMDQ7XG5mdW5jdGlvbiB4YyhhKXtzd2l0Y2goYSYtYSl7Y2FzZSAxOnJldHVybiAxO2Nhc2UgMjpyZXR1cm4gMjtjYXNlIDQ6cmV0dXJuIDQ7Y2FzZSA4OnJldHVybiA4O2Nhc2UgMTY6cmV0dXJuIDE2O2Nhc2UgMzI6cmV0dXJuIDMyO2Nhc2UgNjQ6Y2FzZSAxMjg6Y2FzZSAyNTY6Y2FzZSA1MTI6Y2FzZSAxMDI0OmNhc2UgMjA0ODpjYXNlIDQwOTY6Y2FzZSA4MTkyOmNhc2UgMTYzODQ6Y2FzZSAzMjc2ODpjYXNlIDY1NTM2OmNhc2UgMTMxMDcyOmNhc2UgMjYyMTQ0OmNhc2UgNTI0Mjg4OmNhc2UgMTA0ODU3NjpjYXNlIDIwOTcxNTI6cmV0dXJuIGEmNDE5NDI0MDtjYXNlIDQxOTQzMDQ6Y2FzZSA4Mzg4NjA4OmNhc2UgMTY3NzcyMTY6Y2FzZSAzMzU1NDQzMjpjYXNlIDY3MTA4ODY0OnJldHVybiBhJjEzMDAyMzQyNDtjYXNlIDEzNDIxNzcyODpyZXR1cm4gMTM0MjE3NzI4O2Nhc2UgMjY4NDM1NDU2OnJldHVybiAyNjg0MzU0NTY7Y2FzZSA1MzY4NzA5MTI6cmV0dXJuIDUzNjg3MDkxMjtjYXNlIDEwNzM3NDE4MjQ6cmV0dXJuIDEwNzM3NDE4MjQ7XG5kZWZhdWx0OnJldHVybiBhfX1mdW5jdGlvbiB5YyhhLGIpe3ZhciBjPWEucGVuZGluZ0xhbmVzO2lmKDA9PT1jKXJldHVybiAwO3ZhciBkPTAsZT1hLnN1c3BlbmRlZExhbmVzLGY9YS5waW5nZWRMYW5lcyxnPWMmMjY4NDM1NDU1O2lmKDAhPT1nKXt2YXIgaD1nJn5lOzAhPT1oP2Q9eGMoaCk6KGYmPWcsMCE9PWYmJihkPXhjKGYpKSl9ZWxzZSBnPWMmfmUsMCE9PWc/ZD14YyhnKTowIT09ZiYmKGQ9eGMoZikpO2lmKDA9PT1kKXJldHVybiAwO2lmKDAhPT1iJiZiIT09ZCYmMD09PShiJmUpJiYoZT1kJi1kLGY9YiYtYixlPj1mfHwxNj09PWUmJjAhPT0oZiY0MTk0MjQwKSkpcmV0dXJuIGI7MCE9PShkJjQpJiYoZHw9YyYxNik7Yj1hLmVudGFuZ2xlZExhbmVzO2lmKDAhPT1iKWZvcihhPWEuZW50YW5nbGVtZW50cyxiJj1kOzA8YjspYz0zMS1zYyhiKSxlPTE8PGMsZHw9YVtjXSxiJj1+ZTtyZXR1cm4gZH1cbmZ1bmN0aW9uIHpjKGEsYil7c3dpdGNoKGEpe2Nhc2UgMTpjYXNlIDI6Y2FzZSA0OnJldHVybiBiKzI1MDtjYXNlIDg6Y2FzZSAxNjpjYXNlIDMyOmNhc2UgNjQ6Y2FzZSAxMjg6Y2FzZSAyNTY6Y2FzZSA1MTI6Y2FzZSAxMDI0OmNhc2UgMjA0ODpjYXNlIDQwOTY6Y2FzZSA4MTkyOmNhc2UgMTYzODQ6Y2FzZSAzMjc2ODpjYXNlIDY1NTM2OmNhc2UgMTMxMDcyOmNhc2UgMjYyMTQ0OmNhc2UgNTI0Mjg4OmNhc2UgMTA0ODU3NjpjYXNlIDIwOTcxNTI6cmV0dXJuIGIrNUUzO2Nhc2UgNDE5NDMwNDpjYXNlIDgzODg2MDg6Y2FzZSAxNjc3NzIxNjpjYXNlIDMzNTU0NDMyOmNhc2UgNjcxMDg4NjQ6cmV0dXJuLTE7Y2FzZSAxMzQyMTc3Mjg6Y2FzZSAyNjg0MzU0NTY6Y2FzZSA1MzY4NzA5MTI6Y2FzZSAxMDczNzQxODI0OnJldHVybi0xO2RlZmF1bHQ6cmV0dXJuLTF9fVxuZnVuY3Rpb24gQWMoYSxiKXtmb3IodmFyIGM9YS5zdXNwZW5kZWRMYW5lcyxkPWEucGluZ2VkTGFuZXMsZT1hLmV4cGlyYXRpb25UaW1lcyxmPWEucGVuZGluZ0xhbmVzOzA8Zjspe3ZhciBnPTMxLXNjKGYpLGg9MTw8ZyxrPWVbZ107aWYoLTE9PT1rKXtpZigwPT09KGgmYyl8fDAhPT0oaCZkKSllW2ddPXpjKGgsYil9ZWxzZSBrPD1iJiYoYS5leHBpcmVkTGFuZXN8PWgpO2YmPX5ofX1mdW5jdGlvbiBCYyhhKXthPWEucGVuZGluZ0xhbmVzJi0xMDczNzQxODI1O3JldHVybiAwIT09YT9hOmEmMTA3Mzc0MTgyND8xMDczNzQxODI0OjB9ZnVuY3Rpb24gQ2MoKXt2YXIgYT12Yzt2Yzw8PTE7MD09PSh2YyY0MTk0MjQwKSYmKHZjPTY0KTtyZXR1cm4gYX1mdW5jdGlvbiBEYyhhKXtmb3IodmFyIGI9W10sYz0wOzMxPmM7YysrKWIucHVzaChhKTtyZXR1cm4gYn1cbmZ1bmN0aW9uIEVjKGEsYixjKXthLnBlbmRpbmdMYW5lc3w9Yjs1MzY4NzA5MTIhPT1iJiYoYS5zdXNwZW5kZWRMYW5lcz0wLGEucGluZ2VkTGFuZXM9MCk7YT1hLmV2ZW50VGltZXM7Yj0zMS1zYyhiKTthW2JdPWN9ZnVuY3Rpb24gRmMoYSxiKXt2YXIgYz1hLnBlbmRpbmdMYW5lcyZ+YjthLnBlbmRpbmdMYW5lcz1iO2Euc3VzcGVuZGVkTGFuZXM9MDthLnBpbmdlZExhbmVzPTA7YS5leHBpcmVkTGFuZXMmPWI7YS5tdXRhYmxlUmVhZExhbmVzJj1iO2EuZW50YW5nbGVkTGFuZXMmPWI7Yj1hLmVudGFuZ2xlbWVudHM7dmFyIGQ9YS5ldmVudFRpbWVzO2ZvcihhPWEuZXhwaXJhdGlvblRpbWVzOzA8Yzspe3ZhciBlPTMxLXNjKGMpLGY9MTw8ZTtiW2VdPTA7ZFtlXT0tMTthW2VdPS0xO2MmPX5mfX1cbmZ1bmN0aW9uIEdjKGEsYil7dmFyIGM9YS5lbnRhbmdsZWRMYW5lc3w9Yjtmb3IoYT1hLmVudGFuZ2xlbWVudHM7Yzspe3ZhciBkPTMxLXNjKGMpLGU9MTw8ZDtlJmJ8YVtkXSZiJiYoYVtkXXw9Yik7YyY9fmV9fXZhciBDPTA7ZnVuY3Rpb24gSGMoYSl7YSY9LWE7cmV0dXJuIDE8YT80PGE/MCE9PShhJjI2ODQzNTQ1NSk/MTY6NTM2ODcwOTEyOjQ6MX12YXIgSWM9YmEudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayxKYz1iYS51bnN0YWJsZV9jYW5jZWxDYWxsYmFjayxLYz1iYS51bnN0YWJsZV9zaG91bGRZaWVsZCxMYz1iYS51bnN0YWJsZV9yZXF1ZXN0UGFpbnQsRD1iYS51bnN0YWJsZV9ub3csTWM9YmEudW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHksTmM9YmEudW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHksT2M9YmEudW5zdGFibGVfTm9ybWFsUHJpb3JpdHksUGM9YmEudW5zdGFibGVfSWRsZVByaW9yaXR5LFFjPW51bGwsUmM9bnVsbDtcbmZ1bmN0aW9uIFNjKGEpe2lmKFJjJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgUmMub25Db21taXRGaWJlclJvb3QpdHJ5e1JjLm9uQ29tbWl0RmliZXJSb290KFFjLGEsdm9pZCAwLDEyOD09PShhLmN1cnJlbnQuZmxhZ3MmMTI4KSl9Y2F0Y2goYil7fX1mdW5jdGlvbiBUYyhhLGIpe3JldHVybiBhPT09YiYmKDAhPT1hfHwxL2E9PT0xL2IpfHxhIT09YSYmYiE9PWJ9dmFyIFVjPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBPYmplY3QuaXM/T2JqZWN0LmlzOlRjLFZjPW51bGwsV2M9ITEsWGM9ITE7ZnVuY3Rpb24gWWMoYSl7bnVsbD09PVZjP1ZjPVthXTpWYy5wdXNoKGEpfWZ1bmN0aW9uIFpjKGEpe1djPSEwO1ljKGEpfVxuZnVuY3Rpb24gJGMoKXtpZighWGMmJm51bGwhPT1WYyl7WGM9ITA7dmFyIGE9MCxiPUM7dHJ5e3ZhciBjPVZjO2ZvcihDPTE7YTxjLmxlbmd0aDthKyspe3ZhciBkPWNbYV07ZG8gZD1kKCEwKTt3aGlsZShudWxsIT09ZCl9VmM9bnVsbDtXYz0hMX1jYXRjaChlKXt0aHJvdyBudWxsIT09VmMmJihWYz1WYy5zbGljZShhKzEpKSxJYyhNYywkYyksZTt9ZmluYWxseXtDPWIsWGM9ITF9fXJldHVybiBudWxsfXZhciBhZD1kYS5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZztcbmZ1bmN0aW9uIGJkKGEsYil7aWYoVWMoYSxiKSlyZXR1cm4hMDtpZihcIm9iamVjdFwiIT09dHlwZW9mIGF8fG51bGw9PT1hfHxcIm9iamVjdFwiIT09dHlwZW9mIGJ8fG51bGw9PT1iKXJldHVybiExO3ZhciBjPU9iamVjdC5rZXlzKGEpLGQ9T2JqZWN0LmtleXMoYik7aWYoYy5sZW5ndGghPT1kLmxlbmd0aClyZXR1cm4hMTtmb3IoZD0wO2Q8Yy5sZW5ndGg7ZCsrKXt2YXIgZT1jW2RdO2lmKCFlYy5jYWxsKGIsZSl8fCFVYyhhW2VdLGJbZV0pKXJldHVybiExfXJldHVybiEwfVxuZnVuY3Rpb24gY2QoYSl7c3dpdGNoKGEudGFnKXtjYXNlIDU6cmV0dXJuIGJjKGEudHlwZSk7Y2FzZSAxNjpyZXR1cm4gYmMoXCJMYXp5XCIpO2Nhc2UgMTM6cmV0dXJuIGJjKFwiU3VzcGVuc2VcIik7Y2FzZSAxOTpyZXR1cm4gYmMoXCJTdXNwZW5zZUxpc3RcIik7Y2FzZSAwOmNhc2UgMjpjYXNlIDE1OnJldHVybiBhPWRjKGEudHlwZSwhMSksYTtjYXNlIDExOnJldHVybiBhPWRjKGEudHlwZS5yZW5kZXIsITEpLGE7Y2FzZSAxOnJldHVybiBhPWRjKGEudHlwZSwhMCksYTtkZWZhdWx0OnJldHVyblwiXCJ9fWZ1bmN0aW9uIGRkKGEsYil7aWYoYSYmYS5kZWZhdWx0UHJvcHMpe2I9Y2Eoe30sYik7YT1hLmRlZmF1bHRQcm9wcztmb3IodmFyIGMgaW4gYSl2b2lkIDA9PT1iW2NdJiYoYltjXT1hW2NdKTtyZXR1cm4gYn1yZXR1cm4gYn12YXIgZWQ9aGMobnVsbCksZmQ9bnVsbCxnZD1udWxsLGhkPW51bGw7ZnVuY3Rpb24gaWQoKXtoZD1nZD1mZD1udWxsfVxuZnVuY3Rpb24gamQoYSxiLGMpe1NhPyh2KGVkLGIuX2N1cnJlbnRWYWx1ZSksYi5fY3VycmVudFZhbHVlPWMpOih2KGVkLGIuX2N1cnJlbnRWYWx1ZTIpLGIuX2N1cnJlbnRWYWx1ZTI9Yyl9ZnVuY3Rpb24ga2QoYSl7dmFyIGI9ZWQuY3VycmVudDtwKGVkKTtTYT9hLl9jdXJyZW50VmFsdWU9YjphLl9jdXJyZW50VmFsdWUyPWJ9ZnVuY3Rpb24gbGQoYSxiLGMpe2Zvcig7bnVsbCE9PWE7KXt2YXIgZD1hLmFsdGVybmF0ZTsoYS5jaGlsZExhbmVzJmIpIT09Yj8oYS5jaGlsZExhbmVzfD1iLG51bGwhPT1kJiYoZC5jaGlsZExhbmVzfD1iKSk6bnVsbCE9PWQmJihkLmNoaWxkTGFuZXMmYikhPT1iJiYoZC5jaGlsZExhbmVzfD1iKTtpZihhPT09YylicmVhazthPWEucmV0dXJufX1cbmZ1bmN0aW9uIG1kKGEsYil7ZmQ9YTtoZD1nZD1udWxsO2E9YS5kZXBlbmRlbmNpZXM7bnVsbCE9PWEmJm51bGwhPT1hLmZpcnN0Q29udGV4dCYmKDAhPT0oYS5sYW5lcyZiKSYmKEY9ITApLGEuZmlyc3RDb250ZXh0PW51bGwpfWZ1bmN0aW9uIG5kKGEpe3ZhciBiPVNhP2EuX2N1cnJlbnRWYWx1ZTphLl9jdXJyZW50VmFsdWUyO2lmKGhkIT09YSlpZihhPXtjb250ZXh0OmEsbWVtb2l6ZWRWYWx1ZTpiLG5leHQ6bnVsbH0sbnVsbD09PWdkKXtpZihudWxsPT09ZmQpdGhyb3cgRXJyb3IobigzMDgpKTtnZD1hO2ZkLmRlcGVuZGVuY2llcz17bGFuZXM6MCxmaXJzdENvbnRleHQ6YX19ZWxzZSBnZD1nZC5uZXh0PWE7cmV0dXJuIGJ9dmFyIG9kPW51bGwscGQ9ITE7XG5mdW5jdGlvbiBxZChhKXthLnVwZGF0ZVF1ZXVlPXtiYXNlU3RhdGU6YS5tZW1vaXplZFN0YXRlLGZpcnN0QmFzZVVwZGF0ZTpudWxsLGxhc3RCYXNlVXBkYXRlOm51bGwsc2hhcmVkOntwZW5kaW5nOm51bGwsaW50ZXJsZWF2ZWQ6bnVsbCxsYW5lczowfSxlZmZlY3RzOm51bGx9fWZ1bmN0aW9uIHJkKGEsYil7YT1hLnVwZGF0ZVF1ZXVlO2IudXBkYXRlUXVldWU9PT1hJiYoYi51cGRhdGVRdWV1ZT17YmFzZVN0YXRlOmEuYmFzZVN0YXRlLGZpcnN0QmFzZVVwZGF0ZTphLmZpcnN0QmFzZVVwZGF0ZSxsYXN0QmFzZVVwZGF0ZTphLmxhc3RCYXNlVXBkYXRlLHNoYXJlZDphLnNoYXJlZCxlZmZlY3RzOmEuZWZmZWN0c30pfWZ1bmN0aW9uIHNkKGEsYil7cmV0dXJue2V2ZW50VGltZTphLGxhbmU6Yix0YWc6MCxwYXlsb2FkOm51bGwsY2FsbGJhY2s6bnVsbCxuZXh0Om51bGx9fVxuZnVuY3Rpb24gdGQoYSxiKXt2YXIgYz1hLnVwZGF0ZVF1ZXVlO251bGwhPT1jJiYoYz1jLnNoYXJlZCx1ZChhKT8oYT1jLmludGVybGVhdmVkLG51bGw9PT1hPyhiLm5leHQ9YixudWxsPT09b2Q/b2Q9W2NdOm9kLnB1c2goYykpOihiLm5leHQ9YS5uZXh0LGEubmV4dD1iKSxjLmludGVybGVhdmVkPWIpOihhPWMucGVuZGluZyxudWxsPT09YT9iLm5leHQ9YjooYi5uZXh0PWEubmV4dCxhLm5leHQ9YiksYy5wZW5kaW5nPWIpKX1mdW5jdGlvbiB2ZChhLGIsYyl7Yj1iLnVwZGF0ZVF1ZXVlO2lmKG51bGwhPT1iJiYoYj1iLnNoYXJlZCwwIT09KGMmNDE5NDI0MCkpKXt2YXIgZD1iLmxhbmVzO2QmPWEucGVuZGluZ0xhbmVzO2N8PWQ7Yi5sYW5lcz1jO0djKGEsYyl9fVxuZnVuY3Rpb24gd2QoYSxiKXt2YXIgYz1hLnVwZGF0ZVF1ZXVlLGQ9YS5hbHRlcm5hdGU7aWYobnVsbCE9PWQmJihkPWQudXBkYXRlUXVldWUsYz09PWQpKXt2YXIgZT1udWxsLGY9bnVsbDtjPWMuZmlyc3RCYXNlVXBkYXRlO2lmKG51bGwhPT1jKXtkb3t2YXIgZz17ZXZlbnRUaW1lOmMuZXZlbnRUaW1lLGxhbmU6Yy5sYW5lLHRhZzpjLnRhZyxwYXlsb2FkOmMucGF5bG9hZCxjYWxsYmFjazpjLmNhbGxiYWNrLG5leHQ6bnVsbH07bnVsbD09PWY/ZT1mPWc6Zj1mLm5leHQ9ZztjPWMubmV4dH13aGlsZShudWxsIT09Yyk7bnVsbD09PWY/ZT1mPWI6Zj1mLm5leHQ9Yn1lbHNlIGU9Zj1iO2M9e2Jhc2VTdGF0ZTpkLmJhc2VTdGF0ZSxmaXJzdEJhc2VVcGRhdGU6ZSxsYXN0QmFzZVVwZGF0ZTpmLHNoYXJlZDpkLnNoYXJlZCxlZmZlY3RzOmQuZWZmZWN0c307YS51cGRhdGVRdWV1ZT1jO3JldHVybn1hPWMubGFzdEJhc2VVcGRhdGU7bnVsbD09PWE/Yy5maXJzdEJhc2VVcGRhdGU9YjphLm5leHQ9XG5iO2MubGFzdEJhc2VVcGRhdGU9Yn1cbmZ1bmN0aW9uIHhkKGEsYixjLGQpe3ZhciBlPWEudXBkYXRlUXVldWU7cGQ9ITE7dmFyIGY9ZS5maXJzdEJhc2VVcGRhdGUsZz1lLmxhc3RCYXNlVXBkYXRlLGg9ZS5zaGFyZWQucGVuZGluZztpZihudWxsIT09aCl7ZS5zaGFyZWQucGVuZGluZz1udWxsO3ZhciBrPWgsbD1rLm5leHQ7ay5uZXh0PW51bGw7bnVsbD09PWc/Zj1sOmcubmV4dD1sO2c9azt2YXIgbT1hLmFsdGVybmF0ZTtudWxsIT09bSYmKG09bS51cGRhdGVRdWV1ZSxoPW0ubGFzdEJhc2VVcGRhdGUsaCE9PWcmJihudWxsPT09aD9tLmZpcnN0QmFzZVVwZGF0ZT1sOmgubmV4dD1sLG0ubGFzdEJhc2VVcGRhdGU9aykpfWlmKG51bGwhPT1mKXt2YXIgcj1lLmJhc2VTdGF0ZTtnPTA7bT1sPWs9bnVsbDtoPWY7ZG97dmFyIHE9aC5sYW5lLEI9aC5ldmVudFRpbWU7aWYoKGQmcSk9PT1xKXtudWxsIT09bSYmKG09bS5uZXh0PXtldmVudFRpbWU6QixsYW5lOjAsdGFnOmgudGFnLHBheWxvYWQ6aC5wYXlsb2FkLGNhbGxiYWNrOmguY2FsbGJhY2ssXG5uZXh0Om51bGx9KTthOnt2YXIgdz1hLFo9aDtxPWI7Qj1jO3N3aXRjaChaLnRhZyl7Y2FzZSAxOnc9Wi5wYXlsb2FkO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiB3KXtyPXcuY2FsbChCLHIscSk7YnJlYWsgYX1yPXc7YnJlYWsgYTtjYXNlIDM6dy5mbGFncz13LmZsYWdzJi02NTUzN3wxMjg7Y2FzZSAwOnc9Wi5wYXlsb2FkO3E9XCJmdW5jdGlvblwiPT09dHlwZW9mIHc/dy5jYWxsKEIscixxKTp3O2lmKG51bGw9PT1xfHx2b2lkIDA9PT1xKWJyZWFrIGE7cj1jYSh7fSxyLHEpO2JyZWFrIGE7Y2FzZSAyOnBkPSEwfX1udWxsIT09aC5jYWxsYmFjayYmMCE9PWgubGFuZSYmKGEuZmxhZ3N8PTY0LHE9ZS5lZmZlY3RzLG51bGw9PT1xP2UuZWZmZWN0cz1baF06cS5wdXNoKGgpKX1lbHNlIEI9e2V2ZW50VGltZTpCLGxhbmU6cSx0YWc6aC50YWcscGF5bG9hZDpoLnBheWxvYWQsY2FsbGJhY2s6aC5jYWxsYmFjayxuZXh0Om51bGx9LG51bGw9PT1tPyhsPW09QixrPXIpOm09bS5uZXh0PUIsZ3w9XG5xO2g9aC5uZXh0O2lmKG51bGw9PT1oKWlmKGg9ZS5zaGFyZWQucGVuZGluZyxudWxsPT09aClicmVhaztlbHNlIHE9aCxoPXEubmV4dCxxLm5leHQ9bnVsbCxlLmxhc3RCYXNlVXBkYXRlPXEsZS5zaGFyZWQucGVuZGluZz1udWxsfXdoaWxlKDEpO251bGw9PT1tJiYoaz1yKTtlLmJhc2VTdGF0ZT1rO2UuZmlyc3RCYXNlVXBkYXRlPWw7ZS5sYXN0QmFzZVVwZGF0ZT1tO2I9ZS5zaGFyZWQuaW50ZXJsZWF2ZWQ7aWYobnVsbCE9PWIpe2U9YjtkbyBnfD1lLmxhbmUsZT1lLm5leHQ7d2hpbGUoZSE9PWIpfWVsc2UgbnVsbD09PWYmJihlLnNoYXJlZC5sYW5lcz0wKTt5ZHw9ZzthLmxhbmVzPWc7YS5tZW1vaXplZFN0YXRlPXJ9fVxuZnVuY3Rpb24gemQoYSxiLGMpe2E9Yi5lZmZlY3RzO2IuZWZmZWN0cz1udWxsO2lmKG51bGwhPT1hKWZvcihiPTA7YjxhLmxlbmd0aDtiKyspe3ZhciBkPWFbYl0sZT1kLmNhbGxiYWNrO2lmKG51bGwhPT1lKXtkLmNhbGxiYWNrPW51bGw7ZD1jO2lmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBlKXRocm93IEVycm9yKG4oMTkxLGUpKTtlLmNhbGwoZCl9fX12YXIgQWQ9KG5ldyBhYS5Db21wb25lbnQpLnJlZnM7ZnVuY3Rpb24gQmQoYSxiLGMsZCl7Yj1hLm1lbW9pemVkU3RhdGU7Yz1jKGQsYik7Yz1udWxsPT09Y3x8dm9pZCAwPT09Yz9iOmNhKHt9LGIsYyk7YS5tZW1vaXplZFN0YXRlPWM7MD09PWEubGFuZXMmJihhLnVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZT1jKX1cbnZhciBFZD17aXNNb3VudGVkOmZ1bmN0aW9uKGEpe3JldHVybihhPWEuX3JlYWN0SW50ZXJuYWxzKT93YShhKT09PWE6ITF9LGVucXVldWVTZXRTdGF0ZTpmdW5jdGlvbihhLGIsYyl7YT1hLl9yZWFjdEludGVybmFsczt2YXIgZD1HKCksZT1DZChhKSxmPXNkKGQsZSk7Zi5wYXlsb2FkPWI7dm9pZCAwIT09YyYmbnVsbCE9PWMmJihmLmNhbGxiYWNrPWMpO3RkKGEsZik7Yj1EZChhLGUsZCk7bnVsbCE9PWImJnZkKGIsYSxlKX0sZW5xdWV1ZVJlcGxhY2VTdGF0ZTpmdW5jdGlvbihhLGIsYyl7YT1hLl9yZWFjdEludGVybmFsczt2YXIgZD1HKCksZT1DZChhKSxmPXNkKGQsZSk7Zi50YWc9MTtmLnBheWxvYWQ9Yjt2b2lkIDAhPT1jJiZudWxsIT09YyYmKGYuY2FsbGJhY2s9Yyk7dGQoYSxmKTtiPURkKGEsZSxkKTtudWxsIT09YiYmdmQoYixhLGUpfSxlbnF1ZXVlRm9yY2VVcGRhdGU6ZnVuY3Rpb24oYSxiKXthPWEuX3JlYWN0SW50ZXJuYWxzO3ZhciBjPUcoKSxkPUNkKGEpLGU9c2QoYyxcbmQpO2UudGFnPTI7dm9pZCAwIT09YiYmbnVsbCE9PWImJihlLmNhbGxiYWNrPWIpO3RkKGEsZSk7Yj1EZChhLGQsYyk7bnVsbCE9PWImJnZkKGIsYSxkKX19O2Z1bmN0aW9uIEZkKGEsYixjLGQsZSxmLGcpe2E9YS5zdGF0ZU5vZGU7cmV0dXJuXCJmdW5jdGlvblwiPT09dHlwZW9mIGEuc2hvdWxkQ29tcG9uZW50VXBkYXRlP2Euc2hvdWxkQ29tcG9uZW50VXBkYXRlKGQsZixnKTpiLnByb3RvdHlwZSYmYi5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQ/IWJkKGMsZCl8fCFiZChlLGYpOiEwfVxuZnVuY3Rpb24gR2QoYSxiLGMpe3ZhciBkPSExLGU9aWM7dmFyIGY9Yi5jb250ZXh0VHlwZTtcIm9iamVjdFwiPT09dHlwZW9mIGYmJm51bGwhPT1mP2Y9bmQoZik6KGU9QShiKT9qYzp4LmN1cnJlbnQsZD1iLmNvbnRleHRUeXBlcyxmPShkPW51bGwhPT1kJiZ2b2lkIDAhPT1kKT9rYyhhLGUpOmljKTtiPW5ldyBiKGMsZik7YS5tZW1vaXplZFN0YXRlPW51bGwhPT1iLnN0YXRlJiZ2b2lkIDAhPT1iLnN0YXRlP2Iuc3RhdGU6bnVsbDtiLnVwZGF0ZXI9RWQ7YS5zdGF0ZU5vZGU9YjtiLl9yZWFjdEludGVybmFscz1hO2QmJihhPWEuc3RhdGVOb2RlLGEuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dD1lLGEuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ9Zik7cmV0dXJuIGJ9XG5mdW5jdGlvbiBIZChhLGIsYyxkKXthPWIuc3RhdGU7XCJmdW5jdGlvblwiPT09dHlwZW9mIGIuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyYmYi5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKGMsZCk7XCJmdW5jdGlvblwiPT09dHlwZW9mIGIuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMmJmIuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoYyxkKTtiLnN0YXRlIT09YSYmRWQuZW5xdWV1ZVJlcGxhY2VTdGF0ZShiLGIuc3RhdGUsbnVsbCl9XG5mdW5jdGlvbiBJZChhLGIsYyxkKXt2YXIgZT1hLnN0YXRlTm9kZTtlLnByb3BzPWM7ZS5zdGF0ZT1hLm1lbW9pemVkU3RhdGU7ZS5yZWZzPUFkO3FkKGEpO3ZhciBmPWIuY29udGV4dFR5cGU7XCJvYmplY3RcIj09PXR5cGVvZiBmJiZudWxsIT09Zj9lLmNvbnRleHQ9bmQoZik6KGY9QShiKT9qYzp4LmN1cnJlbnQsZS5jb250ZXh0PWtjKGEsZikpO2Uuc3RhdGU9YS5tZW1vaXplZFN0YXRlO2Y9Yi5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XCJmdW5jdGlvblwiPT09dHlwZW9mIGYmJihCZChhLGIsZixjKSxlLnN0YXRlPWEubWVtb2l6ZWRTdGF0ZSk7XCJmdW5jdGlvblwiPT09dHlwZW9mIGIuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzfHxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXx8XCJmdW5jdGlvblwiIT09dHlwZW9mIGUuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGUuY29tcG9uZW50V2lsbE1vdW50fHwoYj1lLnN0YXRlLFxuXCJmdW5jdGlvblwiPT09dHlwZW9mIGUuY29tcG9uZW50V2lsbE1vdW50JiZlLmNvbXBvbmVudFdpbGxNb3VudCgpLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQmJmUuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpLGIhPT1lLnN0YXRlJiZFZC5lbnF1ZXVlUmVwbGFjZVN0YXRlKGUsZS5zdGF0ZSxudWxsKSx4ZChhLGMsZSxkKSxlLnN0YXRlPWEubWVtb2l6ZWRTdGF0ZSk7XCJmdW5jdGlvblwiPT09dHlwZW9mIGUuY29tcG9uZW50RGlkTW91bnQmJihhLmZsYWdzfD00MTk0MzA4KX12YXIgSmQ9W10sS2Q9MCxMZD1udWxsLE1kPTAsTmQ9W10sT2Q9MCxQZD1udWxsLFFkPTEsUmQ9XCJcIjtmdW5jdGlvbiBTZChhLGIpe0pkW0tkKytdPU1kO0pkW0tkKytdPUxkO0xkPWE7TWQ9Yn1cbmZ1bmN0aW9uIFRkKGEsYixjKXtOZFtPZCsrXT1RZDtOZFtPZCsrXT1SZDtOZFtPZCsrXT1QZDtQZD1hO3ZhciBkPVFkO2E9UmQ7dmFyIGU9MzItc2MoZCktMTtkJj1+KDE8PGUpO2MrPTE7dmFyIGY9MzItc2MoYikrZTtpZigzMDxmKXt2YXIgZz1lLWUlNTtmPShkJigxPDxnKS0xKS50b1N0cmluZygzMik7ZD4+PWc7ZS09ZztRZD0xPDwzMi1zYyhiKStlfGM8PGV8ZDtSZD1mK2F9ZWxzZSBRZD0xPDxmfGM8PGV8ZCxSZD1hfWZ1bmN0aW9uIFVkKGEpe251bGwhPT1hLnJldHVybiYmKFNkKGEsMSksVGQoYSwxLDApKX1mdW5jdGlvbiBWZChhKXtmb3IoO2E9PT1MZDspTGQ9SmRbLS1LZF0sSmRbS2RdPW51bGwsTWQ9SmRbLS1LZF0sSmRbS2RdPW51bGw7Zm9yKDthPT09UGQ7KVBkPU5kWy0tT2RdLE5kW09kXT1udWxsLFJkPU5kWy0tT2RdLE5kW09kXT1udWxsLFFkPU5kWy0tT2RdLE5kW09kXT1udWxsfXZhciBXZD1udWxsLFhkPW51bGwsSD0hMSxZZD0hMSxaZD1udWxsO1xuZnVuY3Rpb24gJGQoYSxiKXt2YXIgYz1hZSg1LG51bGwsbnVsbCwwKTtjLmVsZW1lbnRUeXBlPVwiREVMRVRFRFwiO2Muc3RhdGVOb2RlPWI7Yy5yZXR1cm49YTtiPWEuZGVsZXRpb25zO251bGw9PT1iPyhhLmRlbGV0aW9ucz1bY10sYS5mbGFnc3w9MTYpOmIucHVzaChjKX1cbmZ1bmN0aW9uIGJlKGEsYil7c3dpdGNoKGEudGFnKXtjYXNlIDU6cmV0dXJuIGI9R2IoYixhLnR5cGUsYS5wZW5kaW5nUHJvcHMpLG51bGwhPT1iPyhhLnN0YXRlTm9kZT1iLFdkPWEsWGQ9TmIoYiksITApOiExO2Nhc2UgNjpyZXR1cm4gYj1IYihiLGEucGVuZGluZ1Byb3BzKSxudWxsIT09Yj8oYS5zdGF0ZU5vZGU9YixXZD1hLFhkPW51bGwsITApOiExO2Nhc2UgMTM6Yj1JYihiKTtpZihudWxsIT09Yil7dmFyIGM9bnVsbCE9PVBkP3tpZDpRZCxvdmVyZmxvdzpSZH06bnVsbDthLm1lbW9pemVkU3RhdGU9e2RlaHlkcmF0ZWQ6Yix0cmVlQ29udGV4dDpjLHJldHJ5TGFuZToxMDczNzQxODI0fTtjPWFlKDE4LG51bGwsbnVsbCwwKTtjLnN0YXRlTm9kZT1iO2MucmV0dXJuPWE7YS5jaGlsZD1jO1dkPWE7WGQ9bnVsbDtyZXR1cm4hMH1yZXR1cm4hMTtkZWZhdWx0OnJldHVybiExfX1mdW5jdGlvbiBjZShhKXtyZXR1cm4gMCE9PShhLm1vZGUmMSkmJjA9PT0oYS5mbGFncyYxMjgpfVxuZnVuY3Rpb24gZGUoYSl7aWYoSCl7dmFyIGI9WGQ7aWYoYil7dmFyIGM9YjtpZighYmUoYSxiKSl7aWYoY2UoYSkpdGhyb3cgRXJyb3Iobig0MTgpKTtiPU1iKGMpO3ZhciBkPVdkO2ImJmJlKGEsYik/JGQoZCxjKTooYS5mbGFncz1hLmZsYWdzJi00MDk3fDIsSD0hMSxXZD1hKX19ZWxzZXtpZihjZShhKSl0aHJvdyBFcnJvcihuKDQxOCkpO2EuZmxhZ3M9YS5mbGFncyYtNDA5N3wyO0g9ITE7V2Q9YX19fWZ1bmN0aW9uIGVlKGEpe2ZvcihhPWEucmV0dXJuO251bGwhPT1hJiY1IT09YS50YWcmJjMhPT1hLnRhZyYmMTMhPT1hLnRhZzspYT1hLnJldHVybjtXZD1hfVxuZnVuY3Rpb24gZmUoYSl7aWYoIVZhfHxhIT09V2QpcmV0dXJuITE7aWYoIUgpcmV0dXJuIGVlKGEpLEg9ITAsITE7aWYoMyE9PWEudGFnJiYoNSE9PWEudGFnfHxZYihhLnR5cGUpJiYhTmEoYS50eXBlLGEubWVtb2l6ZWRQcm9wcykpKXt2YXIgYj1YZDtpZihiKXtpZihjZShhKSl7Zm9yKGE9WGQ7YTspYT1NYihhKTt0aHJvdyBFcnJvcihuKDQxOCkpO31mb3IoO2I7KSRkKGEsYiksYj1NYihiKX19ZWUoYSk7aWYoMTM9PT1hLnRhZyl7aWYoIVZhKXRocm93IEVycm9yKG4oMzE2KSk7YT1hLm1lbW9pemVkU3RhdGU7YT1udWxsIT09YT9hLmRlaHlkcmF0ZWQ6bnVsbDtpZighYSl0aHJvdyBFcnJvcihuKDMxNykpO1hkPVRiKGEpfWVsc2UgWGQ9V2Q/TWIoYS5zdGF0ZU5vZGUpOm51bGw7cmV0dXJuITB9ZnVuY3Rpb24gZ2UoKXtWYSYmKFhkPVdkPW51bGwsWWQ9SD0hMSl9ZnVuY3Rpb24gaGUoYSl7bnVsbD09PVpkP1pkPVthXTpaZC5wdXNoKGEpfVxuZnVuY3Rpb24gaWUoYSxiLGMpe2E9Yy5yZWY7aWYobnVsbCE9PWEmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBhJiZcIm9iamVjdFwiIT09dHlwZW9mIGEpe2lmKGMuX293bmVyKXtjPWMuX293bmVyO2lmKGMpe2lmKDEhPT1jLnRhZyl0aHJvdyBFcnJvcihuKDMwOSkpO3ZhciBkPWMuc3RhdGVOb2RlfWlmKCFkKXRocm93IEVycm9yKG4oMTQ3LGEpKTt2YXIgZT1kLGY9XCJcIithO2lmKG51bGwhPT1iJiZudWxsIT09Yi5yZWYmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBiLnJlZiYmYi5yZWYuX3N0cmluZ1JlZj09PWYpcmV0dXJuIGIucmVmO2I9ZnVuY3Rpb24oYSl7dmFyIGI9ZS5yZWZzO2I9PT1BZCYmKGI9ZS5yZWZzPXt9KTtudWxsPT09YT9kZWxldGUgYltmXTpiW2ZdPWF9O2IuX3N0cmluZ1JlZj1mO3JldHVybiBifWlmKFwic3RyaW5nXCIhPT10eXBlb2YgYSl0aHJvdyBFcnJvcihuKDI4NCkpO2lmKCFjLl9vd25lcil0aHJvdyBFcnJvcihuKDI5MCxhKSk7fXJldHVybiBhfVxuZnVuY3Rpb24gamUoYSxiKXthPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChiKTt0aHJvdyBFcnJvcihuKDMxLFwiW29iamVjdCBPYmplY3RdXCI9PT1hP1wib2JqZWN0IHdpdGgga2V5cyB7XCIrT2JqZWN0LmtleXMoYikuam9pbihcIiwgXCIpK1wifVwiOmEpKTt9ZnVuY3Rpb24ga2UoYSl7dmFyIGI9YS5faW5pdDtyZXR1cm4gYihhLl9wYXlsb2FkKX1cbmZ1bmN0aW9uIGxlKGEpe2Z1bmN0aW9uIGIoYixjKXtpZihhKXt2YXIgZD1iLmRlbGV0aW9ucztudWxsPT09ZD8oYi5kZWxldGlvbnM9W2NdLGIuZmxhZ3N8PTE2KTpkLnB1c2goYyl9fWZ1bmN0aW9uIGMoYyxkKXtpZighYSlyZXR1cm4gbnVsbDtmb3IoO251bGwhPT1kOyliKGMsZCksZD1kLnNpYmxpbmc7cmV0dXJuIG51bGx9ZnVuY3Rpb24gZChhLGIpe2ZvcihhPW5ldyBNYXA7bnVsbCE9PWI7KW51bGwhPT1iLmtleT9hLnNldChiLmtleSxiKTphLnNldChiLmluZGV4LGIpLGI9Yi5zaWJsaW5nO3JldHVybiBhfWZ1bmN0aW9uIGUoYSxiKXthPW1lKGEsYik7YS5pbmRleD0wO2Euc2libGluZz1udWxsO3JldHVybiBhfWZ1bmN0aW9uIGYoYixjLGQpe2IuaW5kZXg9ZDtpZighYSlyZXR1cm4gYi5mbGFnc3w9MTA0ODU3NixjO2Q9Yi5hbHRlcm5hdGU7aWYobnVsbCE9PWQpcmV0dXJuIGQ9ZC5pbmRleCxkPGM/KGIuZmxhZ3N8PTIsYyk6ZDtiLmZsYWdzfD0yO3JldHVybiBjfWZ1bmN0aW9uIGcoYil7YSYmXG5udWxsPT09Yi5hbHRlcm5hdGUmJihiLmZsYWdzfD0yKTtyZXR1cm4gYn1mdW5jdGlvbiBoKGEsYixjLGQpe2lmKG51bGw9PT1ifHw2IT09Yi50YWcpcmV0dXJuIGI9bmUoYyxhLm1vZGUsZCksYi5yZXR1cm49YSxiO2I9ZShiLGMpO2IucmV0dXJuPWE7cmV0dXJuIGJ9ZnVuY3Rpb24gayhhLGIsYyxkKXt2YXIgZj1jLnR5cGU7aWYoZj09PWhhKXJldHVybiBtKGEsYixjLnByb3BzLmNoaWxkcmVuLGQsYy5rZXkpO2lmKG51bGwhPT1iJiYoYi5lbGVtZW50VHlwZT09PWZ8fFwib2JqZWN0XCI9PT10eXBlb2YgZiYmbnVsbCE9PWYmJmYuJCR0eXBlb2Y9PT1xYSYma2UoZik9PT1iLnR5cGUpKXJldHVybiBkPWUoYixjLnByb3BzKSxkLnJlZj1pZShhLGIsYyksZC5yZXR1cm49YSxkO2Q9b2UoYy50eXBlLGMua2V5LGMucHJvcHMsbnVsbCxhLm1vZGUsZCk7ZC5yZWY9aWUoYSxiLGMpO2QucmV0dXJuPWE7cmV0dXJuIGR9ZnVuY3Rpb24gbChhLGIsYyxkKXtpZihudWxsPT09Ynx8NCE9PWIudGFnfHxcbmIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8hPT1jLmNvbnRhaW5lckluZm98fGIuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uIT09Yy5pbXBsZW1lbnRhdGlvbilyZXR1cm4gYj1wZShjLGEubW9kZSxkKSxiLnJldHVybj1hLGI7Yj1lKGIsYy5jaGlsZHJlbnx8W10pO2IucmV0dXJuPWE7cmV0dXJuIGJ9ZnVuY3Rpb24gbShhLGIsYyxkLGYpe2lmKG51bGw9PT1ifHw3IT09Yi50YWcpcmV0dXJuIGI9cWUoYyxhLm1vZGUsZCxmKSxiLnJldHVybj1hLGI7Yj1lKGIsYyk7Yi5yZXR1cm49YTtyZXR1cm4gYn1mdW5jdGlvbiByKGEsYixjKXtpZihcInN0cmluZ1wiPT09dHlwZW9mIGImJlwiXCIhPT1ifHxcIm51bWJlclwiPT09dHlwZW9mIGIpcmV0dXJuIGI9bmUoXCJcIitiLGEubW9kZSxjKSxiLnJldHVybj1hLGI7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBiJiZudWxsIT09Yil7c3dpdGNoKGIuJCR0eXBlb2Ype2Nhc2UgZWE6cmV0dXJuIGM9b2UoYi50eXBlLGIua2V5LGIucHJvcHMsbnVsbCxhLm1vZGUsYyksXG5jLnJlZj1pZShhLG51bGwsYiksYy5yZXR1cm49YSxjO2Nhc2UgZmE6cmV0dXJuIGI9cGUoYixhLm1vZGUsYyksYi5yZXR1cm49YSxiO2Nhc2UgcWE6dmFyIGQ9Yi5faW5pdDtyZXR1cm4gcihhLGQoYi5fcGF5bG9hZCksYyl9aWYoRGEoYil8fHRhKGIpKXJldHVybiBiPXFlKGIsYS5tb2RlLGMsbnVsbCksYi5yZXR1cm49YSxiO2plKGEsYil9cmV0dXJuIG51bGx9ZnVuY3Rpb24gcShhLGIsYyxkKXt2YXIgZT1udWxsIT09Yj9iLmtleTpudWxsO2lmKFwic3RyaW5nXCI9PT10eXBlb2YgYyYmXCJcIiE9PWN8fFwibnVtYmVyXCI9PT10eXBlb2YgYylyZXR1cm4gbnVsbCE9PWU/bnVsbDpoKGEsYixcIlwiK2MsZCk7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBjJiZudWxsIT09Yyl7c3dpdGNoKGMuJCR0eXBlb2Ype2Nhc2UgZWE6cmV0dXJuIGMua2V5PT09ZT9rKGEsYixjLGQpOm51bGw7Y2FzZSBmYTpyZXR1cm4gYy5rZXk9PT1lP2woYSxiLGMsZCk6bnVsbDtjYXNlIHFhOnJldHVybiBlPWMuX2luaXQscShhLFxuYixlKGMuX3BheWxvYWQpLGQpfWlmKERhKGMpfHx0YShjKSlyZXR1cm4gbnVsbCE9PWU/bnVsbDptKGEsYixjLGQsbnVsbCk7amUoYSxjKX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBCKGEsYixjLGQsZSl7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBkJiZcIlwiIT09ZHx8XCJudW1iZXJcIj09PXR5cGVvZiBkKXJldHVybiBhPWEuZ2V0KGMpfHxudWxsLGgoYixhLFwiXCIrZCxlKTtpZihcIm9iamVjdFwiPT09dHlwZW9mIGQmJm51bGwhPT1kKXtzd2l0Y2goZC4kJHR5cGVvZil7Y2FzZSBlYTpyZXR1cm4gYT1hLmdldChudWxsPT09ZC5rZXk/YzpkLmtleSl8fG51bGwsayhiLGEsZCxlKTtjYXNlIGZhOnJldHVybiBhPWEuZ2V0KG51bGw9PT1kLmtleT9jOmQua2V5KXx8bnVsbCxsKGIsYSxkLGUpO2Nhc2UgcWE6dmFyIGY9ZC5faW5pdDtyZXR1cm4gQihhLGIsYyxmKGQuX3BheWxvYWQpLGUpfWlmKERhKGQpfHx0YShkKSlyZXR1cm4gYT1hLmdldChjKXx8bnVsbCxtKGIsYSxkLGUsbnVsbCk7amUoYixkKX1yZXR1cm4gbnVsbH1cbmZ1bmN0aW9uIHcoZSxnLGgsayl7Zm9yKHZhciBsPW51bGwsbT1udWxsLHU9Zyx0PWc9MCxFPW51bGw7bnVsbCE9PXUmJnQ8aC5sZW5ndGg7dCsrKXt1LmluZGV4PnQ/KEU9dSx1PW51bGwpOkU9dS5zaWJsaW5nO3ZhciB5PXEoZSx1LGhbdF0sayk7aWYobnVsbD09PXkpe251bGw9PT11JiYodT1FKTticmVha31hJiZ1JiZudWxsPT09eS5hbHRlcm5hdGUmJmIoZSx1KTtnPWYoeSxnLHQpO251bGw9PT1tP2w9eTptLnNpYmxpbmc9eTttPXk7dT1FfWlmKHQ9PT1oLmxlbmd0aClyZXR1cm4gYyhlLHUpLEgmJlNkKGUsdCksbDtpZihudWxsPT09dSl7Zm9yKDt0PGgubGVuZ3RoO3QrKyl1PXIoZSxoW3RdLGspLG51bGwhPT11JiYoZz1mKHUsZyx0KSxudWxsPT09bT9sPXU6bS5zaWJsaW5nPXUsbT11KTtIJiZTZChlLHQpO3JldHVybiBsfWZvcih1PWQoZSx1KTt0PGgubGVuZ3RoO3QrKylFPUIodSxlLHQsaFt0XSxrKSxudWxsIT09RSYmKGEmJm51bGwhPT1FLmFsdGVybmF0ZSYmdS5kZWxldGUobnVsbD09PVxuRS5rZXk/dDpFLmtleSksZz1mKEUsZyx0KSxudWxsPT09bT9sPUU6bS5zaWJsaW5nPUUsbT1FKTthJiZ1LmZvckVhY2goZnVuY3Rpb24oYSl7cmV0dXJuIGIoZSxhKX0pO0gmJlNkKGUsdCk7cmV0dXJuIGx9ZnVuY3Rpb24gWihlLGcsaCxrKXt2YXIgbD10YShoKTtpZihcImZ1bmN0aW9uXCIhPT10eXBlb2YgbCl0aHJvdyBFcnJvcihuKDE1MCkpO2g9bC5jYWxsKGgpO2lmKG51bGw9PWgpdGhyb3cgRXJyb3IobigxNTEpKTtmb3IodmFyIHU9bD1udWxsLG09Zyx0PWc9MCxFPW51bGwseT1oLm5leHQoKTtudWxsIT09bSYmIXkuZG9uZTt0KysseT1oLm5leHQoKSl7bS5pbmRleD50PyhFPW0sbT1udWxsKTpFPW0uc2libGluZzt2YXIgdz1xKGUsbSx5LnZhbHVlLGspO2lmKG51bGw9PT13KXtudWxsPT09bSYmKG09RSk7YnJlYWt9YSYmbSYmbnVsbD09PXcuYWx0ZXJuYXRlJiZiKGUsbSk7Zz1mKHcsZyx0KTtudWxsPT09dT9sPXc6dS5zaWJsaW5nPXc7dT13O209RX1pZih5LmRvbmUpcmV0dXJuIGMoZSxcbm0pLEgmJlNkKGUsdCksbDtpZihudWxsPT09bSl7Zm9yKDsheS5kb25lO3QrKyx5PWgubmV4dCgpKXk9cihlLHkudmFsdWUsayksbnVsbCE9PXkmJihnPWYoeSxnLHQpLG51bGw9PT11P2w9eTp1LnNpYmxpbmc9eSx1PXkpO0gmJlNkKGUsdCk7cmV0dXJuIGx9Zm9yKG09ZChlLG0pOyF5LmRvbmU7dCsrLHk9aC5uZXh0KCkpeT1CKG0sZSx0LHkudmFsdWUsayksbnVsbCE9PXkmJihhJiZudWxsIT09eS5hbHRlcm5hdGUmJm0uZGVsZXRlKG51bGw9PT15LmtleT90Onkua2V5KSxnPWYoeSxnLHQpLG51bGw9PT11P2w9eTp1LnNpYmxpbmc9eSx1PXkpO2EmJm0uZm9yRWFjaChmdW5jdGlvbihhKXtyZXR1cm4gYihlLGEpfSk7SCYmU2QoZSx0KTtyZXR1cm4gbH1mdW5jdGlvbiB6YShhLGQsZixoKXtcIm9iamVjdFwiPT09dHlwZW9mIGYmJm51bGwhPT1mJiZmLnR5cGU9PT1oYSYmbnVsbD09PWYua2V5JiYoZj1mLnByb3BzLmNoaWxkcmVuKTtpZihcIm9iamVjdFwiPT09dHlwZW9mIGYmJm51bGwhPT1cbmYpe3N3aXRjaChmLiQkdHlwZW9mKXtjYXNlIGVhOmE6e2Zvcih2YXIgaz1mLmtleSxsPWQ7bnVsbCE9PWw7KXtpZihsLmtleT09PWspe2s9Zi50eXBlO2lmKGs9PT1oYSl7aWYoNz09PWwudGFnKXtjKGEsbC5zaWJsaW5nKTtkPWUobCxmLnByb3BzLmNoaWxkcmVuKTtkLnJldHVybj1hO2E9ZDticmVhayBhfX1lbHNlIGlmKGwuZWxlbWVudFR5cGU9PT1rfHxcIm9iamVjdFwiPT09dHlwZW9mIGsmJm51bGwhPT1rJiZrLiQkdHlwZW9mPT09cWEmJmtlKGspPT09bC50eXBlKXtjKGEsbC5zaWJsaW5nKTtkPWUobCxmLnByb3BzKTtkLnJlZj1pZShhLGwsZik7ZC5yZXR1cm49YTthPWQ7YnJlYWsgYX1jKGEsbCk7YnJlYWt9ZWxzZSBiKGEsbCk7bD1sLnNpYmxpbmd9Zi50eXBlPT09aGE/KGQ9cWUoZi5wcm9wcy5jaGlsZHJlbixhLm1vZGUsaCxmLmtleSksZC5yZXR1cm49YSxhPWQpOihoPW9lKGYudHlwZSxmLmtleSxmLnByb3BzLG51bGwsYS5tb2RlLGgpLGgucmVmPWllKGEsZCxmKSxoLnJldHVybj1cbmEsYT1oKX1yZXR1cm4gZyhhKTtjYXNlIGZhOmE6e2ZvcihsPWYua2V5O251bGwhPT1kOyl7aWYoZC5rZXk9PT1sKWlmKDQ9PT1kLnRhZyYmZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbz09PWYuY29udGFpbmVySW5mbyYmZC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb249PT1mLmltcGxlbWVudGF0aW9uKXtjKGEsZC5zaWJsaW5nKTtkPWUoZCxmLmNoaWxkcmVufHxbXSk7ZC5yZXR1cm49YTthPWQ7YnJlYWsgYX1lbHNle2MoYSxkKTticmVha31lbHNlIGIoYSxkKTtkPWQuc2libGluZ31kPXBlKGYsYS5tb2RlLGgpO2QucmV0dXJuPWE7YT1kfXJldHVybiBnKGEpO2Nhc2UgcWE6cmV0dXJuIGw9Zi5faW5pdCx6YShhLGQsbChmLl9wYXlsb2FkKSxoKX1pZihEYShmKSlyZXR1cm4gdyhhLGQsZixoKTtpZih0YShmKSlyZXR1cm4gWihhLGQsZixoKTtqZShhLGYpfXJldHVyblwic3RyaW5nXCI9PT10eXBlb2YgZiYmXCJcIiE9PWZ8fFwibnVtYmVyXCI9PT10eXBlb2YgZj8oZj1cIlwiK2YsbnVsbCE9PWQmJlxuNj09PWQudGFnPyhjKGEsZC5zaWJsaW5nKSxkPWUoZCxmKSxkLnJldHVybj1hLGE9ZCk6KGMoYSxkKSxkPW5lKGYsYS5tb2RlLGgpLGQucmV0dXJuPWEsYT1kKSxnKGEpKTpjKGEsZCl9cmV0dXJuIHphfXZhciByZT1sZSghMCksc2U9bGUoITEpLHRlPXt9LHVlPWhjKHRlKSx2ZT1oYyh0ZSksd2U9aGModGUpO2Z1bmN0aW9uIHhlKGEpe2lmKGE9PT10ZSl0aHJvdyBFcnJvcihuKDE3NCkpO3JldHVybiBhfWZ1bmN0aW9uIHllKGEsYil7dih3ZSxiKTt2KHZlLGEpO3YodWUsdGUpO2E9RmEoYik7cCh1ZSk7dih1ZSxhKX1mdW5jdGlvbiB6ZSgpe3AodWUpO3AodmUpO3Aod2UpfWZ1bmN0aW9uIEFlKGEpe3ZhciBiPXhlKHdlLmN1cnJlbnQpLGM9eGUodWUuY3VycmVudCk7Yj1HYShjLGEudHlwZSxiKTtjIT09YiYmKHYodmUsYSksdih1ZSxiKSl9ZnVuY3Rpb24gQmUoYSl7dmUuY3VycmVudD09PWEmJihwKHVlKSxwKHZlKSl9dmFyIEk9aGMoMCk7XG5mdW5jdGlvbiBDZShhKXtmb3IodmFyIGI9YTtudWxsIT09Yjspe2lmKDEzPT09Yi50YWcpe3ZhciBjPWIubWVtb2l6ZWRTdGF0ZTtpZihudWxsIT09YyYmKGM9Yy5kZWh5ZHJhdGVkLG51bGw9PT1jfHxKYihjKXx8S2IoYykpKXJldHVybiBifWVsc2UgaWYoMTk9PT1iLnRhZyYmdm9pZCAwIT09Yi5tZW1vaXplZFByb3BzLnJldmVhbE9yZGVyKXtpZigwIT09KGIuZmxhZ3MmMTI4KSlyZXR1cm4gYn1lbHNlIGlmKG51bGwhPT1iLmNoaWxkKXtiLmNoaWxkLnJldHVybj1iO2I9Yi5jaGlsZDtjb250aW51ZX1pZihiPT09YSlicmVhaztmb3IoO251bGw9PT1iLnNpYmxpbmc7KXtpZihudWxsPT09Yi5yZXR1cm58fGIucmV0dXJuPT09YSlyZXR1cm4gbnVsbDtiPWIucmV0dXJufWIuc2libGluZy5yZXR1cm49Yi5yZXR1cm47Yj1iLnNpYmxpbmd9cmV0dXJuIG51bGx9dmFyIERlPVtdO1xuZnVuY3Rpb24gRWUoKXtmb3IodmFyIGE9MDthPERlLmxlbmd0aDthKyspe3ZhciBiPURlW2FdO1NhP2IuX3dvcmtJblByb2dyZXNzVmVyc2lvblByaW1hcnk9bnVsbDpiLl93b3JrSW5Qcm9ncmVzc1ZlcnNpb25TZWNvbmRhcnk9bnVsbH1EZS5sZW5ndGg9MH12YXIgRmU9ZGEuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixHZT1kYS5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxIZT0wLEo9bnVsbCxLPW51bGwsTD1udWxsLEllPSExLEplPSExLEtlPTAsTGU9MDtmdW5jdGlvbiBNKCl7dGhyb3cgRXJyb3IobigzMjEpKTt9ZnVuY3Rpb24gTWUoYSxiKXtpZihudWxsPT09YilyZXR1cm4hMTtmb3IodmFyIGM9MDtjPGIubGVuZ3RoJiZjPGEubGVuZ3RoO2MrKylpZighVWMoYVtjXSxiW2NdKSlyZXR1cm4hMTtyZXR1cm4hMH1cbmZ1bmN0aW9uIE5lKGEsYixjLGQsZSxmKXtIZT1mO0o9YjtiLm1lbW9pemVkU3RhdGU9bnVsbDtiLnVwZGF0ZVF1ZXVlPW51bGw7Yi5sYW5lcz0wO0ZlLmN1cnJlbnQ9bnVsbD09PWF8fG51bGw9PT1hLm1lbW9pemVkU3RhdGU/T2U6UGU7YT1jKGQsZSk7aWYoSmUpe2Y9MDtkb3tKZT0hMTtLZT0wO2lmKDI1PD1mKXRocm93IEVycm9yKG4oMzAxKSk7Zis9MTtMPUs9bnVsbDtiLnVwZGF0ZVF1ZXVlPW51bGw7RmUuY3VycmVudD1RZTthPWMoZCxlKX13aGlsZShKZSl9RmUuY3VycmVudD1SZTtiPW51bGwhPT1LJiZudWxsIT09Sy5uZXh0O0hlPTA7TD1LPUo9bnVsbDtJZT0hMTtpZihiKXRocm93IEVycm9yKG4oMzAwKSk7cmV0dXJuIGF9ZnVuY3Rpb24gU2UoKXt2YXIgYT0wIT09S2U7S2U9MDtyZXR1cm4gYX1cbmZ1bmN0aW9uIFRlKCl7dmFyIGE9e21lbW9pemVkU3RhdGU6bnVsbCxiYXNlU3RhdGU6bnVsbCxiYXNlUXVldWU6bnVsbCxxdWV1ZTpudWxsLG5leHQ6bnVsbH07bnVsbD09PUw/Si5tZW1vaXplZFN0YXRlPUw9YTpMPUwubmV4dD1hO3JldHVybiBMfWZ1bmN0aW9uIFVlKCl7aWYobnVsbD09PUspe3ZhciBhPUouYWx0ZXJuYXRlO2E9bnVsbCE9PWE/YS5tZW1vaXplZFN0YXRlOm51bGx9ZWxzZSBhPUsubmV4dDt2YXIgYj1udWxsPT09TD9KLm1lbW9pemVkU3RhdGU6TC5uZXh0O2lmKG51bGwhPT1iKUw9YixLPWE7ZWxzZXtpZihudWxsPT09YSl0aHJvdyBFcnJvcihuKDMxMCkpO0s9YTthPXttZW1vaXplZFN0YXRlOksubWVtb2l6ZWRTdGF0ZSxiYXNlU3RhdGU6Sy5iYXNlU3RhdGUsYmFzZVF1ZXVlOksuYmFzZVF1ZXVlLHF1ZXVlOksucXVldWUsbmV4dDpudWxsfTtudWxsPT09TD9KLm1lbW9pemVkU3RhdGU9TD1hOkw9TC5uZXh0PWF9cmV0dXJuIEx9XG5mdW5jdGlvbiBWZShhLGIpe3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBiP2IoYSk6Yn1cbmZ1bmN0aW9uIFdlKGEpe3ZhciBiPVVlKCksYz1iLnF1ZXVlO2lmKG51bGw9PT1jKXRocm93IEVycm9yKG4oMzExKSk7Yy5sYXN0UmVuZGVyZWRSZWR1Y2VyPWE7dmFyIGQ9SyxlPWQuYmFzZVF1ZXVlLGY9Yy5wZW5kaW5nO2lmKG51bGwhPT1mKXtpZihudWxsIT09ZSl7dmFyIGc9ZS5uZXh0O2UubmV4dD1mLm5leHQ7Zi5uZXh0PWd9ZC5iYXNlUXVldWU9ZT1mO2MucGVuZGluZz1udWxsfWlmKG51bGwhPT1lKXtmPWUubmV4dDtkPWQuYmFzZVN0YXRlO3ZhciBoPWc9bnVsbCxrPW51bGwsbD1mO2Rve3ZhciBtPWwubGFuZTtpZigoSGUmbSk9PT1tKW51bGwhPT1rJiYoaz1rLm5leHQ9e2xhbmU6MCxhY3Rpb246bC5hY3Rpb24saGFzRWFnZXJTdGF0ZTpsLmhhc0VhZ2VyU3RhdGUsZWFnZXJTdGF0ZTpsLmVhZ2VyU3RhdGUsbmV4dDpudWxsfSksZD1sLmhhc0VhZ2VyU3RhdGU/bC5lYWdlclN0YXRlOmEoZCxsLmFjdGlvbik7ZWxzZXt2YXIgcj17bGFuZTptLGFjdGlvbjpsLmFjdGlvbixoYXNFYWdlclN0YXRlOmwuaGFzRWFnZXJTdGF0ZSxcbmVhZ2VyU3RhdGU6bC5lYWdlclN0YXRlLG5leHQ6bnVsbH07bnVsbD09PWs/KGg9az1yLGc9ZCk6az1rLm5leHQ9cjtKLmxhbmVzfD1tO3lkfD1tfWw9bC5uZXh0fXdoaWxlKG51bGwhPT1sJiZsIT09Zik7bnVsbD09PWs/Zz1kOmsubmV4dD1oO1VjKGQsYi5tZW1vaXplZFN0YXRlKXx8KEY9ITApO2IubWVtb2l6ZWRTdGF0ZT1kO2IuYmFzZVN0YXRlPWc7Yi5iYXNlUXVldWU9aztjLmxhc3RSZW5kZXJlZFN0YXRlPWR9YT1jLmludGVybGVhdmVkO2lmKG51bGwhPT1hKXtlPWE7ZG8gZj1lLmxhbmUsSi5sYW5lc3w9Zix5ZHw9ZixlPWUubmV4dDt3aGlsZShlIT09YSl9ZWxzZSBudWxsPT09ZSYmKGMubGFuZXM9MCk7cmV0dXJuW2IubWVtb2l6ZWRTdGF0ZSxjLmRpc3BhdGNoXX1cbmZ1bmN0aW9uIFhlKGEpe3ZhciBiPVVlKCksYz1iLnF1ZXVlO2lmKG51bGw9PT1jKXRocm93IEVycm9yKG4oMzExKSk7Yy5sYXN0UmVuZGVyZWRSZWR1Y2VyPWE7dmFyIGQ9Yy5kaXNwYXRjaCxlPWMucGVuZGluZyxmPWIubWVtb2l6ZWRTdGF0ZTtpZihudWxsIT09ZSl7Yy5wZW5kaW5nPW51bGw7dmFyIGc9ZT1lLm5leHQ7ZG8gZj1hKGYsZy5hY3Rpb24pLGc9Zy5uZXh0O3doaWxlKGchPT1lKTtVYyhmLGIubWVtb2l6ZWRTdGF0ZSl8fChGPSEwKTtiLm1lbW9pemVkU3RhdGU9ZjtudWxsPT09Yi5iYXNlUXVldWUmJihiLmJhc2VTdGF0ZT1mKTtjLmxhc3RSZW5kZXJlZFN0YXRlPWZ9cmV0dXJuW2YsZF19ZnVuY3Rpb24gWWUoKXt9XG5mdW5jdGlvbiBaZShhLGIpe3ZhciBjPUosZD1VZSgpLGU9YigpLGY9IVVjKGQubWVtb2l6ZWRTdGF0ZSxlKTtmJiYoZC5tZW1vaXplZFN0YXRlPWUsRj0hMCk7ZD1kLnF1ZXVlOyRlKGFmLmJpbmQobnVsbCxjLGQsYSksW2FdKTtpZihkLmdldFNuYXBzaG90IT09Ynx8Znx8bnVsbCE9PUwmJkwubWVtb2l6ZWRTdGF0ZS50YWcmMSl7Yy5mbGFnc3w9MjA0ODtiZig5LGNmLmJpbmQobnVsbCxjLGQsZSxiKSx2b2lkIDAsbnVsbCk7aWYobnVsbD09PU4pdGhyb3cgRXJyb3IobigzNDkpKTswIT09KEhlJjMwKXx8ZGYoYyxiLGUpfXJldHVybiBlfWZ1bmN0aW9uIGRmKGEsYixjKXthLmZsYWdzfD0xNjM4NDthPXtnZXRTbmFwc2hvdDpiLHZhbHVlOmN9O2I9Si51cGRhdGVRdWV1ZTtudWxsPT09Yj8oYj17bGFzdEVmZmVjdDpudWxsLHN0b3JlczpudWxsfSxKLnVwZGF0ZVF1ZXVlPWIsYi5zdG9yZXM9W2FdKTooYz1iLnN0b3JlcyxudWxsPT09Yz9iLnN0b3Jlcz1bYV06Yy5wdXNoKGEpKX1cbmZ1bmN0aW9uIGNmKGEsYixjLGQpe2IudmFsdWU9YztiLmdldFNuYXBzaG90PWQ7ZWYoYikmJkRkKGEsMSwtMSl9ZnVuY3Rpb24gYWYoYSxiLGMpe3JldHVybiBjKGZ1bmN0aW9uKCl7ZWYoYikmJkRkKGEsMSwtMSl9KX1mdW5jdGlvbiBlZihhKXt2YXIgYj1hLmdldFNuYXBzaG90O2E9YS52YWx1ZTt0cnl7dmFyIGM9YigpO3JldHVybiFVYyhhLGMpfWNhdGNoKGQpe3JldHVybiEwfX1mdW5jdGlvbiBmZihhKXt2YXIgYj1UZSgpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBhJiYoYT1hKCkpO2IubWVtb2l6ZWRTdGF0ZT1iLmJhc2VTdGF0ZT1hO2E9e3BlbmRpbmc6bnVsbCxpbnRlcmxlYXZlZDpudWxsLGxhbmVzOjAsZGlzcGF0Y2g6bnVsbCxsYXN0UmVuZGVyZWRSZWR1Y2VyOlZlLGxhc3RSZW5kZXJlZFN0YXRlOmF9O2IucXVldWU9YTthPWEuZGlzcGF0Y2g9Z2YuYmluZChudWxsLEosYSk7cmV0dXJuW2IubWVtb2l6ZWRTdGF0ZSxhXX1cbmZ1bmN0aW9uIGJmKGEsYixjLGQpe2E9e3RhZzphLGNyZWF0ZTpiLGRlc3Ryb3k6YyxkZXBzOmQsbmV4dDpudWxsfTtiPUoudXBkYXRlUXVldWU7bnVsbD09PWI/KGI9e2xhc3RFZmZlY3Q6bnVsbCxzdG9yZXM6bnVsbH0sSi51cGRhdGVRdWV1ZT1iLGIubGFzdEVmZmVjdD1hLm5leHQ9YSk6KGM9Yi5sYXN0RWZmZWN0LG51bGw9PT1jP2IubGFzdEVmZmVjdD1hLm5leHQ9YTooZD1jLm5leHQsYy5uZXh0PWEsYS5uZXh0PWQsYi5sYXN0RWZmZWN0PWEpKTtyZXR1cm4gYX1mdW5jdGlvbiBoZigpe3JldHVybiBVZSgpLm1lbW9pemVkU3RhdGV9ZnVuY3Rpb24gamYoYSxiLGMsZCl7dmFyIGU9VGUoKTtKLmZsYWdzfD1hO2UubWVtb2l6ZWRTdGF0ZT1iZigxfGIsYyx2b2lkIDAsdm9pZCAwPT09ZD9udWxsOmQpfVxuZnVuY3Rpb24ga2YoYSxiLGMsZCl7dmFyIGU9VWUoKTtkPXZvaWQgMD09PWQ/bnVsbDpkO3ZhciBmPXZvaWQgMDtpZihudWxsIT09Syl7dmFyIGc9Sy5tZW1vaXplZFN0YXRlO2Y9Zy5kZXN0cm95O2lmKG51bGwhPT1kJiZNZShkLGcuZGVwcykpe2UubWVtb2l6ZWRTdGF0ZT1iZihiLGMsZixkKTtyZXR1cm59fUouZmxhZ3N8PWE7ZS5tZW1vaXplZFN0YXRlPWJmKDF8YixjLGYsZCl9ZnVuY3Rpb24gbGYoYSxiKXtyZXR1cm4gamYoODM5MDY1Niw4LGEsYil9ZnVuY3Rpb24gJGUoYSxiKXtyZXR1cm4ga2YoMjA0OCw4LGEsYil9ZnVuY3Rpb24gbWYoYSxiKXtyZXR1cm4ga2YoNCwyLGEsYil9ZnVuY3Rpb24gbmYoYSxiKXtyZXR1cm4ga2YoNCw0LGEsYil9XG5mdW5jdGlvbiBvZihhLGIpe2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBiKXJldHVybiBhPWEoKSxiKGEpLGZ1bmN0aW9uKCl7YihudWxsKX07aWYobnVsbCE9PWImJnZvaWQgMCE9PWIpcmV0dXJuIGE9YSgpLGIuY3VycmVudD1hLGZ1bmN0aW9uKCl7Yi5jdXJyZW50PW51bGx9fWZ1bmN0aW9uIHBmKGEsYixjKXtjPW51bGwhPT1jJiZ2b2lkIDAhPT1jP2MuY29uY2F0KFthXSk6bnVsbDtyZXR1cm4ga2YoNCw0LG9mLmJpbmQobnVsbCxiLGEpLGMpfWZ1bmN0aW9uIHFmKCl7fWZ1bmN0aW9uIHJmKGEsYil7dmFyIGM9VWUoKTtiPXZvaWQgMD09PWI/bnVsbDpiO3ZhciBkPWMubWVtb2l6ZWRTdGF0ZTtpZihudWxsIT09ZCYmbnVsbCE9PWImJk1lKGIsZFsxXSkpcmV0dXJuIGRbMF07Yy5tZW1vaXplZFN0YXRlPVthLGJdO3JldHVybiBhfVxuZnVuY3Rpb24gc2YoYSxiKXt2YXIgYz1VZSgpO2I9dm9pZCAwPT09Yj9udWxsOmI7dmFyIGQ9Yy5tZW1vaXplZFN0YXRlO2lmKG51bGwhPT1kJiZudWxsIT09YiYmTWUoYixkWzFdKSlyZXR1cm4gZFswXTthPWEoKTtjLm1lbW9pemVkU3RhdGU9W2EsYl07cmV0dXJuIGF9ZnVuY3Rpb24gdGYoYSxiLGMpe2lmKDA9PT0oSGUmMjEpKXJldHVybiBhLmJhc2VTdGF0ZSYmKGEuYmFzZVN0YXRlPSExLEY9ITApLGEubWVtb2l6ZWRTdGF0ZT1jO1VjKGMsYil8fChjPUNjKCksSi5sYW5lc3w9Yyx5ZHw9YyxhLmJhc2VTdGF0ZT0hMCk7cmV0dXJuIGJ9ZnVuY3Rpb24gdWYoYSxiKXt2YXIgYz1DO0M9MCE9PWMmJjQ+Yz9jOjQ7YSghMCk7dmFyIGQ9R2UudHJhbnNpdGlvbjtHZS50cmFuc2l0aW9uPXt9O3RyeXthKCExKSxiKCl9ZmluYWxseXtDPWMsR2UudHJhbnNpdGlvbj1kfX1mdW5jdGlvbiB2Zigpe3JldHVybiBVZSgpLm1lbW9pemVkU3RhdGV9XG5mdW5jdGlvbiB3ZihhLGIsYyl7dmFyIGQ9Q2QoYSk7Yz17bGFuZTpkLGFjdGlvbjpjLGhhc0VhZ2VyU3RhdGU6ITEsZWFnZXJTdGF0ZTpudWxsLG5leHQ6bnVsbH07eGYoYSk/eWYoYixjKTooemYoYSxiLGMpLGM9RygpLGE9RGQoYSxkLGMpLG51bGwhPT1hJiZBZihhLGIsZCkpfVxuZnVuY3Rpb24gZ2YoYSxiLGMpe3ZhciBkPUNkKGEpLGU9e2xhbmU6ZCxhY3Rpb246YyxoYXNFYWdlclN0YXRlOiExLGVhZ2VyU3RhdGU6bnVsbCxuZXh0Om51bGx9O2lmKHhmKGEpKXlmKGIsZSk7ZWxzZXt6ZihhLGIsZSk7dmFyIGY9YS5hbHRlcm5hdGU7aWYoMD09PWEubGFuZXMmJihudWxsPT09Znx8MD09PWYubGFuZXMpJiYoZj1iLmxhc3RSZW5kZXJlZFJlZHVjZXIsbnVsbCE9PWYpKXRyeXt2YXIgZz1iLmxhc3RSZW5kZXJlZFN0YXRlLGg9ZihnLGMpO2UuaGFzRWFnZXJTdGF0ZT0hMDtlLmVhZ2VyU3RhdGU9aDtpZihVYyhoLGcpKXJldHVybn1jYXRjaChrKXt9ZmluYWxseXt9Yz1HKCk7YT1EZChhLGQsYyk7bnVsbCE9PWEmJkFmKGEsYixkKX19ZnVuY3Rpb24geGYoYSl7dmFyIGI9YS5hbHRlcm5hdGU7cmV0dXJuIGE9PT1KfHxudWxsIT09YiYmYj09PUp9XG5mdW5jdGlvbiB5ZihhLGIpe0plPUllPSEwO3ZhciBjPWEucGVuZGluZztudWxsPT09Yz9iLm5leHQ9YjooYi5uZXh0PWMubmV4dCxjLm5leHQ9Yik7YS5wZW5kaW5nPWJ9ZnVuY3Rpb24gemYoYSxiLGMpe3VkKGEpPyhhPWIuaW50ZXJsZWF2ZWQsbnVsbD09PWE/KGMubmV4dD1jLG51bGw9PT1vZD9vZD1bYl06b2QucHVzaChiKSk6KGMubmV4dD1hLm5leHQsYS5uZXh0PWMpLGIuaW50ZXJsZWF2ZWQ9Yyk6KGE9Yi5wZW5kaW5nLG51bGw9PT1hP2MubmV4dD1jOihjLm5leHQ9YS5uZXh0LGEubmV4dD1jKSxiLnBlbmRpbmc9Yyl9ZnVuY3Rpb24gQWYoYSxiLGMpe2lmKDAhPT0oYyY0MTk0MjQwKSl7dmFyIGQ9Yi5sYW5lcztkJj1hLnBlbmRpbmdMYW5lcztjfD1kO2IubGFuZXM9YztHYyhhLGMpfX1cbnZhciBSZT17cmVhZENvbnRleHQ6bmQsdXNlQ2FsbGJhY2s6TSx1c2VDb250ZXh0Ok0sdXNlRWZmZWN0Ok0sdXNlSW1wZXJhdGl2ZUhhbmRsZTpNLHVzZUluc2VydGlvbkVmZmVjdDpNLHVzZUxheW91dEVmZmVjdDpNLHVzZU1lbW86TSx1c2VSZWR1Y2VyOk0sdXNlUmVmOk0sdXNlU3RhdGU6TSx1c2VEZWJ1Z1ZhbHVlOk0sdXNlRGVmZXJyZWRWYWx1ZTpNLHVzZVRyYW5zaXRpb246TSx1c2VNdXRhYmxlU291cmNlOk0sdXNlU3luY0V4dGVybmFsU3RvcmU6TSx1c2VJZDpNLHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjohMX0sT2U9e3JlYWRDb250ZXh0Om5kLHVzZUNhbGxiYWNrOmZ1bmN0aW9uKGEsYil7VGUoKS5tZW1vaXplZFN0YXRlPVthLHZvaWQgMD09PWI/bnVsbDpiXTtyZXR1cm4gYX0sdXNlQ29udGV4dDpuZCx1c2VFZmZlY3Q6bGYsdXNlSW1wZXJhdGl2ZUhhbmRsZTpmdW5jdGlvbihhLGIsYyl7Yz1udWxsIT09YyYmdm9pZCAwIT09Yz9jLmNvbmNhdChbYV0pOm51bGw7cmV0dXJuIGpmKDQxOTQzMDgsXG40LG9mLmJpbmQobnVsbCxiLGEpLGMpfSx1c2VMYXlvdXRFZmZlY3Q6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gamYoNDE5NDMwOCw0LGEsYil9LHVzZUluc2VydGlvbkVmZmVjdDpmdW5jdGlvbihhLGIpe3JldHVybiBqZig0LDIsYSxiKX0sdXNlTWVtbzpmdW5jdGlvbihhLGIpe3ZhciBjPVRlKCk7Yj12b2lkIDA9PT1iP251bGw6YjthPWEoKTtjLm1lbW9pemVkU3RhdGU9W2EsYl07cmV0dXJuIGF9LHVzZVJlZHVjZXI6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPVRlKCk7Yj12b2lkIDAhPT1jP2MoYik6YjtkLm1lbW9pemVkU3RhdGU9ZC5iYXNlU3RhdGU9YjthPXtwZW5kaW5nOm51bGwsaW50ZXJsZWF2ZWQ6bnVsbCxsYW5lczowLGRpc3BhdGNoOm51bGwsbGFzdFJlbmRlcmVkUmVkdWNlcjphLGxhc3RSZW5kZXJlZFN0YXRlOmJ9O2QucXVldWU9YTthPWEuZGlzcGF0Y2g9d2YuYmluZChudWxsLEosYSk7cmV0dXJuW2QubWVtb2l6ZWRTdGF0ZSxhXX0sdXNlUmVmOmZ1bmN0aW9uKGEpe3ZhciBiPVxuVGUoKTthPXtjdXJyZW50OmF9O3JldHVybiBiLm1lbW9pemVkU3RhdGU9YX0sdXNlU3RhdGU6ZmYsdXNlRGVidWdWYWx1ZTpxZix1c2VEZWZlcnJlZFZhbHVlOmZ1bmN0aW9uKGEpe3JldHVybiBUZSgpLm1lbW9pemVkU3RhdGU9YX0sdXNlVHJhbnNpdGlvbjpmdW5jdGlvbigpe3ZhciBhPWZmKCExKSxiPWFbMF07YT11Zi5iaW5kKG51bGwsYVsxXSk7VGUoKS5tZW1vaXplZFN0YXRlPWE7cmV0dXJuW2IsYV19LHVzZU11dGFibGVTb3VyY2U6ZnVuY3Rpb24oKXt9LHVzZVN5bmNFeHRlcm5hbFN0b3JlOmZ1bmN0aW9uKGEsYixjKXt2YXIgZD1KLGU9VGUoKTtpZihIKXtpZih2b2lkIDA9PT1jKXRocm93IEVycm9yKG4oNDA3KSk7Yz1jKCl9ZWxzZXtjPWIoKTtpZihudWxsPT09Til0aHJvdyBFcnJvcihuKDM0OSkpOzAhPT0oSGUmMzApfHxkZihkLGIsYyl9ZS5tZW1vaXplZFN0YXRlPWM7dmFyIGY9e3ZhbHVlOmMsZ2V0U25hcHNob3Q6Yn07ZS5xdWV1ZT1mO2xmKGFmLmJpbmQobnVsbCxkLFxuZixhKSxbYV0pO2QuZmxhZ3N8PTIwNDg7YmYoOSxjZi5iaW5kKG51bGwsZCxmLGMsYiksdm9pZCAwLG51bGwpO3JldHVybiBjfSx1c2VJZDpmdW5jdGlvbigpe3ZhciBhPVRlKCksYj1OLmlkZW50aWZpZXJQcmVmaXg7aWYoSCl7dmFyIGM9UmQ7dmFyIGQ9UWQ7Yz0oZCZ+KDE8PDMyLXNjKGQpLTEpKS50b1N0cmluZygzMikrYztiPVwiOlwiK2IrXCJSXCIrYztjPUtlKys7MDxjJiYoYis9XCJIXCIrYy50b1N0cmluZygzMikpO2IrPVwiOlwifWVsc2UgYz1MZSsrLGI9XCI6XCIrYitcInJcIitjLnRvU3RyaW5nKDMyKStcIjpcIjtyZXR1cm4gYS5tZW1vaXplZFN0YXRlPWJ9LHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjohMX0sUGU9e3JlYWRDb250ZXh0Om5kLHVzZUNhbGxiYWNrOnJmLHVzZUNvbnRleHQ6bmQsdXNlRWZmZWN0OiRlLHVzZUltcGVyYXRpdmVIYW5kbGU6cGYsdXNlSW5zZXJ0aW9uRWZmZWN0Om1mLHVzZUxheW91dEVmZmVjdDpuZix1c2VNZW1vOnNmLHVzZVJlZHVjZXI6V2UsdXNlUmVmOmhmLHVzZVN0YXRlOmZ1bmN0aW9uKCl7cmV0dXJuIFdlKFZlKX0sXG51c2VEZWJ1Z1ZhbHVlOnFmLHVzZURlZmVycmVkVmFsdWU6ZnVuY3Rpb24oYSl7dmFyIGI9VWUoKTtyZXR1cm4gdGYoYixLLm1lbW9pemVkU3RhdGUsYSl9LHVzZVRyYW5zaXRpb246ZnVuY3Rpb24oKXt2YXIgYT1XZShWZSlbMF0sYj1VZSgpLm1lbW9pemVkU3RhdGU7cmV0dXJuW2EsYl19LHVzZU11dGFibGVTb3VyY2U6WWUsdXNlU3luY0V4dGVybmFsU3RvcmU6WmUsdXNlSWQ6dmYsdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiExfSxRZT17cmVhZENvbnRleHQ6bmQsdXNlQ2FsbGJhY2s6cmYsdXNlQ29udGV4dDpuZCx1c2VFZmZlY3Q6JGUsdXNlSW1wZXJhdGl2ZUhhbmRsZTpwZix1c2VJbnNlcnRpb25FZmZlY3Q6bWYsdXNlTGF5b3V0RWZmZWN0Om5mLHVzZU1lbW86c2YsdXNlUmVkdWNlcjpYZSx1c2VSZWY6aGYsdXNlU3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gWGUoVmUpfSx1c2VEZWJ1Z1ZhbHVlOnFmLHVzZURlZmVycmVkVmFsdWU6ZnVuY3Rpb24oYSl7dmFyIGI9VWUoKTtyZXR1cm4gbnVsbD09PVxuSz9iLm1lbW9pemVkU3RhdGU9YTp0ZihiLEsubWVtb2l6ZWRTdGF0ZSxhKX0sdXNlVHJhbnNpdGlvbjpmdW5jdGlvbigpe3ZhciBhPVhlKFZlKVswXSxiPVVlKCkubWVtb2l6ZWRTdGF0ZTtyZXR1cm5bYSxiXX0sdXNlTXV0YWJsZVNvdXJjZTpZZSx1c2VTeW5jRXh0ZXJuYWxTdG9yZTpaZSx1c2VJZDp2Zix1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6ITF9O2Z1bmN0aW9uIEJmKGEsYil7dHJ5e3ZhciBjPVwiXCIsZD1iO2RvIGMrPWNkKGQpLGQ9ZC5yZXR1cm47d2hpbGUoZCk7dmFyIGU9Y31jYXRjaChmKXtlPVwiXFxuRXJyb3IgZ2VuZXJhdGluZyBzdGFjazogXCIrZi5tZXNzYWdlK1wiXFxuXCIrZi5zdGFja31yZXR1cm57dmFsdWU6YSxzb3VyY2U6YixzdGFjazplfX1mdW5jdGlvbiBDZihhLGIpe3RyeXtjb25zb2xlLmVycm9yKGIudmFsdWUpfWNhdGNoKGMpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt0aHJvdyBjO30pfX1cbnZhciBEZj1cImZ1bmN0aW9uXCI9PT10eXBlb2YgV2Vha01hcD9XZWFrTWFwOk1hcDtmdW5jdGlvbiBFZihhLGIsYyl7Yz1zZCgtMSxjKTtjLnRhZz0zO2MucGF5bG9hZD17ZWxlbWVudDpudWxsfTt2YXIgZD1iLnZhbHVlO2MuY2FsbGJhY2s9ZnVuY3Rpb24oKXtGZnx8KEZmPSEwLEdmPWQpO0NmKGEsYil9O3JldHVybiBjfVxuZnVuY3Rpb24gSGYoYSxiLGMpe2M9c2QoLTEsYyk7Yy50YWc9Mzt2YXIgZD1hLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBkKXt2YXIgZT1iLnZhbHVlO2MucGF5bG9hZD1mdW5jdGlvbigpe3JldHVybiBkKGUpfTtjLmNhbGxiYWNrPWZ1bmN0aW9uKCl7Q2YoYSxiKX19dmFyIGY9YS5zdGF0ZU5vZGU7bnVsbCE9PWYmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBmLmNvbXBvbmVudERpZENhdGNoJiYoYy5jYWxsYmFjaz1mdW5jdGlvbigpe0NmKGEsYik7XCJmdW5jdGlvblwiIT09dHlwZW9mIGQmJihudWxsPT09SWY/SWY9bmV3IFNldChbdGhpc10pOklmLmFkZCh0aGlzKSk7dmFyIGM9Yi5zdGFjazt0aGlzLmNvbXBvbmVudERpZENhdGNoKGIudmFsdWUse2NvbXBvbmVudFN0YWNrOm51bGwhPT1jP2M6XCJcIn0pfSk7cmV0dXJuIGN9XG5mdW5jdGlvbiBKZihhLGIsYyl7dmFyIGQ9YS5waW5nQ2FjaGU7aWYobnVsbD09PWQpe2Q9YS5waW5nQ2FjaGU9bmV3IERmO3ZhciBlPW5ldyBTZXQ7ZC5zZXQoYixlKX1lbHNlIGU9ZC5nZXQoYiksdm9pZCAwPT09ZSYmKGU9bmV3IFNldCxkLnNldChiLGUpKTtlLmhhcyhjKXx8KGUuYWRkKGMpLGE9S2YuYmluZChudWxsLGEsYixjKSxiLnRoZW4oYSxhKSl9ZnVuY3Rpb24gTGYoYSl7ZG97dmFyIGI7aWYoYj0xMz09PWEudGFnKWI9YS5tZW1vaXplZFN0YXRlLGI9bnVsbCE9PWI/bnVsbCE9PWIuZGVoeWRyYXRlZD8hMDohMTohMDtpZihiKXJldHVybiBhO2E9YS5yZXR1cm59d2hpbGUobnVsbCE9PWEpO3JldHVybiBudWxsfVxuZnVuY3Rpb24gTWYoYSxiLGMsZCxlKXtpZigwPT09KGEubW9kZSYxKSlyZXR1cm4gYT09PWI/YS5mbGFnc3w9NjU1MzY6KGEuZmxhZ3N8PTEyOCxjLmZsYWdzfD0xMzEwNzIsYy5mbGFncyY9LTUyODA1LDE9PT1jLnRhZyYmKG51bGw9PT1jLmFsdGVybmF0ZT9jLnRhZz0xNzooYj1zZCgtMSwxKSxiLnRhZz0yLHRkKGMsYikpKSxjLmxhbmVzfD0xKSxhO2EuZmxhZ3N8PTY1NTM2O2EubGFuZXM9ZTtyZXR1cm4gYX1mdW5jdGlvbiBOZihhKXthLmZsYWdzfD00fWZ1bmN0aW9uIE9mKGEsYil7aWYobnVsbCE9PWEmJmEuY2hpbGQ9PT1iLmNoaWxkKXJldHVybiEwO2lmKDAhPT0oYi5mbGFncyYxNikpcmV0dXJuITE7Zm9yKGE9Yi5jaGlsZDtudWxsIT09YTspe2lmKDAhPT0oYS5mbGFncyYxMjg1NCl8fDAhPT0oYS5zdWJ0cmVlRmxhZ3MmMTI4NTQpKXJldHVybiExO2E9YS5zaWJsaW5nfXJldHVybiEwfXZhciBQZixRZixSZixTZjtcbmlmKFRhKVBmPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPWIuY2hpbGQ7bnVsbCE9PWM7KXtpZig1PT09Yy50YWd8fDY9PT1jLnRhZylLYShhLGMuc3RhdGVOb2RlKTtlbHNlIGlmKDQhPT1jLnRhZyYmbnVsbCE9PWMuY2hpbGQpe2MuY2hpbGQucmV0dXJuPWM7Yz1jLmNoaWxkO2NvbnRpbnVlfWlmKGM9PT1iKWJyZWFrO2Zvcig7bnVsbD09PWMuc2libGluZzspe2lmKG51bGw9PT1jLnJldHVybnx8Yy5yZXR1cm49PT1iKXJldHVybjtjPWMucmV0dXJufWMuc2libGluZy5yZXR1cm49Yy5yZXR1cm47Yz1jLnNpYmxpbmd9fSxRZj1mdW5jdGlvbigpe30sUmY9ZnVuY3Rpb24oYSxiLGMsZCxlKXthPWEubWVtb2l6ZWRQcm9wcztpZihhIT09ZCl7dmFyIGY9Yi5zdGF0ZU5vZGUsZz14ZSh1ZS5jdXJyZW50KTtjPU1hKGYsYyxhLGQsZSxnKTsoYi51cGRhdGVRdWV1ZT1jKSYmTmYoYil9fSxTZj1mdW5jdGlvbihhLGIsYyxkKXtjIT09ZCYmTmYoYil9O2Vsc2UgaWYoVWEpe1BmPWZ1bmN0aW9uKGEsXG5iLGMsZCl7Zm9yKHZhciBlPWIuY2hpbGQ7bnVsbCE9PWU7KXtpZig1PT09ZS50YWcpe3ZhciBmPWUuc3RhdGVOb2RlO2MmJmQmJihmPUViKGYsZS50eXBlLGUubWVtb2l6ZWRQcm9wcyxlKSk7S2EoYSxmKX1lbHNlIGlmKDY9PT1lLnRhZylmPWUuc3RhdGVOb2RlLGMmJmQmJihmPUZiKGYsZS5tZW1vaXplZFByb3BzLGUpKSxLYShhLGYpO2Vsc2UgaWYoNCE9PWUudGFnKWlmKDIyPT09ZS50YWcmJm51bGwhPT1lLm1lbW9pemVkU3RhdGUpZj1lLmNoaWxkLG51bGwhPT1mJiYoZi5yZXR1cm49ZSksUGYoYSxlLCEwLCEwKTtlbHNlIGlmKG51bGwhPT1lLmNoaWxkKXtlLmNoaWxkLnJldHVybj1lO2U9ZS5jaGlsZDtjb250aW51ZX1pZihlPT09YilicmVhaztmb3IoO251bGw9PT1lLnNpYmxpbmc7KXtpZihudWxsPT09ZS5yZXR1cm58fGUucmV0dXJuPT09YilyZXR1cm47ZT1lLnJldHVybn1lLnNpYmxpbmcucmV0dXJuPWUucmV0dXJuO2U9ZS5zaWJsaW5nfX07dmFyIFRmPWZ1bmN0aW9uKGEsXG5iLGMsZCl7Zm9yKHZhciBlPWIuY2hpbGQ7bnVsbCE9PWU7KXtpZig1PT09ZS50YWcpe3ZhciBmPWUuc3RhdGVOb2RlO2MmJmQmJihmPUViKGYsZS50eXBlLGUubWVtb2l6ZWRQcm9wcyxlKSk7QWIoYSxmKX1lbHNlIGlmKDY9PT1lLnRhZylmPWUuc3RhdGVOb2RlLGMmJmQmJihmPUZiKGYsZS5tZW1vaXplZFByb3BzLGUpKSxBYihhLGYpO2Vsc2UgaWYoNCE9PWUudGFnKWlmKDIyPT09ZS50YWcmJm51bGwhPT1lLm1lbW9pemVkU3RhdGUpZj1lLmNoaWxkLG51bGwhPT1mJiYoZi5yZXR1cm49ZSksVGYoYSxlLCEwLCEwKTtlbHNlIGlmKG51bGwhPT1lLmNoaWxkKXtlLmNoaWxkLnJldHVybj1lO2U9ZS5jaGlsZDtjb250aW51ZX1pZihlPT09YilicmVhaztmb3IoO251bGw9PT1lLnNpYmxpbmc7KXtpZihudWxsPT09ZS5yZXR1cm58fGUucmV0dXJuPT09YilyZXR1cm47ZT1lLnJldHVybn1lLnNpYmxpbmcucmV0dXJuPWUucmV0dXJuO2U9ZS5zaWJsaW5nfX07UWY9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cbmIuc3RhdGVOb2RlO2lmKCFPZihhLGIpKXthPWMuY29udGFpbmVySW5mbzt2YXIgZD16YihhKTtUZihkLGIsITEsITEpO2MucGVuZGluZ0NoaWxkcmVuPWQ7TmYoYik7QmIoYSxkKX19O1JmPWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9YS5zdGF0ZU5vZGUsZz1hLm1lbW9pemVkUHJvcHM7aWYoKGE9T2YoYSxiKSkmJmc9PT1kKWIuc3RhdGVOb2RlPWY7ZWxzZXt2YXIgaD1iLnN0YXRlTm9kZSxrPXhlKHVlLmN1cnJlbnQpLGw9bnVsbDtnIT09ZCYmKGw9TWEoaCxjLGcsZCxlLGspKTthJiZudWxsPT09bD9iLnN0YXRlTm9kZT1mOihmPXliKGYsbCxjLGcsZCxiLGEsaCksTGEoZixjLGQsZSxrKSYmTmYoYiksYi5zdGF0ZU5vZGU9ZixhP05mKGIpOlBmKGYsYiwhMSwhMSkpfX07U2Y9ZnVuY3Rpb24oYSxiLGMsZCl7YyE9PWQ/KGE9eGUod2UuY3VycmVudCksYz14ZSh1ZS5jdXJyZW50KSxiLnN0YXRlTm9kZT1PYShkLGEsYyxiKSxOZihiKSk6Yi5zdGF0ZU5vZGU9YS5zdGF0ZU5vZGV9fWVsc2UgUWY9XG5mdW5jdGlvbigpe30sUmY9ZnVuY3Rpb24oKXt9LFNmPWZ1bmN0aW9uKCl7fTtmdW5jdGlvbiBVZihhLGIpe2lmKCFIKXN3aXRjaChhLnRhaWxNb2RlKXtjYXNlIFwiaGlkZGVuXCI6Yj1hLnRhaWw7Zm9yKHZhciBjPW51bGw7bnVsbCE9PWI7KW51bGwhPT1iLmFsdGVybmF0ZSYmKGM9YiksYj1iLnNpYmxpbmc7bnVsbD09PWM/YS50YWlsPW51bGw6Yy5zaWJsaW5nPW51bGw7YnJlYWs7Y2FzZSBcImNvbGxhcHNlZFwiOmM9YS50YWlsO2Zvcih2YXIgZD1udWxsO251bGwhPT1jOyludWxsIT09Yy5hbHRlcm5hdGUmJihkPWMpLGM9Yy5zaWJsaW5nO251bGw9PT1kP2J8fG51bGw9PT1hLnRhaWw/YS50YWlsPW51bGw6YS50YWlsLnNpYmxpbmc9bnVsbDpkLnNpYmxpbmc9bnVsbH19XG5mdW5jdGlvbiBPKGEpe3ZhciBiPW51bGwhPT1hLmFsdGVybmF0ZSYmYS5hbHRlcm5hdGUuY2hpbGQ9PT1hLmNoaWxkLGM9MCxkPTA7aWYoYilmb3IodmFyIGU9YS5jaGlsZDtudWxsIT09ZTspY3w9ZS5sYW5lc3xlLmNoaWxkTGFuZXMsZHw9ZS5zdWJ0cmVlRmxhZ3MmMTQ2ODAwNjQsZHw9ZS5mbGFncyYxNDY4MDA2NCxlLnJldHVybj1hLGU9ZS5zaWJsaW5nO2Vsc2UgZm9yKGU9YS5jaGlsZDtudWxsIT09ZTspY3w9ZS5sYW5lc3xlLmNoaWxkTGFuZXMsZHw9ZS5zdWJ0cmVlRmxhZ3MsZHw9ZS5mbGFncyxlLnJldHVybj1hLGU9ZS5zaWJsaW5nO2Euc3VidHJlZUZsYWdzfD1kO2EuY2hpbGRMYW5lcz1jO3JldHVybiBifVxuZnVuY3Rpb24gVmYoYSxiLGMpe3ZhciBkPWIucGVuZGluZ1Byb3BzO1ZkKGIpO3N3aXRjaChiLnRhZyl7Y2FzZSAyOmNhc2UgMTY6Y2FzZSAxNTpjYXNlIDA6Y2FzZSAxMTpjYXNlIDc6Y2FzZSA4OmNhc2UgMTI6Y2FzZSA5OmNhc2UgMTQ6cmV0dXJuIE8oYiksbnVsbDtjYXNlIDE6cmV0dXJuIEEoYi50eXBlKSYmbGMoKSxPKGIpLG51bGw7Y2FzZSAzOmQ9Yi5zdGF0ZU5vZGU7emUoKTtwKHopO3AoeCk7RWUoKTtkLnBlbmRpbmdDb250ZXh0JiYoZC5jb250ZXh0PWQucGVuZGluZ0NvbnRleHQsZC5wZW5kaW5nQ29udGV4dD1udWxsKTtpZihudWxsPT09YXx8bnVsbD09PWEuY2hpbGQpZmUoYik/TmYoYik6bnVsbD09PWF8fGEubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQmJjA9PT0oYi5mbGFncyYyNTYpfHwoYi5mbGFnc3w9MTAyNCxudWxsIT09WmQmJihXZihaZCksWmQ9bnVsbCkpO1FmKGEsYik7TyhiKTtyZXR1cm4gbnVsbDtjYXNlIDU6QmUoYik7Yz14ZSh3ZS5jdXJyZW50KTt2YXIgZT1cbmIudHlwZTtpZihudWxsIT09YSYmbnVsbCE9Yi5zdGF0ZU5vZGUpUmYoYSxiLGUsZCxjKSxhLnJlZiE9PWIucmVmJiYoYi5mbGFnc3w9NTEyLGIuZmxhZ3N8PTIwOTcxNTIpO2Vsc2V7aWYoIWQpe2lmKG51bGw9PT1iLnN0YXRlTm9kZSl0aHJvdyBFcnJvcihuKDE2NikpO08oYik7cmV0dXJuIG51bGx9YT14ZSh1ZS5jdXJyZW50KTtpZihmZShiKSl7aWYoIVZhKXRocm93IEVycm9yKG4oMTc1KSk7YT1RYihiLnN0YXRlTm9kZSxiLnR5cGUsYi5tZW1vaXplZFByb3BzLGMsYSxiLCFZZCk7Yi51cGRhdGVRdWV1ZT1hO251bGwhPT1hJiZOZihiKX1lbHNle3ZhciBmPUphKGUsZCxjLGEsYik7UGYoZixiLCExLCExKTtiLnN0YXRlTm9kZT1mO0xhKGYsZSxkLGMsYSkmJk5mKGIpfW51bGwhPT1iLnJlZiYmKGIuZmxhZ3N8PTUxMixiLmZsYWdzfD0yMDk3MTUyKX1PKGIpO3JldHVybiBudWxsO2Nhc2UgNjppZihhJiZudWxsIT1iLnN0YXRlTm9kZSlTZihhLGIsYS5tZW1vaXplZFByb3BzLGQpO1xuZWxzZXtpZihcInN0cmluZ1wiIT09dHlwZW9mIGQmJm51bGw9PT1iLnN0YXRlTm9kZSl0aHJvdyBFcnJvcihuKDE2NikpO2E9eGUod2UuY3VycmVudCk7Yz14ZSh1ZS5jdXJyZW50KTtpZihmZShiKSl7aWYoIVZhKXRocm93IEVycm9yKG4oMTc2KSk7YT1iLnN0YXRlTm9kZTtkPWIubWVtb2l6ZWRQcm9wcztpZihjPVJiKGEsZCxiLCFZZCkpaWYoZT1XZCxudWxsIT09ZSlzd2l0Y2goZS50YWcpe2Nhc2UgMzpaYihlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvLGEsZCwwIT09KGUubW9kZSYxKSk7YnJlYWs7Y2FzZSA1OiRiKGUudHlwZSxlLm1lbW9pemVkUHJvcHMsZS5zdGF0ZU5vZGUsYSxkLDAhPT0oZS5tb2RlJjEpKX1jJiZOZihiKX1lbHNlIGIuc3RhdGVOb2RlPU9hKGQsYSxjLGIpfU8oYik7cmV0dXJuIG51bGw7Y2FzZSAxMzpwKEkpO2Q9Yi5tZW1vaXplZFN0YXRlO2lmKEgmJm51bGwhPT1YZCYmMCE9PShiLm1vZGUmMSkmJjA9PT0oYi5mbGFncyYxMjgpKXtmb3IoYT1YZDthOylhPU1iKGEpO1xuZ2UoKTtiLmZsYWdzfD05ODU2MDtyZXR1cm4gYn1pZihudWxsIT09ZCYmbnVsbCE9PWQuZGVoeWRyYXRlZCl7ZD1mZShiKTtpZihudWxsPT09YSl7aWYoIWQpdGhyb3cgRXJyb3IobigzMTgpKTtpZighVmEpdGhyb3cgRXJyb3IobigzNDQpKTthPWIubWVtb2l6ZWRTdGF0ZTthPW51bGwhPT1hP2EuZGVoeWRyYXRlZDpudWxsO2lmKCFhKXRocm93IEVycm9yKG4oMzE3KSk7U2IoYSxiKX1lbHNlIGdlKCksMD09PShiLmZsYWdzJjEyOCkmJihiLm1lbW9pemVkU3RhdGU9bnVsbCksYi5mbGFnc3w9NDtPKGIpO3JldHVybiBudWxsfW51bGwhPT1aZCYmKFdmKFpkKSxaZD1udWxsKTtpZigwIT09KGIuZmxhZ3MmMTI4KSlyZXR1cm4gYi5sYW5lcz1jLGI7ZD1udWxsIT09ZDtjPSExO251bGw9PT1hP2ZlKGIpOmM9bnVsbCE9PWEubWVtb2l6ZWRTdGF0ZTtkIT09YyYmZCYmKGIuY2hpbGQuZmxhZ3N8PTgxOTIsMCE9PShiLm1vZGUmMSkmJihudWxsPT09YXx8MCE9PShJLmN1cnJlbnQmMSk/MD09PVxuUCYmKFA9Myk6WGYoKSkpO251bGwhPT1iLnVwZGF0ZVF1ZXVlJiYoYi5mbGFnc3w9NCk7TyhiKTtyZXR1cm4gbnVsbDtjYXNlIDQ6cmV0dXJuIHplKCksUWYoYSxiKSxudWxsPT09YSYmWGEoYi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyksTyhiKSxudWxsO2Nhc2UgMTA6cmV0dXJuIGtkKGIudHlwZS5fY29udGV4dCksTyhiKSxudWxsO2Nhc2UgMTc6cmV0dXJuIEEoYi50eXBlKSYmbGMoKSxPKGIpLG51bGw7Y2FzZSAxOTpwKEkpO2U9Yi5tZW1vaXplZFN0YXRlO2lmKG51bGw9PT1lKXJldHVybiBPKGIpLG51bGw7ZD0wIT09KGIuZmxhZ3MmMTI4KTtmPWUucmVuZGVyaW5nO2lmKG51bGw9PT1mKWlmKGQpVWYoZSwhMSk7ZWxzZXtpZigwIT09UHx8bnVsbCE9PWEmJjAhPT0oYS5mbGFncyYxMjgpKWZvcihhPWIuY2hpbGQ7bnVsbCE9PWE7KXtmPUNlKGEpO2lmKG51bGwhPT1mKXtiLmZsYWdzfD0xMjg7VWYoZSwhMSk7YT1mLnVwZGF0ZVF1ZXVlO251bGwhPT1hJiYoYi51cGRhdGVRdWV1ZT1cbmEsYi5mbGFnc3w9NCk7Yi5zdWJ0cmVlRmxhZ3M9MDthPWM7Zm9yKGQ9Yi5jaGlsZDtudWxsIT09ZDspYz1kLGU9YSxjLmZsYWdzJj0xNDY4MDA2NixmPWMuYWx0ZXJuYXRlLG51bGw9PT1mPyhjLmNoaWxkTGFuZXM9MCxjLmxhbmVzPWUsYy5jaGlsZD1udWxsLGMuc3VidHJlZUZsYWdzPTAsYy5tZW1vaXplZFByb3BzPW51bGwsYy5tZW1vaXplZFN0YXRlPW51bGwsYy51cGRhdGVRdWV1ZT1udWxsLGMuZGVwZW5kZW5jaWVzPW51bGwsYy5zdGF0ZU5vZGU9bnVsbCk6KGMuY2hpbGRMYW5lcz1mLmNoaWxkTGFuZXMsYy5sYW5lcz1mLmxhbmVzLGMuY2hpbGQ9Zi5jaGlsZCxjLnN1YnRyZWVGbGFncz0wLGMuZGVsZXRpb25zPW51bGwsYy5tZW1vaXplZFByb3BzPWYubWVtb2l6ZWRQcm9wcyxjLm1lbW9pemVkU3RhdGU9Zi5tZW1vaXplZFN0YXRlLGMudXBkYXRlUXVldWU9Zi51cGRhdGVRdWV1ZSxjLnR5cGU9Zi50eXBlLGU9Zi5kZXBlbmRlbmNpZXMsYy5kZXBlbmRlbmNpZXM9bnVsbD09PVxuZT9udWxsOntsYW5lczplLmxhbmVzLGZpcnN0Q29udGV4dDplLmZpcnN0Q29udGV4dH0pLGQ9ZC5zaWJsaW5nO3YoSSxJLmN1cnJlbnQmMXwyKTtyZXR1cm4gYi5jaGlsZH1hPWEuc2libGluZ31udWxsIT09ZS50YWlsJiZEKCk+WWYmJihiLmZsYWdzfD0xMjgsZD0hMCxVZihlLCExKSxiLmxhbmVzPTQxOTQzMDQpfWVsc2V7aWYoIWQpaWYoYT1DZShmKSxudWxsIT09YSl7aWYoYi5mbGFnc3w9MTI4LGQ9ITAsYT1hLnVwZGF0ZVF1ZXVlLG51bGwhPT1hJiYoYi51cGRhdGVRdWV1ZT1hLGIuZmxhZ3N8PTQpLFVmKGUsITApLG51bGw9PT1lLnRhaWwmJlwiaGlkZGVuXCI9PT1lLnRhaWxNb2RlJiYhZi5hbHRlcm5hdGUmJiFIKXJldHVybiBPKGIpLG51bGx9ZWxzZSAyKkQoKS1lLnJlbmRlcmluZ1N0YXJ0VGltZT5ZZiYmMTA3Mzc0MTgyNCE9PWMmJihiLmZsYWdzfD0xMjgsZD0hMCxVZihlLCExKSxiLmxhbmVzPTQxOTQzMDQpO2UuaXNCYWNrd2FyZHM/KGYuc2libGluZz1iLmNoaWxkLGIuY2hpbGQ9XG5mKTooYT1lLmxhc3QsbnVsbCE9PWE/YS5zaWJsaW5nPWY6Yi5jaGlsZD1mLGUubGFzdD1mKX1pZihudWxsIT09ZS50YWlsKXJldHVybiBiPWUudGFpbCxlLnJlbmRlcmluZz1iLGUudGFpbD1iLnNpYmxpbmcsZS5yZW5kZXJpbmdTdGFydFRpbWU9RCgpLGIuc2libGluZz1udWxsLGE9SS5jdXJyZW50LHYoSSxkP2EmMXwyOmEmMSksYjtPKGIpO3JldHVybiBudWxsO2Nhc2UgMjI6Y2FzZSAyMzpyZXR1cm4gWmYoKSxkPW51bGwhPT1iLm1lbW9pemVkU3RhdGUsbnVsbCE9PWEmJm51bGwhPT1hLm1lbW9pemVkU3RhdGUhPT1kJiYoYi5mbGFnc3w9ODE5MiksZCYmMCE9PShiLm1vZGUmMSk/MCE9PSgkZiYxMDczNzQxODI0KSYmKE8oYiksVGEmJmIuc3VidHJlZUZsYWdzJjYmJihiLmZsYWdzfD04MTkyKSk6TyhiKSxudWxsO2Nhc2UgMjQ6cmV0dXJuIG51bGw7Y2FzZSAyNTpyZXR1cm4gbnVsbH10aHJvdyBFcnJvcihuKDE1NixiLnRhZykpO31cbnZhciBhZz1kYS5SZWFjdEN1cnJlbnRPd25lcixGPSExO2Z1bmN0aW9uIFEoYSxiLGMsZCl7Yi5jaGlsZD1udWxsPT09YT9zZShiLG51bGwsYyxkKTpyZShiLGEuY2hpbGQsYyxkKX1mdW5jdGlvbiBiZyhhLGIsYyxkLGUpe2M9Yy5yZW5kZXI7dmFyIGY9Yi5yZWY7bWQoYixlKTtkPU5lKGEsYixjLGQsZixlKTtjPVNlKCk7aWYobnVsbCE9PWEmJiFGKXJldHVybiBiLnVwZGF0ZVF1ZXVlPWEudXBkYXRlUXVldWUsYi5mbGFncyY9LTIwNTMsYS5sYW5lcyY9fmUsY2coYSxiLGUpO0gmJmMmJlVkKGIpO2IuZmxhZ3N8PTE7UShhLGIsZCxlKTtyZXR1cm4gYi5jaGlsZH1cbmZ1bmN0aW9uIGRnKGEsYixjLGQsZSl7aWYobnVsbD09PWEpe3ZhciBmPWMudHlwZTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZiYmIWVnKGYpJiZ2b2lkIDA9PT1mLmRlZmF1bHRQcm9wcyYmbnVsbD09PWMuY29tcGFyZSYmdm9pZCAwPT09Yy5kZWZhdWx0UHJvcHMpcmV0dXJuIGIudGFnPTE1LGIudHlwZT1mLGZnKGEsYixmLGQsZSk7YT1vZShjLnR5cGUsbnVsbCxkLGIsYi5tb2RlLGUpO2EucmVmPWIucmVmO2EucmV0dXJuPWI7cmV0dXJuIGIuY2hpbGQ9YX1mPWEuY2hpbGQ7aWYoMD09PShhLmxhbmVzJmUpKXt2YXIgZz1mLm1lbW9pemVkUHJvcHM7Yz1jLmNvbXBhcmU7Yz1udWxsIT09Yz9jOmJkO2lmKGMoZyxkKSYmYS5yZWY9PT1iLnJlZilyZXR1cm4gY2coYSxiLGUpfWIuZmxhZ3N8PTE7YT1tZShmLGQpO2EucmVmPWIucmVmO2EucmV0dXJuPWI7cmV0dXJuIGIuY2hpbGQ9YX1cbmZ1bmN0aW9uIGZnKGEsYixjLGQsZSl7aWYobnVsbCE9PWEpe3ZhciBmPWEubWVtb2l6ZWRQcm9wcztpZihiZChmLGQpJiZhLnJlZj09PWIucmVmKWlmKEY9ITEsYi5wZW5kaW5nUHJvcHM9ZD1mLDAhPT0oYS5sYW5lcyZlKSkwIT09KGEuZmxhZ3MmMTMxMDcyKSYmKEY9ITApO2Vsc2UgcmV0dXJuIGIubGFuZXM9YS5sYW5lcyxjZyhhLGIsZSl9cmV0dXJuIGdnKGEsYixjLGQsZSl9XG5mdW5jdGlvbiBoZyhhLGIsYyl7dmFyIGQ9Yi5wZW5kaW5nUHJvcHMsZT1kLmNoaWxkcmVuLGY9bnVsbCE9PWE/YS5tZW1vaXplZFN0YXRlOm51bGw7aWYoXCJoaWRkZW5cIj09PWQubW9kZSlpZigwPT09KGIubW9kZSYxKSliLm1lbW9pemVkU3RhdGU9e2Jhc2VMYW5lczowLGNhY2hlUG9vbDpudWxsLHRyYW5zaXRpb25zOm51bGx9LHYoaWcsJGYpLCRmfD1jO2Vsc2UgaWYoMCE9PShjJjEwNzM3NDE4MjQpKWIubWVtb2l6ZWRTdGF0ZT17YmFzZUxhbmVzOjAsY2FjaGVQb29sOm51bGwsdHJhbnNpdGlvbnM6bnVsbH0sZD1udWxsIT09Zj9mLmJhc2VMYW5lczpjLHYoaWcsJGYpLCRmfD1kO2Vsc2UgcmV0dXJuIGE9bnVsbCE9PWY/Zi5iYXNlTGFuZXN8YzpjLGIubGFuZXM9Yi5jaGlsZExhbmVzPTEwNzM3NDE4MjQsYi5tZW1vaXplZFN0YXRlPXtiYXNlTGFuZXM6YSxjYWNoZVBvb2w6bnVsbCx0cmFuc2l0aW9uczpudWxsfSxiLnVwZGF0ZVF1ZXVlPW51bGwsdihpZywkZiksJGZ8PWEsbnVsbDtcbmVsc2UgbnVsbCE9PWY/KGQ9Zi5iYXNlTGFuZXN8YyxiLm1lbW9pemVkU3RhdGU9bnVsbCk6ZD1jLHYoaWcsJGYpLCRmfD1kO1EoYSxiLGUsYyk7cmV0dXJuIGIuY2hpbGR9ZnVuY3Rpb24gamcoYSxiKXt2YXIgYz1iLnJlZjtpZihudWxsPT09YSYmbnVsbCE9PWN8fG51bGwhPT1hJiZhLnJlZiE9PWMpYi5mbGFnc3w9NTEyLGIuZmxhZ3N8PTIwOTcxNTJ9ZnVuY3Rpb24gZ2coYSxiLGMsZCxlKXt2YXIgZj1BKGMpP2pjOnguY3VycmVudDtmPWtjKGIsZik7bWQoYixlKTtjPU5lKGEsYixjLGQsZixlKTtkPVNlKCk7aWYobnVsbCE9PWEmJiFGKXJldHVybiBiLnVwZGF0ZVF1ZXVlPWEudXBkYXRlUXVldWUsYi5mbGFncyY9LTIwNTMsYS5sYW5lcyY9fmUsY2coYSxiLGUpO0gmJmQmJlVkKGIpO2IuZmxhZ3N8PTE7UShhLGIsYyxlKTtyZXR1cm4gYi5jaGlsZH1cbmZ1bmN0aW9uIGtnKGEsYixjLGQsZSl7aWYoQShjKSl7dmFyIGY9ITA7cGMoYil9ZWxzZSBmPSExO21kKGIsZSk7aWYobnVsbD09PWIuc3RhdGVOb2RlKW51bGwhPT1hJiYoYS5hbHRlcm5hdGU9bnVsbCxiLmFsdGVybmF0ZT1udWxsLGIuZmxhZ3N8PTIpLEdkKGIsYyxkKSxJZChiLGMsZCxlKSxkPSEwO2Vsc2UgaWYobnVsbD09PWEpe3ZhciBnPWIuc3RhdGVOb2RlLGg9Yi5tZW1vaXplZFByb3BzO2cucHJvcHM9aDt2YXIgaz1nLmNvbnRleHQsbD1jLmNvbnRleHRUeXBlO1wib2JqZWN0XCI9PT10eXBlb2YgbCYmbnVsbCE9PWw/bD1uZChsKToobD1BKGMpP2pjOnguY3VycmVudCxsPWtjKGIsbCkpO3ZhciBtPWMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLHI9XCJmdW5jdGlvblwiPT09dHlwZW9mIG18fFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlO3J8fFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJiZcImZ1bmN0aW9uXCIhPT1cbnR5cGVvZiBnLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHN8fChoIT09ZHx8ayE9PWwpJiZIZChiLGcsZCxsKTtwZD0hMTt2YXIgcT1iLm1lbW9pemVkU3RhdGU7Zy5zdGF0ZT1xO3hkKGIsZCxnLGUpO2s9Yi5tZW1vaXplZFN0YXRlO2ghPT1kfHxxIT09a3x8ei5jdXJyZW50fHxwZD8oXCJmdW5jdGlvblwiPT09dHlwZW9mIG0mJihCZChiLGMsbSxkKSxrPWIubWVtb2l6ZWRTdGF0ZSksKGg9cGR8fEZkKGIsYyxoLGQscSxrLGwpKT8ocnx8XCJmdW5jdGlvblwiIT09dHlwZW9mIGcuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGcuY29tcG9uZW50V2lsbE1vdW50fHwoXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuY29tcG9uZW50V2lsbE1vdW50JiZnLmNvbXBvbmVudFdpbGxNb3VudCgpLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQmJmcuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpKSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnREaWRNb3VudCYmXG4oYi5mbGFnc3w9NDE5NDMwOCkpOihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnREaWRNb3VudCYmKGIuZmxhZ3N8PTQxOTQzMDgpLGIubWVtb2l6ZWRQcm9wcz1kLGIubWVtb2l6ZWRTdGF0ZT1rKSxnLnByb3BzPWQsZy5zdGF0ZT1rLGcuY29udGV4dD1sLGQ9aCk6KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmNvbXBvbmVudERpZE1vdW50JiYoYi5mbGFnc3w9NDE5NDMwOCksZD0hMSl9ZWxzZXtnPWIuc3RhdGVOb2RlO3JkKGEsYik7aD1iLm1lbW9pemVkUHJvcHM7bD1iLnR5cGU9PT1iLmVsZW1lbnRUeXBlP2g6ZGQoYi50eXBlLGgpO2cucHJvcHM9bDtyPWIucGVuZGluZ1Byb3BzO3E9Zy5jb250ZXh0O2s9Yy5jb250ZXh0VHlwZTtcIm9iamVjdFwiPT09dHlwZW9mIGsmJm51bGwhPT1rP2s9bmQoayk6KGs9QShjKT9qYzp4LmN1cnJlbnQsaz1rYyhiLGspKTt2YXIgQj1jLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczsobT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgQnx8XCJmdW5jdGlvblwiPT09XG50eXBlb2YgZy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSl8fFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzfHwoaCE9PXJ8fHEhPT1rKSYmSGQoYixnLGQsayk7cGQ9ITE7cT1iLm1lbW9pemVkU3RhdGU7Zy5zdGF0ZT1xO3hkKGIsZCxnLGUpO3ZhciB3PWIubWVtb2l6ZWRTdGF0ZTtoIT09cnx8cSE9PXd8fHouY3VycmVudHx8cGQ/KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBCJiYoQmQoYixjLEIsZCksdz1iLm1lbW9pemVkU3RhdGUpLChsPXBkfHxGZChiLGMsbCxkLHEsdyxrKXx8ITEpPyhtfHxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGcuY29tcG9uZW50V2lsbFVwZGF0ZXx8KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxVcGRhdGUmJmcuY29tcG9uZW50V2lsbFVwZGF0ZShkLFxudyxrKSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSYmZy5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZShkLHcsaykpLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmNvbXBvbmVudERpZFVwZGF0ZSYmKGIuZmxhZ3N8PTQpLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlJiYoYi5mbGFnc3w9MTAyNCkpOihcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGV8fGg9PT1hLm1lbW9pemVkUHJvcHMmJnE9PT1hLm1lbW9pemVkU3RhdGV8fChiLmZsYWdzfD00KSxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXx8aD09PWEubWVtb2l6ZWRQcm9wcyYmcT09PWEubWVtb2l6ZWRTdGF0ZXx8KGIuZmxhZ3N8PTEwMjQpLGIubWVtb2l6ZWRQcm9wcz1kLGIubWVtb2l6ZWRTdGF0ZT13KSxnLnByb3BzPWQsZy5zdGF0ZT13LGcuY29udGV4dD1rLGQ9bCk6KFwiZnVuY3Rpb25cIiE9PVxudHlwZW9mIGcuY29tcG9uZW50RGlkVXBkYXRlfHxoPT09YS5tZW1vaXplZFByb3BzJiZxPT09YS5tZW1vaXplZFN0YXRlfHwoYi5mbGFnc3w9NCksXCJmdW5jdGlvblwiIT09dHlwZW9mIGcuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGV8fGg9PT1hLm1lbW9pemVkUHJvcHMmJnE9PT1hLm1lbW9pemVkU3RhdGV8fChiLmZsYWdzfD0xMDI0KSxkPSExKX1yZXR1cm4gbGcoYSxiLGMsZCxmLGUpfVxuZnVuY3Rpb24gbGcoYSxiLGMsZCxlLGYpe2pnKGEsYik7dmFyIGc9MCE9PShiLmZsYWdzJjEyOCk7aWYoIWQmJiFnKXJldHVybiBlJiZxYyhiLGMsITEpLGNnKGEsYixmKTtkPWIuc3RhdGVOb2RlO2FnLmN1cnJlbnQ9Yjt2YXIgaD1nJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgYy5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I/bnVsbDpkLnJlbmRlcigpO2IuZmxhZ3N8PTE7bnVsbCE9PWEmJmc/KGIuY2hpbGQ9cmUoYixhLmNoaWxkLG51bGwsZiksYi5jaGlsZD1yZShiLG51bGwsaCxmKSk6UShhLGIsaCxmKTtiLm1lbW9pemVkU3RhdGU9ZC5zdGF0ZTtlJiZxYyhiLGMsITApO3JldHVybiBiLmNoaWxkfWZ1bmN0aW9uIG1nKGEpe3ZhciBiPWEuc3RhdGVOb2RlO2IucGVuZGluZ0NvbnRleHQ/bWMoYSxiLnBlbmRpbmdDb250ZXh0LGIucGVuZGluZ0NvbnRleHQhPT1iLmNvbnRleHQpOmIuY29udGV4dCYmbWMoYSxiLmNvbnRleHQsITEpO3llKGEsYi5jb250YWluZXJJbmZvKX1cbmZ1bmN0aW9uIG5nKGEsYixjLGQsZSl7Z2UoKTtoZShlKTtiLmZsYWdzfD0yNTY7UShhLGIsYyxkKTtyZXR1cm4gYi5jaGlsZH12YXIgb2c9e2RlaHlkcmF0ZWQ6bnVsbCx0cmVlQ29udGV4dDpudWxsLHJldHJ5TGFuZTowfTtmdW5jdGlvbiBwZyhhKXtyZXR1cm57YmFzZUxhbmVzOmEsY2FjaGVQb29sOm51bGwsdHJhbnNpdGlvbnM6bnVsbH19ZnVuY3Rpb24gcWcoYSxiKXtyZXR1cm57YmFzZUxhbmVzOmEuYmFzZUxhbmVzfGIsY2FjaGVQb29sOm51bGwsdHJhbnNpdGlvbnM6YS50cmFuc2l0aW9uc319XG5mdW5jdGlvbiByZyhhLGIsYyl7dmFyIGQ9Yi5wZW5kaW5nUHJvcHMsZT1JLmN1cnJlbnQsZj0hMSxnPTAhPT0oYi5mbGFncyYxMjgpLGg7KGg9Zyl8fChoPW51bGwhPT1hJiZudWxsPT09YS5tZW1vaXplZFN0YXRlPyExOjAhPT0oZSYyKSk7aWYoaClmPSEwLGIuZmxhZ3MmPS0xMjk7ZWxzZSBpZihudWxsPT09YXx8bnVsbCE9PWEubWVtb2l6ZWRTdGF0ZSllfD0xO3YoSSxlJjEpO2lmKG51bGw9PT1hKXtkZShiKTthPWIubWVtb2l6ZWRTdGF0ZTtpZihudWxsIT09YSYmKGE9YS5kZWh5ZHJhdGVkLG51bGwhPT1hKSlyZXR1cm4gMD09PShiLm1vZGUmMSk/Yi5sYW5lcz0xOktiKGEpP2IubGFuZXM9ODpiLmxhbmVzPTEwNzM3NDE4MjQsbnVsbDtlPWQuY2hpbGRyZW47YT1kLmZhbGxiYWNrO3JldHVybiBmPyhkPWIubW9kZSxmPWIuY2hpbGQsZT17bW9kZTpcImhpZGRlblwiLGNoaWxkcmVuOmV9LDA9PT0oZCYxKSYmbnVsbCE9PWY/KGYuY2hpbGRMYW5lcz0wLGYucGVuZGluZ1Byb3BzPWUpOlxuZj1zZyhlLGQsMCxudWxsKSxhPXFlKGEsZCxjLG51bGwpLGYucmV0dXJuPWIsYS5yZXR1cm49YixmLnNpYmxpbmc9YSxiLmNoaWxkPWYsYi5jaGlsZC5tZW1vaXplZFN0YXRlPXBnKGMpLGIubWVtb2l6ZWRTdGF0ZT1vZyxhKTp0ZyhiLGUpfWU9YS5tZW1vaXplZFN0YXRlO2lmKG51bGwhPT1lKXtoPWUuZGVoeWRyYXRlZDtpZihudWxsIT09aCl7aWYoZyl7aWYoYi5mbGFncyYyNTYpcmV0dXJuIGIuZmxhZ3MmPS0yNTcsdWcoYSxiLGMsRXJyb3Iobig0MjIpKSk7aWYobnVsbCE9PWIubWVtb2l6ZWRTdGF0ZSlyZXR1cm4gYi5jaGlsZD1hLmNoaWxkLGIuZmxhZ3N8PTEyOCxudWxsO2Y9ZC5mYWxsYmFjaztlPWIubW9kZTtkPXNnKHttb2RlOlwidmlzaWJsZVwiLGNoaWxkcmVuOmQuY2hpbGRyZW59LGUsMCxudWxsKTtmPXFlKGYsZSxjLG51bGwpO2YuZmxhZ3N8PTI7ZC5yZXR1cm49YjtmLnJldHVybj1iO2Quc2libGluZz1mO2IuY2hpbGQ9ZDswIT09KGIubW9kZSYxKSYmcmUoYixhLmNoaWxkLFxubnVsbCxjKTtiLmNoaWxkLm1lbW9pemVkU3RhdGU9cGcoYyk7Yi5tZW1vaXplZFN0YXRlPW9nO3JldHVybiBmfWlmKDA9PT0oYi5tb2RlJjEpKWI9dWcoYSxiLGMsbnVsbCk7ZWxzZSBpZihLYihoKSliPXVnKGEsYixjLEVycm9yKG4oNDE5KSkpO2Vsc2UgaWYoZD0wIT09KGMmYS5jaGlsZExhbmVzKSxGfHxkKXtkPU47aWYobnVsbCE9PWQpe3N3aXRjaChjJi1jKXtjYXNlIDQ6Zj0yO2JyZWFrO2Nhc2UgMTY6Zj04O2JyZWFrO2Nhc2UgNjQ6Y2FzZSAxMjg6Y2FzZSAyNTY6Y2FzZSA1MTI6Y2FzZSAxMDI0OmNhc2UgMjA0ODpjYXNlIDQwOTY6Y2FzZSA4MTkyOmNhc2UgMTYzODQ6Y2FzZSAzMjc2ODpjYXNlIDY1NTM2OmNhc2UgMTMxMDcyOmNhc2UgMjYyMTQ0OmNhc2UgNTI0Mjg4OmNhc2UgMTA0ODU3NjpjYXNlIDIwOTcxNTI6Y2FzZSA0MTk0MzA0OmNhc2UgODM4ODYwODpjYXNlIDE2Nzc3MjE2OmNhc2UgMzM1NTQ0MzI6Y2FzZSA2NzEwODg2NDpmPTMyO2JyZWFrO2Nhc2UgNTM2ODcwOTEyOmY9XG4yNjg0MzU0NTY7YnJlYWs7ZGVmYXVsdDpmPTB9ZD0wIT09KGYmKGQuc3VzcGVuZGVkTGFuZXN8YykpPzA6ZjswIT09ZCYmZCE9PWUucmV0cnlMYW5lJiYoZS5yZXRyeUxhbmU9ZCxEZChhLGQsLTEpKX1YZigpO2I9dWcoYSxiLGMsRXJyb3Iobig0MjEpKSl9ZWxzZSBKYihoKT8oYi5mbGFnc3w9MTI4LGIuY2hpbGQ9YS5jaGlsZCxiPXZnLmJpbmQobnVsbCxhKSxMYihoLGIpLGI9bnVsbCk6KGM9ZS50cmVlQ29udGV4dCxWYSYmKFhkPVBiKGgpLFdkPWIsSD0hMCxaZD1udWxsLFlkPSExLG51bGwhPT1jJiYoTmRbT2QrK109UWQsTmRbT2QrK109UmQsTmRbT2QrK109UGQsUWQ9Yy5pZCxSZD1jLm92ZXJmbG93LFBkPWIpKSxiPXRnKGIsYi5wZW5kaW5nUHJvcHMuY2hpbGRyZW4pLGIuZmxhZ3N8PTQwOTYpO3JldHVybiBifWlmKGYpcmV0dXJuIGQ9d2coYSxiLGQuY2hpbGRyZW4sZC5mYWxsYmFjayxjKSxmPWIuY2hpbGQsZT1hLmNoaWxkLm1lbW9pemVkU3RhdGUsZi5tZW1vaXplZFN0YXRlPVxubnVsbD09PWU/cGcoYyk6cWcoZSxjKSxmLmNoaWxkTGFuZXM9YS5jaGlsZExhbmVzJn5jLGIubWVtb2l6ZWRTdGF0ZT1vZyxkO2M9eGcoYSxiLGQuY2hpbGRyZW4sYyk7Yi5tZW1vaXplZFN0YXRlPW51bGw7cmV0dXJuIGN9aWYoZilyZXR1cm4gZD13ZyhhLGIsZC5jaGlsZHJlbixkLmZhbGxiYWNrLGMpLGY9Yi5jaGlsZCxlPWEuY2hpbGQubWVtb2l6ZWRTdGF0ZSxmLm1lbW9pemVkU3RhdGU9bnVsbD09PWU/cGcoYyk6cWcoZSxjKSxmLmNoaWxkTGFuZXM9YS5jaGlsZExhbmVzJn5jLGIubWVtb2l6ZWRTdGF0ZT1vZyxkO2M9eGcoYSxiLGQuY2hpbGRyZW4sYyk7Yi5tZW1vaXplZFN0YXRlPW51bGw7cmV0dXJuIGN9ZnVuY3Rpb24gdGcoYSxiKXtiPXNnKHttb2RlOlwidmlzaWJsZVwiLGNoaWxkcmVuOmJ9LGEubW9kZSwwLG51bGwpO2IucmV0dXJuPWE7cmV0dXJuIGEuY2hpbGQ9Yn1cbmZ1bmN0aW9uIHhnKGEsYixjLGQpe3ZhciBlPWEuY2hpbGQ7YT1lLnNpYmxpbmc7Yz1tZShlLHttb2RlOlwidmlzaWJsZVwiLGNoaWxkcmVuOmN9KTswPT09KGIubW9kZSYxKSYmKGMubGFuZXM9ZCk7Yy5yZXR1cm49YjtjLnNpYmxpbmc9bnVsbDtudWxsIT09YSYmKGQ9Yi5kZWxldGlvbnMsbnVsbD09PWQ/KGIuZGVsZXRpb25zPVthXSxiLmZsYWdzfD0xNik6ZC5wdXNoKGEpKTtyZXR1cm4gYi5jaGlsZD1jfVxuZnVuY3Rpb24gd2coYSxiLGMsZCxlKXt2YXIgZj1iLm1vZGU7YT1hLmNoaWxkO3ZhciBnPWEuc2libGluZyxoPXttb2RlOlwiaGlkZGVuXCIsY2hpbGRyZW46Y307MD09PShmJjEpJiZiLmNoaWxkIT09YT8oYz1iLmNoaWxkLGMuY2hpbGRMYW5lcz0wLGMucGVuZGluZ1Byb3BzPWgsYi5kZWxldGlvbnM9bnVsbCk6KGM9bWUoYSxoKSxjLnN1YnRyZWVGbGFncz1hLnN1YnRyZWVGbGFncyYxNDY4MDA2NCk7bnVsbCE9PWc/ZD1tZShnLGQpOihkPXFlKGQsZixlLG51bGwpLGQuZmxhZ3N8PTIpO2QucmV0dXJuPWI7Yy5yZXR1cm49YjtjLnNpYmxpbmc9ZDtiLmNoaWxkPWM7cmV0dXJuIGR9ZnVuY3Rpb24gdWcoYSxiLGMsZCl7bnVsbCE9PWQmJmhlKGQpO3JlKGIsYS5jaGlsZCxudWxsLGMpO2E9dGcoYixiLnBlbmRpbmdQcm9wcy5jaGlsZHJlbik7YS5mbGFnc3w9MjtiLm1lbW9pemVkU3RhdGU9bnVsbDtyZXR1cm4gYX1cbmZ1bmN0aW9uIHlnKGEsYixjKXthLmxhbmVzfD1iO3ZhciBkPWEuYWx0ZXJuYXRlO251bGwhPT1kJiYoZC5sYW5lc3w9Yik7bGQoYS5yZXR1cm4sYixjKX1mdW5jdGlvbiB6ZyhhLGIsYyxkLGUpe3ZhciBmPWEubWVtb2l6ZWRTdGF0ZTtudWxsPT09Zj9hLm1lbW9pemVkU3RhdGU9e2lzQmFja3dhcmRzOmIscmVuZGVyaW5nOm51bGwscmVuZGVyaW5nU3RhcnRUaW1lOjAsbGFzdDpkLHRhaWw6Yyx0YWlsTW9kZTplfTooZi5pc0JhY2t3YXJkcz1iLGYucmVuZGVyaW5nPW51bGwsZi5yZW5kZXJpbmdTdGFydFRpbWU9MCxmLmxhc3Q9ZCxmLnRhaWw9YyxmLnRhaWxNb2RlPWUpfVxuZnVuY3Rpb24gQWcoYSxiLGMpe3ZhciBkPWIucGVuZGluZ1Byb3BzLGU9ZC5yZXZlYWxPcmRlcixmPWQudGFpbDtRKGEsYixkLmNoaWxkcmVuLGMpO2Q9SS5jdXJyZW50O2lmKDAhPT0oZCYyKSlkPWQmMXwyLGIuZmxhZ3N8PTEyODtlbHNle2lmKG51bGwhPT1hJiYwIT09KGEuZmxhZ3MmMTI4KSlhOmZvcihhPWIuY2hpbGQ7bnVsbCE9PWE7KXtpZigxMz09PWEudGFnKW51bGwhPT1hLm1lbW9pemVkU3RhdGUmJnlnKGEsYyxiKTtlbHNlIGlmKDE5PT09YS50YWcpeWcoYSxjLGIpO2Vsc2UgaWYobnVsbCE9PWEuY2hpbGQpe2EuY2hpbGQucmV0dXJuPWE7YT1hLmNoaWxkO2NvbnRpbnVlfWlmKGE9PT1iKWJyZWFrIGE7Zm9yKDtudWxsPT09YS5zaWJsaW5nOyl7aWYobnVsbD09PWEucmV0dXJufHxhLnJldHVybj09PWIpYnJlYWsgYTthPWEucmV0dXJufWEuc2libGluZy5yZXR1cm49YS5yZXR1cm47YT1hLnNpYmxpbmd9ZCY9MX12KEksZCk7aWYoMD09PShiLm1vZGUmMSkpYi5tZW1vaXplZFN0YXRlPVxubnVsbDtlbHNlIHN3aXRjaChlKXtjYXNlIFwiZm9yd2FyZHNcIjpjPWIuY2hpbGQ7Zm9yKGU9bnVsbDtudWxsIT09YzspYT1jLmFsdGVybmF0ZSxudWxsIT09YSYmbnVsbD09PUNlKGEpJiYoZT1jKSxjPWMuc2libGluZztjPWU7bnVsbD09PWM/KGU9Yi5jaGlsZCxiLmNoaWxkPW51bGwpOihlPWMuc2libGluZyxjLnNpYmxpbmc9bnVsbCk7emcoYiwhMSxlLGMsZik7YnJlYWs7Y2FzZSBcImJhY2t3YXJkc1wiOmM9bnVsbDtlPWIuY2hpbGQ7Zm9yKGIuY2hpbGQ9bnVsbDtudWxsIT09ZTspe2E9ZS5hbHRlcm5hdGU7aWYobnVsbCE9PWEmJm51bGw9PT1DZShhKSl7Yi5jaGlsZD1lO2JyZWFrfWE9ZS5zaWJsaW5nO2Uuc2libGluZz1jO2M9ZTtlPWF9emcoYiwhMCxjLG51bGwsZik7YnJlYWs7Y2FzZSBcInRvZ2V0aGVyXCI6emcoYiwhMSxudWxsLG51bGwsdm9pZCAwKTticmVhaztkZWZhdWx0OmIubWVtb2l6ZWRTdGF0ZT1udWxsfXJldHVybiBiLmNoaWxkfVxuZnVuY3Rpb24gY2coYSxiLGMpe251bGwhPT1hJiYoYi5kZXBlbmRlbmNpZXM9YS5kZXBlbmRlbmNpZXMpO3lkfD1iLmxhbmVzO2lmKDA9PT0oYyZiLmNoaWxkTGFuZXMpKXJldHVybiBudWxsO2lmKG51bGwhPT1hJiZiLmNoaWxkIT09YS5jaGlsZCl0aHJvdyBFcnJvcihuKDE1MykpO2lmKG51bGwhPT1iLmNoaWxkKXthPWIuY2hpbGQ7Yz1tZShhLGEucGVuZGluZ1Byb3BzKTtiLmNoaWxkPWM7Zm9yKGMucmV0dXJuPWI7bnVsbCE9PWEuc2libGluZzspYT1hLnNpYmxpbmcsYz1jLnNpYmxpbmc9bWUoYSxhLnBlbmRpbmdQcm9wcyksYy5yZXR1cm49YjtjLnNpYmxpbmc9bnVsbH1yZXR1cm4gYi5jaGlsZH1cbmZ1bmN0aW9uIEJnKGEsYixjKXtzd2l0Y2goYi50YWcpe2Nhc2UgMzptZyhiKTtnZSgpO2JyZWFrO2Nhc2UgNTpBZShiKTticmVhaztjYXNlIDE6QShiLnR5cGUpJiZwYyhiKTticmVhaztjYXNlIDQ6eWUoYixiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTticmVhaztjYXNlIDEwOmpkKGIsYi50eXBlLl9jb250ZXh0LGIubWVtb2l6ZWRQcm9wcy52YWx1ZSk7YnJlYWs7Y2FzZSAxMzp2YXIgZD1iLm1lbW9pemVkU3RhdGU7aWYobnVsbCE9PWQpe2lmKG51bGwhPT1kLmRlaHlkcmF0ZWQpcmV0dXJuIHYoSSxJLmN1cnJlbnQmMSksYi5mbGFnc3w9MTI4LG51bGw7aWYoMCE9PShjJmIuY2hpbGQuY2hpbGRMYW5lcykpcmV0dXJuIHJnKGEsYixjKTt2KEksSS5jdXJyZW50JjEpO2E9Y2coYSxiLGMpO3JldHVybiBudWxsIT09YT9hLnNpYmxpbmc6bnVsbH12KEksSS5jdXJyZW50JjEpO2JyZWFrO2Nhc2UgMTk6ZD0wIT09KGMmYi5jaGlsZExhbmVzKTtpZigwIT09KGEuZmxhZ3MmMTI4KSl7aWYoZClyZXR1cm4gQWcoYSxcbmIsYyk7Yi5mbGFnc3w9MTI4fXZhciBlPWIubWVtb2l6ZWRTdGF0ZTtudWxsIT09ZSYmKGUucmVuZGVyaW5nPW51bGwsZS50YWlsPW51bGwsZS5sYXN0RWZmZWN0PW51bGwpO3YoSSxJLmN1cnJlbnQpO2lmKGQpYnJlYWs7ZWxzZSByZXR1cm4gbnVsbDtjYXNlIDIyOmNhc2UgMjM6cmV0dXJuIGIubGFuZXM9MCxoZyhhLGIsYyl9cmV0dXJuIGNnKGEsYixjKX1cbmZ1bmN0aW9uIENnKGEsYil7VmQoYik7c3dpdGNoKGIudGFnKXtjYXNlIDE6cmV0dXJuIEEoYi50eXBlKSYmbGMoKSxhPWIuZmxhZ3MsYSY2NTUzNj8oYi5mbGFncz1hJi02NTUzN3wxMjgsYik6bnVsbDtjYXNlIDM6cmV0dXJuIHplKCkscCh6KSxwKHgpLEVlKCksYT1iLmZsYWdzLDAhPT0oYSY2NTUzNikmJjA9PT0oYSYxMjgpPyhiLmZsYWdzPWEmLTY1NTM3fDEyOCxiKTpudWxsO2Nhc2UgNTpyZXR1cm4gQmUoYiksbnVsbDtjYXNlIDEzOnAoSSk7YT1iLm1lbW9pemVkU3RhdGU7aWYobnVsbCE9PWEmJm51bGwhPT1hLmRlaHlkcmF0ZWQpe2lmKG51bGw9PT1iLmFsdGVybmF0ZSl0aHJvdyBFcnJvcihuKDM0MCkpO2dlKCl9YT1iLmZsYWdzO3JldHVybiBhJjY1NTM2PyhiLmZsYWdzPWEmLTY1NTM3fDEyOCxiKTpudWxsO2Nhc2UgMTk6cmV0dXJuIHAoSSksbnVsbDtjYXNlIDQ6cmV0dXJuIHplKCksbnVsbDtjYXNlIDEwOnJldHVybiBrZChiLnR5cGUuX2NvbnRleHQpLG51bGw7Y2FzZSAyMjpjYXNlIDIzOnJldHVybiBaZigpLFxubnVsbDtjYXNlIDI0OnJldHVybiBudWxsO2RlZmF1bHQ6cmV0dXJuIG51bGx9fXZhciBEZz0hMSxSPSExLEVnPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBXZWFrU2V0P1dlYWtTZXQ6U2V0LFM9bnVsbDtmdW5jdGlvbiBGZyhhLGIpe3ZhciBjPWEucmVmO2lmKG51bGwhPT1jKWlmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBjKXRyeXtjKG51bGwpfWNhdGNoKGQpe1QoYSxiLGQpfWVsc2UgYy5jdXJyZW50PW51bGx9ZnVuY3Rpb24gR2coYSxiLGMpe3RyeXtjKCl9Y2F0Y2goZCl7VChhLGIsZCl9fXZhciBIZz0hMTtcbmZ1bmN0aW9uIElnKGEsYil7SGEoYS5jb250YWluZXJJbmZvKTtmb3IoUz1iO251bGwhPT1TOylpZihhPVMsYj1hLmNoaWxkLDAhPT0oYS5zdWJ0cmVlRmxhZ3MmMTAyOCkmJm51bGwhPT1iKWIucmV0dXJuPWEsUz1iO2Vsc2UgZm9yKDtudWxsIT09Uzspe2E9Uzt0cnl7dmFyIGM9YS5hbHRlcm5hdGU7aWYoMCE9PShhLmZsYWdzJjEwMjQpKXN3aXRjaChhLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNTpicmVhaztjYXNlIDE6aWYobnVsbCE9PWMpe3ZhciBkPWMubWVtb2l6ZWRQcm9wcyxlPWMubWVtb2l6ZWRTdGF0ZSxmPWEuc3RhdGVOb2RlLGc9Zi5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShhLmVsZW1lbnRUeXBlPT09YS50eXBlP2Q6ZGQoYS50eXBlLGQpLGUpO2YuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGU9Z31icmVhaztjYXNlIDM6VGEmJnhiKGEuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO2JyZWFrO2Nhc2UgNTpjYXNlIDY6Y2FzZSA0OmNhc2UgMTc6YnJlYWs7XG5kZWZhdWx0OnRocm93IEVycm9yKG4oMTYzKSk7fX1jYXRjaChoKXtUKGEsYS5yZXR1cm4saCl9Yj1hLnNpYmxpbmc7aWYobnVsbCE9PWIpe2IucmV0dXJuPWEucmV0dXJuO1M9YjticmVha31TPWEucmV0dXJufWM9SGc7SGc9ITE7cmV0dXJuIGN9ZnVuY3Rpb24gSmcoYSxiLGMpe3ZhciBkPWIudXBkYXRlUXVldWU7ZD1udWxsIT09ZD9kLmxhc3RFZmZlY3Q6bnVsbDtpZihudWxsIT09ZCl7dmFyIGU9ZD1kLm5leHQ7ZG97aWYoKGUudGFnJmEpPT09YSl7dmFyIGY9ZS5kZXN0cm95O2UuZGVzdHJveT12b2lkIDA7dm9pZCAwIT09ZiYmR2coYixjLGYpfWU9ZS5uZXh0fXdoaWxlKGUhPT1kKX19ZnVuY3Rpb24gS2coYSxiKXtiPWIudXBkYXRlUXVldWU7Yj1udWxsIT09Yj9iLmxhc3RFZmZlY3Q6bnVsbDtpZihudWxsIT09Yil7dmFyIGM9Yj1iLm5leHQ7ZG97aWYoKGMudGFnJmEpPT09YSl7dmFyIGQ9Yy5jcmVhdGU7Yy5kZXN0cm95PWQoKX1jPWMubmV4dH13aGlsZShjIT09Yil9fVxuZnVuY3Rpb24gTGcoYSl7dmFyIGI9YS5yZWY7aWYobnVsbCE9PWIpe3ZhciBjPWEuc3RhdGVOb2RlO3N3aXRjaChhLnRhZyl7Y2FzZSA1OmE9RWEoYyk7YnJlYWs7ZGVmYXVsdDphPWN9XCJmdW5jdGlvblwiPT09dHlwZW9mIGI/YihhKTpiLmN1cnJlbnQ9YX19ZnVuY3Rpb24gTWcoYSl7dmFyIGI9YS5hbHRlcm5hdGU7bnVsbCE9PWImJihhLmFsdGVybmF0ZT1udWxsLE1nKGIpKTthLmNoaWxkPW51bGw7YS5kZWxldGlvbnM9bnVsbDthLnNpYmxpbmc9bnVsbDs1PT09YS50YWcmJihiPWEuc3RhdGVOb2RlLG51bGwhPT1iJiZaYShiKSk7YS5zdGF0ZU5vZGU9bnVsbDthLnJldHVybj1udWxsO2EuZGVwZW5kZW5jaWVzPW51bGw7YS5tZW1vaXplZFByb3BzPW51bGw7YS5tZW1vaXplZFN0YXRlPW51bGw7YS5wZW5kaW5nUHJvcHM9bnVsbDthLnN0YXRlTm9kZT1udWxsO2EudXBkYXRlUXVldWU9bnVsbH1cbmZ1bmN0aW9uIE5nKGEpe3JldHVybiA1PT09YS50YWd8fDM9PT1hLnRhZ3x8ND09PWEudGFnfWZ1bmN0aW9uIE9nKGEpe2E6Zm9yKDs7KXtmb3IoO251bGw9PT1hLnNpYmxpbmc7KXtpZihudWxsPT09YS5yZXR1cm58fE5nKGEucmV0dXJuKSlyZXR1cm4gbnVsbDthPWEucmV0dXJufWEuc2libGluZy5yZXR1cm49YS5yZXR1cm47Zm9yKGE9YS5zaWJsaW5nOzUhPT1hLnRhZyYmNiE9PWEudGFnJiYxOCE9PWEudGFnOyl7aWYoYS5mbGFncyYyKWNvbnRpbnVlIGE7aWYobnVsbD09PWEuY2hpbGR8fDQ9PT1hLnRhZyljb250aW51ZSBhO2Vsc2UgYS5jaGlsZC5yZXR1cm49YSxhPWEuY2hpbGR9aWYoIShhLmZsYWdzJjIpKXJldHVybiBhLnN0YXRlTm9kZX19XG5mdW5jdGlvbiBQZyhhLGIsYyl7dmFyIGQ9YS50YWc7aWYoNT09PWR8fDY9PT1kKWE9YS5zdGF0ZU5vZGUsYj9wYihjLGEsYik6a2IoYyxhKTtlbHNlIGlmKDQhPT1kJiYoYT1hLmNoaWxkLG51bGwhPT1hKSlmb3IoUGcoYSxiLGMpLGE9YS5zaWJsaW5nO251bGwhPT1hOylQZyhhLGIsYyksYT1hLnNpYmxpbmd9ZnVuY3Rpb24gUWcoYSxiLGMpe3ZhciBkPWEudGFnO2lmKDU9PT1kfHw2PT09ZClhPWEuc3RhdGVOb2RlLGI/b2IoYyxhLGIpOmpiKGMsYSk7ZWxzZSBpZig0IT09ZCYmKGE9YS5jaGlsZCxudWxsIT09YSkpZm9yKFFnKGEsYixjKSxhPWEuc2libGluZztudWxsIT09YTspUWcoYSxiLGMpLGE9YS5zaWJsaW5nfXZhciBVPW51bGwsUmc9ITE7ZnVuY3Rpb24gU2coYSxiLGMpe2ZvcihjPWMuY2hpbGQ7bnVsbCE9PWM7KVRnKGEsYixjKSxjPWMuc2libGluZ31cbmZ1bmN0aW9uIFRnKGEsYixjKXtpZihSYyYmXCJmdW5jdGlvblwiPT09dHlwZW9mIFJjLm9uQ29tbWl0RmliZXJVbm1vdW50KXRyeXtSYy5vbkNvbW1pdEZpYmVyVW5tb3VudChRYyxjKX1jYXRjaChoKXt9c3dpdGNoKGMudGFnKXtjYXNlIDU6Unx8RmcoYyxiKTtjYXNlIDY6aWYoVGEpe3ZhciBkPVUsZT1SZztVPW51bGw7U2coYSxiLGMpO1U9ZDtSZz1lO251bGwhPT1VJiYoUmc/cmIoVSxjLnN0YXRlTm9kZSk6cWIoVSxjLnN0YXRlTm9kZSkpfWVsc2UgU2coYSxiLGMpO2JyZWFrO2Nhc2UgMTg6VGEmJm51bGwhPT1VJiYoUmc/WGIoVSxjLnN0YXRlTm9kZSk6V2IoVSxjLnN0YXRlTm9kZSkpO2JyZWFrO2Nhc2UgNDpUYT8oZD1VLGU9UmcsVT1jLnN0YXRlTm9kZS5jb250YWluZXJJbmZvLFJnPSEwLFNnKGEsYixjKSxVPWQsUmc9ZSk6KFVhJiYoZD1jLnN0YXRlTm9kZS5jb250YWluZXJJbmZvLGU9emIoZCksQ2IoZCxlKSksU2coYSxiLGMpKTticmVhaztjYXNlIDA6Y2FzZSAxMTpjYXNlIDE0OmNhc2UgMTU6aWYoIVImJlxuKGQ9Yy51cGRhdGVRdWV1ZSxudWxsIT09ZCYmKGQ9ZC5sYXN0RWZmZWN0LG51bGwhPT1kKSkpe2U9ZD1kLm5leHQ7ZG97dmFyIGY9ZSxnPWYuZGVzdHJveTtmPWYudGFnO3ZvaWQgMCE9PWcmJigwIT09KGYmMik/R2coYyxiLGcpOjAhPT0oZiY0KSYmR2coYyxiLGcpKTtlPWUubmV4dH13aGlsZShlIT09ZCl9U2coYSxiLGMpO2JyZWFrO2Nhc2UgMTppZighUiYmKEZnKGMsYiksZD1jLnN0YXRlTm9kZSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5jb21wb25lbnRXaWxsVW5tb3VudCkpdHJ5e2QucHJvcHM9Yy5tZW1vaXplZFByb3BzLGQuc3RhdGU9Yy5tZW1vaXplZFN0YXRlLGQuY29tcG9uZW50V2lsbFVubW91bnQoKX1jYXRjaChoKXtUKGMsYixoKX1TZyhhLGIsYyk7YnJlYWs7Y2FzZSAyMTpTZyhhLGIsYyk7YnJlYWs7Y2FzZSAyMjpjLm1vZGUmMT8oUj0oZD1SKXx8bnVsbCE9PWMubWVtb2l6ZWRTdGF0ZSxTZyhhLGIsYyksUj1kKTpTZyhhLGIsYyk7YnJlYWs7ZGVmYXVsdDpTZyhhLGIsXG5jKX19ZnVuY3Rpb24gVWcoYSl7dmFyIGI9YS51cGRhdGVRdWV1ZTtpZihudWxsIT09Yil7YS51cGRhdGVRdWV1ZT1udWxsO3ZhciBjPWEuc3RhdGVOb2RlO251bGw9PT1jJiYoYz1hLnN0YXRlTm9kZT1uZXcgRWcpO2IuZm9yRWFjaChmdW5jdGlvbihiKXt2YXIgZD1WZy5iaW5kKG51bGwsYSxiKTtjLmhhcyhiKXx8KGMuYWRkKGIpLGIudGhlbihkLGQpKX0pfX1cbmZ1bmN0aW9uIFdnKGEsYil7dmFyIGM9Yi5kZWxldGlvbnM7aWYobnVsbCE9PWMpZm9yKHZhciBkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBlPWNbZF07dHJ5e3ZhciBmPWEsZz1iO2lmKFRhKXt2YXIgaD1nO2E6Zm9yKDtudWxsIT09aDspe3N3aXRjaChoLnRhZyl7Y2FzZSA1OlU9aC5zdGF0ZU5vZGU7Umc9ITE7YnJlYWsgYTtjYXNlIDM6VT1oLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1JnPSEwO2JyZWFrIGE7Y2FzZSA0OlU9aC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztSZz0hMDticmVhayBhfWg9aC5yZXR1cm59aWYobnVsbD09PVUpdGhyb3cgRXJyb3IobigxNjApKTtUZyhmLGcsZSk7VT1udWxsO1JnPSExfWVsc2UgVGcoZixnLGUpO3ZhciBrPWUuYWx0ZXJuYXRlO251bGwhPT1rJiYoay5yZXR1cm49bnVsbCk7ZS5yZXR1cm49bnVsbH1jYXRjaChsKXtUKGUsYixsKX19aWYoYi5zdWJ0cmVlRmxhZ3MmMTI4NTQpZm9yKGI9Yi5jaGlsZDtudWxsIT09YjspWGcoYixhKSxiPWIuc2libGluZ31cbmZ1bmN0aW9uIFhnKGEsYil7dmFyIGM9YS5hbHRlcm5hdGUsZD1hLmZsYWdzO3N3aXRjaChhLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNDpjYXNlIDE1OldnKGIsYSk7WWcoYSk7aWYoZCY0KXt0cnl7SmcoMyxhLGEucmV0dXJuKSxLZygzLGEpfWNhdGNoKGspe1QoYSxhLnJldHVybixrKX10cnl7SmcoNSxhLGEucmV0dXJuKX1jYXRjaChrKXtUKGEsYS5yZXR1cm4sayl9fWJyZWFrO2Nhc2UgMTpXZyhiLGEpO1lnKGEpO2QmNTEyJiZudWxsIT09YyYmRmcoYyxjLnJldHVybik7YnJlYWs7Y2FzZSA1OldnKGIsYSk7WWcoYSk7ZCY1MTImJm51bGwhPT1jJiZGZyhjLGMucmV0dXJuKTtpZihUYSl7aWYoYS5mbGFncyYzMil7dmFyIGU9YS5zdGF0ZU5vZGU7dHJ5e3NiKGUpfWNhdGNoKGspe1QoYSxhLnJldHVybixrKX19aWYoZCY0JiYoZT1hLnN0YXRlTm9kZSxudWxsIT1lKSl7dmFyIGY9YS5tZW1vaXplZFByb3BzO2M9bnVsbCE9PWM/Yy5tZW1vaXplZFByb3BzOmY7ZD1hLnR5cGU7Yj1cbmEudXBkYXRlUXVldWU7YS51cGRhdGVRdWV1ZT1udWxsO2lmKG51bGwhPT1iKXRyeXtuYihlLGIsZCxjLGYsYSl9Y2F0Y2goayl7VChhLGEucmV0dXJuLGspfX19YnJlYWs7Y2FzZSA2OldnKGIsYSk7WWcoYSk7aWYoZCY0JiZUYSl7aWYobnVsbD09PWEuc3RhdGVOb2RlKXRocm93IEVycm9yKG4oMTYyKSk7ZT1hLnN0YXRlTm9kZTtmPWEubWVtb2l6ZWRQcm9wcztjPW51bGwhPT1jP2MubWVtb2l6ZWRQcm9wczpmO3RyeXtsYihlLGMsZil9Y2F0Y2goayl7VChhLGEucmV0dXJuLGspfX1icmVhaztjYXNlIDM6V2coYixhKTtZZyhhKTtpZihkJjQpe2lmKFRhJiZWYSYmbnVsbCE9PWMmJmMubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQpdHJ5e1ViKGIuY29udGFpbmVySW5mbyl9Y2F0Y2goayl7VChhLGEucmV0dXJuLGspfWlmKFVhKXtjPWIuY29udGFpbmVySW5mbztlPWIucGVuZGluZ0NoaWxkcmVuO3RyeXtDYihjLGUpfWNhdGNoKGspe1QoYSxhLnJldHVybixrKX19fWJyZWFrO2Nhc2UgNDpXZyhiLFxuYSk7WWcoYSk7aWYoZCY0JiZVYSl7ZT1hLnN0YXRlTm9kZTtjPWUuY29udGFpbmVySW5mbztlPWUucGVuZGluZ0NoaWxkcmVuO3RyeXtDYihjLGUpfWNhdGNoKGspe1QoYSxhLnJldHVybixrKX19YnJlYWs7Y2FzZSAxMzpXZyhiLGEpO1lnKGEpO2M9YS5jaGlsZDtjLmZsYWdzJjgxOTImJm51bGwhPT1jLm1lbW9pemVkU3RhdGUmJihudWxsPT09Yy5hbHRlcm5hdGV8fG51bGw9PT1jLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlKSYmKFpnPUQoKSk7ZCY0JiZVZyhhKTticmVhaztjYXNlIDIyOmM9bnVsbCE9PWMmJm51bGwhPT1jLm1lbW9pemVkU3RhdGU7aWYoYS5tb2RlJjEpe3ZhciBnPVI7Uj1nfHxjO1dnKGIsYSk7Uj1nfWVsc2UgV2coYixhKTtZZyhhKTtpZihkJjgxOTIpe2Q9bnVsbCE9PWEubWVtb2l6ZWRTdGF0ZTtpZihUYSlhOmlmKGI9bnVsbCxUYSlmb3IoZz1hOzspe2lmKDU9PT1nLnRhZyl7aWYobnVsbD09PWIpe2I9Zzt0cnl7ZT1nLnN0YXRlTm9kZSxkP3RiKGUpOnZiKGcuc3RhdGVOb2RlLFxuZy5tZW1vaXplZFByb3BzKX1jYXRjaChrKXtUKGEsYS5yZXR1cm4sayl9fX1lbHNlIGlmKDY9PT1nLnRhZyl7aWYobnVsbD09PWIpdHJ5e2Y9Zy5zdGF0ZU5vZGUsZD91YihmKTp3YihmLGcubWVtb2l6ZWRQcm9wcyl9Y2F0Y2goayl7VChhLGEucmV0dXJuLGspfX1lbHNlIGlmKCgyMiE9PWcudGFnJiYyMyE9PWcudGFnfHxudWxsPT09Zy5tZW1vaXplZFN0YXRlfHxnPT09YSkmJm51bGwhPT1nLmNoaWxkKXtnLmNoaWxkLnJldHVybj1nO2c9Zy5jaGlsZDtjb250aW51ZX1pZihnPT09YSlicmVhayBhO2Zvcig7bnVsbD09PWcuc2libGluZzspe2lmKG51bGw9PT1nLnJldHVybnx8Zy5yZXR1cm49PT1hKWJyZWFrIGE7Yj09PWcmJihiPW51bGwpO2c9Zy5yZXR1cm59Yj09PWcmJihiPW51bGwpO2cuc2libGluZy5yZXR1cm49Zy5yZXR1cm47Zz1nLnNpYmxpbmd9aWYoZCYmIWMmJjAhPT0oYS5tb2RlJjEpKWZvcihTPWEsYT1hLmNoaWxkO251bGwhPT1hOyl7Zm9yKGM9Uz1hO251bGwhPT1TOyl7ZT1cblM7Zj1lLmNoaWxkO3N3aXRjaChlLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNDpjYXNlIDE1OkpnKDQsZSxlLnJldHVybik7YnJlYWs7Y2FzZSAxOkZnKGUsZS5yZXR1cm4pO3ZhciBoPWUuc3RhdGVOb2RlO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBoLmNvbXBvbmVudFdpbGxVbm1vdW50KXtkPWU7Yj1lLnJldHVybjt0cnl7Zz1kLGgucHJvcHM9Zy5tZW1vaXplZFByb3BzLGguc3RhdGU9Zy5tZW1vaXplZFN0YXRlLGguY29tcG9uZW50V2lsbFVubW91bnQoKX1jYXRjaChrKXtUKGQsYixrKX19YnJlYWs7Y2FzZSA1OkZnKGUsZS5yZXR1cm4pO2JyZWFrO2Nhc2UgMjI6aWYobnVsbCE9PWUubWVtb2l6ZWRTdGF0ZSl7JGcoYyk7Y29udGludWV9fW51bGwhPT1mPyhmLnJldHVybj1lLFM9Zik6JGcoYyl9YT1hLnNpYmxpbmd9fWJyZWFrO2Nhc2UgMTk6V2coYixhKTtZZyhhKTtkJjQmJlVnKGEpO2JyZWFrO2Nhc2UgMjE6YnJlYWs7ZGVmYXVsdDpXZyhiLGEpLFlnKGEpfX1cbmZ1bmN0aW9uIFlnKGEpe3ZhciBiPWEuZmxhZ3M7aWYoYiYyKXt0cnl7aWYoVGEpe2I6e2Zvcih2YXIgYz1hLnJldHVybjtudWxsIT09Yzspe2lmKE5nKGMpKXt2YXIgZD1jO2JyZWFrIGJ9Yz1jLnJldHVybn10aHJvdyBFcnJvcihuKDE2MCkpO31zd2l0Y2goZC50YWcpe2Nhc2UgNTp2YXIgZT1kLnN0YXRlTm9kZTtkLmZsYWdzJjMyJiYoc2IoZSksZC5mbGFncyY9LTMzKTt2YXIgZj1PZyhhKTtRZyhhLGYsZSk7YnJlYWs7Y2FzZSAzOmNhc2UgNDp2YXIgZz1kLnN0YXRlTm9kZS5jb250YWluZXJJbmZvLGg9T2coYSk7UGcoYSxoLGcpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IobigxNjEpKTt9fX1jYXRjaChrKXtUKGEsYS5yZXR1cm4sayl9YS5mbGFncyY9LTN9YiY0MDk2JiYoYS5mbGFncyY9LTQwOTcpfWZ1bmN0aW9uIGFoKGEsYixjKXtTPWE7YmgoYSxiLGMpfVxuZnVuY3Rpb24gYmgoYSxiLGMpe2Zvcih2YXIgZD0wIT09KGEubW9kZSYxKTtudWxsIT09Uzspe3ZhciBlPVMsZj1lLmNoaWxkO2lmKDIyPT09ZS50YWcmJmQpe3ZhciBnPW51bGwhPT1lLm1lbW9pemVkU3RhdGV8fERnO2lmKCFnKXt2YXIgaD1lLmFsdGVybmF0ZSxrPW51bGwhPT1oJiZudWxsIT09aC5tZW1vaXplZFN0YXRlfHxSO2g9RGc7dmFyIGw9UjtEZz1nO2lmKChSPWspJiYhbClmb3IoUz1lO251bGwhPT1TOylnPVMsaz1nLmNoaWxkLDIyPT09Zy50YWcmJm51bGwhPT1nLm1lbW9pemVkU3RhdGU/Y2goZSk6bnVsbCE9PWs/KGsucmV0dXJuPWcsUz1rKTpjaChlKTtmb3IoO251bGwhPT1mOylTPWYsYmgoZixiLGMpLGY9Zi5zaWJsaW5nO1M9ZTtEZz1oO1I9bH1kaChhLGIsYyl9ZWxzZSAwIT09KGUuc3VidHJlZUZsYWdzJjg3NzIpJiZudWxsIT09Zj8oZi5yZXR1cm49ZSxTPWYpOmRoKGEsYixjKX19XG5mdW5jdGlvbiBkaChhKXtmb3IoO251bGwhPT1TOyl7dmFyIGI9UztpZigwIT09KGIuZmxhZ3MmODc3Mikpe3ZhciBjPWIuYWx0ZXJuYXRlO3RyeXtpZigwIT09KGIuZmxhZ3MmODc3Mikpc3dpdGNoKGIudGFnKXtjYXNlIDA6Y2FzZSAxMTpjYXNlIDE1OlJ8fEtnKDUsYik7YnJlYWs7Y2FzZSAxOnZhciBkPWIuc3RhdGVOb2RlO2lmKGIuZmxhZ3MmNCYmIVIpaWYobnVsbD09PWMpZC5jb21wb25lbnREaWRNb3VudCgpO2Vsc2V7dmFyIGU9Yi5lbGVtZW50VHlwZT09PWIudHlwZT9jLm1lbW9pemVkUHJvcHM6ZGQoYi50eXBlLGMubWVtb2l6ZWRQcm9wcyk7ZC5jb21wb25lbnREaWRVcGRhdGUoZSxjLm1lbW9pemVkU3RhdGUsZC5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSl9dmFyIGY9Yi51cGRhdGVRdWV1ZTtudWxsIT09ZiYmemQoYixmLGQpO2JyZWFrO2Nhc2UgMzp2YXIgZz1iLnVwZGF0ZVF1ZXVlO2lmKG51bGwhPT1nKXtjPW51bGw7aWYobnVsbCE9PWIuY2hpbGQpc3dpdGNoKGIuY2hpbGQudGFnKXtjYXNlIDU6Yz1cbkVhKGIuY2hpbGQuc3RhdGVOb2RlKTticmVhaztjYXNlIDE6Yz1iLmNoaWxkLnN0YXRlTm9kZX16ZChiLGcsYyl9YnJlYWs7Y2FzZSA1OnZhciBoPWIuc3RhdGVOb2RlO251bGw9PT1jJiZiLmZsYWdzJjQmJm1iKGgsYi50eXBlLGIubWVtb2l6ZWRQcm9wcyxiKTticmVhaztjYXNlIDY6YnJlYWs7Y2FzZSA0OmJyZWFrO2Nhc2UgMTI6YnJlYWs7Y2FzZSAxMzppZihWYSYmbnVsbD09PWIubWVtb2l6ZWRTdGF0ZSl7dmFyIGs9Yi5hbHRlcm5hdGU7aWYobnVsbCE9PWspe3ZhciBsPWsubWVtb2l6ZWRTdGF0ZTtpZihudWxsIT09bCl7dmFyIG09bC5kZWh5ZHJhdGVkO251bGwhPT1tJiZWYihtKX19fWJyZWFrO2Nhc2UgMTk6Y2FzZSAxNzpjYXNlIDIxOmNhc2UgMjI6Y2FzZSAyMzpicmVhaztkZWZhdWx0OnRocm93IEVycm9yKG4oMTYzKSk7fVJ8fGIuZmxhZ3MmNTEyJiZMZyhiKX1jYXRjaChyKXtUKGIsYi5yZXR1cm4scil9fWlmKGI9PT1hKXtTPW51bGw7YnJlYWt9Yz1iLnNpYmxpbmc7aWYobnVsbCE9PVxuYyl7Yy5yZXR1cm49Yi5yZXR1cm47Uz1jO2JyZWFrfVM9Yi5yZXR1cm59fWZ1bmN0aW9uICRnKGEpe2Zvcig7bnVsbCE9PVM7KXt2YXIgYj1TO2lmKGI9PT1hKXtTPW51bGw7YnJlYWt9dmFyIGM9Yi5zaWJsaW5nO2lmKG51bGwhPT1jKXtjLnJldHVybj1iLnJldHVybjtTPWM7YnJlYWt9Uz1iLnJldHVybn19XG5mdW5jdGlvbiBjaChhKXtmb3IoO251bGwhPT1TOyl7dmFyIGI9Uzt0cnl7c3dpdGNoKGIudGFnKXtjYXNlIDA6Y2FzZSAxMTpjYXNlIDE1OnZhciBjPWIucmV0dXJuO3RyeXtLZyg0LGIpfWNhdGNoKGspe1QoYixjLGspfWJyZWFrO2Nhc2UgMTp2YXIgZD1iLnN0YXRlTm9kZTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5jb21wb25lbnREaWRNb3VudCl7dmFyIGU9Yi5yZXR1cm47dHJ5e2QuY29tcG9uZW50RGlkTW91bnQoKX1jYXRjaChrKXtUKGIsZSxrKX19dmFyIGY9Yi5yZXR1cm47dHJ5e0xnKGIpfWNhdGNoKGspe1QoYixmLGspfWJyZWFrO2Nhc2UgNTp2YXIgZz1iLnJldHVybjt0cnl7TGcoYil9Y2F0Y2goayl7VChiLGcsayl9fX1jYXRjaChrKXtUKGIsYi5yZXR1cm4sayl9aWYoYj09PWEpe1M9bnVsbDticmVha312YXIgaD1iLnNpYmxpbmc7aWYobnVsbCE9PWgpe2gucmV0dXJuPWIucmV0dXJuO1M9aDticmVha31TPWIucmV0dXJufX1cbnZhciBlaD0wLGZoPTEsZ2g9MixoaD0zLGloPTQ7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLmZvcil7dmFyIGpoPVN5bWJvbC5mb3I7ZWg9amgoXCJzZWxlY3Rvci5jb21wb25lbnRcIik7Zmg9amgoXCJzZWxlY3Rvci5oYXNfcHNldWRvX2NsYXNzXCIpO2doPWpoKFwic2VsZWN0b3Iucm9sZVwiKTtoaD1qaChcInNlbGVjdG9yLnRlc3RfaWRcIik7aWg9amgoXCJzZWxlY3Rvci50ZXh0XCIpfWZ1bmN0aW9uIGtoKGEpe3ZhciBiPVdhKGEpO2lmKG51bGwhPWIpe2lmKFwic3RyaW5nXCIhPT10eXBlb2YgYi5tZW1vaXplZFByb3BzW1wiZGF0YS10ZXN0bmFtZVwiXSl0aHJvdyBFcnJvcihuKDM2NCkpO3JldHVybiBifWE9Y2IoYSk7aWYobnVsbD09PWEpdGhyb3cgRXJyb3IobigzNjIpKTtyZXR1cm4gYS5zdGF0ZU5vZGUuY3VycmVudH1cbmZ1bmN0aW9uIGxoKGEsYil7c3dpdGNoKGIuJCR0eXBlb2Ype2Nhc2UgZWg6aWYoYS50eXBlPT09Yi52YWx1ZSlyZXR1cm4hMDticmVhaztjYXNlIGZoOmE6e2I9Yi52YWx1ZTthPVthLDBdO2Zvcih2YXIgYz0wO2M8YS5sZW5ndGg7KXt2YXIgZD1hW2MrK10sZT1hW2MrK10sZj1iW2VdO2lmKDUhPT1kLnRhZ3x8IWZiKGQpKXtmb3IoO251bGwhPWYmJmxoKGQsZik7KWUrKyxmPWJbZV07aWYoZT09PWIubGVuZ3RoKXtiPSEwO2JyZWFrIGF9ZWxzZSBmb3IoZD1kLmNoaWxkO251bGwhPT1kOylhLnB1c2goZCxlKSxkPWQuc2libGluZ319Yj0hMX1yZXR1cm4gYjtjYXNlIGdoOmlmKDU9PT1hLnRhZyYmZ2IoYS5zdGF0ZU5vZGUsYi52YWx1ZSkpcmV0dXJuITA7YnJlYWs7Y2FzZSBpaDppZig1PT09YS50YWd8fDY9PT1hLnRhZylpZihhPWViKGEpLG51bGwhPT1hJiYwPD1hLmluZGV4T2YoYi52YWx1ZSkpcmV0dXJuITA7YnJlYWs7Y2FzZSBoaDppZig1PT09YS50YWcmJihhPWEubWVtb2l6ZWRQcm9wc1tcImRhdGEtdGVzdG5hbWVcIl0sXG5cInN0cmluZ1wiPT09dHlwZW9mIGEmJmEudG9Mb3dlckNhc2UoKT09PWIudmFsdWUudG9Mb3dlckNhc2UoKSkpcmV0dXJuITA7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihuKDM2NSkpO31yZXR1cm4hMX1mdW5jdGlvbiBtaChhKXtzd2l0Y2goYS4kJHR5cGVvZil7Y2FzZSBlaDpyZXR1cm5cIjxcIisodWEoYS52YWx1ZSl8fFwiVW5rbm93blwiKStcIj5cIjtjYXNlIGZoOnJldHVyblwiOmhhcyhcIisobWgoYSl8fFwiXCIpK1wiKVwiO2Nhc2UgZ2g6cmV0dXJuJ1tyb2xlPVwiJythLnZhbHVlKydcIl0nO2Nhc2UgaWg6cmV0dXJuJ1wiJythLnZhbHVlKydcIic7Y2FzZSBoaDpyZXR1cm4nW2RhdGEtdGVzdG5hbWU9XCInK2EudmFsdWUrJ1wiXSc7ZGVmYXVsdDp0aHJvdyBFcnJvcihuKDM2NSkpO319XG5mdW5jdGlvbiBuaChhLGIpe3ZhciBjPVtdO2E9W2EsMF07Zm9yKHZhciBkPTA7ZDxhLmxlbmd0aDspe3ZhciBlPWFbZCsrXSxmPWFbZCsrXSxnPWJbZl07aWYoNSE9PWUudGFnfHwhZmIoZSkpe2Zvcig7bnVsbCE9ZyYmbGgoZSxnKTspZisrLGc9YltmXTtpZihmPT09Yi5sZW5ndGgpYy5wdXNoKGUpO2Vsc2UgZm9yKGU9ZS5jaGlsZDtudWxsIT09ZTspYS5wdXNoKGUsZiksZT1lLnNpYmxpbmd9fXJldHVybiBjfWZ1bmN0aW9uIG9oKGEsYil7aWYoIWJiKXRocm93IEVycm9yKG4oMzYzKSk7YT1raChhKTthPW5oKGEsYik7Yj1bXTthPUFycmF5LmZyb20oYSk7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDspe3ZhciBkPWFbYysrXTtpZig1PT09ZC50YWcpZmIoZCl8fGIucHVzaChkLnN0YXRlTm9kZSk7ZWxzZSBmb3IoZD1kLmNoaWxkO251bGwhPT1kOylhLnB1c2goZCksZD1kLnNpYmxpbmd9cmV0dXJuIGJ9XG52YXIgcGg9TWF0aC5jZWlsLHFoPWRhLlJlYWN0Q3VycmVudERpc3BhdGNoZXIscmg9ZGEuUmVhY3RDdXJyZW50T3duZXIsVj1kYS5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxXPTAsTj1udWxsLFg9bnVsbCxZPTAsJGY9MCxpZz1oYygwKSxQPTAsc2g9bnVsbCx5ZD0wLHRoPTAsdWg9MCx2aD1udWxsLHdoPW51bGwsWmc9MCxZZj1JbmZpbml0eSx4aD1udWxsO2Z1bmN0aW9uIHloKCl7WWY9RCgpKzUwMH12YXIgRmY9ITEsR2Y9bnVsbCxJZj1udWxsLHpoPSExLEFoPW51bGwsQmg9MCxDaD0wLERoPW51bGwsRWg9LTEsRmg9MDtmdW5jdGlvbiBHKCl7cmV0dXJuIDAhPT0oVyY2KT9EKCk6LTEhPT1FaD9FaDpFaD1EKCl9ZnVuY3Rpb24gQ2QoYSl7aWYoMD09PShhLm1vZGUmMSkpcmV0dXJuIDE7aWYoMCE9PShXJjIpJiYwIT09WSlyZXR1cm4gWSYtWTtpZihudWxsIT09YWQudHJhbnNpdGlvbilyZXR1cm4gMD09PUZoJiYoRmg9Q2MoKSksRmg7YT1DO3JldHVybiAwIT09YT9hOllhKCl9XG5mdW5jdGlvbiBEZChhLGIsYyl7aWYoNTA8Q2gpdGhyb3cgQ2g9MCxEaD1udWxsLEVycm9yKG4oMTg1KSk7dmFyIGQ9R2goYSxiKTtpZihudWxsPT09ZClyZXR1cm4gbnVsbDtFYyhkLGIsYyk7aWYoMD09PShXJjIpfHxkIT09TilkPT09TiYmKDA9PT0oVyYyKSYmKHRofD1iKSw0PT09UCYmSGgoZCxZKSksSWgoZCxjKSwxPT09YiYmMD09PVcmJjA9PT0oYS5tb2RlJjEpJiYoeWgoKSxXYyYmJGMoKSk7cmV0dXJuIGR9ZnVuY3Rpb24gR2goYSxiKXthLmxhbmVzfD1iO3ZhciBjPWEuYWx0ZXJuYXRlO251bGwhPT1jJiYoYy5sYW5lc3w9Yik7Yz1hO2ZvcihhPWEucmV0dXJuO251bGwhPT1hOylhLmNoaWxkTGFuZXN8PWIsYz1hLmFsdGVybmF0ZSxudWxsIT09YyYmKGMuY2hpbGRMYW5lc3w9YiksYz1hLGE9YS5yZXR1cm47cmV0dXJuIDM9PT1jLnRhZz9jLnN0YXRlTm9kZTpudWxsfVxuZnVuY3Rpb24gdWQoYSl7cmV0dXJuKG51bGwhPT1OfHxudWxsIT09b2QpJiYwIT09KGEubW9kZSYxKSYmMD09PShXJjIpfVxuZnVuY3Rpb24gSWgoYSxiKXt2YXIgYz1hLmNhbGxiYWNrTm9kZTtBYyhhLGIpO3ZhciBkPXljKGEsYT09PU4/WTowKTtpZigwPT09ZCludWxsIT09YyYmSmMoYyksYS5jYWxsYmFja05vZGU9bnVsbCxhLmNhbGxiYWNrUHJpb3JpdHk9MDtlbHNlIGlmKGI9ZCYtZCxhLmNhbGxiYWNrUHJpb3JpdHkhPT1iKXtudWxsIT1jJiZKYyhjKTtpZigxPT09YikwPT09YS50YWc/WmMoSmguYmluZChudWxsLGEpKTpZYyhKaC5iaW5kKG51bGwsYSkpLCRhP2FiKGZ1bmN0aW9uKCl7MD09PVcmJiRjKCl9KTpJYyhNYywkYyksYz1udWxsO2Vsc2V7c3dpdGNoKEhjKGQpKXtjYXNlIDE6Yz1NYzticmVhaztjYXNlIDQ6Yz1OYzticmVhaztjYXNlIDE2OmM9T2M7YnJlYWs7Y2FzZSA1MzY4NzA5MTI6Yz1QYzticmVhaztkZWZhdWx0OmM9T2N9Yz1LaChjLExoLmJpbmQobnVsbCxhKSl9YS5jYWxsYmFja1ByaW9yaXR5PWI7YS5jYWxsYmFja05vZGU9Y319XG5mdW5jdGlvbiBMaChhLGIpe0VoPS0xO0ZoPTA7aWYoMCE9PShXJjYpKXRocm93IEVycm9yKG4oMzI3KSk7dmFyIGM9YS5jYWxsYmFja05vZGU7aWYoTWgoKSYmYS5jYWxsYmFja05vZGUhPT1jKXJldHVybiBudWxsO3ZhciBkPXljKGEsYT09PU4/WTowKTtpZigwPT09ZClyZXR1cm4gbnVsbDtpZigwIT09KGQmMzApfHwwIT09KGQmYS5leHBpcmVkTGFuZXMpfHxiKWI9TmgoYSxkKTtlbHNle2I9ZDt2YXIgZT1XO1d8PTI7dmFyIGY9T2goKTtpZihOIT09YXx8WSE9PWIpeGg9bnVsbCx5aCgpLFBoKGEsYik7ZG8gdHJ5e1FoKCk7YnJlYWt9Y2F0Y2goaCl7UmgoYSxoKX13aGlsZSgxKTtpZCgpO3FoLmN1cnJlbnQ9ZjtXPWU7bnVsbCE9PVg/Yj0wOihOPW51bGwsWT0wLGI9UCl9aWYoMCE9PWIpezI9PT1iJiYoZT1CYyhhKSwwIT09ZSYmKGQ9ZSxiPVNoKGEsZSkpKTtpZigxPT09Yil0aHJvdyBjPXNoLFBoKGEsMCksSGgoYSxkKSxJaChhLEQoKSksYztpZig2PT09YilIaChhLGQpO2Vsc2V7ZT1cbmEuY3VycmVudC5hbHRlcm5hdGU7aWYoMD09PShkJjMwKSYmIVRoKGUpJiYoYj1OaChhLGQpLDI9PT1iJiYoZj1CYyhhKSwwIT09ZiYmKGQ9ZixiPVNoKGEsZikpKSwxPT09YikpdGhyb3cgYz1zaCxQaChhLDApLEhoKGEsZCksSWgoYSxEKCkpLGM7YS5maW5pc2hlZFdvcms9ZTthLmZpbmlzaGVkTGFuZXM9ZDtzd2l0Y2goYil7Y2FzZSAwOmNhc2UgMTp0aHJvdyBFcnJvcihuKDM0NSkpO2Nhc2UgMjpVaChhLHdoLHhoKTticmVhaztjYXNlIDM6SGgoYSxkKTtpZigoZCYxMzAwMjM0MjQpPT09ZCYmKGI9WmcrNTAwLUQoKSwxMDxiKSl7aWYoMCE9PXljKGEsMCkpYnJlYWs7ZT1hLnN1c3BlbmRlZExhbmVzO2lmKChlJmQpIT09ZCl7RygpO2EucGluZ2VkTGFuZXN8PWEuc3VzcGVuZGVkTGFuZXMmZTticmVha31hLnRpbWVvdXRIYW5kbGU9UGEoVWguYmluZChudWxsLGEsd2gseGgpLGIpO2JyZWFrfVVoKGEsd2gseGgpO2JyZWFrO2Nhc2UgNDpIaChhLGQpO2lmKChkJjQxOTQyNDApPT09ZClicmVhaztcbmI9YS5ldmVudFRpbWVzO2ZvcihlPS0xOzA8ZDspe3ZhciBnPTMxLXNjKGQpO2Y9MTw8ZztnPWJbZ107Zz5lJiYoZT1nKTtkJj1+Zn1kPWU7ZD1EKCktZDtkPSgxMjA+ZD8xMjA6NDgwPmQ/NDgwOjEwODA+ZD8xMDgwOjE5MjA+ZD8xOTIwOjNFMz5kPzNFMzo0MzIwPmQ/NDMyMDoxOTYwKnBoKGQvMTk2MCkpLWQ7aWYoMTA8ZCl7YS50aW1lb3V0SGFuZGxlPVBhKFVoLmJpbmQobnVsbCxhLHdoLHhoKSxkKTticmVha31VaChhLHdoLHhoKTticmVhaztjYXNlIDU6VWgoYSx3aCx4aCk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihuKDMyOSkpO319fUloKGEsRCgpKTtyZXR1cm4gYS5jYWxsYmFja05vZGU9PT1jP0xoLmJpbmQobnVsbCxhKTpudWxsfVxuZnVuY3Rpb24gU2goYSxiKXt2YXIgYz12aDthLmN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQmJihQaChhLGIpLmZsYWdzfD0yNTYpO2E9TmgoYSxiKTsyIT09YSYmKGI9d2gsd2g9YyxudWxsIT09YiYmV2YoYikpO3JldHVybiBhfWZ1bmN0aW9uIFdmKGEpe251bGw9PT13aD93aD1hOndoLnB1c2guYXBwbHkod2gsYSl9XG5mdW5jdGlvbiBUaChhKXtmb3IodmFyIGI9YTs7KXtpZihiLmZsYWdzJjE2Mzg0KXt2YXIgYz1iLnVwZGF0ZVF1ZXVlO2lmKG51bGwhPT1jJiYoYz1jLnN0b3JlcyxudWxsIT09YykpZm9yKHZhciBkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBlPWNbZF0sZj1lLmdldFNuYXBzaG90O2U9ZS52YWx1ZTt0cnl7aWYoIVVjKGYoKSxlKSlyZXR1cm4hMX1jYXRjaChnKXtyZXR1cm4hMX19fWM9Yi5jaGlsZDtpZihiLnN1YnRyZWVGbGFncyYxNjM4NCYmbnVsbCE9PWMpYy5yZXR1cm49YixiPWM7ZWxzZXtpZihiPT09YSlicmVhaztmb3IoO251bGw9PT1iLnNpYmxpbmc7KXtpZihudWxsPT09Yi5yZXR1cm58fGIucmV0dXJuPT09YSlyZXR1cm4hMDtiPWIucmV0dXJufWIuc2libGluZy5yZXR1cm49Yi5yZXR1cm47Yj1iLnNpYmxpbmd9fXJldHVybiEwfVxuZnVuY3Rpb24gSGgoYSxiKXtiJj1+dWg7YiY9fnRoO2Euc3VzcGVuZGVkTGFuZXN8PWI7YS5waW5nZWRMYW5lcyY9fmI7Zm9yKGE9YS5leHBpcmF0aW9uVGltZXM7MDxiOyl7dmFyIGM9MzEtc2MoYiksZD0xPDxjO2FbY109LTE7YiY9fmR9fWZ1bmN0aW9uIEpoKGEpe2lmKDAhPT0oVyY2KSl0aHJvdyBFcnJvcihuKDMyNykpO01oKCk7dmFyIGI9eWMoYSwwKTtpZigwPT09KGImMSkpcmV0dXJuIEloKGEsRCgpKSxudWxsO3ZhciBjPU5oKGEsYik7aWYoMCE9PWEudGFnJiYyPT09Yyl7dmFyIGQ9QmMoYSk7MCE9PWQmJihiPWQsYz1TaChhLGQpKX1pZigxPT09Yyl0aHJvdyBjPXNoLFBoKGEsMCksSGgoYSxiKSxJaChhLEQoKSksYztpZig2PT09Yyl0aHJvdyBFcnJvcihuKDM0NSkpO2EuZmluaXNoZWRXb3JrPWEuY3VycmVudC5hbHRlcm5hdGU7YS5maW5pc2hlZExhbmVzPWI7VWgoYSx3aCx4aCk7SWgoYSxEKCkpO3JldHVybiBudWxsfVxuZnVuY3Rpb24gVmgoYSl7bnVsbCE9PUFoJiYwPT09QWgudGFnJiYwPT09KFcmNikmJk1oKCk7dmFyIGI9VztXfD0xO3ZhciBjPVYudHJhbnNpdGlvbixkPUM7dHJ5e2lmKFYudHJhbnNpdGlvbj1udWxsLEM9MSxhKXJldHVybiBhKCl9ZmluYWxseXtDPWQsVi50cmFuc2l0aW9uPWMsVz1iLDA9PT0oVyY2KSYmJGMoKX19ZnVuY3Rpb24gWmYoKXskZj1pZy5jdXJyZW50O3AoaWcpfVxuZnVuY3Rpb24gUGgoYSxiKXthLmZpbmlzaGVkV29yaz1udWxsO2EuZmluaXNoZWRMYW5lcz0wO3ZhciBjPWEudGltZW91dEhhbmRsZTtjIT09UmEmJihhLnRpbWVvdXRIYW5kbGU9UmEsUWEoYykpO2lmKG51bGwhPT1YKWZvcihjPVgucmV0dXJuO251bGwhPT1jOyl7dmFyIGQ9YztWZChkKTtzd2l0Y2goZC50YWcpe2Nhc2UgMTpkPWQudHlwZS5jaGlsZENvbnRleHRUeXBlcztudWxsIT09ZCYmdm9pZCAwIT09ZCYmbGMoKTticmVhaztjYXNlIDM6emUoKTtwKHopO3AoeCk7RWUoKTticmVhaztjYXNlIDU6QmUoZCk7YnJlYWs7Y2FzZSA0OnplKCk7YnJlYWs7Y2FzZSAxMzpwKEkpO2JyZWFrO2Nhc2UgMTk6cChJKTticmVhaztjYXNlIDEwOmtkKGQudHlwZS5fY29udGV4dCk7YnJlYWs7Y2FzZSAyMjpjYXNlIDIzOlpmKCl9Yz1jLnJldHVybn1OPWE7WD1hPW1lKGEuY3VycmVudCxudWxsKTtZPSRmPWI7UD0wO3NoPW51bGw7dWg9dGg9eWQ9MDt3aD12aD1udWxsO2lmKG51bGwhPT1vZCl7Zm9yKGI9XG4wO2I8b2QubGVuZ3RoO2IrKylpZihjPW9kW2JdLGQ9Yy5pbnRlcmxlYXZlZCxudWxsIT09ZCl7Yy5pbnRlcmxlYXZlZD1udWxsO3ZhciBlPWQubmV4dCxmPWMucGVuZGluZztpZihudWxsIT09Zil7dmFyIGc9Zi5uZXh0O2YubmV4dD1lO2QubmV4dD1nfWMucGVuZGluZz1kfW9kPW51bGx9cmV0dXJuIGF9XG5mdW5jdGlvbiBSaChhLGIpe2Rve3ZhciBjPVg7dHJ5e2lkKCk7RmUuY3VycmVudD1SZTtpZihJZSl7Zm9yKHZhciBkPUoubWVtb2l6ZWRTdGF0ZTtudWxsIT09ZDspe3ZhciBlPWQucXVldWU7bnVsbCE9PWUmJihlLnBlbmRpbmc9bnVsbCk7ZD1kLm5leHR9SWU9ITF9SGU9MDtMPUs9Sj1udWxsO0plPSExO0tlPTA7cmguY3VycmVudD1udWxsO2lmKG51bGw9PT1jfHxudWxsPT09Yy5yZXR1cm4pe1A9MTtzaD1iO1g9bnVsbDticmVha31hOnt2YXIgZj1hLGc9Yy5yZXR1cm4saD1jLGs9YjtiPVk7aC5mbGFnc3w9MzI3Njg7aWYobnVsbCE9PWsmJlwib2JqZWN0XCI9PT10eXBlb2YgayYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGsudGhlbil7dmFyIGw9ayxtPWgscj1tLnRhZztpZigwPT09KG0ubW9kZSYxKSYmKDA9PT1yfHwxMT09PXJ8fDE1PT09cikpe3ZhciBxPW0uYWx0ZXJuYXRlO3E/KG0udXBkYXRlUXVldWU9cS51cGRhdGVRdWV1ZSxtLm1lbW9pemVkU3RhdGU9cS5tZW1vaXplZFN0YXRlLFxubS5sYW5lcz1xLmxhbmVzKToobS51cGRhdGVRdWV1ZT1udWxsLG0ubWVtb2l6ZWRTdGF0ZT1udWxsKX12YXIgQj1MZihnKTtpZihudWxsIT09Qil7Qi5mbGFncyY9LTI1NztNZihCLGcsaCxmLGIpO0IubW9kZSYxJiZKZihmLGwsYik7Yj1CO2s9bDt2YXIgdz1iLnVwZGF0ZVF1ZXVlO2lmKG51bGw9PT13KXt2YXIgWj1uZXcgU2V0O1ouYWRkKGspO2IudXBkYXRlUXVldWU9Wn1lbHNlIHcuYWRkKGspO2JyZWFrIGF9ZWxzZXtpZigwPT09KGImMSkpe0pmKGYsbCxiKTtYZigpO2JyZWFrIGF9az1FcnJvcihuKDQyNikpfX1lbHNlIGlmKEgmJmgubW9kZSYxKXt2YXIgemE9TGYoZyk7aWYobnVsbCE9PXphKXswPT09KHphLmZsYWdzJjY1NTM2KSYmKHphLmZsYWdzfD0yNTYpO01mKHphLGcsaCxmLGIpO2hlKGspO2JyZWFrIGF9fWY9azs0IT09UCYmKFA9Mik7bnVsbD09PXZoP3ZoPVtmXTp2aC5wdXNoKGYpO2s9QmYoayxoKTtoPWc7ZG97c3dpdGNoKGgudGFnKXtjYXNlIDM6aC5mbGFnc3w9XG42NTUzNjtiJj0tYjtoLmxhbmVzfD1iO3ZhciBFPUVmKGgsayxiKTt3ZChoLEUpO2JyZWFrIGE7Y2FzZSAxOmY9azt2YXIgdT1oLnR5cGUsdD1oLnN0YXRlTm9kZTtpZigwPT09KGguZmxhZ3MmMTI4KSYmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiB1LmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcnx8bnVsbCE9PXQmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiB0LmNvbXBvbmVudERpZENhdGNoJiYobnVsbD09PUlmfHwhSWYuaGFzKHQpKSkpe2guZmxhZ3N8PTY1NTM2O2ImPS1iO2gubGFuZXN8PWI7dmFyIERiPUhmKGgsZixiKTt3ZChoLERiKTticmVhayBhfX1oPWgucmV0dXJufXdoaWxlKG51bGwhPT1oKX1XaChjKX1jYXRjaChvYyl7Yj1vYztYPT09YyYmbnVsbCE9PWMmJihYPWM9Yy5yZXR1cm4pO2NvbnRpbnVlfWJyZWFrfXdoaWxlKDEpfWZ1bmN0aW9uIE9oKCl7dmFyIGE9cWguY3VycmVudDtxaC5jdXJyZW50PVJlO3JldHVybiBudWxsPT09YT9SZTphfVxuZnVuY3Rpb24gWGYoKXtpZigwPT09UHx8Mz09PVB8fDI9PT1QKVA9NDtudWxsPT09Tnx8MD09PSh5ZCYyNjg0MzU0NTUpJiYwPT09KHRoJjI2ODQzNTQ1NSl8fEhoKE4sWSl9ZnVuY3Rpb24gTmgoYSxiKXt2YXIgYz1XO1d8PTI7dmFyIGQ9T2goKTtpZihOIT09YXx8WSE9PWIpeGg9bnVsbCxQaChhLGIpO2RvIHRyeXtYaCgpO2JyZWFrfWNhdGNoKGUpe1JoKGEsZSl9d2hpbGUoMSk7aWQoKTtXPWM7cWguY3VycmVudD1kO2lmKG51bGwhPT1YKXRocm93IEVycm9yKG4oMjYxKSk7Tj1udWxsO1k9MDtyZXR1cm4gUH1mdW5jdGlvbiBYaCgpe2Zvcig7bnVsbCE9PVg7KVloKFgpfWZ1bmN0aW9uIFFoKCl7Zm9yKDtudWxsIT09WCYmIUtjKCk7KVloKFgpfWZ1bmN0aW9uIFloKGEpe3ZhciBiPVpoKGEuYWx0ZXJuYXRlLGEsJGYpO2EubWVtb2l6ZWRQcm9wcz1hLnBlbmRpbmdQcm9wcztudWxsPT09Yj9XaChhKTpYPWI7cmguY3VycmVudD1udWxsfVxuZnVuY3Rpb24gV2goYSl7dmFyIGI9YTtkb3t2YXIgYz1iLmFsdGVybmF0ZTthPWIucmV0dXJuO2lmKDA9PT0oYi5mbGFncyYzMjc2OCkpe2lmKGM9VmYoYyxiLCRmKSxudWxsIT09Yyl7WD1jO3JldHVybn19ZWxzZXtjPUNnKGMsYik7aWYobnVsbCE9PWMpe2MuZmxhZ3MmPTMyNzY3O1g9YztyZXR1cm59aWYobnVsbCE9PWEpYS5mbGFnc3w9MzI3NjgsYS5zdWJ0cmVlRmxhZ3M9MCxhLmRlbGV0aW9ucz1udWxsO2Vsc2V7UD02O1g9bnVsbDtyZXR1cm59fWI9Yi5zaWJsaW5nO2lmKG51bGwhPT1iKXtYPWI7cmV0dXJufVg9Yj1hfXdoaWxlKG51bGwhPT1iKTswPT09UCYmKFA9NSl9ZnVuY3Rpb24gVWgoYSxiLGMpe3ZhciBkPUMsZT1WLnRyYW5zaXRpb247dHJ5e1YudHJhbnNpdGlvbj1udWxsLEM9MSwkaChhLGIsYyxkKX1maW5hbGx5e1YudHJhbnNpdGlvbj1lLEM9ZH1yZXR1cm4gbnVsbH1cbmZ1bmN0aW9uICRoKGEsYixjLGQpe2RvIE1oKCk7d2hpbGUobnVsbCE9PUFoKTtpZigwIT09KFcmNikpdGhyb3cgRXJyb3IobigzMjcpKTtjPWEuZmluaXNoZWRXb3JrO3ZhciBlPWEuZmluaXNoZWRMYW5lcztpZihudWxsPT09YylyZXR1cm4gbnVsbDthLmZpbmlzaGVkV29yaz1udWxsO2EuZmluaXNoZWRMYW5lcz0wO2lmKGM9PT1hLmN1cnJlbnQpdGhyb3cgRXJyb3IobigxNzcpKTthLmNhbGxiYWNrTm9kZT1udWxsO2EuY2FsbGJhY2tQcmlvcml0eT0wO3ZhciBmPWMubGFuZXN8Yy5jaGlsZExhbmVzO0ZjKGEsZik7YT09PU4mJihYPU49bnVsbCxZPTApOzA9PT0oYy5zdWJ0cmVlRmxhZ3MmMjA2NCkmJjA9PT0oYy5mbGFncyYyMDY0KXx8emh8fCh6aD0hMCxLaChPYyxmdW5jdGlvbigpe01oKCk7cmV0dXJuIG51bGx9KSk7Zj0wIT09KGMuZmxhZ3MmMTU5OTApO2lmKDAhPT0oYy5zdWJ0cmVlRmxhZ3MmMTU5OTApfHxmKXtmPVYudHJhbnNpdGlvbjtWLnRyYW5zaXRpb249bnVsbDt2YXIgZz1cbkM7Qz0xO3ZhciBoPVc7V3w9NDtyaC5jdXJyZW50PW51bGw7SWcoYSxjKTtYZyhjLGEpO0lhKGEuY29udGFpbmVySW5mbyk7YS5jdXJyZW50PWM7YWgoYyxhLGUpO0xjKCk7Vz1oO0M9ZztWLnRyYW5zaXRpb249Zn1lbHNlIGEuY3VycmVudD1jO3poJiYoemg9ITEsQWg9YSxCaD1lKTtmPWEucGVuZGluZ0xhbmVzOzA9PT1mJiYoSWY9bnVsbCk7U2MoYy5zdGF0ZU5vZGUsZCk7SWgoYSxEKCkpO2lmKG51bGwhPT1iKWZvcihkPWEub25SZWNvdmVyYWJsZUVycm9yLGM9MDtjPGIubGVuZ3RoO2MrKylkKGJbY10pO2lmKEZmKXRocm93IEZmPSExLGE9R2YsR2Y9bnVsbCxhOzAhPT0oQmgmMSkmJjAhPT1hLnRhZyYmTWgoKTtmPWEucGVuZGluZ0xhbmVzOzAhPT0oZiYxKT9hPT09RGg/Q2grKzooQ2g9MCxEaD1hKTpDaD0wOyRjKCk7cmV0dXJuIG51bGx9XG5mdW5jdGlvbiBNaCgpe2lmKG51bGwhPT1BaCl7dmFyIGE9SGMoQmgpLGI9Vi50cmFuc2l0aW9uLGM9Qzt0cnl7Vi50cmFuc2l0aW9uPW51bGw7Qz0xNj5hPzE2OmE7aWYobnVsbD09PUFoKXZhciBkPSExO2Vsc2V7YT1BaDtBaD1udWxsO0JoPTA7aWYoMCE9PShXJjYpKXRocm93IEVycm9yKG4oMzMxKSk7dmFyIGU9VztXfD00O2ZvcihTPWEuY3VycmVudDtudWxsIT09Uzspe3ZhciBmPVMsZz1mLmNoaWxkO2lmKDAhPT0oUy5mbGFncyYxNikpe3ZhciBoPWYuZGVsZXRpb25zO2lmKG51bGwhPT1oKXtmb3IodmFyIGs9MDtrPGgubGVuZ3RoO2srKyl7dmFyIGw9aFtrXTtmb3IoUz1sO251bGwhPT1TOyl7dmFyIG09Uztzd2l0Y2gobS50YWcpe2Nhc2UgMDpjYXNlIDExOmNhc2UgMTU6SmcoOCxtLGYpfXZhciByPW0uY2hpbGQ7aWYobnVsbCE9PXIpci5yZXR1cm49bSxTPXI7ZWxzZSBmb3IoO251bGwhPT1TOyl7bT1TO3ZhciBxPW0uc2libGluZyxCPW0ucmV0dXJuO01nKG0pO2lmKG09PT1cbmwpe1M9bnVsbDticmVha31pZihudWxsIT09cSl7cS5yZXR1cm49QjtTPXE7YnJlYWt9Uz1CfX19dmFyIHc9Zi5hbHRlcm5hdGU7aWYobnVsbCE9PXcpe3ZhciBaPXcuY2hpbGQ7aWYobnVsbCE9PVope3cuY2hpbGQ9bnVsbDtkb3t2YXIgemE9Wi5zaWJsaW5nO1ouc2libGluZz1udWxsO1o9emF9d2hpbGUobnVsbCE9PVopfX1TPWZ9fWlmKDAhPT0oZi5zdWJ0cmVlRmxhZ3MmMjA2NCkmJm51bGwhPT1nKWcucmV0dXJuPWYsUz1nO2Vsc2UgYjpmb3IoO251bGwhPT1TOyl7Zj1TO2lmKDAhPT0oZi5mbGFncyYyMDQ4KSlzd2l0Y2goZi50YWcpe2Nhc2UgMDpjYXNlIDExOmNhc2UgMTU6SmcoOSxmLGYucmV0dXJuKX12YXIgRT1mLnNpYmxpbmc7aWYobnVsbCE9PUUpe0UucmV0dXJuPWYucmV0dXJuO1M9RTticmVhayBifVM9Zi5yZXR1cm59fXZhciB1PWEuY3VycmVudDtmb3IoUz11O251bGwhPT1TOyl7Zz1TO3ZhciB0PWcuY2hpbGQ7aWYoMCE9PShnLnN1YnRyZWVGbGFncyYyMDY0KSYmbnVsbCE9PVxudCl0LnJldHVybj1nLFM9dDtlbHNlIGI6Zm9yKGc9dTtudWxsIT09Uzspe2g9UztpZigwIT09KGguZmxhZ3MmMjA0OCkpdHJ5e3N3aXRjaChoLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNTpLZyg5LGgpfX1jYXRjaChvYyl7VChoLGgucmV0dXJuLG9jKX1pZihoPT09Zyl7Uz1udWxsO2JyZWFrIGJ9dmFyIERiPWguc2libGluZztpZihudWxsIT09RGIpe0RiLnJldHVybj1oLnJldHVybjtTPURiO2JyZWFrIGJ9Uz1oLnJldHVybn19Vz1lOyRjKCk7aWYoUmMmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBSYy5vblBvc3RDb21taXRGaWJlclJvb3QpdHJ5e1JjLm9uUG9zdENvbW1pdEZpYmVyUm9vdChRYyxhKX1jYXRjaChvYyl7fWQ9ITB9cmV0dXJuIGR9ZmluYWxseXtDPWMsVi50cmFuc2l0aW9uPWJ9fXJldHVybiExfWZ1bmN0aW9uIGFpKGEsYixjKXtiPUJmKGMsYik7Yj1FZihhLGIsMSk7dGQoYSxiKTtiPUcoKTthPUdoKGEsMSk7bnVsbCE9PWEmJihFYyhhLDEsYiksSWgoYSxiKSl9XG5mdW5jdGlvbiBUKGEsYixjKXtpZigzPT09YS50YWcpYWkoYSxhLGMpO2Vsc2UgZm9yKDtudWxsIT09Yjspe2lmKDM9PT1iLnRhZyl7YWkoYixhLGMpO2JyZWFrfWVsc2UgaWYoMT09PWIudGFnKXt2YXIgZD1iLnN0YXRlTm9kZTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYi50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcnx8XCJmdW5jdGlvblwiPT09dHlwZW9mIGQuY29tcG9uZW50RGlkQ2F0Y2gmJihudWxsPT09SWZ8fCFJZi5oYXMoZCkpKXthPUJmKGMsYSk7YT1IZihiLGEsMSk7dGQoYixhKTthPUcoKTtiPUdoKGIsMSk7bnVsbCE9PWImJihFYyhiLDEsYSksSWgoYixhKSk7YnJlYWt9fWI9Yi5yZXR1cm59fVxuZnVuY3Rpb24gS2YoYSxiLGMpe3ZhciBkPWEucGluZ0NhY2hlO251bGwhPT1kJiZkLmRlbGV0ZShiKTtiPUcoKTthLnBpbmdlZExhbmVzfD1hLnN1c3BlbmRlZExhbmVzJmM7Tj09PWEmJihZJmMpPT09YyYmKDQ9PT1QfHwzPT09UCYmKFkmMTMwMDIzNDI0KT09PVkmJjUwMD5EKCktWmc/UGgoYSwwKTp1aHw9Yyk7SWgoYSxiKX1mdW5jdGlvbiBiaShhLGIpezA9PT1iJiYoMD09PShhLm1vZGUmMSk/Yj0xOihiPXdjLHdjPDw9MSwwPT09KHdjJjEzMDAyMzQyNCkmJih3Yz00MTk0MzA0KSkpO3ZhciBjPUcoKTthPUdoKGEsYik7bnVsbCE9PWEmJihFYyhhLGIsYyksSWgoYSxjKSl9ZnVuY3Rpb24gdmcoYSl7dmFyIGI9YS5tZW1vaXplZFN0YXRlLGM9MDtudWxsIT09YiYmKGM9Yi5yZXRyeUxhbmUpO2JpKGEsYyl9XG5mdW5jdGlvbiBWZyhhLGIpe3ZhciBjPTA7c3dpdGNoKGEudGFnKXtjYXNlIDEzOnZhciBkPWEuc3RhdGVOb2RlO3ZhciBlPWEubWVtb2l6ZWRTdGF0ZTtudWxsIT09ZSYmKGM9ZS5yZXRyeUxhbmUpO2JyZWFrO2Nhc2UgMTk6ZD1hLnN0YXRlTm9kZTticmVhaztkZWZhdWx0OnRocm93IEVycm9yKG4oMzE0KSk7fW51bGwhPT1kJiZkLmRlbGV0ZShiKTtiaShhLGMpfXZhciBaaDtcblpoPWZ1bmN0aW9uKGEsYixjKXtpZihudWxsIT09YSlpZihhLm1lbW9pemVkUHJvcHMhPT1iLnBlbmRpbmdQcm9wc3x8ei5jdXJyZW50KUY9ITA7ZWxzZXtpZigwPT09KGEubGFuZXMmYykmJjA9PT0oYi5mbGFncyYxMjgpKXJldHVybiBGPSExLEJnKGEsYixjKTtGPTAhPT0oYS5mbGFncyYxMzEwNzIpPyEwOiExfWVsc2UgRj0hMSxIJiYwIT09KGIuZmxhZ3MmMTA0ODU3NikmJlRkKGIsTWQsYi5pbmRleCk7Yi5sYW5lcz0wO3N3aXRjaChiLnRhZyl7Y2FzZSAyOnZhciBkPWIudHlwZTtudWxsIT09YSYmKGEuYWx0ZXJuYXRlPW51bGwsYi5hbHRlcm5hdGU9bnVsbCxiLmZsYWdzfD0yKTthPWIucGVuZGluZ1Byb3BzO3ZhciBlPWtjKGIseC5jdXJyZW50KTttZChiLGMpO2U9TmUobnVsbCxiLGQsYSxlLGMpO3ZhciBmPVNlKCk7Yi5mbGFnc3w9MTtcIm9iamVjdFwiPT09dHlwZW9mIGUmJm51bGwhPT1lJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgZS5yZW5kZXImJnZvaWQgMD09PWUuJCR0eXBlb2Y/XG4oYi50YWc9MSxiLm1lbW9pemVkU3RhdGU9bnVsbCxiLnVwZGF0ZVF1ZXVlPW51bGwsQShkKT8oZj0hMCxwYyhiKSk6Zj0hMSxiLm1lbW9pemVkU3RhdGU9bnVsbCE9PWUuc3RhdGUmJnZvaWQgMCE9PWUuc3RhdGU/ZS5zdGF0ZTpudWxsLHFkKGIpLGUudXBkYXRlcj1FZCxiLnN0YXRlTm9kZT1lLGUuX3JlYWN0SW50ZXJuYWxzPWIsSWQoYixkLGEsYyksYj1sZyhudWxsLGIsZCwhMCxmLGMpKTooYi50YWc9MCxIJiZmJiZVZChiKSxRKG51bGwsYixlLGMpLGI9Yi5jaGlsZCk7cmV0dXJuIGI7Y2FzZSAxNjpkPWIuZWxlbWVudFR5cGU7YTp7bnVsbCE9PWEmJihhLmFsdGVybmF0ZT1udWxsLGIuYWx0ZXJuYXRlPW51bGwsYi5mbGFnc3w9Mik7YT1iLnBlbmRpbmdQcm9wcztlPWQuX2luaXQ7ZD1lKGQuX3BheWxvYWQpO2IudHlwZT1kO2U9Yi50YWc9Y2koZCk7YT1kZChkLGEpO3N3aXRjaChlKXtjYXNlIDA6Yj1nZyhudWxsLGIsZCxhLGMpO2JyZWFrIGE7Y2FzZSAxOmI9a2cobnVsbCxiLGQsXG5hLGMpO2JyZWFrIGE7Y2FzZSAxMTpiPWJnKG51bGwsYixkLGEsYyk7YnJlYWsgYTtjYXNlIDE0OmI9ZGcobnVsbCxiLGQsZGQoZC50eXBlLGEpLGMpO2JyZWFrIGF9dGhyb3cgRXJyb3IobigzMDYsZCxcIlwiKSk7fXJldHVybiBiO2Nhc2UgMDpyZXR1cm4gZD1iLnR5cGUsZT1iLnBlbmRpbmdQcm9wcyxlPWIuZWxlbWVudFR5cGU9PT1kP2U6ZGQoZCxlKSxnZyhhLGIsZCxlLGMpO2Nhc2UgMTpyZXR1cm4gZD1iLnR5cGUsZT1iLnBlbmRpbmdQcm9wcyxlPWIuZWxlbWVudFR5cGU9PT1kP2U6ZGQoZCxlKSxrZyhhLGIsZCxlLGMpO2Nhc2UgMzphOnttZyhiKTtpZihudWxsPT09YSl0aHJvdyBFcnJvcihuKDM4NykpO2Q9Yi5wZW5kaW5nUHJvcHM7Zj1iLm1lbW9pemVkU3RhdGU7ZT1mLmVsZW1lbnQ7cmQoYSxiKTt4ZChiLGQsbnVsbCxjKTt2YXIgZz1iLm1lbW9pemVkU3RhdGU7ZD1nLmVsZW1lbnQ7aWYoVmEmJmYuaXNEZWh5ZHJhdGVkKWlmKGY9e2VsZW1lbnQ6ZCxpc0RlaHlkcmF0ZWQ6ITEsXG5jYWNoZTpnLmNhY2hlLHBlbmRpbmdTdXNwZW5zZUJvdW5kYXJpZXM6Zy5wZW5kaW5nU3VzcGVuc2VCb3VuZGFyaWVzLHRyYW5zaXRpb25zOmcudHJhbnNpdGlvbnN9LGIudXBkYXRlUXVldWUuYmFzZVN0YXRlPWYsYi5tZW1vaXplZFN0YXRlPWYsYi5mbGFncyYyNTYpe2U9RXJyb3Iobig0MjMpKTtiPW5nKGEsYixkLGMsZSk7YnJlYWsgYX1lbHNlIGlmKGQhPT1lKXtlPUVycm9yKG4oNDI0KSk7Yj1uZyhhLGIsZCxjLGUpO2JyZWFrIGF9ZWxzZSBmb3IoVmEmJihYZD1PYihiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKSxXZD1iLEg9ITAsWmQ9bnVsbCxZZD0hMSksYz1zZShiLG51bGwsZCxjKSxiLmNoaWxkPWM7YzspYy5mbGFncz1jLmZsYWdzJi0zfDQwOTYsYz1jLnNpYmxpbmc7ZWxzZXtnZSgpO2lmKGQ9PT1lKXtiPWNnKGEsYixjKTticmVhayBhfVEoYSxiLGQsYyl9Yj1iLmNoaWxkfXJldHVybiBiO2Nhc2UgNTpyZXR1cm4gQWUoYiksbnVsbD09PWEmJmRlKGIpLGQ9Yi50eXBlLGU9XG5iLnBlbmRpbmdQcm9wcyxmPW51bGwhPT1hP2EubWVtb2l6ZWRQcm9wczpudWxsLGc9ZS5jaGlsZHJlbixOYShkLGUpP2c9bnVsbDpudWxsIT09ZiYmTmEoZCxmKSYmKGIuZmxhZ3N8PTMyKSxqZyhhLGIpLFEoYSxiLGcsYyksYi5jaGlsZDtjYXNlIDY6cmV0dXJuIG51bGw9PT1hJiZkZShiKSxudWxsO2Nhc2UgMTM6cmV0dXJuIHJnKGEsYixjKTtjYXNlIDQ6cmV0dXJuIHllKGIsYi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyksZD1iLnBlbmRpbmdQcm9wcyxudWxsPT09YT9iLmNoaWxkPXJlKGIsbnVsbCxkLGMpOlEoYSxiLGQsYyksYi5jaGlsZDtjYXNlIDExOnJldHVybiBkPWIudHlwZSxlPWIucGVuZGluZ1Byb3BzLGU9Yi5lbGVtZW50VHlwZT09PWQ/ZTpkZChkLGUpLGJnKGEsYixkLGUsYyk7Y2FzZSA3OnJldHVybiBRKGEsYixiLnBlbmRpbmdQcm9wcyxjKSxiLmNoaWxkO2Nhc2UgODpyZXR1cm4gUShhLGIsYi5wZW5kaW5nUHJvcHMuY2hpbGRyZW4sYyksYi5jaGlsZDtjYXNlIDEyOnJldHVybiBRKGEsXG5iLGIucGVuZGluZ1Byb3BzLmNoaWxkcmVuLGMpLGIuY2hpbGQ7Y2FzZSAxMDphOntkPWIudHlwZS5fY29udGV4dDtlPWIucGVuZGluZ1Byb3BzO2Y9Yi5tZW1vaXplZFByb3BzO2c9ZS52YWx1ZTtqZChiLGQsZyk7aWYobnVsbCE9PWYpaWYoVWMoZi52YWx1ZSxnKSl7aWYoZi5jaGlsZHJlbj09PWUuY2hpbGRyZW4mJiF6LmN1cnJlbnQpe2I9Y2coYSxiLGMpO2JyZWFrIGF9fWVsc2UgZm9yKGY9Yi5jaGlsZCxudWxsIT09ZiYmKGYucmV0dXJuPWIpO251bGwhPT1mOyl7dmFyIGg9Zi5kZXBlbmRlbmNpZXM7aWYobnVsbCE9PWgpe2c9Zi5jaGlsZDtmb3IodmFyIGs9aC5maXJzdENvbnRleHQ7bnVsbCE9PWs7KXtpZihrLmNvbnRleHQ9PT1kKXtpZigxPT09Zi50YWcpe2s9c2QoLTEsYyYtYyk7ay50YWc9Mjt2YXIgbD1mLnVwZGF0ZVF1ZXVlO2lmKG51bGwhPT1sKXtsPWwuc2hhcmVkO3ZhciBtPWwucGVuZGluZztudWxsPT09bT9rLm5leHQ9azooay5uZXh0PW0ubmV4dCxtLm5leHQ9ayk7XG5sLnBlbmRpbmc9a319Zi5sYW5lc3w9YztrPWYuYWx0ZXJuYXRlO251bGwhPT1rJiYoay5sYW5lc3w9Yyk7bGQoZi5yZXR1cm4sYyxiKTtoLmxhbmVzfD1jO2JyZWFrfWs9ay5uZXh0fX1lbHNlIGlmKDEwPT09Zi50YWcpZz1mLnR5cGU9PT1iLnR5cGU/bnVsbDpmLmNoaWxkO2Vsc2UgaWYoMTg9PT1mLnRhZyl7Zz1mLnJldHVybjtpZihudWxsPT09Zyl0aHJvdyBFcnJvcihuKDM0MSkpO2cubGFuZXN8PWM7aD1nLmFsdGVybmF0ZTtudWxsIT09aCYmKGgubGFuZXN8PWMpO2xkKGcsYyxiKTtnPWYuc2libGluZ31lbHNlIGc9Zi5jaGlsZDtpZihudWxsIT09ZylnLnJldHVybj1mO2Vsc2UgZm9yKGc9ZjtudWxsIT09Zzspe2lmKGc9PT1iKXtnPW51bGw7YnJlYWt9Zj1nLnNpYmxpbmc7aWYobnVsbCE9PWYpe2YucmV0dXJuPWcucmV0dXJuO2c9ZjticmVha31nPWcucmV0dXJufWY9Z31RKGEsYixlLmNoaWxkcmVuLGMpO2I9Yi5jaGlsZH1yZXR1cm4gYjtjYXNlIDk6cmV0dXJuIGU9Yi50eXBlLFxuZD1iLnBlbmRpbmdQcm9wcy5jaGlsZHJlbixtZChiLGMpLGU9bmQoZSksZD1kKGUpLGIuZmxhZ3N8PTEsUShhLGIsZCxjKSxiLmNoaWxkO2Nhc2UgMTQ6cmV0dXJuIGQ9Yi50eXBlLGU9ZGQoZCxiLnBlbmRpbmdQcm9wcyksZT1kZChkLnR5cGUsZSksZGcoYSxiLGQsZSxjKTtjYXNlIDE1OnJldHVybiBmZyhhLGIsYi50eXBlLGIucGVuZGluZ1Byb3BzLGMpO2Nhc2UgMTc6cmV0dXJuIGQ9Yi50eXBlLGU9Yi5wZW5kaW5nUHJvcHMsZT1iLmVsZW1lbnRUeXBlPT09ZD9lOmRkKGQsZSksbnVsbCE9PWEmJihhLmFsdGVybmF0ZT1udWxsLGIuYWx0ZXJuYXRlPW51bGwsYi5mbGFnc3w9MiksYi50YWc9MSxBKGQpPyhhPSEwLHBjKGIpKTphPSExLG1kKGIsYyksR2QoYixkLGUpLElkKGIsZCxlLGMpLGxnKG51bGwsYixkLCEwLGEsYyk7Y2FzZSAxOTpyZXR1cm4gQWcoYSxiLGMpO2Nhc2UgMjI6cmV0dXJuIGhnKGEsYixjKX10aHJvdyBFcnJvcihuKDE1NixiLnRhZykpO307XG5mdW5jdGlvbiBLaChhLGIpe3JldHVybiBJYyhhLGIpfWZ1bmN0aW9uIGRpKGEsYixjLGQpe3RoaXMudGFnPWE7dGhpcy5rZXk9Yzt0aGlzLnNpYmxpbmc9dGhpcy5jaGlsZD10aGlzLnJldHVybj10aGlzLnN0YXRlTm9kZT10aGlzLnR5cGU9dGhpcy5lbGVtZW50VHlwZT1udWxsO3RoaXMuaW5kZXg9MDt0aGlzLnJlZj1udWxsO3RoaXMucGVuZGluZ1Byb3BzPWI7dGhpcy5kZXBlbmRlbmNpZXM9dGhpcy5tZW1vaXplZFN0YXRlPXRoaXMudXBkYXRlUXVldWU9dGhpcy5tZW1vaXplZFByb3BzPW51bGw7dGhpcy5tb2RlPWQ7dGhpcy5zdWJ0cmVlRmxhZ3M9dGhpcy5mbGFncz0wO3RoaXMuZGVsZXRpb25zPW51bGw7dGhpcy5jaGlsZExhbmVzPXRoaXMubGFuZXM9MDt0aGlzLmFsdGVybmF0ZT1udWxsfWZ1bmN0aW9uIGFlKGEsYixjLGQpe3JldHVybiBuZXcgZGkoYSxiLGMsZCl9XG5mdW5jdGlvbiBlZyhhKXthPWEucHJvdG90eXBlO3JldHVybiEoIWF8fCFhLmlzUmVhY3RDb21wb25lbnQpfWZ1bmN0aW9uIGNpKGEpe2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBhKXJldHVybiBlZyhhKT8xOjA7aWYodm9pZCAwIT09YSYmbnVsbCE9PWEpe2E9YS4kJHR5cGVvZjtpZihhPT09bWEpcmV0dXJuIDExO2lmKGE9PT1wYSlyZXR1cm4gMTR9cmV0dXJuIDJ9XG5mdW5jdGlvbiBtZShhLGIpe3ZhciBjPWEuYWx0ZXJuYXRlO251bGw9PT1jPyhjPWFlKGEudGFnLGIsYS5rZXksYS5tb2RlKSxjLmVsZW1lbnRUeXBlPWEuZWxlbWVudFR5cGUsYy50eXBlPWEudHlwZSxjLnN0YXRlTm9kZT1hLnN0YXRlTm9kZSxjLmFsdGVybmF0ZT1hLGEuYWx0ZXJuYXRlPWMpOihjLnBlbmRpbmdQcm9wcz1iLGMudHlwZT1hLnR5cGUsYy5mbGFncz0wLGMuc3VidHJlZUZsYWdzPTAsYy5kZWxldGlvbnM9bnVsbCk7Yy5mbGFncz1hLmZsYWdzJjE0NjgwMDY0O2MuY2hpbGRMYW5lcz1hLmNoaWxkTGFuZXM7Yy5sYW5lcz1hLmxhbmVzO2MuY2hpbGQ9YS5jaGlsZDtjLm1lbW9pemVkUHJvcHM9YS5tZW1vaXplZFByb3BzO2MubWVtb2l6ZWRTdGF0ZT1hLm1lbW9pemVkU3RhdGU7Yy51cGRhdGVRdWV1ZT1hLnVwZGF0ZVF1ZXVlO2I9YS5kZXBlbmRlbmNpZXM7Yy5kZXBlbmRlbmNpZXM9bnVsbD09PWI/bnVsbDp7bGFuZXM6Yi5sYW5lcyxmaXJzdENvbnRleHQ6Yi5maXJzdENvbnRleHR9O1xuYy5zaWJsaW5nPWEuc2libGluZztjLmluZGV4PWEuaW5kZXg7Yy5yZWY9YS5yZWY7cmV0dXJuIGN9XG5mdW5jdGlvbiBvZShhLGIsYyxkLGUsZil7dmFyIGc9MjtkPWE7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGEpZWcoYSkmJihnPTEpO2Vsc2UgaWYoXCJzdHJpbmdcIj09PXR5cGVvZiBhKWc9NTtlbHNlIGE6c3dpdGNoKGEpe2Nhc2UgaGE6cmV0dXJuIHFlKGMuY2hpbGRyZW4sZSxmLGIpO2Nhc2UgaWE6Zz04O2V8PTg7YnJlYWs7Y2FzZSBqYTpyZXR1cm4gYT1hZSgxMixjLGIsZXwyKSxhLmVsZW1lbnRUeXBlPWphLGEubGFuZXM9ZixhO2Nhc2UgbmE6cmV0dXJuIGE9YWUoMTMsYyxiLGUpLGEuZWxlbWVudFR5cGU9bmEsYS5sYW5lcz1mLGE7Y2FzZSBvYTpyZXR1cm4gYT1hZSgxOSxjLGIsZSksYS5lbGVtZW50VHlwZT1vYSxhLmxhbmVzPWYsYTtjYXNlIHJhOnJldHVybiBzZyhjLGUsZixiKTtkZWZhdWx0OmlmKFwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEpc3dpdGNoKGEuJCR0eXBlb2Ype2Nhc2Uga2E6Zz0xMDticmVhayBhO2Nhc2UgbGE6Zz05O2JyZWFrIGE7Y2FzZSBtYTpnPTExO1xuYnJlYWsgYTtjYXNlIHBhOmc9MTQ7YnJlYWsgYTtjYXNlIHFhOmc9MTY7ZD1udWxsO2JyZWFrIGF9dGhyb3cgRXJyb3IobigxMzAsbnVsbD09YT9hOnR5cGVvZiBhLFwiXCIpKTt9Yj1hZShnLGMsYixlKTtiLmVsZW1lbnRUeXBlPWE7Yi50eXBlPWQ7Yi5sYW5lcz1mO3JldHVybiBifWZ1bmN0aW9uIHFlKGEsYixjLGQpe2E9YWUoNyxhLGQsYik7YS5sYW5lcz1jO3JldHVybiBhfWZ1bmN0aW9uIHNnKGEsYixjLGQpe2E9YWUoMjIsYSxkLGIpO2EuZWxlbWVudFR5cGU9cmE7YS5sYW5lcz1jO2Euc3RhdGVOb2RlPXt9O3JldHVybiBhfWZ1bmN0aW9uIG5lKGEsYixjKXthPWFlKDYsYSxudWxsLGIpO2EubGFuZXM9YztyZXR1cm4gYX1cbmZ1bmN0aW9uIHBlKGEsYixjKXtiPWFlKDQsbnVsbCE9PWEuY2hpbGRyZW4/YS5jaGlsZHJlbjpbXSxhLmtleSxiKTtiLmxhbmVzPWM7Yi5zdGF0ZU5vZGU9e2NvbnRhaW5lckluZm86YS5jb250YWluZXJJbmZvLHBlbmRpbmdDaGlsZHJlbjpudWxsLGltcGxlbWVudGF0aW9uOmEuaW1wbGVtZW50YXRpb259O3JldHVybiBifVxuZnVuY3Rpb24gZWkoYSxiLGMsZCxlKXt0aGlzLnRhZz1iO3RoaXMuY29udGFpbmVySW5mbz1hO3RoaXMuZmluaXNoZWRXb3JrPXRoaXMucGluZ0NhY2hlPXRoaXMuY3VycmVudD10aGlzLnBlbmRpbmdDaGlsZHJlbj1udWxsO3RoaXMudGltZW91dEhhbmRsZT1SYTt0aGlzLmNhbGxiYWNrTm9kZT10aGlzLnBlbmRpbmdDb250ZXh0PXRoaXMuY29udGV4dD1udWxsO3RoaXMuY2FsbGJhY2tQcmlvcml0eT0wO3RoaXMuZXZlbnRUaW1lcz1EYygwKTt0aGlzLmV4cGlyYXRpb25UaW1lcz1EYygtMSk7dGhpcy5lbnRhbmdsZWRMYW5lcz10aGlzLmZpbmlzaGVkTGFuZXM9dGhpcy5tdXRhYmxlUmVhZExhbmVzPXRoaXMuZXhwaXJlZExhbmVzPXRoaXMucGluZ2VkTGFuZXM9dGhpcy5zdXNwZW5kZWRMYW5lcz10aGlzLnBlbmRpbmdMYW5lcz0wO3RoaXMuZW50YW5nbGVtZW50cz1EYygwKTt0aGlzLmlkZW50aWZpZXJQcmVmaXg9ZDt0aGlzLm9uUmVjb3ZlcmFibGVFcnJvcj1lO1ZhJiYodGhpcy5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhPVxubnVsbCl9ZnVuY3Rpb24gZmkoYSxiLGMsZCxlLGYsZyxoLGspe2E9bmV3IGVpKGEsYixjLGgsayk7MT09PWI/KGI9MSwhMD09PWYmJihifD04KSk6Yj0wO2Y9YWUoMyxudWxsLG51bGwsYik7YS5jdXJyZW50PWY7Zi5zdGF0ZU5vZGU9YTtmLm1lbW9pemVkU3RhdGU9e2VsZW1lbnQ6ZCxpc0RlaHlkcmF0ZWQ6YyxjYWNoZTpudWxsLHRyYW5zaXRpb25zOm51bGwscGVuZGluZ1N1c3BlbnNlQm91bmRhcmllczpudWxsfTtxZChmKTtyZXR1cm4gYX1cbmZ1bmN0aW9uIGdpKGEpe2lmKCFhKXJldHVybiBpYzthPWEuX3JlYWN0SW50ZXJuYWxzO2E6e2lmKHdhKGEpIT09YXx8MSE9PWEudGFnKXRocm93IEVycm9yKG4oMTcwKSk7dmFyIGI9YTtkb3tzd2l0Y2goYi50YWcpe2Nhc2UgMzpiPWIuc3RhdGVOb2RlLmNvbnRleHQ7YnJlYWsgYTtjYXNlIDE6aWYoQShiLnR5cGUpKXtiPWIuc3RhdGVOb2RlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0O2JyZWFrIGF9fWI9Yi5yZXR1cm59d2hpbGUobnVsbCE9PWIpO3Rocm93IEVycm9yKG4oMTcxKSk7fWlmKDE9PT1hLnRhZyl7dmFyIGM9YS50eXBlO2lmKEEoYykpcmV0dXJuIG5jKGEsYyxiKX1yZXR1cm4gYn1cbmZ1bmN0aW9uIGhpKGEpe3ZhciBiPWEuX3JlYWN0SW50ZXJuYWxzO2lmKHZvaWQgMD09PWIpe2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBhLnJlbmRlcil0aHJvdyBFcnJvcihuKDE4OCkpO2E9T2JqZWN0LmtleXMoYSkuam9pbihcIixcIik7dGhyb3cgRXJyb3IobigyNjgsYSkpO31hPUFhKGIpO3JldHVybiBudWxsPT09YT9udWxsOmEuc3RhdGVOb2RlfWZ1bmN0aW9uIGlpKGEsYil7YT1hLm1lbW9pemVkU3RhdGU7aWYobnVsbCE9PWEmJm51bGwhPT1hLmRlaHlkcmF0ZWQpe3ZhciBjPWEucmV0cnlMYW5lO2EucmV0cnlMYW5lPTAhPT1jJiZjPGI/YzpifX1mdW5jdGlvbiBqaShhLGIpe2lpKGEsYik7KGE9YS5hbHRlcm5hdGUpJiZpaShhLGIpfWZ1bmN0aW9uIGtpKGEpe2E9QWEoYSk7cmV0dXJuIG51bGw9PT1hP251bGw6YS5zdGF0ZU5vZGV9ZnVuY3Rpb24gbGkoKXtyZXR1cm4gbnVsbH1cbmV4cG9ydHMuYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb249ZnVuY3Rpb24oYSl7aWYoMTM9PT1hLnRhZyl7dmFyIGI9RygpO0RkKGEsMTM0MjE3NzI4LGIpO2ppKGEsMTM0MjE3NzI4KX19O2V4cG9ydHMuYXR0ZW1wdERpc2NyZXRlSHlkcmF0aW9uPWZ1bmN0aW9uKGEpe2lmKDEzPT09YS50YWcpe3ZhciBiPUcoKTtEZChhLDEsYik7amkoYSwxKX19O2V4cG9ydHMuYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5PWZ1bmN0aW9uKGEpe2lmKDEzPT09YS50YWcpe3ZhciBiPUcoKSxjPUNkKGEpO0RkKGEsYyxiKTtqaShhLGMpfX07XG5leHBvcnRzLmF0dGVtcHRTeW5jaHJvbm91c0h5ZHJhdGlvbj1mdW5jdGlvbihhKXtzd2l0Y2goYS50YWcpe2Nhc2UgMzp2YXIgYj1hLnN0YXRlTm9kZTtpZihiLmN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQpe3ZhciBjPXhjKGIucGVuZGluZ0xhbmVzKTswIT09YyYmKEdjKGIsY3wxKSxJaChiLEQoKSksMD09PShXJjYpJiYoeWgoKSwkYygpKSl9YnJlYWs7Y2FzZSAxMzp2YXIgZD1HKCk7VmgoZnVuY3Rpb24oKXtyZXR1cm4gRGQoYSwxLGQpfSk7amkoYSwxKX19O2V4cG9ydHMuYmF0Y2hlZFVwZGF0ZXM9ZnVuY3Rpb24oYSxiKXt2YXIgYz1XO1d8PTE7dHJ5e3JldHVybiBhKGIpfWZpbmFsbHl7Vz1jLDA9PT1XJiYoeWgoKSxXYyYmJGMoKSl9fTtleHBvcnRzLmNyZWF0ZUNvbXBvbmVudFNlbGVjdG9yPWZ1bmN0aW9uKGEpe3JldHVybnskJHR5cGVvZjplaCx2YWx1ZTphfX07XG5leHBvcnRzLmNyZWF0ZUNvbnRhaW5lcj1mdW5jdGlvbihhLGIsYyxkLGUsZixnKXtyZXR1cm4gZmkoYSxiLCExLG51bGwsYyxkLGUsZixnKX07ZXhwb3J0cy5jcmVhdGVIYXNQc2V1ZG9DbGFzc1NlbGVjdG9yPWZ1bmN0aW9uKGEpe3JldHVybnskJHR5cGVvZjpmaCx2YWx1ZTphfX07ZXhwb3J0cy5jcmVhdGVIeWRyYXRpb25Db250YWluZXI9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoLGspe2E9ZmkoYyxkLCEwLGEsZSxmLGcsaCxrKTthLmNvbnRleHQ9Z2kobnVsbCk7Yz1hLmN1cnJlbnQ7ZD1HKCk7ZT1DZChjKTtmPXNkKGQsZSk7Zi5jYWxsYmFjaz12b2lkIDAhPT1iJiZudWxsIT09Yj9iOm51bGw7dGQoYyxmKTthLmN1cnJlbnQubGFuZXM9ZTtFYyhhLGUsZCk7SWgoYSxkKTtyZXR1cm4gYX07XG5leHBvcnRzLmNyZWF0ZVBvcnRhbD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9Mzxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOm51bGw7cmV0dXJueyQkdHlwZW9mOmZhLGtleTpudWxsPT1kP251bGw6XCJcIitkLGNoaWxkcmVuOmEsY29udGFpbmVySW5mbzpiLGltcGxlbWVudGF0aW9uOmN9fTtleHBvcnRzLmNyZWF0ZVJvbGVTZWxlY3Rvcj1mdW5jdGlvbihhKXtyZXR1cm57JCR0eXBlb2Y6Z2gsdmFsdWU6YX19O2V4cG9ydHMuY3JlYXRlVGVzdE5hbWVTZWxlY3Rvcj1mdW5jdGlvbihhKXtyZXR1cm57JCR0eXBlb2Y6aGgsdmFsdWU6YX19O2V4cG9ydHMuY3JlYXRlVGV4dFNlbGVjdG9yPWZ1bmN0aW9uKGEpe3JldHVybnskJHR5cGVvZjppaCx2YWx1ZTphfX07XG5leHBvcnRzLmRlZmVycmVkVXBkYXRlcz1mdW5jdGlvbihhKXt2YXIgYj1DLGM9Vi50cmFuc2l0aW9uO3RyeXtyZXR1cm4gVi50cmFuc2l0aW9uPW51bGwsQz0xNixhKCl9ZmluYWxseXtDPWIsVi50cmFuc2l0aW9uPWN9fTtleHBvcnRzLmRpc2NyZXRlVXBkYXRlcz1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPUMsZz1WLnRyYW5zaXRpb247dHJ5e3JldHVybiBWLnRyYW5zaXRpb249bnVsbCxDPTEsYShiLGMsZCxlKX1maW5hbGx5e0M9ZixWLnRyYW5zaXRpb249ZywwPT09VyYmeWgoKX19O2V4cG9ydHMuZmluZEFsbE5vZGVzPW9oO1xuZXhwb3J0cy5maW5kQm91bmRpbmdSZWN0cz1mdW5jdGlvbihhLGIpe2lmKCFiYil0aHJvdyBFcnJvcihuKDM2MykpO2I9b2goYSxiKTthPVtdO2Zvcih2YXIgYz0wO2M8Yi5sZW5ndGg7YysrKWEucHVzaChkYihiW2NdKSk7Zm9yKGI9YS5sZW5ndGgtMTswPGI7Yi0tKXtjPWFbYl07Zm9yKHZhciBkPWMueCxlPWQrYy53aWR0aCxmPWMueSxnPWYrYy5oZWlnaHQsaD1iLTE7MDw9aDtoLS0paWYoYiE9PWgpe3ZhciBrPWFbaF0sbD1rLngsbT1sK2sud2lkdGgscj1rLnkscT1yK2suaGVpZ2h0O2lmKGQ+PWwmJmY+PXImJmU8PW0mJmc8PXEpe2Euc3BsaWNlKGIsMSk7YnJlYWt9ZWxzZSBpZighKGQhPT1sfHxjLndpZHRoIT09ay53aWR0aHx8cTxmfHxyPmcpKXtyPmYmJihrLmhlaWdodCs9ci1mLGsueT1mKTtxPGcmJihrLmhlaWdodD1nLXIpO2Euc3BsaWNlKGIsMSk7YnJlYWt9ZWxzZSBpZighKGYhPT1yfHxjLmhlaWdodCE9PWsuaGVpZ2h0fHxtPGR8fGw+ZSkpe2w+ZCYmKGsud2lkdGgrPVxubC1kLGsueD1kKTttPGUmJihrLndpZHRoPWUtbCk7YS5zcGxpY2UoYiwxKTticmVha319fXJldHVybiBhfTtleHBvcnRzLmZpbmRIb3N0SW5zdGFuY2U9aGk7ZXhwb3J0cy5maW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscz1mdW5jdGlvbihhKXthPXlhKGEpO2E9bnVsbCE9PWE/Q2EoYSk6bnVsbDtyZXR1cm4gbnVsbD09PWE/bnVsbDphLnN0YXRlTm9kZX07ZXhwb3J0cy5maW5kSG9zdEluc3RhbmNlV2l0aFdhcm5pbmc9ZnVuY3Rpb24oYSl7cmV0dXJuIGhpKGEpfTtleHBvcnRzLmZsdXNoQ29udHJvbGxlZD1mdW5jdGlvbihhKXt2YXIgYj1XO1d8PTE7dmFyIGM9Vi50cmFuc2l0aW9uLGQ9Qzt0cnl7Vi50cmFuc2l0aW9uPW51bGwsQz0xLGEoKX1maW5hbGx5e0M9ZCxWLnRyYW5zaXRpb249YyxXPWIsMD09PVcmJih5aCgpLCRjKCkpfX07ZXhwb3J0cy5mbHVzaFBhc3NpdmVFZmZlY3RzPU1oO2V4cG9ydHMuZmx1c2hTeW5jPVZoO1xuZXhwb3J0cy5mb2N1c1dpdGhpbj1mdW5jdGlvbihhLGIpe2lmKCFiYil0aHJvdyBFcnJvcihuKDM2MykpO2E9a2goYSk7Yj1uaChhLGIpO2I9QXJyYXkuZnJvbShiKTtmb3IoYT0wO2E8Yi5sZW5ndGg7KXt2YXIgYz1iW2ErK107aWYoIWZiKGMpKXtpZig1PT09Yy50YWcmJmhiKGMuc3RhdGVOb2RlKSlyZXR1cm4hMDtmb3IoYz1jLmNoaWxkO251bGwhPT1jOyliLnB1c2goYyksYz1jLnNpYmxpbmd9fXJldHVybiExfTtleHBvcnRzLmdldEN1cnJlbnRVcGRhdGVQcmlvcml0eT1mdW5jdGlvbigpe3JldHVybiBDfTtcbmV4cG9ydHMuZ2V0RmluZEFsbE5vZGVzRmFpbHVyZURlc2NyaXB0aW9uPWZ1bmN0aW9uKGEsYil7aWYoIWJiKXRocm93IEVycm9yKG4oMzYzKSk7dmFyIGM9MCxkPVtdO2E9W2toKGEpLDBdO2Zvcih2YXIgZT0wO2U8YS5sZW5ndGg7KXt2YXIgZj1hW2UrK10sZz1hW2UrK10saD1iW2ddO2lmKDUhPT1mLnRhZ3x8IWZiKGYpKWlmKGxoKGYsaCkmJihkLnB1c2gobWgoaCkpLGcrKyxnPmMmJihjPWcpKSxnPGIubGVuZ3RoKWZvcihmPWYuY2hpbGQ7bnVsbCE9PWY7KWEucHVzaChmLGcpLGY9Zi5zaWJsaW5nfWlmKGM8Yi5sZW5ndGgpe2ZvcihhPVtdO2M8Yi5sZW5ndGg7YysrKWEucHVzaChtaChiW2NdKSk7cmV0dXJuXCJmaW5kQWxsTm9kZXMgd2FzIGFibGUgdG8gbWF0Y2ggcGFydCBvZiB0aGUgc2VsZWN0b3I6XFxuICBcIisoZC5qb2luKFwiID4gXCIpK1wiXFxuXFxuTm8gbWF0Y2hpbmcgY29tcG9uZW50IHdhcyBmb3VuZCBmb3I6XFxuICBcIikrYS5qb2luKFwiID4gXCIpfXJldHVybiBudWxsfTtcbmV4cG9ydHMuZ2V0UHVibGljUm9vdEluc3RhbmNlPWZ1bmN0aW9uKGEpe2E9YS5jdXJyZW50O2lmKCFhLmNoaWxkKXJldHVybiBudWxsO3N3aXRjaChhLmNoaWxkLnRhZyl7Y2FzZSA1OnJldHVybiBFYShhLmNoaWxkLnN0YXRlTm9kZSk7ZGVmYXVsdDpyZXR1cm4gYS5jaGlsZC5zdGF0ZU5vZGV9fTtcbmV4cG9ydHMuaW5qZWN0SW50b0RldlRvb2xzPWZ1bmN0aW9uKGEpe2E9e2J1bmRsZVR5cGU6YS5idW5kbGVUeXBlLHZlcnNpb246YS52ZXJzaW9uLHJlbmRlcmVyUGFja2FnZU5hbWU6YS5yZW5kZXJlclBhY2thZ2VOYW1lLHJlbmRlcmVyQ29uZmlnOmEucmVuZGVyZXJDb25maWcsb3ZlcnJpZGVIb29rU3RhdGU6bnVsbCxvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGg6bnVsbCxvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGg6bnVsbCxvdmVycmlkZVByb3BzOm51bGwsb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGg6bnVsbCxvdmVycmlkZVByb3BzUmVuYW1lUGF0aDpudWxsLHNldEVycm9ySGFuZGxlcjpudWxsLHNldFN1c3BlbnNlSGFuZGxlcjpudWxsLHNjaGVkdWxlVXBkYXRlOm51bGwsY3VycmVudERpc3BhdGNoZXJSZWY6ZGEuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixmaW5kSG9zdEluc3RhbmNlQnlGaWJlcjpraSxmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTphLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlfHxcbmxpLGZpbmRIb3N0SW5zdGFuY2VzRm9yUmVmcmVzaDpudWxsLHNjaGVkdWxlUmVmcmVzaDpudWxsLHNjaGVkdWxlUm9vdDpudWxsLHNldFJlZnJlc2hIYW5kbGVyOm51bGwsZ2V0Q3VycmVudEZpYmVyOm51bGwscmVjb25jaWxlclZlcnNpb246XCIxOC4xLjBcIn07aWYoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18pYT0hMTtlbHNle3ZhciBiPV9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztpZihiLmlzRGlzYWJsZWR8fCFiLnN1cHBvcnRzRmliZXIpYT0hMDtlbHNle3RyeXtRYz1iLmluamVjdChhKSxSYz1ifWNhdGNoKGMpe31hPWIuY2hlY2tEQ0U/ITA6ITF9fXJldHVybiBhfTtleHBvcnRzLmlzQWxyZWFkeVJlbmRlcmluZz1mdW5jdGlvbigpe3JldHVybiExfTtcbmV4cG9ydHMub2JzZXJ2ZVZpc2libGVSZWN0cz1mdW5jdGlvbihhLGIsYyxkKXtpZighYmIpdGhyb3cgRXJyb3IobigzNjMpKTthPW9oKGEsYik7dmFyIGU9aWIoYSxjLGQpLmRpc2Nvbm5lY3Q7cmV0dXJue2Rpc2Nvbm5lY3Q6ZnVuY3Rpb24oKXtlKCl9fX07ZXhwb3J0cy5yZWdpc3Rlck11dGFibGVTb3VyY2VGb3JIeWRyYXRpb249ZnVuY3Rpb24oYSxiKXt2YXIgYz1iLl9nZXRWZXJzaW9uO2M9YyhiLl9zb3VyY2UpO251bGw9PWEubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YT9hLm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGE9W2IsY106YS5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhLnB1c2goYixjKX07ZXhwb3J0cy5ydW5XaXRoUHJpb3JpdHk9ZnVuY3Rpb24oYSxiKXt2YXIgYz1DO3RyeXtyZXR1cm4gQz1hLGIoKX1maW5hbGx5e0M9Y319O2V4cG9ydHMuc2hvdWxkRXJyb3I9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07XG5leHBvcnRzLnNob3VsZFN1c3BlbmQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX07ZXhwb3J0cy51cGRhdGVDb250YWluZXI9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9Yi5jdXJyZW50LGY9RygpLGc9Q2QoZSk7Yz1naShjKTtudWxsPT09Yi5jb250ZXh0P2IuY29udGV4dD1jOmIucGVuZGluZ0NvbnRleHQ9YztiPXNkKGYsZyk7Yi5wYXlsb2FkPXtlbGVtZW50OmF9O2Q9dm9pZCAwPT09ZD9udWxsOmQ7bnVsbCE9PWQmJihiLmNhbGxiYWNrPWQpO3RkKGUsYik7YT1EZChlLGcsZik7bnVsbCE9PWEmJnZkKGEsZSxnKTtyZXR1cm4gZ307XG5cbiAgICByZXR1cm4gZXhwb3J0cztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///287\n')},576:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(511);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTc2LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx5Q0FBOEU7QUFDaEYsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWNvbmNpbGVyL2NvbnN0YW50cy5qcz9hM2VmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLWNvbnN0YW50cy5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLWNvbnN0YW50cy5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///576\n")},525:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(287);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTI1LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx5Q0FBb0U7QUFDdEUsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWNvbmNpbGVyL2luZGV4LmpzPzM0OTciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LXJlY29uY2lsZXIucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtcmVjb25jaWxlci5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///525\n")},359:(__unused_webpack_module,exports)=>{"use strict";eval('var __webpack_unused_export__;\n/**\n * @license React\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar b=Symbol.for("react.element"),c=Symbol.for("react.portal"),d=Symbol.for("react.fragment"),e=Symbol.for("react.strict_mode"),f=Symbol.for("react.profiler"),g=Symbol.for("react.provider"),h=Symbol.for("react.context"),k=Symbol.for("react.server_context"),l=Symbol.for("react.forward_ref"),m=Symbol.for("react.suspense"),n=Symbol.for("react.suspense_list"),p=Symbol.for("react.memo"),q=Symbol.for("react.lazy"),t=Symbol.for("react.offscreen"),u;u=Symbol.for("react.module.reference");\nfunction v(a){if("object"===typeof a&&null!==a){var r=a.$$typeof;switch(r){case b:switch(a=a.type,a){case d:case f:case e:case m:case n:return a;default:switch(a=a&&a.$$typeof,a){case k:case h:case l:case q:case p:case g:return a;default:return r}}case c:return r}}}__webpack_unused_export__=h;__webpack_unused_export__=g;__webpack_unused_export__=b;__webpack_unused_export__=l;__webpack_unused_export__=d;__webpack_unused_export__=q;__webpack_unused_export__=p;__webpack_unused_export__=c;__webpack_unused_export__=f;__webpack_unused_export__=e;__webpack_unused_export__=m;\n__webpack_unused_export__=n;__webpack_unused_export__=function(){return!1};__webpack_unused_export__=function(){return!1};exports.isContextConsumer=function(a){return v(a)===h};__webpack_unused_export__=function(a){return v(a)===g};__webpack_unused_export__=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===b};__webpack_unused_export__=function(a){return v(a)===l};__webpack_unused_export__=function(a){return v(a)===d};__webpack_unused_export__=function(a){return v(a)===q};__webpack_unused_export__=function(a){return v(a)===p};\n__webpack_unused_export__=function(a){return v(a)===c};__webpack_unused_export__=function(a){return v(a)===f};__webpack_unused_export__=function(a){return v(a)===e};__webpack_unused_export__=function(a){return v(a)===m};__webpack_unused_export__=function(a){return v(a)===n};\n__webpack_unused_export__=function(a){return"string"===typeof a||"function"===typeof a||a===d||a===f||a===e||a===m||a===n||a===t||"object"===typeof a&&null!==a&&(a.$$typeof===q||a.$$typeof===p||a.$$typeof===g||a.$$typeof===h||a.$$typeof===l||a.$$typeof===u||void 0!==a.getModuleId)?!0:!1};__webpack_unused_export__=v;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzU5LmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYSw4YkFBOGI7QUFDM2MsY0FBYyxrQ0FBa0MsaUJBQWlCLFVBQVUsMEJBQTBCLDRDQUE0QyxrQ0FBa0MsbURBQW1ELGtCQUFrQixrQkFBa0IseUJBQXVCLEdBQUcseUJBQXVCLEdBQUcseUJBQWUsR0FBRyx5QkFBa0IsR0FBRyx5QkFBZ0IsR0FBRyx5QkFBWSxHQUFHLHlCQUFZLEdBQUcseUJBQWMsR0FBRyx5QkFBZ0IsR0FBRyx5QkFBa0IsR0FBRyx5QkFBZ0I7QUFDL2QseUJBQW9CLEdBQUcseUJBQW1CLFlBQVksVUFBVSx5QkFBd0IsWUFBWSxVQUFVLHlCQUF5QixhQUFhLGlCQUFpQix5QkFBeUIsYUFBYSxpQkFBaUIseUJBQWlCLGFBQWEscURBQXFELHlCQUFvQixhQUFhLGlCQUFpQix5QkFBa0IsYUFBYSxpQkFBaUIseUJBQWMsYUFBYSxpQkFBaUIseUJBQWMsYUFBYTtBQUN4ZCx5QkFBZ0IsYUFBYSxpQkFBaUIseUJBQWtCLGFBQWEsaUJBQWlCLHlCQUFvQixhQUFhLGlCQUFpQix5QkFBa0IsYUFBYSxpQkFBaUIseUJBQXNCLGFBQWE7QUFDbk8seUJBQTBCLGFBQWEsMlBBQTJQLHlCQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcz8wZDRjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0Jzt2YXIgYj1TeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSxjPVN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksZD1TeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksZT1TeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksZj1TeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksZz1TeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIiksaD1TeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxrPVN5bWJvbC5mb3IoXCJyZWFjdC5zZXJ2ZXJfY29udGV4dFwiKSxsPVN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxtPVN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSxuPVN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLHA9U3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIikscT1TeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSx0PVN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIiksdTt1PVN5bWJvbC5mb3IoXCJyZWFjdC5tb2R1bGUucmVmZXJlbmNlXCIpO1xuZnVuY3Rpb24gdihhKXtpZihcIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hKXt2YXIgcj1hLiQkdHlwZW9mO3N3aXRjaChyKXtjYXNlIGI6c3dpdGNoKGE9YS50eXBlLGEpe2Nhc2UgZDpjYXNlIGY6Y2FzZSBlOmNhc2UgbTpjYXNlIG46cmV0dXJuIGE7ZGVmYXVsdDpzd2l0Y2goYT1hJiZhLiQkdHlwZW9mLGEpe2Nhc2UgazpjYXNlIGg6Y2FzZSBsOmNhc2UgcTpjYXNlIHA6Y2FzZSBnOnJldHVybiBhO2RlZmF1bHQ6cmV0dXJuIHJ9fWNhc2UgYzpyZXR1cm4gcn19fWV4cG9ydHMuQ29udGV4dENvbnN1bWVyPWg7ZXhwb3J0cy5Db250ZXh0UHJvdmlkZXI9ZztleHBvcnRzLkVsZW1lbnQ9YjtleHBvcnRzLkZvcndhcmRSZWY9bDtleHBvcnRzLkZyYWdtZW50PWQ7ZXhwb3J0cy5MYXp5PXE7ZXhwb3J0cy5NZW1vPXA7ZXhwb3J0cy5Qb3J0YWw9YztleHBvcnRzLlByb2ZpbGVyPWY7ZXhwb3J0cy5TdHJpY3RNb2RlPWU7ZXhwb3J0cy5TdXNwZW5zZT1tO1xuZXhwb3J0cy5TdXNwZW5zZUxpc3Q9bjtleHBvcnRzLmlzQXN5bmNNb2RlPWZ1bmN0aW9uKCl7cmV0dXJuITF9O2V4cG9ydHMuaXNDb25jdXJyZW50TW9kZT1mdW5jdGlvbigpe3JldHVybiExfTtleHBvcnRzLmlzQ29udGV4dENvbnN1bWVyPWZ1bmN0aW9uKGEpe3JldHVybiB2KGEpPT09aH07ZXhwb3J0cy5pc0NvbnRleHRQcm92aWRlcj1mdW5jdGlvbihhKXtyZXR1cm4gdihhKT09PWd9O2V4cG9ydHMuaXNFbGVtZW50PWZ1bmN0aW9uKGEpe3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEmJmEuJCR0eXBlb2Y9PT1ifTtleHBvcnRzLmlzRm9yd2FyZFJlZj1mdW5jdGlvbihhKXtyZXR1cm4gdihhKT09PWx9O2V4cG9ydHMuaXNGcmFnbWVudD1mdW5jdGlvbihhKXtyZXR1cm4gdihhKT09PWR9O2V4cG9ydHMuaXNMYXp5PWZ1bmN0aW9uKGEpe3JldHVybiB2KGEpPT09cX07ZXhwb3J0cy5pc01lbW89ZnVuY3Rpb24oYSl7cmV0dXJuIHYoYSk9PT1wfTtcbmV4cG9ydHMuaXNQb3J0YWw9ZnVuY3Rpb24oYSl7cmV0dXJuIHYoYSk9PT1jfTtleHBvcnRzLmlzUHJvZmlsZXI9ZnVuY3Rpb24oYSl7cmV0dXJuIHYoYSk9PT1mfTtleHBvcnRzLmlzU3RyaWN0TW9kZT1mdW5jdGlvbihhKXtyZXR1cm4gdihhKT09PWV9O2V4cG9ydHMuaXNTdXNwZW5zZT1mdW5jdGlvbihhKXtyZXR1cm4gdihhKT09PW19O2V4cG9ydHMuaXNTdXNwZW5zZUxpc3Q9ZnVuY3Rpb24oYSl7cmV0dXJuIHYoYSk9PT1ufTtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnRUeXBlPWZ1bmN0aW9uKGEpe3JldHVyblwic3RyaW5nXCI9PT10eXBlb2YgYXx8XCJmdW5jdGlvblwiPT09dHlwZW9mIGF8fGE9PT1kfHxhPT09Znx8YT09PWV8fGE9PT1tfHxhPT09bnx8YT09PXR8fFwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEmJihhLiQkdHlwZW9mPT09cXx8YS4kJHR5cGVvZj09PXB8fGEuJCR0eXBlb2Y9PT1nfHxhLiQkdHlwZW9mPT09aHx8YS4kJHR5cGVvZj09PWx8fGEuJCR0eXBlb2Y9PT11fHx2b2lkIDAhPT1hLmdldE1vZHVsZUlkKT8hMDohMX07ZXhwb3J0cy50eXBlT2Y9djtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///359\n')},973:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(359);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTczLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx5Q0FBNEQ7QUFDOUQsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanM/ZDJmYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///973\n")},251:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('var __webpack_unused_export__;\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar f=__webpack_require__(294),k=Symbol.for("react.element"),l=Symbol.for("react.fragment"),m=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p={key:!0,ref:!0,__self:!0,__source:!0};\nfunction q(c,a,g){var b,d={},e=null,h=null;void 0!==g&&(e=""+g);void 0!==a.key&&(e=""+a.key);void 0!==a.ref&&(h=a.ref);for(b in a)m.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:k,type:c,key:e,ref:h,props:d,_owner:n.current}}__webpack_unused_export__=l;exports.jsx=q;__webpack_unused_export__=q;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUxLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYSxNQUFNLG1CQUFPLENBQUMsR0FBTyw2S0FBNks7QUFDL00sa0JBQWtCLFVBQVUsZUFBZSxxQkFBcUIsNkJBQTZCLDBCQUEwQiwwREFBMEQsNEVBQTRFLE9BQU8sd0RBQXdELHlCQUFnQixHQUFHLFdBQVcsR0FBRyx5QkFBWSIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC1qc3gtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qcz9kMzFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0Jzt2YXIgZj1yZXF1aXJlKFwicmVhY3RcIiksaz1TeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSxsPVN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxtPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksbj1mLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELlJlYWN0Q3VycmVudE93bmVyLHA9e2tleTohMCxyZWY6ITAsX19zZWxmOiEwLF9fc291cmNlOiEwfTtcbmZ1bmN0aW9uIHEoYyxhLGcpe3ZhciBiLGQ9e30sZT1udWxsLGg9bnVsbDt2b2lkIDAhPT1nJiYoZT1cIlwiK2cpO3ZvaWQgMCE9PWEua2V5JiYoZT1cIlwiK2Eua2V5KTt2b2lkIDAhPT1hLnJlZiYmKGg9YS5yZWYpO2ZvcihiIGluIGEpbS5jYWxsKGEsYikmJiFwLmhhc093blByb3BlcnR5KGIpJiYoZFtiXT1hW2JdKTtpZihjJiZjLmRlZmF1bHRQcm9wcylmb3IoYiBpbiBhPWMuZGVmYXVsdFByb3BzLGEpdm9pZCAwPT09ZFtiXSYmKGRbYl09YVtiXSk7cmV0dXJueyQkdHlwZW9mOmssdHlwZTpjLGtleTplLHJlZjpoLHByb3BzOmQsX293bmVyOm4uY3VycmVudH19ZXhwb3J0cy5GcmFnbWVudD1sO2V4cG9ydHMuanN4PXE7ZXhwb3J0cy5qc3hzPXE7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///251\n')},408:(__unused_webpack_module,exports)=>{"use strict";eval('/**\n * @license React\n * react.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar l=Symbol.for("react.element"),n=Symbol.for("react.portal"),p=Symbol.for("react.fragment"),q=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),t=Symbol.for("react.provider"),u=Symbol.for("react.context"),v=Symbol.for("react.forward_ref"),w=Symbol.for("react.suspense"),x=Symbol.for("react.memo"),y=Symbol.for("react.lazy"),z=Symbol.iterator;function A(a){if(null===a||"object"!==typeof a)return null;a=z&&a[z]||a["@@iterator"];return"function"===typeof a?a:null}\nvar B={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C=Object.assign,D={};function E(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}E.prototype.isReactComponent={};\nE.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,a,b,"setState")};E.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};function F(){}F.prototype=E.prototype;function G(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}var H=G.prototype=new F;\nH.constructor=G;C(H,E.prototype);H.isPureReactComponent=!0;var I=Array.isArray,J=Object.prototype.hasOwnProperty,K={current:null},L={key:!0,ref:!0,__self:!0,__source:!0};\nfunction M(a,b,e){var d,c={},k=null,h=null;if(null!=b)for(d in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(k=""+b.key),b)J.call(b,d)&&!L.hasOwnProperty(d)&&(c[d]=b[d]);var g=arguments.length-2;if(1===g)c.children=e;else if(1<g){for(var f=Array(g),m=0;m<g;m++)f[m]=arguments[m+2];c.children=f}if(a&&a.defaultProps)for(d in g=a.defaultProps,g)void 0===c[d]&&(c[d]=g[d]);return{$$typeof:l,type:a,key:k,ref:h,props:c,_owner:K.current}}\nfunction N(a,b){return{$$typeof:l,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return"object"===typeof a&&null!==a&&a.$$typeof===l}function escape(a){var b={"=":"=0",":":"=2"};return"$"+a.replace(/[=:]/g,function(a){return b[a]})}var P=/\\/+/g;function Q(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(""+a.key):b.toString(36)}\nfunction R(a,b,e,d,c){var k=typeof a;if("undefined"===k||"boolean"===k)a=null;var h=!1;if(null===a)h=!0;else switch(k){case "string":case "number":h=!0;break;case "object":switch(a.$$typeof){case l:case n:h=!0}}if(h)return h=a,c=c(h),a=""===d?"."+Q(h,0):d,I(c)?(e="",null!=a&&(e=a.replace(P,"$&/")+"/"),R(c,b,e,"",function(a){return a})):null!=c&&(O(c)&&(c=N(c,e+(!c.key||h&&h.key===c.key?"":(""+c.key).replace(P,"$&/")+"/")+a)),b.push(c)),1;h=0;d=""===d?".":d+":";if(I(a))for(var g=0;g<a.length;g++){k=\na[g];var f=d+Q(k,g);h+=R(k,b,e,f,c)}else if(f=A(a),"function"===typeof f)for(a=f.call(a),g=0;!(k=a.next()).done;)k=k.value,f=d+Q(k,g++),h+=R(k,b,e,f,c);else if("object"===k)throw b=String(a),Error("Objects are not valid as a React child (found: "+("[object Object]"===b?"object with keys {"+Object.keys(a).join(", ")+"}":b)+"). If you meant to render a collection of children, use an array instead.");return h}\nfunction S(a,b,e){if(null==a)return a;var d=[],c=0;R(a,d,"","",function(a){return b.call(e,a,c++)});return d}function T(a){if(-1===a._status){var b=a._result;b=b();b.then(function(b){if(0===a._status||-1===a._status)a._status=1,a._result=b},function(b){if(0===a._status||-1===a._status)a._status=2,a._result=b});-1===a._status&&(a._status=0,a._result=b)}if(1===a._status)return a._result.default;throw a._result;}\nvar U={current:null},V={transition:null},W={ReactCurrentDispatcher:U,ReactCurrentBatchConfig:V,ReactCurrentOwner:K};exports.Children={map:S,forEach:function(a,b,e){S(a,function(){b.apply(this,arguments)},e)},count:function(a){var b=0;S(a,function(){b++});return b},toArray:function(a){return S(a,function(a){return a})||[]},only:function(a){if(!O(a))throw Error("React.Children.only expected to receive a single React element child.");return a}};exports.Component=E;exports.Fragment=p;\nexports.Profiler=r;exports.PureComponent=G;exports.StrictMode=q;exports.Suspense=w;exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W;\nexports.cloneElement=function(a,b,e){if(null===a||void 0===a)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+a+".");var d=C({},a.props),c=a.key,k=a.ref,h=a._owner;if(null!=b){void 0!==b.ref&&(k=b.ref,h=K.current);void 0!==b.key&&(c=""+b.key);if(a.type&&a.type.defaultProps)var g=a.type.defaultProps;for(f in b)J.call(b,f)&&!L.hasOwnProperty(f)&&(d[f]=void 0===b[f]&&void 0!==g?g[f]:b[f])}var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){g=Array(f);\nfor(var m=0;m<f;m++)g[m]=arguments[m+2];d.children=g}return{$$typeof:l,type:a.type,key:c,ref:k,props:d,_owner:h}};exports.createContext=function(a){a={$$typeof:u,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null};a.Provider={$$typeof:t,_context:a};return a.Consumer=a};exports.createElement=M;exports.createFactory=function(a){var b=M.bind(null,a);b.type=a;return b};exports.createRef=function(){return{current:null}};\nexports.forwardRef=function(a){return{$$typeof:v,render:a}};exports.isValidElement=O;exports.lazy=function(a){return{$$typeof:y,_payload:{_status:-1,_result:a},_init:T}};exports.memo=function(a,b){return{$$typeof:x,type:a,compare:void 0===b?null:b}};exports.startTransition=function(a){var b=V.transition;V.transition={};try{a()}finally{V.transition=b}};exports.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.");};\nexports.useCallback=function(a,b){return U.current.useCallback(a,b)};exports.useContext=function(a){return U.current.useContext(a)};exports.useDebugValue=function(){};exports.useDeferredValue=function(a){return U.current.useDeferredValue(a)};exports.useEffect=function(a,b){return U.current.useEffect(a,b)};exports.useId=function(){return U.current.useId()};exports.useImperativeHandle=function(a,b,e){return U.current.useImperativeHandle(a,b,e)};\nexports.useInsertionEffect=function(a,b){return U.current.useInsertionEffect(a,b)};exports.useLayoutEffect=function(a,b){return U.current.useLayoutEffect(a,b)};exports.useMemo=function(a,b){return U.current.useMemo(a,b)};exports.useReducer=function(a,b,e){return U.current.useReducer(a,b,e)};exports.useRef=function(a){return U.current.useRef(a)};exports.useState=function(a){return U.current.useState(a)};exports.useSyncExternalStore=function(a,b,e){return U.current.useSyncExternalStore(a,b,e)};\nexports.useTransition=function(){return U.current.useTransition()};exports.version="18.1.0";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDA4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhLHFXQUFxVyxjQUFjLDZDQUE2QywyQkFBMkI7QUFDeGMsT0FBTyxxQkFBcUIsU0FBUyxnQ0FBZ0MsaUNBQWlDLDhCQUE4QixzQkFBc0Isa0JBQWtCLGFBQWEsZUFBZSxZQUFZLGtCQUFrQjtBQUN0TyxtQ0FBbUMsNExBQTRMLG1EQUFtRCxvQ0FBb0MsdURBQXVELGNBQWMsd0JBQXdCLGtCQUFrQixhQUFhLGVBQWUsWUFBWSxrQkFBa0I7QUFDL2QsZ0JBQWdCLGlCQUFpQiwwQkFBMEIseURBQXlELGFBQWEsSUFBSTtBQUNySSxrQkFBa0IsVUFBVSxlQUFlLDRIQUE0SCx5QkFBeUIsc0JBQXNCLGFBQWEsdUJBQXVCLElBQUksd0JBQXdCLGFBQWEsNEVBQTRFLE9BQU87QUFDdFgsZ0JBQWdCLE9BQU8sc0VBQXNFLGNBQWMsb0RBQW9ELG1CQUFtQixPQUFPLG1CQUFtQix3Q0FBd0MsWUFBWSxFQUFFLGFBQWEsZ0JBQWdCO0FBQy9SLHNCQUFzQixlQUFlLHlDQUF5QyxTQUFTLGlCQUFpQixlQUFlLGlDQUFpQyxNQUFNLGlDQUFpQyxvQkFBb0IsbUhBQW1ILFNBQVMsMkdBQTJHLElBQUksbUJBQW1CLG9CQUFvQixXQUFXLEtBQUs7QUFDcmYsS0FBSyxlQUFlLGdCQUFnQix5REFBeUQsbUJBQW1CLHdDQUF3Qyx5SUFBeUksOEJBQThCLGtGQUFrRjtBQUNqWixrQkFBa0Isb0JBQW9CLGFBQWEsd0JBQXdCLHVCQUF1QixFQUFFLFNBQVMsY0FBYyxtQkFBbUIsZ0JBQWdCLE1BQU0sbUJBQW1CLHlEQUF5RCxhQUFhLHlEQUF5RCxFQUFFLDBDQUEwQywwQ0FBMEM7QUFDNVksT0FBTyxhQUFhLElBQUksZ0JBQWdCLElBQUksd0VBQXdFLGdCQUFnQixFQUFFLDhCQUE4QixlQUFlLHdCQUF3QixJQUFJLG1CQUFtQixRQUFRLGVBQWUsSUFBSSxFQUFFLFNBQVMscUJBQXFCLHVCQUF1QixTQUFTLE1BQU0sa0JBQWtCLDhGQUE4RixXQUFXLGlCQUFpQixHQUFHLGdCQUFnQjtBQUNsZSxnQkFBZ0IsR0FBRyxxQkFBcUIsR0FBRyxrQkFBa0IsR0FBRyxnQkFBZ0IsR0FBRywwREFBMEQ7QUFDN0ksb0JBQW9CLGlCQUFpQiw0SEFBNEgsVUFBVSxxQ0FBcUMsWUFBWSxzQ0FBc0MsNkJBQTZCLHlEQUF5RCx5RkFBeUYseUJBQXlCLHNCQUFzQixhQUFhO0FBQzdlLFlBQVksSUFBSSx3QkFBd0IsYUFBYSxPQUFPLHNEQUFzRCxxQkFBcUIsYUFBYSxHQUFHLDRIQUE0SCxZQUFZLHVCQUF1QixxQkFBcUIscUJBQXFCLEdBQUcscUJBQXFCLGFBQWEscUJBQXFCLFNBQVMsVUFBVSxpQkFBaUIsWUFBWSxPQUFPO0FBQ2pkLGtCQUFrQixhQUFhLE9BQU8sc0JBQXNCLHNCQUFzQixHQUFHLFlBQVksYUFBYSxPQUFPLHFCQUFxQixxQkFBcUIsV0FBVyxZQUFZLGVBQWUsT0FBTyw4Q0FBOEMsdUJBQXVCLGFBQWEsbUJBQW1CLGdCQUFnQixJQUFJLElBQUksUUFBUSxpQkFBaUIsb0JBQW9CLFlBQVk7QUFDbFksbUJBQW1CLGVBQWUsbUNBQW1DLGtCQUFrQixhQUFhLGdDQUFnQyxxQkFBcUIsY0FBYyx3QkFBd0IsYUFBYSxzQ0FBc0MsaUJBQWlCLGVBQWUsaUNBQWlDLGFBQWEsWUFBWSwwQkFBMEIsMkJBQTJCLGlCQUFpQjtBQUNsWiwwQkFBMEIsZUFBZSwwQ0FBMEMsdUJBQXVCLGVBQWUsdUNBQXVDLGVBQWUsZUFBZSwrQkFBK0Isa0JBQWtCLGlCQUFpQixvQ0FBb0MsY0FBYyxhQUFhLDRCQUE0QixnQkFBZ0IsYUFBYSw4QkFBOEIsNEJBQTRCLGlCQUFpQjtBQUNuYyxxQkFBcUIsWUFBWSxrQ0FBa0MsZUFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcz9iZTI0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0Jzt2YXIgbD1TeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSxuPVN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIikscD1TeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIikscT1TeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIikscj1TeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksdD1TeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIiksdT1TeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSx2PVN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSx3PVN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSx4PVN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLHk9U3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksej1TeW1ib2wuaXRlcmF0b3I7ZnVuY3Rpb24gQShhKXtpZihudWxsPT09YXx8XCJvYmplY3RcIiE9PXR5cGVvZiBhKXJldHVybiBudWxsO2E9eiYmYVt6XXx8YVtcIkBAaXRlcmF0b3JcIl07cmV0dXJuXCJmdW5jdGlvblwiPT09dHlwZW9mIGE/YTpudWxsfVxudmFyIEI9e2lzTW91bnRlZDpmdW5jdGlvbigpe3JldHVybiExfSxlbnF1ZXVlRm9yY2VVcGRhdGU6ZnVuY3Rpb24oKXt9LGVucXVldWVSZXBsYWNlU3RhdGU6ZnVuY3Rpb24oKXt9LGVucXVldWVTZXRTdGF0ZTpmdW5jdGlvbigpe319LEM9T2JqZWN0LmFzc2lnbixEPXt9O2Z1bmN0aW9uIEUoYSxiLGUpe3RoaXMucHJvcHM9YTt0aGlzLmNvbnRleHQ9Yjt0aGlzLnJlZnM9RDt0aGlzLnVwZGF0ZXI9ZXx8Qn1FLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50PXt9O1xuRS5wcm90b3R5cGUuc2V0U3RhdGU9ZnVuY3Rpb24oYSxiKXtpZihcIm9iamVjdFwiIT09dHlwZW9mIGEmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBhJiZudWxsIT1hKXRocm93IEVycm9yKFwic2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuXCIpO3RoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcyxhLGIsXCJzZXRTdGF0ZVwiKX07RS5wcm90b3R5cGUuZm9yY2VVcGRhdGU9ZnVuY3Rpb24oYSl7dGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLGEsXCJmb3JjZVVwZGF0ZVwiKX07ZnVuY3Rpb24gRigpe31GLnByb3RvdHlwZT1FLnByb3RvdHlwZTtmdW5jdGlvbiBHKGEsYixlKXt0aGlzLnByb3BzPWE7dGhpcy5jb250ZXh0PWI7dGhpcy5yZWZzPUQ7dGhpcy51cGRhdGVyPWV8fEJ9dmFyIEg9Ry5wcm90b3R5cGU9bmV3IEY7XG5ILmNvbnN0cnVjdG9yPUc7QyhILEUucHJvdG90eXBlKTtILmlzUHVyZVJlYWN0Q29tcG9uZW50PSEwO3ZhciBJPUFycmF5LmlzQXJyYXksSj1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LEs9e2N1cnJlbnQ6bnVsbH0sTD17a2V5OiEwLHJlZjohMCxfX3NlbGY6ITAsX19zb3VyY2U6ITB9O1xuZnVuY3Rpb24gTShhLGIsZSl7dmFyIGQsYz17fSxrPW51bGwsaD1udWxsO2lmKG51bGwhPWIpZm9yKGQgaW4gdm9pZCAwIT09Yi5yZWYmJihoPWIucmVmKSx2b2lkIDAhPT1iLmtleSYmKGs9XCJcIitiLmtleSksYilKLmNhbGwoYixkKSYmIUwuaGFzT3duUHJvcGVydHkoZCkmJihjW2RdPWJbZF0pO3ZhciBnPWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09ZyljLmNoaWxkcmVuPWU7ZWxzZSBpZigxPGcpe2Zvcih2YXIgZj1BcnJheShnKSxtPTA7bTxnO20rKylmW21dPWFyZ3VtZW50c1ttKzJdO2MuY2hpbGRyZW49Zn1pZihhJiZhLmRlZmF1bHRQcm9wcylmb3IoZCBpbiBnPWEuZGVmYXVsdFByb3BzLGcpdm9pZCAwPT09Y1tkXSYmKGNbZF09Z1tkXSk7cmV0dXJueyQkdHlwZW9mOmwsdHlwZTphLGtleTprLHJlZjpoLHByb3BzOmMsX293bmVyOksuY3VycmVudH19XG5mdW5jdGlvbiBOKGEsYil7cmV0dXJueyQkdHlwZW9mOmwsdHlwZTphLnR5cGUsa2V5OmIscmVmOmEucmVmLHByb3BzOmEucHJvcHMsX293bmVyOmEuX293bmVyfX1mdW5jdGlvbiBPKGEpe3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEmJmEuJCR0eXBlb2Y9PT1sfWZ1bmN0aW9uIGVzY2FwZShhKXt2YXIgYj17XCI9XCI6XCI9MFwiLFwiOlwiOlwiPTJcIn07cmV0dXJuXCIkXCIrYS5yZXBsYWNlKC9bPTpdL2csZnVuY3Rpb24oYSl7cmV0dXJuIGJbYV19KX12YXIgUD0vXFwvKy9nO2Z1bmN0aW9uIFEoYSxiKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZudWxsIT1hLmtleT9lc2NhcGUoXCJcIithLmtleSk6Yi50b1N0cmluZygzNil9XG5mdW5jdGlvbiBSKGEsYixlLGQsYyl7dmFyIGs9dHlwZW9mIGE7aWYoXCJ1bmRlZmluZWRcIj09PWt8fFwiYm9vbGVhblwiPT09aylhPW51bGw7dmFyIGg9ITE7aWYobnVsbD09PWEpaD0hMDtlbHNlIHN3aXRjaChrKXtjYXNlIFwic3RyaW5nXCI6Y2FzZSBcIm51bWJlclwiOmg9ITA7YnJlYWs7Y2FzZSBcIm9iamVjdFwiOnN3aXRjaChhLiQkdHlwZW9mKXtjYXNlIGw6Y2FzZSBuOmg9ITB9fWlmKGgpcmV0dXJuIGg9YSxjPWMoaCksYT1cIlwiPT09ZD9cIi5cIitRKGgsMCk6ZCxJKGMpPyhlPVwiXCIsbnVsbCE9YSYmKGU9YS5yZXBsYWNlKFAsXCIkJi9cIikrXCIvXCIpLFIoYyxiLGUsXCJcIixmdW5jdGlvbihhKXtyZXR1cm4gYX0pKTpudWxsIT1jJiYoTyhjKSYmKGM9TihjLGUrKCFjLmtleXx8aCYmaC5rZXk9PT1jLmtleT9cIlwiOihcIlwiK2Mua2V5KS5yZXBsYWNlKFAsXCIkJi9cIikrXCIvXCIpK2EpKSxiLnB1c2goYykpLDE7aD0wO2Q9XCJcIj09PWQ/XCIuXCI6ZCtcIjpcIjtpZihJKGEpKWZvcih2YXIgZz0wO2c8YS5sZW5ndGg7ZysrKXtrPVxuYVtnXTt2YXIgZj1kK1EoayxnKTtoKz1SKGssYixlLGYsYyl9ZWxzZSBpZihmPUEoYSksXCJmdW5jdGlvblwiPT09dHlwZW9mIGYpZm9yKGE9Zi5jYWxsKGEpLGc9MDshKGs9YS5uZXh0KCkpLmRvbmU7KWs9ay52YWx1ZSxmPWQrUShrLGcrKyksaCs9UihrLGIsZSxmLGMpO2Vsc2UgaWYoXCJvYmplY3RcIj09PWspdGhyb3cgYj1TdHJpbmcoYSksRXJyb3IoXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiKyhcIltvYmplY3QgT2JqZWN0XVwiPT09Yj9cIm9iamVjdCB3aXRoIGtleXMge1wiK09iamVjdC5rZXlzKGEpLmpvaW4oXCIsIFwiKStcIn1cIjpiKStcIikuIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgaW5zdGVhZC5cIik7cmV0dXJuIGh9XG5mdW5jdGlvbiBTKGEsYixlKXtpZihudWxsPT1hKXJldHVybiBhO3ZhciBkPVtdLGM9MDtSKGEsZCxcIlwiLFwiXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGIuY2FsbChlLGEsYysrKX0pO3JldHVybiBkfWZ1bmN0aW9uIFQoYSl7aWYoLTE9PT1hLl9zdGF0dXMpe3ZhciBiPWEuX3Jlc3VsdDtiPWIoKTtiLnRoZW4oZnVuY3Rpb24oYil7aWYoMD09PWEuX3N0YXR1c3x8LTE9PT1hLl9zdGF0dXMpYS5fc3RhdHVzPTEsYS5fcmVzdWx0PWJ9LGZ1bmN0aW9uKGIpe2lmKDA9PT1hLl9zdGF0dXN8fC0xPT09YS5fc3RhdHVzKWEuX3N0YXR1cz0yLGEuX3Jlc3VsdD1ifSk7LTE9PT1hLl9zdGF0dXMmJihhLl9zdGF0dXM9MCxhLl9yZXN1bHQ9Yil9aWYoMT09PWEuX3N0YXR1cylyZXR1cm4gYS5fcmVzdWx0LmRlZmF1bHQ7dGhyb3cgYS5fcmVzdWx0O31cbnZhciBVPXtjdXJyZW50Om51bGx9LFY9e3RyYW5zaXRpb246bnVsbH0sVz17UmVhY3RDdXJyZW50RGlzcGF0Y2hlcjpVLFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnOlYsUmVhY3RDdXJyZW50T3duZXI6S307ZXhwb3J0cy5DaGlsZHJlbj17bWFwOlMsZm9yRWFjaDpmdW5jdGlvbihhLGIsZSl7UyhhLGZ1bmN0aW9uKCl7Yi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGUpfSxjb3VudDpmdW5jdGlvbihhKXt2YXIgYj0wO1MoYSxmdW5jdGlvbigpe2IrK30pO3JldHVybiBifSx0b0FycmF5OmZ1bmN0aW9uKGEpe3JldHVybiBTKGEsZnVuY3Rpb24oYSl7cmV0dXJuIGF9KXx8W119LG9ubHk6ZnVuY3Rpb24oYSl7aWYoIU8oYSkpdGhyb3cgRXJyb3IoXCJSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC5cIik7cmV0dXJuIGF9fTtleHBvcnRzLkNvbXBvbmVudD1FO2V4cG9ydHMuRnJhZ21lbnQ9cDtcbmV4cG9ydHMuUHJvZmlsZXI9cjtleHBvcnRzLlB1cmVDb21wb25lbnQ9RztleHBvcnRzLlN0cmljdE1vZGU9cTtleHBvcnRzLlN1c3BlbnNlPXc7ZXhwb3J0cy5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRD1XO1xuZXhwb3J0cy5jbG9uZUVsZW1lbnQ9ZnVuY3Rpb24oYSxiLGUpe2lmKG51bGw9PT1hfHx2b2lkIDA9PT1hKXRocm93IEVycm9yKFwiUmVhY3QuY2xvbmVFbGVtZW50KC4uLik6IFRoZSBhcmd1bWVudCBtdXN0IGJlIGEgUmVhY3QgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQgXCIrYStcIi5cIik7dmFyIGQ9Qyh7fSxhLnByb3BzKSxjPWEua2V5LGs9YS5yZWYsaD1hLl9vd25lcjtpZihudWxsIT1iKXt2b2lkIDAhPT1iLnJlZiYmKGs9Yi5yZWYsaD1LLmN1cnJlbnQpO3ZvaWQgMCE9PWIua2V5JiYoYz1cIlwiK2Iua2V5KTtpZihhLnR5cGUmJmEudHlwZS5kZWZhdWx0UHJvcHMpdmFyIGc9YS50eXBlLmRlZmF1bHRQcm9wcztmb3IoZiBpbiBiKUouY2FsbChiLGYpJiYhTC5oYXNPd25Qcm9wZXJ0eShmKSYmKGRbZl09dm9pZCAwPT09YltmXSYmdm9pZCAwIT09Zz9nW2ZdOmJbZl0pfXZhciBmPWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09ZilkLmNoaWxkcmVuPWU7ZWxzZSBpZigxPGYpe2c9QXJyYXkoZik7XG5mb3IodmFyIG09MDttPGY7bSsrKWdbbV09YXJndW1lbnRzW20rMl07ZC5jaGlsZHJlbj1nfXJldHVybnskJHR5cGVvZjpsLHR5cGU6YS50eXBlLGtleTpjLHJlZjprLHByb3BzOmQsX293bmVyOmh9fTtleHBvcnRzLmNyZWF0ZUNvbnRleHQ9ZnVuY3Rpb24oYSl7YT17JCR0eXBlb2Y6dSxfY3VycmVudFZhbHVlOmEsX2N1cnJlbnRWYWx1ZTI6YSxfdGhyZWFkQ291bnQ6MCxQcm92aWRlcjpudWxsLENvbnN1bWVyOm51bGwsX2RlZmF1bHRWYWx1ZTpudWxsLF9nbG9iYWxOYW1lOm51bGx9O2EuUHJvdmlkZXI9eyQkdHlwZW9mOnQsX2NvbnRleHQ6YX07cmV0dXJuIGEuQ29uc3VtZXI9YX07ZXhwb3J0cy5jcmVhdGVFbGVtZW50PU07ZXhwb3J0cy5jcmVhdGVGYWN0b3J5PWZ1bmN0aW9uKGEpe3ZhciBiPU0uYmluZChudWxsLGEpO2IudHlwZT1hO3JldHVybiBifTtleHBvcnRzLmNyZWF0ZVJlZj1mdW5jdGlvbigpe3JldHVybntjdXJyZW50Om51bGx9fTtcbmV4cG9ydHMuZm9yd2FyZFJlZj1mdW5jdGlvbihhKXtyZXR1cm57JCR0eXBlb2Y6dixyZW5kZXI6YX19O2V4cG9ydHMuaXNWYWxpZEVsZW1lbnQ9TztleHBvcnRzLmxhenk9ZnVuY3Rpb24oYSl7cmV0dXJueyQkdHlwZW9mOnksX3BheWxvYWQ6e19zdGF0dXM6LTEsX3Jlc3VsdDphfSxfaW5pdDpUfX07ZXhwb3J0cy5tZW1vPWZ1bmN0aW9uKGEsYil7cmV0dXJueyQkdHlwZW9mOngsdHlwZTphLGNvbXBhcmU6dm9pZCAwPT09Yj9udWxsOmJ9fTtleHBvcnRzLnN0YXJ0VHJhbnNpdGlvbj1mdW5jdGlvbihhKXt2YXIgYj1WLnRyYW5zaXRpb247Vi50cmFuc2l0aW9uPXt9O3RyeXthKCl9ZmluYWxseXtWLnRyYW5zaXRpb249Yn19O2V4cG9ydHMudW5zdGFibGVfYWN0PWZ1bmN0aW9uKCl7dGhyb3cgRXJyb3IoXCJhY3QoLi4uKSBpcyBub3Qgc3VwcG9ydGVkIGluIHByb2R1Y3Rpb24gYnVpbGRzIG9mIFJlYWN0LlwiKTt9O1xuZXhwb3J0cy51c2VDYWxsYmFjaz1mdW5jdGlvbihhLGIpe3JldHVybiBVLmN1cnJlbnQudXNlQ2FsbGJhY2soYSxiKX07ZXhwb3J0cy51c2VDb250ZXh0PWZ1bmN0aW9uKGEpe3JldHVybiBVLmN1cnJlbnQudXNlQ29udGV4dChhKX07ZXhwb3J0cy51c2VEZWJ1Z1ZhbHVlPWZ1bmN0aW9uKCl7fTtleHBvcnRzLnVzZURlZmVycmVkVmFsdWU9ZnVuY3Rpb24oYSl7cmV0dXJuIFUuY3VycmVudC51c2VEZWZlcnJlZFZhbHVlKGEpfTtleHBvcnRzLnVzZUVmZmVjdD1mdW5jdGlvbihhLGIpe3JldHVybiBVLmN1cnJlbnQudXNlRWZmZWN0KGEsYil9O2V4cG9ydHMudXNlSWQ9ZnVuY3Rpb24oKXtyZXR1cm4gVS5jdXJyZW50LnVzZUlkKCl9O2V4cG9ydHMudXNlSW1wZXJhdGl2ZUhhbmRsZT1mdW5jdGlvbihhLGIsZSl7cmV0dXJuIFUuY3VycmVudC51c2VJbXBlcmF0aXZlSGFuZGxlKGEsYixlKX07XG5leHBvcnRzLnVzZUluc2VydGlvbkVmZmVjdD1mdW5jdGlvbihhLGIpe3JldHVybiBVLmN1cnJlbnQudXNlSW5zZXJ0aW9uRWZmZWN0KGEsYil9O2V4cG9ydHMudXNlTGF5b3V0RWZmZWN0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIFUuY3VycmVudC51c2VMYXlvdXRFZmZlY3QoYSxiKX07ZXhwb3J0cy51c2VNZW1vPWZ1bmN0aW9uKGEsYil7cmV0dXJuIFUuY3VycmVudC51c2VNZW1vKGEsYil9O2V4cG9ydHMudXNlUmVkdWNlcj1mdW5jdGlvbihhLGIsZSl7cmV0dXJuIFUuY3VycmVudC51c2VSZWR1Y2VyKGEsYixlKX07ZXhwb3J0cy51c2VSZWY9ZnVuY3Rpb24oYSl7cmV0dXJuIFUuY3VycmVudC51c2VSZWYoYSl9O2V4cG9ydHMudXNlU3RhdGU9ZnVuY3Rpb24oYSl7cmV0dXJuIFUuY3VycmVudC51c2VTdGF0ZShhKX07ZXhwb3J0cy51c2VTeW5jRXh0ZXJuYWxTdG9yZT1mdW5jdGlvbihhLGIsZSl7cmV0dXJuIFUuY3VycmVudC51c2VTeW5jRXh0ZXJuYWxTdG9yZShhLGIsZSl9O1xuZXhwb3J0cy51c2VUcmFuc2l0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIFUuY3VycmVudC51c2VUcmFuc2l0aW9uKCl9O2V4cG9ydHMudmVyc2lvbj1cIjE4LjEuMFwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///408\n')},294:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(408);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx5Q0FBeUQ7QUFDM0QsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qcz9hYjViIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///294\n")},893:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(251);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODkzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx5Q0FBcUU7QUFDdkUsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC9qc3gtcnVudGltZS5qcz85Y2E1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///893\n")},53:(__unused_webpack_module,exports)=>{"use strict";eval('/**\n * @license React\n * scheduler.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nfunction f(a,b){var c=a.length;a.push(b);a:for(;0<c;){var d=c-1>>>1,e=a[d];if(0<g(e,b))a[d]=b,a[c]=e,c=d;else break a}}function h(a){return 0===a.length?null:a[0]}function k(a){if(0===a.length)return null;var b=a[0],c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length,w=e>>>1;d<w;){var m=2*(d+1)-1,C=a[m],n=m+1,x=a[n];if(0>g(C,c))n<e&&0>g(x,C)?(a[d]=x,a[n]=c,d=n):(a[d]=C,a[m]=c,d=m);else if(n<e&&0>g(x,c))a[d]=x,a[n]=c,d=n;else break a}}return b}\nfunction g(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}if("object"===typeof performance&&"function"===typeof performance.now){var l=performance;exports.unstable_now=function(){return l.now()}}else{var p=Date,q=p.now();exports.unstable_now=function(){return p.now()-q}}var r=[],t=[],u=1,v=null,y=3,z=!1,A=!1,B=!1,D="function"===typeof setTimeout?setTimeout:null,E="function"===typeof clearTimeout?clearTimeout:null,F="undefined"!==typeof setImmediate?setImmediate:null;\n"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function G(a){for(var b=h(t);null!==b;){if(null===b.callback)k(t);else if(b.startTime<=a)k(t),b.sortIndex=b.expirationTime,f(r,b);else break;b=h(t)}}function H(a){B=!1;G(a);if(!A)if(null!==h(r))A=!0,I(J);else{var b=h(t);null!==b&&K(H,b.startTime-a)}}\nfunction J(a,b){A=!1;B&&(B=!1,E(L),L=-1);z=!0;var c=y;try{G(b);for(v=h(r);null!==v&&(!(v.expirationTime>b)||a&&!M());){var d=v.callback;if("function"===typeof d){v.callback=null;y=v.priorityLevel;var e=d(v.expirationTime<=b);b=exports.unstable_now();"function"===typeof e?v.callback=e:v===h(r)&&k(r);G(b)}else k(r);v=h(r)}if(null!==v)var w=!0;else{var m=h(t);null!==m&&K(H,m.startTime-b);w=!1}return w}finally{v=null,y=c,z=!1}}var N=!1,O=null,L=-1,P=5,Q=-1;\nfunction M(){return exports.unstable_now()-Q<P?!1:!0}function R(){if(null!==O){var a=exports.unstable_now();Q=a;var b=!0;try{b=O(!0,a)}finally{b?S():(N=!1,O=null)}}else N=!1}var S;if("function"===typeof F)S=function(){F(R)};else if("undefined"!==typeof MessageChannel){var T=new MessageChannel,U=T.port2;T.port1.onmessage=R;S=function(){U.postMessage(null)}}else S=function(){D(R,0)};function I(a){O=a;N||(N=!0,S())}function K(a,b){L=D(function(){a(exports.unstable_now())},b)}\nexports.unstable_IdlePriority=5;exports.unstable_ImmediatePriority=1;exports.unstable_LowPriority=4;exports.unstable_NormalPriority=3;exports.unstable_Profiling=null;exports.unstable_UserBlockingPriority=2;exports.unstable_cancelCallback=function(a){a.callback=null};exports.unstable_continueExecution=function(){A||z||(A=!0,I(J))};\nexports.unstable_forceFrameRate=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):P=0<a?Math.floor(1E3/a):5};exports.unstable_getCurrentPriorityLevel=function(){return y};exports.unstable_getFirstCallbackNode=function(){return h(r)};exports.unstable_next=function(a){switch(y){case 1:case 2:case 3:var b=3;break;default:b=y}var c=y;y=b;try{return a()}finally{y=c}};exports.unstable_pauseExecution=function(){};\nexports.unstable_requestPaint=function(){};exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=y;y=a;try{return b()}finally{y=c}};\nexports.unstable_scheduleCallback=function(a,b,c){var d=exports.unstable_now();"object"===typeof c&&null!==c?(c=c.delay,c="number"===typeof c&&0<c?d+c:d):c=d;switch(a){case 1:var e=-1;break;case 2:e=250;break;case 5:e=1073741823;break;case 4:e=1E4;break;default:e=5E3}e=c+e;a={id:u++,callback:b,priorityLevel:a,startTime:c,expirationTime:e,sortIndex:-1};c>d?(a.sortIndex=c,f(t,a),null===h(r)&&a===h(t)&&(B?(E(L),L=-1):B=!0,K(H,c-d))):(a.sortIndex=e,f(r,a),A||z||(A=!0,I(J)));return a};\nexports.unstable_shouldYield=M;exports.unstable_wrapCallback=function(a){var b=y;return function(){var c=y;y=b;try{return a.apply(this,arguments)}finally{y=c}}};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2EsZ0JBQWdCLGVBQWUsVUFBVSxPQUFPLElBQUksRUFBRSxxQkFBcUIsOEJBQThCLGNBQWMsY0FBYyw4QkFBOEIsY0FBYyw0QkFBNEIscUJBQXFCLFVBQVUsT0FBTyxpQ0FBaUMsSUFBSSxFQUFFLG9DQUFvQyxrRUFBa0Usd0NBQXdDLGNBQWM7QUFDbmMsZ0JBQWdCLDhCQUE4Qix5QkFBeUIsdUVBQXVFLGtCQUFrQixvQkFBb0IsWUFBWSxnQkFBZ0IsS0FBSyxxQkFBcUIsb0JBQW9CLFlBQVksa0JBQWtCO0FBQzVSLDRLQUE0SyxjQUFjLGVBQWUsU0FBUyxFQUFFLDBCQUEwQixnRUFBZ0UsV0FBVyxRQUFRLGNBQWMsS0FBSyxLQUFLLCtCQUErQixLQUFLLFdBQVc7QUFDeFksZ0JBQWdCLEtBQUssb0JBQW9CLEtBQUssUUFBUSxJQUFJLEtBQUssV0FBVywyQ0FBMkMsRUFBRSxpQkFBaUIsMEJBQTBCLGdCQUFnQixrQkFBa0IsNkJBQTZCLHlCQUF5QixrREFBa0QsS0FBSyxVQUFVLE9BQU8scUJBQXFCLEtBQUssV0FBVyw2QkFBNkIsS0FBSyxTQUFTLFFBQVEsaUJBQWlCO0FBQzNhLGFBQWEsd0NBQXdDLGFBQWEsYUFBYSw2QkFBNkIsSUFBSSxTQUFTLElBQUksVUFBVSxRQUFRLHFCQUFxQixVQUFVLE1BQU0sc0NBQXNDLE1BQU0sNkNBQTZDLG1DQUFtQyxvQkFBb0IsYUFBYSxxQkFBcUIsa0JBQWtCLFFBQVEsY0FBYyxJQUFJLGNBQWMsZ0JBQWdCLGVBQWUsMEJBQTBCO0FBQ3pkLDZCQUE2QixHQUFHLGtDQUFrQyxHQUFHLDRCQUE0QixHQUFHLCtCQUErQixHQUFHLDBCQUEwQixNQUFNLHFDQUFxQyxHQUFHLCtCQUErQixhQUFhLGlCQUFpQixrQ0FBa0MsWUFBWTtBQUN6VCwrQkFBK0IsYUFBYSx1S0FBdUssd0NBQXdDLFlBQVksVUFBVSxxQ0FBcUMsWUFBWSxhQUFhLHFCQUFxQixhQUFhLFVBQVUsNkJBQTZCLE1BQU0sWUFBWSxRQUFRLElBQUksSUFBSSxXQUFXLFFBQVEsTUFBTSwrQkFBK0I7QUFDbGYsNkJBQTZCLGNBQWMsZ0NBQWdDLGVBQWUsVUFBVSx5Q0FBeUMsWUFBWSxRQUFRLElBQUksSUFBSSxXQUFXLFFBQVE7QUFDNUwsaUNBQWlDLGlCQUFpQiw2QkFBNkIsK0VBQStFLFVBQVUsZ0JBQWdCLE1BQU0sYUFBYSxNQUFNLG9CQUFvQixNQUFNLGFBQWEsTUFBTSxjQUFjLE1BQU0sR0FBRyw2RUFBNkUseUhBQXlIO0FBQzNkLDRCQUE0QixHQUFHLDZCQUE2QixhQUFhLFFBQVEsa0JBQWtCLFFBQVEsSUFBSSxJQUFJLCtCQUErQixRQUFRIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIucHJvZHVjdGlvbi5taW4uanM/ZmIwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiBzY2hlZHVsZXIucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO2Z1bmN0aW9uIGYoYSxiKXt2YXIgYz1hLmxlbmd0aDthLnB1c2goYik7YTpmb3IoOzA8Yzspe3ZhciBkPWMtMT4+PjEsZT1hW2RdO2lmKDA8ZyhlLGIpKWFbZF09YixhW2NdPWUsYz1kO2Vsc2UgYnJlYWsgYX19ZnVuY3Rpb24gaChhKXtyZXR1cm4gMD09PWEubGVuZ3RoP251bGw6YVswXX1mdW5jdGlvbiBrKGEpe2lmKDA9PT1hLmxlbmd0aClyZXR1cm4gbnVsbDt2YXIgYj1hWzBdLGM9YS5wb3AoKTtpZihjIT09Yil7YVswXT1jO2E6Zm9yKHZhciBkPTAsZT1hLmxlbmd0aCx3PWU+Pj4xO2Q8dzspe3ZhciBtPTIqKGQrMSktMSxDPWFbbV0sbj1tKzEseD1hW25dO2lmKDA+ZyhDLGMpKW48ZSYmMD5nKHgsQyk/KGFbZF09eCxhW25dPWMsZD1uKTooYVtkXT1DLGFbbV09YyxkPW0pO2Vsc2UgaWYobjxlJiYwPmcoeCxjKSlhW2RdPXgsYVtuXT1jLGQ9bjtlbHNlIGJyZWFrIGF9fXJldHVybiBifVxuZnVuY3Rpb24gZyhhLGIpe3ZhciBjPWEuc29ydEluZGV4LWIuc29ydEluZGV4O3JldHVybiAwIT09Yz9jOmEuaWQtYi5pZH1pZihcIm9iamVjdFwiPT09dHlwZW9mIHBlcmZvcm1hbmNlJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgcGVyZm9ybWFuY2Uubm93KXt2YXIgbD1wZXJmb3JtYW5jZTtleHBvcnRzLnVuc3RhYmxlX25vdz1mdW5jdGlvbigpe3JldHVybiBsLm5vdygpfX1lbHNle3ZhciBwPURhdGUscT1wLm5vdygpO2V4cG9ydHMudW5zdGFibGVfbm93PWZ1bmN0aW9uKCl7cmV0dXJuIHAubm93KCktcX19dmFyIHI9W10sdD1bXSx1PTEsdj1udWxsLHk9Myx6PSExLEE9ITEsQj0hMSxEPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBzZXRUaW1lb3V0P3NldFRpbWVvdXQ6bnVsbCxFPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBjbGVhclRpbWVvdXQ/Y2xlYXJUaW1lb3V0Om51bGwsRj1cInVuZGVmaW5lZFwiIT09dHlwZW9mIHNldEltbWVkaWF0ZT9zZXRJbW1lZGlhdGU6bnVsbDtcblwidW5kZWZpbmVkXCIhPT10eXBlb2YgbmF2aWdhdG9yJiZ2b2lkIDAhPT1uYXZpZ2F0b3Iuc2NoZWR1bGluZyYmdm9pZCAwIT09bmF2aWdhdG9yLnNjaGVkdWxpbmcuaXNJbnB1dFBlbmRpbmcmJm5hdmlnYXRvci5zY2hlZHVsaW5nLmlzSW5wdXRQZW5kaW5nLmJpbmQobmF2aWdhdG9yLnNjaGVkdWxpbmcpO2Z1bmN0aW9uIEcoYSl7Zm9yKHZhciBiPWgodCk7bnVsbCE9PWI7KXtpZihudWxsPT09Yi5jYWxsYmFjaylrKHQpO2Vsc2UgaWYoYi5zdGFydFRpbWU8PWEpayh0KSxiLnNvcnRJbmRleD1iLmV4cGlyYXRpb25UaW1lLGYocixiKTtlbHNlIGJyZWFrO2I9aCh0KX19ZnVuY3Rpb24gSChhKXtCPSExO0coYSk7aWYoIUEpaWYobnVsbCE9PWgocikpQT0hMCxJKEopO2Vsc2V7dmFyIGI9aCh0KTtudWxsIT09YiYmSyhILGIuc3RhcnRUaW1lLWEpfX1cbmZ1bmN0aW9uIEooYSxiKXtBPSExO0ImJihCPSExLEUoTCksTD0tMSk7ej0hMDt2YXIgYz15O3RyeXtHKGIpO2Zvcih2PWgocik7bnVsbCE9PXYmJighKHYuZXhwaXJhdGlvblRpbWU+Yil8fGEmJiFNKCkpOyl7dmFyIGQ9di5jYWxsYmFjaztpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZCl7di5jYWxsYmFjaz1udWxsO3k9di5wcmlvcml0eUxldmVsO3ZhciBlPWQodi5leHBpcmF0aW9uVGltZTw9Yik7Yj1leHBvcnRzLnVuc3RhYmxlX25vdygpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBlP3YuY2FsbGJhY2s9ZTp2PT09aChyKSYmayhyKTtHKGIpfWVsc2UgayhyKTt2PWgocil9aWYobnVsbCE9PXYpdmFyIHc9ITA7ZWxzZXt2YXIgbT1oKHQpO251bGwhPT1tJiZLKEgsbS5zdGFydFRpbWUtYik7dz0hMX1yZXR1cm4gd31maW5hbGx5e3Y9bnVsbCx5PWMsej0hMX19dmFyIE49ITEsTz1udWxsLEw9LTEsUD01LFE9LTE7XG5mdW5jdGlvbiBNKCl7cmV0dXJuIGV4cG9ydHMudW5zdGFibGVfbm93KCktUTxQPyExOiEwfWZ1bmN0aW9uIFIoKXtpZihudWxsIT09Tyl7dmFyIGE9ZXhwb3J0cy51bnN0YWJsZV9ub3coKTtRPWE7dmFyIGI9ITA7dHJ5e2I9TyghMCxhKX1maW5hbGx5e2I/UygpOihOPSExLE89bnVsbCl9fWVsc2UgTj0hMX12YXIgUztpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgRilTPWZ1bmN0aW9uKCl7RihSKX07ZWxzZSBpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIE1lc3NhZ2VDaGFubmVsKXt2YXIgVD1uZXcgTWVzc2FnZUNoYW5uZWwsVT1ULnBvcnQyO1QucG9ydDEub25tZXNzYWdlPVI7Uz1mdW5jdGlvbigpe1UucG9zdE1lc3NhZ2UobnVsbCl9fWVsc2UgUz1mdW5jdGlvbigpe0QoUiwwKX07ZnVuY3Rpb24gSShhKXtPPWE7Tnx8KE49ITAsUygpKX1mdW5jdGlvbiBLKGEsYil7TD1EKGZ1bmN0aW9uKCl7YShleHBvcnRzLnVuc3RhYmxlX25vdygpKX0sYil9XG5leHBvcnRzLnVuc3RhYmxlX0lkbGVQcmlvcml0eT01O2V4cG9ydHMudW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHk9MTtleHBvcnRzLnVuc3RhYmxlX0xvd1ByaW9yaXR5PTQ7ZXhwb3J0cy51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eT0zO2V4cG9ydHMudW5zdGFibGVfUHJvZmlsaW5nPW51bGw7ZXhwb3J0cy51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eT0yO2V4cG9ydHMudW5zdGFibGVfY2FuY2VsQ2FsbGJhY2s9ZnVuY3Rpb24oYSl7YS5jYWxsYmFjaz1udWxsfTtleHBvcnRzLnVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uPWZ1bmN0aW9uKCl7QXx8enx8KEE9ITAsSShKKSl9O1xuZXhwb3J0cy51bnN0YWJsZV9mb3JjZUZyYW1lUmF0ZT1mdW5jdGlvbihhKXswPmF8fDEyNTxhP2NvbnNvbGUuZXJyb3IoXCJmb3JjZUZyYW1lUmF0ZSB0YWtlcyBhIHBvc2l0aXZlIGludCBiZXR3ZWVuIDAgYW5kIDEyNSwgZm9yY2luZyBmcmFtZSByYXRlcyBoaWdoZXIgdGhhbiAxMjUgZnBzIGlzIG5vdCBzdXBwb3J0ZWRcIik6UD0wPGE/TWF0aC5mbG9vcigxRTMvYSk6NX07ZXhwb3J0cy51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbD1mdW5jdGlvbigpe3JldHVybiB5fTtleHBvcnRzLnVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlPWZ1bmN0aW9uKCl7cmV0dXJuIGgocil9O2V4cG9ydHMudW5zdGFibGVfbmV4dD1mdW5jdGlvbihhKXtzd2l0Y2goeSl7Y2FzZSAxOmNhc2UgMjpjYXNlIDM6dmFyIGI9MzticmVhaztkZWZhdWx0OmI9eX12YXIgYz15O3k9Yjt0cnl7cmV0dXJuIGEoKX1maW5hbGx5e3k9Y319O2V4cG9ydHMudW5zdGFibGVfcGF1c2VFeGVjdXRpb249ZnVuY3Rpb24oKXt9O1xuZXhwb3J0cy51bnN0YWJsZV9yZXF1ZXN0UGFpbnQ9ZnVuY3Rpb24oKXt9O2V4cG9ydHMudW5zdGFibGVfcnVuV2l0aFByaW9yaXR5PWZ1bmN0aW9uKGEsYil7c3dpdGNoKGEpe2Nhc2UgMTpjYXNlIDI6Y2FzZSAzOmNhc2UgNDpjYXNlIDU6YnJlYWs7ZGVmYXVsdDphPTN9dmFyIGM9eTt5PWE7dHJ5e3JldHVybiBiKCl9ZmluYWxseXt5PWN9fTtcbmV4cG9ydHMudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjaz1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9ZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcIm9iamVjdFwiPT09dHlwZW9mIGMmJm51bGwhPT1jPyhjPWMuZGVsYXksYz1cIm51bWJlclwiPT09dHlwZW9mIGMmJjA8Yz9kK2M6ZCk6Yz1kO3N3aXRjaChhKXtjYXNlIDE6dmFyIGU9LTE7YnJlYWs7Y2FzZSAyOmU9MjUwO2JyZWFrO2Nhc2UgNTplPTEwNzM3NDE4MjM7YnJlYWs7Y2FzZSA0OmU9MUU0O2JyZWFrO2RlZmF1bHQ6ZT01RTN9ZT1jK2U7YT17aWQ6dSsrLGNhbGxiYWNrOmIscHJpb3JpdHlMZXZlbDphLHN0YXJ0VGltZTpjLGV4cGlyYXRpb25UaW1lOmUsc29ydEluZGV4Oi0xfTtjPmQ/KGEuc29ydEluZGV4PWMsZih0LGEpLG51bGw9PT1oKHIpJiZhPT09aCh0KSYmKEI/KEUoTCksTD0tMSk6Qj0hMCxLKEgsYy1kKSkpOihhLnNvcnRJbmRleD1lLGYocixhKSxBfHx6fHwoQT0hMCxJKEopKSk7cmV0dXJuIGF9O1xuZXhwb3J0cy51bnN0YWJsZV9zaG91bGRZaWVsZD1NO2V4cG9ydHMudW5zdGFibGVfd3JhcENhbGxiYWNrPWZ1bmN0aW9uKGEpe3ZhciBiPXk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGM9eTt5PWI7dHJ5e3JldHVybiBhLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maW5hbGx5e3k9Y319fTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///53\n')},840:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(53);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQwLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx3Q0FBNkQ7QUFDL0QsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvaW5kZXguanM/NDAyOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///840\n")},774:module=>{eval('//\n\nmodule.exports = function shallowEqual(objA, objB, compare, compareContext) {\n  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;\n\n  if (ret !== void 0) {\n    return !!ret;\n  }\n\n  if (objA === objB) {\n    return true;\n  }\n\n  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);\n\n  // Test for A\'s keys different from B.\n  for (var idx = 0; idx < keysA.length; idx++) {\n    var key = keysA[idx];\n\n    if (!bHasOwnProperty(key)) {\n      return false;\n    }\n\n    var valueA = objA[key];\n    var valueB = objB[key];\n\n    ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;\n\n    if (ret === false || (ret === void 0 && valueA !== valueB)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzc0LmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9zaGFsbG93ZXF1YWwvaW5kZXguanM/MWIyYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCLCBjb21wYXJlLCBjb21wYXJlQ29udGV4dCkge1xuICB2YXIgcmV0ID0gY29tcGFyZSA/IGNvbXBhcmUuY2FsbChjb21wYXJlQ29udGV4dCwgb2JqQSwgb2JqQikgOiB2b2lkIDA7XG5cbiAgaWYgKHJldCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuICEhcmV0O1xuICB9XG5cbiAgaWYgKG9iakEgPT09IG9iakIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gXCJvYmplY3RcIiB8fCAhb2JqQSB8fCB0eXBlb2Ygb2JqQiAhPT0gXCJvYmplY3RcIiB8fCAhb2JqQikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgYkhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5iaW5kKG9iakIpO1xuXG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGtleXNBLmxlbmd0aDsgaWR4KyspIHtcbiAgICB2YXIga2V5ID0ga2V5c0FbaWR4XTtcblxuICAgIGlmICghYkhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVBID0gb2JqQVtrZXldO1xuICAgIHZhciB2YWx1ZUIgPSBvYmpCW2tleV07XG5cbiAgICByZXQgPSBjb21wYXJlID8gY29tcGFyZS5jYWxsKGNvbXBhcmVDb250ZXh0LCB2YWx1ZUEsIHZhbHVlQiwga2V5KSA6IHZvaWQgMDtcblxuICAgIGlmIChyZXQgPT09IGZhbHNlIHx8IChyZXQgPT09IHZvaWQgMCAmJiB2YWx1ZUEgIT09IHZhbHVlQikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///774\n')},250:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('/**\n * @license React\n * use-sync-external-store-shim.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar e=__webpack_require__(294);function h(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var k="function"===typeof Object.is?Object.is:h,l=e.useState,m=e.useEffect,n=e.useLayoutEffect,p=e.useDebugValue;function q(a,b){var d=b(),f=l({inst:{value:d,getSnapshot:b}}),c=f[0].inst,g=f[1];n(function(){c.value=d;c.getSnapshot=b;r(c)&&g({inst:c})},[a,d,b]);m(function(){r(c)&&g({inst:c});return a(function(){r(c)&&g({inst:c})})},[a]);p(d);return d}\nfunction r(a){var b=a.getSnapshot;a=a.value;try{var d=b();return!k(a,d)}catch(f){return!0}}function t(a,b){return b()}var u="undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement?t:q;exports.useSyncExternalStore=void 0!==e.useSyncExternalStore?e.useSyncExternalStore:u;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUwLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhLE1BQU0sbUJBQU8sQ0FBQyxHQUFPLEVBQUUsZ0JBQWdCLCtDQUErQyxpSEFBaUgsZ0JBQWdCLGVBQWUsTUFBTSx1QkFBdUIscUJBQXFCLGFBQWEsVUFBVSxnQkFBZ0IsU0FBUyxPQUFPLEVBQUUsVUFBVSxhQUFhLFNBQVMsT0FBTyxFQUFFLG9CQUFvQixTQUFTLE9BQU8sRUFBRSxFQUFFLE1BQU0sS0FBSztBQUMxYixjQUFjLG9CQUFvQixVQUFVLElBQUksVUFBVSxjQUFjLFNBQVMsVUFBVSxnQkFBZ0IsV0FBVyxnSUFBZ0ksNEJBQTRCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGh5c2ljcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0ucHJvZHVjdGlvbi5taW4uanM/OTRhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiB1c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0Jzt2YXIgZT1yZXF1aXJlKFwicmVhY3RcIik7ZnVuY3Rpb24gaChhLGIpe3JldHVybiBhPT09YiYmKDAhPT1hfHwxL2E9PT0xL2IpfHxhIT09YSYmYiE9PWJ9dmFyIGs9XCJmdW5jdGlvblwiPT09dHlwZW9mIE9iamVjdC5pcz9PYmplY3QuaXM6aCxsPWUudXNlU3RhdGUsbT1lLnVzZUVmZmVjdCxuPWUudXNlTGF5b3V0RWZmZWN0LHA9ZS51c2VEZWJ1Z1ZhbHVlO2Z1bmN0aW9uIHEoYSxiKXt2YXIgZD1iKCksZj1sKHtpbnN0Ont2YWx1ZTpkLGdldFNuYXBzaG90OmJ9fSksYz1mWzBdLmluc3QsZz1mWzFdO24oZnVuY3Rpb24oKXtjLnZhbHVlPWQ7Yy5nZXRTbmFwc2hvdD1iO3IoYykmJmcoe2luc3Q6Y30pfSxbYSxkLGJdKTttKGZ1bmN0aW9uKCl7cihjKSYmZyh7aW5zdDpjfSk7cmV0dXJuIGEoZnVuY3Rpb24oKXtyKGMpJiZnKHtpbnN0OmN9KX0pfSxbYV0pO3AoZCk7cmV0dXJuIGR9XG5mdW5jdGlvbiByKGEpe3ZhciBiPWEuZ2V0U25hcHNob3Q7YT1hLnZhbHVlO3RyeXt2YXIgZD1iKCk7cmV0dXJuIWsoYSxkKX1jYXRjaChmKXtyZXR1cm4hMH19ZnVuY3Rpb24gdChhLGIpe3JldHVybiBiKCl9dmFyIHU9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiB3aW5kb3d8fFwidW5kZWZpbmVkXCI9PT10eXBlb2Ygd2luZG93LmRvY3VtZW50fHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50P3Q6cTtleHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlPXZvaWQgMCE9PWUudXNlU3luY0V4dGVybmFsU3RvcmU/ZS51c2VTeW5jRXh0ZXJuYWxTdG9yZTp1O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///250\n')},139:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('/**\n * @license React\n * use-sync-external-store-shim/with-selector.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar h=__webpack_require__(294),n=__webpack_require__(688);function p(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var q="function"===typeof Object.is?Object.is:p,r=n.useSyncExternalStore,t=h.useRef,u=h.useEffect,v=h.useMemo,w=h.useDebugValue;\nexports.useSyncExternalStoreWithSelector=function(a,b,e,l,g){var c=t(null);if(null===c.current){var f={hasValue:!1,value:null};c.current=f}else f=c.current;c=v(function(){function a(a){if(!c){c=!0;d=a;a=l(a);if(void 0!==g&&f.hasValue){var b=f.value;if(g(b,a))return k=b}return k=a}b=k;if(q(d,a))return b;var e=l(a);if(void 0!==g&&g(b,e))return b;d=a;return k=e}var c=!1,d,k,m=void 0===e?null:e;return[function(){return a(b())},null===m?void 0:function(){return a(m())}]},[b,e,l,g]);var d=r(a,c[0],c[1]);\nu(function(){f.hasValue=!0;f.value=d},[d]);w(d);return d};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM5LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhLE1BQU0sbUJBQU8sQ0FBQyxHQUFPLElBQUksbUJBQU8sQ0FBQyxHQUE4QixFQUFFLGdCQUFnQiwrQ0FBK0M7QUFDN0ksd0NBQXdDLHFCQUFxQixjQUFjLHFCQUFxQixPQUFPLHdCQUF3QixZQUFZLGlCQUFpQixlQUFlLGNBQWMsT0FBTyxLQUFLLElBQUksT0FBTywyQkFBMkIsY0FBYyxxQkFBcUIsV0FBVyxJQUFJLG1CQUFtQixXQUFXLCtCQUErQixJQUFJLFdBQVcsaUNBQWlDLGtCQUFrQixjQUFjLDRCQUE0QixjQUFjLEVBQUUsWUFBWTtBQUNsZSxhQUFhLGNBQWMsVUFBVSxNQUFNLEtBQUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS93aXRoLXNlbGVjdG9yLnByb2R1Y3Rpb24ubWluLmpzPzAwMWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS93aXRoLXNlbGVjdG9yLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0Jzt2YXIgaD1yZXF1aXJlKFwicmVhY3RcIiksbj1yZXF1aXJlKFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbVwiKTtmdW5jdGlvbiBwKGEsYil7cmV0dXJuIGE9PT1iJiYoMCE9PWF8fDEvYT09PTEvYil8fGEhPT1hJiZiIT09Yn12YXIgcT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgT2JqZWN0LmlzP09iamVjdC5pczpwLHI9bi51c2VTeW5jRXh0ZXJuYWxTdG9yZSx0PWgudXNlUmVmLHU9aC51c2VFZmZlY3Qsdj1oLnVzZU1lbW8sdz1oLnVzZURlYnVnVmFsdWU7XG5leHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yPWZ1bmN0aW9uKGEsYixlLGwsZyl7dmFyIGM9dChudWxsKTtpZihudWxsPT09Yy5jdXJyZW50KXt2YXIgZj17aGFzVmFsdWU6ITEsdmFsdWU6bnVsbH07Yy5jdXJyZW50PWZ9ZWxzZSBmPWMuY3VycmVudDtjPXYoZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEpe2lmKCFjKXtjPSEwO2Q9YTthPWwoYSk7aWYodm9pZCAwIT09ZyYmZi5oYXNWYWx1ZSl7dmFyIGI9Zi52YWx1ZTtpZihnKGIsYSkpcmV0dXJuIGs9Yn1yZXR1cm4gaz1hfWI9aztpZihxKGQsYSkpcmV0dXJuIGI7dmFyIGU9bChhKTtpZih2b2lkIDAhPT1nJiZnKGIsZSkpcmV0dXJuIGI7ZD1hO3JldHVybiBrPWV9dmFyIGM9ITEsZCxrLG09dm9pZCAwPT09ZT9udWxsOmU7cmV0dXJuW2Z1bmN0aW9uKCl7cmV0dXJuIGEoYigpKX0sbnVsbD09PW0/dm9pZCAwOmZ1bmN0aW9uKCl7cmV0dXJuIGEobSgpKX1dfSxbYixlLGwsZ10pO3ZhciBkPXIoYSxjWzBdLGNbMV0pO1xudShmdW5jdGlvbigpe2YuaGFzVmFsdWU9ITA7Zi52YWx1ZT1kfSxbZF0pO3coZCk7cmV0dXJuIGR9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///139\n')},688:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(250);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjg4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx5Q0FBaUY7QUFDbkYsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL2luZGV4LmpzPzZhZGYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///688\n")},798:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(139);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzk4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx5Q0FBK0Y7QUFDakcsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL3dpdGgtc2VsZWN0b3IuanM/N2EzOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0vd2l0aC1zZWxlY3Rvci5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS93aXRoLXNlbGVjdG9yLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///798\n")}},__webpack_module_cache__={};function __webpack_require__(n){var g=__webpack_module_cache__[n];if(void 0!==g)return g.exports;var I=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n](I,I.exports,__webpack_require__),I.exports}__webpack_require__.n=n=>{var g=n&&n.__esModule?()=>n.default:()=>n;return __webpack_require__.d(g,{a:g}),g},__webpack_require__.d=(n,g)=>{for(var I in g)__webpack_require__.o(g,I)&&!__webpack_require__.o(n,I)&&Object.defineProperty(n,I,{enumerable:!0,get:g[I]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(n){if("object"==typeof window)return window}}(),__webpack_require__.o=(n,g)=>Object.prototype.hasOwnProperty.call(n,g),__webpack_require__.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(27)})();